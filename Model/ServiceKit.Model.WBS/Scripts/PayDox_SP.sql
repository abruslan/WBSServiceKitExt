/*    ==Scripting Parameters==

    Source Server Version : SQL Server 2016 (13.0.5888)
    Source Database Engine Edition : Microsoft SQL Server Standard Edition
    Source Database Engine Type : Standalone SQL Server

    Target Server Version : SQL Server 2017
    Target Database Engine Edition : Microsoft SQL Server Standard Edition
    Target Database Engine Type : Standalone SQL Server
*/

USE [PaydoxOP]
GO
/****** Object:  StoredProcedure [dbo].[ChangeDocsCFO] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[ChangeDocsCFO]
	@DocID varchar(128),
	@CFO varchar(1024),
	@EGP varchar(3),
	@GP varchar(10),
	@EAV varchar(3),
	@AP varchar(10),
	@NC varchar(128),
	@Act int, --1--ceate, 2-update,3 delete
	@Chk bit = 0

		
as
	declare @DocIDInt int,
	@DC datetime, @isOK bit,
	@dec_GP decimal(5,2), @s_EGP char(1),
	@dec_AP decimal(5,2), @s_EAV char(1)
	
declare @ErrList varchar(1024),@Res int

	select @ErrList = '', @Res=0
	set @isOK = 0
	set @CFO = ltrim(ISNULL(@CFO,''))
	set @NC = ltrim(ISNULL(@NC,''))
	set @DC = GETDATE()
	set @s_EGP = case @EGP when 'ДА' then '1' else '0' end
	set @GP = REPLACE(@GP,',','.')
	set @s_EAV = case @EAV when 'ДА' then '1' else '0' end
	set @AP = REPLACE(@AP,',','.')
	
	if ISNUMERIC(@GP) = 0
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
				'Указанно некорректное значение процента генподряда.'
		goto NXT
	end
	set @dec_GP = CAST(@GP as decimal(5,2))
		
	If @s_EGP = '0' and @dec_GP <> 0
	begin 		
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
				'Указанно некорректное значение процента генподряда (должно быть = 0).'
		goto NXT
	end
	else If @s_EGP <> '0'
	begin		
		if @dec_GP = 0
		begin
			select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
					'Указанно некорректное значение процента генподряда (должно быть > 0).'
				goto NXT
		end
		else if @dec_GP > 100
		begin
			select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
					'Значение процента генподряда не может быть > 100.'
				goto NXT
		end		
	end
	
	if ISNUMERIC(@AP) = 0
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
				'Указанно некорректное значение процента зачета аванса.'
		goto NXT
	end
	set @dec_AP = CAST(@AP as decimal(5,2))
	
	If @s_EAV = '0' and (@dec_AP < 1 or @dec_AP > 100)
	begin 		
			select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
				'Указанно некорректное значение процента зачета аванса (должно быть от 1 до 100).'
			goto NXT
	end
	else If @s_EAV <> '0'
	begin
		if CAST(@AP as decimal) <> 0
		begin
			select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
					'Указанно некорректное значение процента зачета аванса (должно быть = 0).'
				goto NXT
		end		
	end
	
	
	select
		@DocIDInt = DocIDInt
	from dbo.Docs
	where DocID = @DocID
	select @Res = @@error if @Res <> 0 goto Err

	if @CFO <> '' and not exists (select 1 from dbo.PDX_pay_CFO where Name = @CFO) 
		begin
		
  			select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
				'Значение [' + @CFO + '] в справочнике ЦФО не существует.'
			goto NXT
		end

	select @Res = @@error if @Res <> 0 goto Err
NXT:

If @Chk = 0
begin --если это создание , то нужно генерить ошибкуесли она есть
	If @ErrList <> '' 
	begin
		RAISERROR (@ErrList, 16,1)
		goto Err
	end
end
else --если это проверка просто выводим сообщение, даже если оно пустое
begin
	select @ErrList as ErrList 
end
--select @DocIDInt,@Act,@ErrList,@Chk
IF @ErrList = '' and @Chk = 0
BEGIN 
	If @Act = 1
	begin
		insert into [dbo].DocsCFO
			([DocIDInt],
			[CFO],
			ExistGPPercent,
			GPPercent,
			[ExistAvans],
			[AvansPercent],
			[DC],
			[DLM],
			[NC],
			[NLM])
		values
			(@DocIDInt, --[DocIDInt],
			@CFO,--[[CFO]],
			@s_EGP,
			@dec_GP,
			@s_EAV,
			@dec_AP,
			@DC,--[DC],
			@DC,--[DLM],
			@NC,--[NC],
			@NC)--[NLM])
	end
	else
	If @Act = 2
	begin
		update [dbo].DocsCFO
			set CFO = @CFO,
			ExistGPPercent = @s_EGP,
			GPPercent = @dec_GP,
			[ExistAvans] = @s_EAV,
			[AvansPercent] = @dec_AP,
			NLM = @NC,
			DLM = @DC
		where DocIDInt = @DocIDInt
	end
END	
	select @Res = @@error if @Res <> 0 goto Err

OK:

	return @Res
Err:
	return @Res




GO
/****** Object:  StoredProcedure [dbo].[ChangePayStatusDetails] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[ChangePayStatusDetails]
	@DocID varchar(128),
	@Status varchar(60),
	@Comment varchar(4000),
	@NC varchar(128),
	@Act int, --1--ceate, 2-update,3 delete
	@Chk bit = 0

		
as
	declare @DocIDInt int,
	@DC datetime
	
declare @ErrList varchar(1024),@Res int

	select @ErrList = '', @Res=0
	set @NC = ltrim(ISNULL(@NC,''))
	set @DC = GETDATE()
	set @Status = ISNULL(@Status,'')
	set @Comment = ISNULL(@Comment,'')
		
	select
		@DocIDInt = DocIDInt
	from dbo.Docs
	where DocID = @DocID
	select @Res = @@error if @Res <> 0 goto Err
/*
	if @Status <> ''
	begin
		If @Comment = '' 
		begin
			select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
					'Укажите комментарий к статусу ПЗ.'
				goto NXT
		end
	end
	*/
	
NXT:

If @Chk = 0
begin --если это создание , то нужно генерить ошибкуесли она есть
	If @ErrList <> '' 
	begin
		RAISERROR (@ErrList, 16,1)
		goto Err
	end
end
else --если это проверка просто выводим сообщение, даже если оно пустое
begin
	select @ErrList as ErrList 
end
--select @DocIDInt,@Act,@ErrList,@Chk
IF @ErrList = '' and @Chk = 0
BEGIN 
	If @Act = 1
	begin
		insert into [dbo].PayStatusDetails
			([DocIDInt],
			[FinStatus],
			Comment,
			[DC],
			[DLM],
			[NC],
			[NLM])
		values
			(@DocIDInt, --[DocIDInt],
			@Status,--[[CFO]],
			@Comment,
			@DC,--[DC],
			@DC,--[DLM],
			@NC,--[NC],
			@NC)--[NLM])
	end
	else
	If @Act = 2
	begin
		update [dbo].PayStatusDetails
			set 
			[FinStatus] = @Status,
			Comment = @Comment,
			NLM = @NC,
			DLM = @DC
		where DocIDInt = @DocIDInt
	end
END	
	select @Res = @@error if @Res <> 0 goto Err

OK:

	return @Res
Err:
	return @Res





GO
/****** Object:  StoredProcedure [dbo].[CheckPartnerStatus] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE procedure [dbo].[CheckPartnerStatus]
	@DocID varchar(128)
as 
	declare @PN varchar(1024),
	@ActDoc varchar(128),
	@CheckPartner bit,
	@Message varchar(4000),
	@ContractsPermitted bit,
	@PDocList varchar (4000), 
	@PFieldList varchar (4000)
	
	set @Message = ''
	set @ContractsPermitted = 1
	set @PDocList = ''
	set @PFieldList = ''
	set @CheckPartner = 1
	
	select 
		@PN = PartnerName,
		@ActDoc = ActDoc
	from dbo.Docs
	where DocID = @DocID
	
	select
		@CheckPartner = CheckPartner
	from dbo.Activities
	where Name = @ActDoc
	
	if @CheckPartner = 1
	begin
		select top 1
			@ContractsPermitted = isnull(ContractsPermitted,0),
			@PDocList = isnull(PDocList,''),
			@PFieldList = isnull(PFieldList,'')
		from dbo.Partners
		where Name = @PN
		
		If @ContractsPermitted = 0 
		begin
			If @PDocList <> ''
			begin
				set @Message = @Message + 'на портал не загружены документы : ' + @PDocList
			end
			If @PFieldList <> ''
			begin
				set @Message = @Message + case @Message when '' then '' else ' и ' end + 'не заполнены поля : ' + @PFieldList
			end
			
			set @Message = '<br><font color="red">ОШИБКА!</font> Активация договора с контрагентом [' + @PN + '] невозможна' + case @Message when '' then ', обратитесь к Администратору справочника контрагентов на портале.' else ' , т.к. ' end + @Message + '<br>'
			
		end
	end

	select @Message as 'Mess'	


GO
/****** Object:  StoredProcedure [dbo].[ClearProject_Paydocs_CreateProject] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[ClearProject_Paydocs_CreateProject]
	@FullName nvarchar(2000)
AS
	
	declare @DocID varchar(128), @Error varchar(4096)

	create table #tmp (Error varchar(4096), DocID varchar(128))
 	
	insert into #tmp exec [dbo].PDX_CreateRD
		@DocID				= @DocID out,
		@Error				= @Error out,
		
		/*подставляется, что передано - без проверок на правильность*/
		@DocIDPrevious		= '',				--Предшествующий документ

		/*любой перечень, пользователей, вносится в ПД, ровно в том виде в каком передано в хр.пр. (без к-л. проверок)*/
		@Correspondent		= '"А. А. Нескромнов" <NeskromnovAA>',				--Список рассылки
		
		/*указывается или конктретное значение из справочника ПД 
		или значение <ByUser:>, которое означает , что нужно взять подразделение от Создателя карточки*/
		@Department			= '<ByUser:>',		--подразделение 
		
		@Name				= 'О назначении Главного инженера проекта',	--заголовок
		@Description		= 'Приказ создан автоматически из системы Clear Project',	--Приложения
		
		/*Распорядительные док-ты / Приказы
		или Распорядительные док-ты / Распоряжения*/
		@ClassDoc			= 'Распорядительные док-ты / Приказы',
		
		/*любой из используемых видов деят-ти*/
		@ActDoc				= 'Для обучения<99>',			--Вид деятельности
		
		/*или только логин пользователя в ПД или полное имя формате ПД (с логинов у угловых скобках)*/
		@NameCreation		= 'NeskromnovAA',	--Автор

		/*или только логин пользователя в ПД или полное имя формате ПД (с логинов у угловых скобках)*/
		@NameAproval		= '"А. А. Нескромнов" <NeskromnovAA>;',--Имя подписывающего

		/*любой перечень, пользователей. вносится в ПД, ровно в том виде в каком передано в хр.пр. (без к-л. проверок)
		дополняется автором карточки и первым согласующим(нормоконтролером)*/
		@ListToEdit			= '"А. А. Нескромнов" <NeskromnovAA>',				--Список имеющих право редактирования д-та
		
		/*любой перечень, пользователей, вносится в ПД, ровно в том виде в каком передано в хр.пр. (без к-л. проверок)
		дополняется обязательными согласующими 
		(только "первым" и "последним". "любой" не добавляется, та как не понятно куда его вставлять)*/
		@ListToReconcile	= '"А. А. Нескромнов" <NeskromnovAA>',				--Лист согласования
		
		/*вносится то что передается - на соответствие справочнику не проверяется*/
		@UserFieldText4		= @FullName,				--Проект
		
		/*если передан null подставляется текущая дата*/
		@UserFieldDate1		= null,				--Дата ввода в действие
		
		/*подставляется, что передано - без проверок по справочнику
		если передано путое значение - подставляется самая "несрочная" срочность*/
		@Rank				= '',				--Срочность
		
		/*любой перечень, пользователей, вносится в ПД, ровно в том виде в каком передано в хр.пр. (без к-л. проверок)*/
		@ListToView			= '"А. А. Нескромнов" <NeskromnovAA>'				--Список ознакомления

	drop table #tmp
	
	select @DocID ID, @DocID OrderNumber, @Error Error

	return

GO
/****** Object:  StoredProcedure [dbo].[ClearProject_Paydocs_UpdateProjectStartOrder] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[ClearProject_Paydocs_UpdateProjectStartOrder]
	@ID varchar(128),
	@OrderForm varbinary(max)
AS

return 0

GO
/****** Object:  StoredProcedure [dbo].[ContractListFor1C] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[ContractListFor1C]
@PortalIDs varchar(2048),
@DateTimeFrom datetime

as


set nocount on

create table #PNs (PortalID int, PNName varchar(125))
create table #dcs (DocIDInt int, RegDate_last datetime,
	DocID varchar(128), --Рег. Номер - строка
	DateActivation datetime, --	Рег. Дата - дата
	DocIDIncoming  varchar(128),
	Currency varchar(24),
	AmountDoc money,
	UserFieldText7 varchar(1024),
	DateActive datetime,
	DateCompletion datetime,
	Description varchar(4000),
	DocIDParent varchar(128),
	UserFieldText3 varchar(1024),
	NameResponsible varchar(96),
	UserFieldText2 varchar(1024),
	UserFieldText8 varchar(1024),
	PartnerName varchar(128)
	)

--разбираем входящий список КА
insert into #PNs (PortalID)
select ltrim(rtrim(Value))
from dbo.inline_split_with_param(@PortalIDs, ',')
where dbo.PDX_IsTextAsInteger(ltrim(rtrim(Value))) = 1

--получаем названия КА, т.к. в картчоках используются именно названия
--не учитываем устаревшие названия КА, анализируем только актуальные (неизвестно ведут они старые названия или нет)
update P
set PNName = PP.ShortName
from #PNs P
inner join dbo.Partners PP on PP.PortalID = P.PortalID

--отбираем документы по датам, часть дат из комментарием, часть из картчоки
insert into #dcs (DocIDInt,
	DocID, DateActivation, DocIDIncoming, Currency, AmountDoc, UserFieldText7, DateActive, DateCompletion, Description, DocIDParent,
	UserFieldText3, NameResponsible, UserFieldText2, UserFieldText8, PartnerName)
select C.DocIDInt, 
	D.DocID, D.DateActivation, D.DocIDIncoming, D.Currency, D.AmountDoc, D.UserFieldText7, D.DateActive, D.DateCompletion, D.Description, D.DocIDParent,
	D.UserFieldText3, D.NameResponsible, D.UserFieldText2, D.UserFieldText8, D.PartnerName
from dbo.Comments C
inner join dbo.Docs D on D.DocIDInt = C.DocIDInt
	and D.ClassDoc in ( --фильтр по категории
	'Договоры / (B) Осн. на проект',
	'Договоры / (C) СМР',
	'Договоры / (E) По проектированию',
	'Договоры / (F) Фин. обеспечение',
	'Договоры / (H) Прочие(исполнитель)',
	'Договоры / (L) Исх. гарантийное письмо',
	'Договоры / (M) Вх. гарантийное письмо',
	'Договоры / (P) Поставка',
	'Договоры / (S) Пуско-наладка',
	'Договоры / (T) Сервисное обслуживание',
	'Договоры / (X) Прочие(заказчик)',
	'Договоры / (Y) Консульт. услуги'
	)
	and D.IsActive = 'Y' --только активные
	and D.StatusDevelopment = '4' --только утвержденные
	and ISNULL(D.StatusCompletion,'') <> '0' -- только неотмененные
	and not D.DateSigned is null --только подписанные со второй стороны
	and (D.DocIDParent = '' or D.DocIDParent is null) --только договоры 
where C.DateCreation >= @DateTimeFrom
	and C.CommentType = 'HISTORY'
	and (/*C.Comment like 'Документ зарегистрирован , Информация изменена%'
			or C.Comment like 'Document registered , Information updated%'
			or */C.Comment like 'Подписано контрагентом %')
union
 
select D.DocIDInt,
	D.DocID, D.DateActivation, D.DocIDIncoming, D.Currency, D.AmountDoc, D.UserFieldText7, D.DateActive, D.DateCompletion, D.Description, D.DocIDParent,
	D.UserFieldText3, D.NameResponsible, D.UserFieldText2, D.UserFieldText8, D.PartnerName
from dbo.Docs D
where D.DateApproved >= @DateTimeFrom
	and D.ClassDoc in ( --фильтр по категории
	'Договоры / (B) Осн. на проект',
	'Договоры / (C) СМР',
	'Договоры / (E) По проектированию',
	'Договоры / (F) Фин. обеспечение',
	'Договоры / (H) Прочие(исполнитель)',
	'Договоры / (L) Исх. гарантийное письмо',
	'Договоры / (M) Вх. гарантийное письмо',
	'Договоры / (P) Поставка',
	'Договоры / (S) Пуско-наладка',
	'Договоры / (T) Сервисное обслуживание',
	'Договоры / (X) Прочие(заказчик)',
	'Договоры / (Y) Консульт. услуги'
	)
	and D.IsActive = 'Y' --только активные
	and D.StatusDevelopment = '4' --только утвержденные
	and ISNULL(D.StatusCompletion,'') <> '0' -- только неотмененные
	and not D.DateSigned is null --только подписанные со второй стороны
	and (D.DocIDParent = '' or D.DocIDParent is null) --только договоры 

--вычисляем дату последней регистрации	
update X
	set RegDate_last = Y.RegDate_last
from #dcs X
inner join (
	select D.DocIDInt, MAX(C.DateCreation) as RegDate_last
	from #dcs D
	inner join dbo.Comments  C on C.DocIDInt = D.DocIDint
		and UPPER(C.CommentType) = 'HISTORY'
		and (C.Comment like 'Документ зарегистрирован , Информация изменена%'
			or C.Comment like 'Document registered , Information updated%')
	group by D.DocIDInt) as Y on X.DocIDInt = Y.DocIDInt
		
--выводим окончательные данные
select 
	DD.DocID, --Рег. Номер - строка
	DD.DateActivation, --	Рег. Дата - дата
	DD.DocIDIncoming,--	№ договора контрагента -строка
	--PP1.PortalID as Partner1ID, --Юридическое лицо  - PortalID
	case P.PortalID 
		when PP1.PortalID then PP1.PortalID
		else PP2.PortalID
	end as Partner1ID,
	--PP2.PortalID as Partner2ID, --Контрагент  - PortalID
	case P.PortalID 
		when PP1.PortalID then PP2.PortalID
		else PP1.PortalID
	end as Partner2ID,	
	case
		when P.PortalID = PP1.PortalID and DD.UserFieldText3= 'Заказчик' and ROW_NUMBER () OVER ( PARTITION BY DD.DocID order by PP1.PortalID,PP2.PortalID ) = 1 then 'С поставщиком'
		when P.PortalID = PP2.PortalID and DD.UserFieldText3= 'Исполнитель' then 'С поставщиком'
		when P.PortalID = PP1.PortalID and DD.UserFieldText3= 'Исполнитель' and ROW_NUMBER () OVER ( PARTITION BY DD.DocID order by PP1.PortalID,PP2.PortalID ) = 1 then 'С покупателем'
		when P.PortalID = PP2.PortalID and DD.UserFieldText3= 'Заказчик' then 'С покупателем'
		else ''
	end as ContractType, --вид документа
	DD.Currency,--Валюта документа – строка
	DD.AmountDoc, --Сумма документа -число

	
    isnull(Curr.Code2,'') as CurrCode2,
	F.AvansPercent,
	F.GPPercent as GP,
	V.IntKeyField as ID_UFT2,
	[dbo].[PDX_fn_pay_CFOGET] (F.CFO) as CFO,
	dbo.PDX_SubstringReturn(DD.UserFieldText7,CHARINDEX('<',DD.UserFieldText7),CHARINDEX('>',DD.UserFieldText7)) as ID_UFT7,
	isnull(NR.Name,'') as NameResp,
	DD.DateActive,
	DD.DateCompletion,
	--DD.DateActivation,
	DD.Description,
	DD.DocIDParent,
	DD.RegDate_last
from #dcs DD 
inner join #PNs P on (P.PNName = DD.PartnerName or P.PNName = DD.UserFieldText8) --фильтр по входящему списку КА
inner join dbo.Partners PP1 on PP1.Name = DD.UserFieldText8 --Контрагент1 (нужен join , т.к. какой-то из 2-х КА не из исходного списка)
inner join dbo.Partners PP2 on PP2.Name = DD.PartnerName--Контрагент2 (нужен join , т.к. какой-то из 2-х КА не из исходного списка)

left join dbo.Users NR on NR.UserID = dbo.PDX_SubstringReturn(DD.NameResponsible, CHARINDEX('<',DD.NameResponsible), charindex('>',DD.NameResponsible))--D.NameResponsible like '%<' + NR.UserID + '>%'  
left join dbo.CurrencyRates Curr on Curr.Code = DD.Currency
left join dbo.[DocsCFO] F on F.DocIDInt = DD.DocIDInt
left join dbo.UserDirValues V on V.UDKeyField = 30 and V.Field1 = DD.UserFieldText2
    
  



order by DD.DocIDInt


drop table #PNs
drop table #dcs



GO
/****** Object:  StoredProcedure [dbo].[CreateDocsCFO] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[CreateDocsCFO]
	@DocID varchar(128)

		
as
	declare @NC varchar(96),@DocIDInt int,
	@DC datetime, @isOK bit

	set @isOK = 0

	select
		@NC = NameCreation,
		@DC = DateCreation,
		@DocIDInt = DocIDInt,
		@IsOK = case 
					when dbo.PDX_CLSGrByNameGet(ClassDoc) = 'Договоры /' then 1
					--when ClassDoc = 'Прочие / Договоры' then 1
					else 0
				end

	from dbo.Docs
	where DocID = @DocID


	If @isOK = 1
	begin
		insert into [dbo].DocsCFO
			([DocIDInt],
			[CFO],
			ExistGPPercent,
			GPPercent,
			ExistAvans,
			AvansPercent,
			[DC],
			[DLM],
			[NC],
			[NLM])
		values
			(@DocIDInt, --[DocIDInt],
			'',--[[CFO]],
			'0',--ExistGPPercent,
			0,--GPPercent,
			'0',--ExistAvans,
			100,--AvansPercent,
			@DC,--[DC],
			@DC,--[DLM],
			@NC,--[NC],
			@NC)--[NLM])
	end




GO
/****** Object:  StoredProcedure [dbo].[DefValueForKAZUFM] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[DefValueForKAZUFM]
		@ClassDoc	varchar(128),
		--@UFM_Num	tinyint,
		@PN		varchar(1024),
		@UFT8 varchar(1024)

as	
	declare @NameConst varchar(128), @Values varchar(4000), @Descr varchar(4000), @Val money, @Val1 tinyint, @Val2 tinyint

	set @NameConst = dbo.PDX_CLSConstGet(@ClassDoc)

	select top 1 @Val1 = Vnutr_oborot from dbo.Partners where Name = ltrim(rtrim(@PN))
	select top 1 @Val2 = Vnutr_oborot from dbo.PDX_pay_Firms where Name = ltrim(rtrim(@UFT8))
	
	set @Val = 0
	if @Val1 = 1 and @Val2 = 1
	begin
		set @Val = 1
	end
	
/*
	select top 1 Val
	from dbo.SelectValueForUFM 
	where ClsConstName = @NameConst
		and UFM_Num = @UFM_Num
		and Val = @Val
	*/
	select ISNULL(@Val,0) as Val

GO
/****** Object:  StoredProcedure [dbo].[DocsNSI_Change] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE proc [dbo].[DocsNSI_Change]
	@DocID varchar(128),
	
	@DocIDParent varchar(128),
	@PN varchar(128),
	@UFT8 varchar(128),
	@Descr varchar(4000),
	@Currency varchar(12),
	@UFT2 varchar(1024),
	@Percent varchar(128),
	@DocDate datetime ,
	
	@Act tinyint,
	
	@NC varchar(128),
	@Chk bit = 0
	
as
	declare  @Res int

	declare @ErrList varchar(1024),
	@UserID varchar(128), @DocIDInt int, @pPercent money
	

	select @Res = 0,@ErrList = ''
	
	select
		@DocIDInt = DocIDInt
	from dbo.Docs 
	where DocID = @DocID
	and ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_OTHERS_DGC')

	select
		@PN = ltrim(rtrim(isnull(@PN,''))),
		@UFT8 = ltrim(rtrim(isnull(@UFT8,''))),
		@Descr = ltrim(rtrim(isnull(@Descr,''))),
		@Currency = isnull(@Currency,''),
		@UFT2 = isnull(@UFT2,''),
		@DocDate = ISNULL(@DocDate,'1900-02-01'),
		@NC  = ltrim(rtrim(isnull(@NC,''))),
		
		@Percent = ltrim(rtrim(replace(replace(replace(isnull(@Percent,'0'),',','.'),SPACE(1),''),CHAR(160),'')))

/************************************
ПРОВЕРКИ ВВЕДЕННЫХ ЗНАЧЕНИЙ
*************************************/
If @Act in (2)
begin

	if @PN <> ''
	begin
		if not exists (select 1 from dbo.Partners where Name = @PN)
		begin		
			select @ErrList = @ErrList + 
				'<br><font color=red>ОШИБКА! </font> В поле [Организация] указано несуществующее значение.</font>' 
		end
	end
	if @UFT8 <> ''
	begin
		if not exists (select 1 from dbo.Partners where Name = @UFT8)
		begin		
			select @ErrList = @ErrList + 
				'<br><font color=red>ОШИБКА! </font> В поле [Контрагент] указано несуществующее значение.</font>' 
		end
	end
	if @Currency <> ''
	begin
		if not exists (select 1 from dbo.CurrencyRates where Code = @Currency)
		begin		
			select @ErrList = @ErrList + 
				'<br><font color=red>ОШИБКА! </font> В поле [Валюта] указано несуществующее значение.</font>' 
		end
	end
	
	If @Percent = '' 
	begin
	  set @pPercent = 0
	  select @Res = @@error if @Res <> 0 goto Err
	end
	else
	begin
	
	  if ISNUMERIC(@Percent) = 1
	  begin
		set @pPercent = CAST(@Percent as money)
		select @Res = @@error if @Res <> 0 goto Err
		
			
		if not @pPercent between 0 and 100
		begin		
			select @ErrList = @ErrList + 
				'<br><font color=red>ОШИБКА! </font> В поле [Процент зачета аванса] указано некорректное значение.</font>' 
		end
	  end
	  else
	  begin
  		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'В поле [Процент зачета аванса] должно быть указано числовое значение'
		goto NXT
	  end 
	end
	
 
end
/************************************/


NXT:

If @Chk = 0
begin --если это создание , то нужно генерить ошибкуесли она есть
	If @ErrList <> '' 
	begin
		RAISERROR (@ErrList, 16,1)
		goto Err
	end
end
else --если это проверка просто выводим сообщение, даже если оно пустое
begin
	select @ErrList as ErrList 
	select @Res = @@error if @Res <> 0 goto Err
end

IF @ErrList = '' and @Chk = 0
BEGIN
	if @Act = 2
	begin
		update [dbo].[DocsNSI]
			set
				[DocIDParent] = @DocIDParent,
				[Descr] = @Descr,
				[Currency] = @Currency,
				[UFT2] = @UFT2,
				[Percent] = @Percent,
				[DocDate] = @DocDate,
				[PN] = @PN,
				[UFT8] = @UFT8,
				[NLM] = @NC,
				[DLM] = GETDATE()
		where DocIDInt = @DocIDInt
		select @Res = @@error if @Res <> 0 goto Err
	end

END
	select @Res = @@error if @Res <> 0 goto Err

OK:

	return @Res
Err:
	return @Res



GO
/****** Object:  StoredProcedure [dbo].[DocsNSI_Save] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[DocsNSI_Save]
	@DocID varchar(128),	
	@NC varchar(128)
	
as

declare 
	@DocIDParent varchar(128), @DocIDInt int, @RootID varchar(128)

set @NC = dbo.User_PaydoxLogin(@NC)
select 
	@DocIDParent = DocIDParent,
	@DocIDInt = DocIDInt
from dbo.Docs 
where DocID = @DocID

if not @DocIDInt is null
begin

	;with X(DocID,DocIDParent) as (
	select DocID, DocIDParent
	from dbo.Docs
	where DocID = @DocIDParent
	union all
	select D.DocID, D.DocIDParent
	from X
	inner join dbo.Docs D on D.DocID = X.DocIDParent
	)
	select @RootID = DocID
	from X 
	where X.DocIDParent = ''
	
	set @RootID = ISNULL(@RootID,'')
	set @RootID = case @RootID when '' then @DocIDParent else @RootID end
	
	if exists (select 1 from [dbo].[DocsNSI] where DocIDInt = @DocIDInt)
	begin
		update N
			set
				--[DocIDParent] = @RootID,
				[Descr] = case D.DocIDParent
							when '01/X000' then ''
							else isnull(DD.Description,'')
						end,
				[Currency] = case D.DocIDParent
								when '01/X000' then ''
								else isnull(DD.Currency,'')
							end,
				[UFT2] = case D.DocIDParent
							when '01/X000' then ''
							else isnull(DD.UserFieldText2,'')
						end,
				[Percent] = case D.DocIDParent
								when '01/X000' then 0
								else isnull(C.AvansPercent,0)
							end,
				[DocDate] = case D.DocIDParent
								when '01/X000' then '1900-02-01'
								else ISNULL(DD.DateActivation,'1900-02-01')
							end,
				[NLM] = @NC,
				[DLM] = GETDATE()
		from [dbo].[DocsNSI] N
		inner join dbo.Docs D on D.DocIDInt = N.DocIDInt
		left join dbo.Docs DD on DD.DocID = D.DocIDParent
		left join dbo.DocsCFO C on DD.DocIDInt = C.DocIDInt
		where N.DocIDInt = @DocIDInt
	--select * from DocsNSI where DocIDInt = @DocIDInt	
	end
	else 
	begin
		if exists (select 1 from dbo.Docs D where D.DocID = @DocIDParent)
		begin
			insert into [dbo].[DocsNSI]
				([DocIDInt] ,
				[DocIDParent],
				[UFT8],
				[PN],
				[Descr],
				[Currency],
				[UFT2],
				[Percent],
				[DocDate],
				[NLM],
				[DLM])
			select
				@DocIDInt,
				@RootID,
				case @DocIDParent
					when '01/X000' then ''
					else D.UserFieldText8
				end,
				case @DocIDParent
					when '01/X000' then ''
					else D.PartnerName
				end,
				case @DocIDParent
					when '01/X000' then ''
					else D.Description
				end,
				case @DocIDParent
					when '01/X000' then ''
					else D.Currency
				end,
				case @DocIDParent
					when '01/X000' then ''
					else D.UserFieldText2
				end,
				case @DocIDParent
					when '01/X000' then 0
					else isnull(C.AvansPercent,0)
				end,
				case @DocIDParent
					when '01/X000' then '1900-02-01'
					else D.DateActivation
				end,
				@NC,
				GETDATE()
			from dbo.Docs D
			left join dbo.DocsCFO C on D.DocIDInt = C.DocIDInt
			where D.DocID = @DocIDParent
		end
		else
		begin
			insert into [dbo].[DocsNSI]
				([DocIDInt] ,
				[DocIDParent],
				[PN],
				[UFT8],
				[Descr],
				[Currency],
				[UFT2],
				[Percent],
				[DocDate],
				[NLM],
				[DLM])
			values 
				(@DocIDInt,
				'',
				'',
				'',
				'',
				'',
				'',
				0,
				'1900-02-01',
				@NC,
				GETDATE())
		end
	end
end

return


GO
/****** Object:  StoredProcedure [dbo].[GetSelectValueForUFM] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[GetSelectValueForUFM]
		@ClassDoc	varchar(128),
		@UFM_Num	tinyint

as	
	declare @NameConst varchar(128), @Values varchar(4000), @Descr varchar(4000)

	set @NameConst = dbo.PDX_CLSConstGet(@ClassDoc)

	select distinct Val as ID, Descr as Name
	from dbo.SelectValueForUFM
	where ClsConstName = @NameConst
		and UFM_Num = @UFM_Num
	order by Val
GO
/****** Object:  StoredProcedure [dbo].[GetUsersbyRole] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[GetUsersbyRole]
	@UserID varchar(20)
	
as
declare @PRoles varchar(4096)
set @PRoles = ''

select 
--@PRoles = @PRoles + case LEN(@PRoles) when 0 then '' else CHAR(13)+CHAR(10) end + 
dbo.User_PaydoxLoginByParam(UserID,Name) as UName,
Department,
Position
from dbo.Users
where PossibleRoles like '%<' + @UserID + '>%'
order by Name

--select @PRoles as 'PRoles', dbo.User_PaydoxLogin(@UserID) as 'UName'


GO
/****** Object:  StoredProcedure [dbo].[PayKPP_Change] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PayKPP_Change]
	@Firm varchar(256),
	@KPP varchar(10),
	@KeyField int,
	@NC varchar(128),
	@Act int, --1--ceate, 2-update,3 delete
	@Chk bit = 0
	
as
	declare  @Res int

	declare @ErrList varchar(1024)

	select @Res = 0,@ErrList = ''
	


	select
		@Firm = ltrim(rtrim(isnull(@Firm,''))),
		@KPP = ltrim(rtrim(isnull(@KPP,''))),
		@NC  = ltrim(rtrim(isnull(@NC,'')))
	select @Res = @@error if @Res <> 0 goto Err


/************************************
ПРОВЕРКИ ВВЕДЕННЫХ ЗНАЧЕНИЙ
*************************************/

If @Firm = ''
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Укажите бизнес-единицу'
	goto NXT
end

If @KPP = ''
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Укажите КПП'
	goto NXT
end
else if LEN(@KPP)<> 9
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Некорректно указан КПП (должно быть 9 символов)'
	goto NXT
end

If not exists (select 1 from dbo.PDX_pay_Firms where Name = @Firm)
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Указанная бизнес-единица не существует'
	select @Res = @@error if @Res <> 0 goto Err		
end

If exists (select 1 from dbo.PayKPP where Firm = @Firm and Kpp = @KPP
		and KeyField <> isnull(@KeyField,-1))
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Указанное сочетание БЕ и КПП в справочнике уже существует'
	select @Res = @@error if @Res <> 0 goto Err		
end

/************************************/

NXT:

If @Chk = 0
begin --если это создание , то нужно генерить ошибкуесли она есть
	If @ErrList <> '' 
	begin
		RAISERROR (@ErrList, 16,1)
		goto Err
	end
end
else --если это проверка просто выводим сообщение, даже если оно пустое
begin
	select @ErrList as ErrList 
	select @Res = @@error if @Res <> 0 goto Err
end

IF @ErrList = '' and @Chk = 0
BEGIN
	if @Act = 2
	begin
		update dbo.PayKPP
			set 
				Firm = @Firm,
				KPP = @KPP,
				NLM = @NC,
				DLM = getdate()
		where KeyField = @KeyField
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 1
	begin
		insert into dbo.PayKPP
			(Firm, KPP, NC, DC, NLM, DLM)
		values 
			(@Firm, @KPP, @NC, getdate(), @NC, getdate())
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 3
	begin
		delete from dbo.PayKPP where KeyField = @KeyField
		select @Res = @@error if @Res <> 0 goto Err
	end
END
	select @Res = @@error if @Res <> 0 goto Err

OK:

	return @Res
Err:
	return @Res



GO
/****** Object:  StoredProcedure [dbo].[PDX_1C_DataGet] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE proc [dbo].[PDX_1C_DataGet]
		@CFO varchar(512),   --наименование ЦФО (ид вычисляется внутри)
		@Article varchar(512), --наименование статьи с кодом (полное "деревянное" название, если нужно вычисляется внутри, а вот как получить ИД не понятно)
		@Currency varchar(10), --валюта (и вычисляется внутри)
		@Date datetime  --дата

as
	declare @Result int,
		@CFOID varchar(25), --ИД ЦФО
		@ArticleID int, --ИД статьи
		@ArticleFull varchar(1024), --полное "деревянное" название статьи
		@CurrencyID int, --ИД валюты
		@AmountPlanned money, --сумма запланированная
		@AmountExpense money --сумма потраченная
		
		
	select @Result = 0
	--create table #RES (Val money)
	
	--получаем ИДЕНТИФИКАТОРЫ для переданных значений
	select 
		@CFOID		= dbo.PDX_fn_pay_CFOGET(@CFO), --ИД ЦФО
		@ArticleID = dbo.PDX_fn_pay_PRiZIDGET(@Article), -- ПОЛУЧАЕМ ИД СТАТЬИ ПО ЕЕ КОДУ, КОД ОДНОЗНАЧНО ИДЕНТИФИЦИРУЕТ СТАТЬЮ
		@ArticleFull= dbo.PDX_fn_pay_PRiZGET(@Article),--А ВОТ ИД СТАТЬИ У МЕНЯ НЕТ, ТОЛЬКО "ПОЛНОЕ ДЕРЕВЯННОЕ" ИМЯ
		@CurrencyID = (select Code2 from dbo.CurrencyRates where Code = @Currency) --ИД ВАЛЮТЫ - ПРАВИЛЬНО ЛИ ЧТО ЭТО CODE2 ИЗ ПД-ТАБЛИЦЫ ВАЛЮТ
	select @Result = @@error if @Result <> 0 goto Err

--ПОЛУЧАЕМ ДАННЫЕ ИЗ 1С
--***********************************
  --ЗАПЛАНИРОВАННАЯ СУММА
	select 0
	--insert into #RES (Val)
	/*EXEC [server06].[accounting2].[dbo].[PayDox_Planned_Sum_Get]
		  @CFOID = @CFOID,
		  @ArticleID = @ArticleID,
		  @CurrencyID = @CurrencyID,
		  @Date = @Date
	select @Result = @@error if @Result <> 0 goto Err*/
	/*
	select top 1 @AmountPlanned = Val
	from #RES
	select @Result = @@error if @Result <> 0 goto Err
	
	delete from #RES
	select @Result = @@error if @Result <> 0 goto Err
	*/
	
	--ПОТРАЧЕННАЯ СУММА
	select 0
	--insert into #RES (Val)
	/*EXEC [server06].[accounting2].[dbo].[PayDox_Expense_Sum_Get]
		  @CFOID = @CFOID,
		  @ArticleID = @ArticleID,
		  @CurrencyID = @CurrencyID,
		  @Date = @Date*/
	select @Result = @@error if @Result <> 0 goto Err
/*
	select top 1 @AmountExpense = Val
	from #RES
	select @Result = @@error if @Result <> 0 goto Err
	*/
	
--***********************************
/*
	--возвращаем результат
	select @AmountExpense as AmountExpense, @AmountPlanned as AmountPlanned
	select @Result = @@error if @Result <> 0 goto Err
*/
	--drop table #RES
	return @Result
Err:
	
	--drop table #RES
	return @Result


GO
/****** Object:  StoredProcedure [dbo].[PDX_1C_DataGet_TEMP] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_1C_DataGet_TEMP]
		@CFO varchar(512),   --наименование ЦФО (ид вычисляется внутри)
		@Article varchar(512), --наименование статьи с кодом (полное "деревянное" название, если нужно вычисляется внутри, а вот как получить ИД не понятно)
		@Currency varchar(10), --валюта (и вычисляется внутри)
		@Date datetime  --дата

as
	declare @Result int,
		@CFOID varchar(25), --ИД ЦФО
		@ArticleID int, --ИД статьи
		@ArticleFull varchar(1024), --полное "деревянное" название статьи
		@CurrencyID int, --ИД валюты
		@AmountPlanned money, --сумма запланированная
		@AmountExpense money --сумма потраченная
		
		
	select @Result = 0
	--create table #RES (Val money)
	
	--получаем ИДЕНТИФИКАТОРЫ для переданных значений
	select 
		@CFOID		= dbo.PDX_fn_pay_CFOGET(@CFO), --ИД ЦФО
		@ArticleID = dbo.PDX_fn_pay_PRiZIDGET(@Article), -- ПОЛУЧАЕМ ИД СТАТЬИ ПО ЕЕ КОДУ, КОД ОДНОЗНАЧНО ИДЕНТИФИЦИРУЕТ СТАТЬЮ
		@ArticleFull= dbo.PDX_fn_pay_PRiZGET(@Article),--А ВОТ ИД СТАТЬИ У МЕНЯ НЕТ, ТОЛЬКО "ПОЛНОЕ ДЕРЕВЯННОЕ" ИМЯ
		@CurrencyID = (select Code2 from dbo.CurrencyRates where Code = @Currency) --ИД ВАЛЮТЫ - ПРАВИЛЬНО ЛИ ЧТО ЭТО CODE2 ИЗ ПД-ТАБЛИЦЫ ВАЛЮТ
	select @Result = @@error if @Result <> 0 goto Err

--ПОЛУЧАЕМ ДАННЫЕ ИЗ 1С
--***********************************
  --ЗАПЛАНИРОВАННАЯ СУММА
	--insert into #RES (Val)
	select 0
	/*EXEC [server06].[accounting2].[dbo].[PayDox_Planned_Sum_Get]
		  @CFOID = @CFOID,
		  @ArticleID = @ArticleID,
		  @CurrencyID = @CurrencyID,
		  @Date = @Date
	select @Result = @@error if @Result <> 0 goto Err*/
	/*
	select top 1 @AmountPlanned = Val
	from #RES
	select @Result = @@error if @Result <> 0 goto Err
	
	delete from #RES
	select @Result = @@error if @Result <> 0 goto Err
	*/
	
	--ПОТРАЧЕННАЯ СУММА
	--insert into #RES (Val)
	select 0
	/*EXEC [server06].[accounting2].[dbo].[PayDox_Expense_Sum_Get]
		  @CFOID = @CFOID,
		  @ArticleID = @ArticleID,
		  @CurrencyID = @CurrencyID,
		  @Date = @Date
	select @Result = @@error if @Result <> 0 goto Err*/
/*
	select top 1 @AmountExpense = Val
	from #RES
	select @Result = @@error if @Result <> 0 goto Err
	*/
	
--***********************************
/*
	--возвращаем результат
	select @AmountExpense as AmountExpense, @AmountPlanned as AmountPlanned
	select @Result = @@error if @Result <> 0 goto Err
*/
	--drop table #RES
	return @Result
Err:
	
	--drop table #RES
	return @Result


GO
/****** Object:  StoredProcedure [dbo].[PDX_1Cn_DataGet] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE proc [dbo].[PDX_1Cn_DataGet]
		@CFO nvarchar(9),   --наименование ЦФО (ид вычисляется внутри)
		@Article nvarchar(9), --наименование статьи с кодом (полное "деревянное" название, если нужно вычисляется внутри, а вот как получить ИД не понятно)
		@Currency nvarchar(3), --валюта (и вычисляется внутри)
		@Date datetime  --дата

as
	declare @Result int,
		@CurrencyID int --ИД валюты
		
		
	select @Result = 0
	
	--получаем ИДЕНТИФИКАТОРЫ для переданных значений
	select 
		@CurrencyID = (select Code2 from dbo.CurrencyRates where Code = @Currency) --ИД ВАЛЮТЫ - ПРАВИЛЬНО ЛИ ЧТО ЭТО CODE2 ИЗ ПД-ТАБЛИЦЫ ВАЛЮТ
	select @Result = @@error if @Result <> 0 goto Err

--ПОЛУЧАЕМ ДАННЫЕ ИЗ 1С
--***********************************
  --ЗАПЛАНИРОВАННАЯ СУММА
	EXEC [DWI-VSB-SQL01\SQL_1C].[83optreasure].dbo.[PayDox_Planned_Sum_Get] 
		  @CFOID = @CFO, --@CFOID,
		  @ArticleID = @Article, --@ArticleID,
		  @CurrencyID = @CurrencyID,
		  @Date = @Date
	select @Result = @@error if @Result <> 0 goto Err
	
	
	--ПОТРАЧЕННАЯ СУММА
	
	EXEC [DWI-VSB-SQL01\SQL_1C].[83optreasure].[dbo].[PayDox_Expense_Sum_Get]
	      @CFOID = @CFO, --@CFOID,
		  @ArticleID = @Article, --@ArticleID,
		  @CurrencyID = @CurrencyID,
		  @Date = @Date
	select @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:
	
	return @Result


GO
/****** Object:  StoredProcedure [dbo].[PDX_ACCR_Aprove] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
--drop proc [dbo].[PDX_ACCR_Aprove]
--go
create proc [dbo].[PDX_ACCR_Aprove]
	@UserID varchar(128),
	@NameAproval varchar(128),
	@Date datetime,
	@Flg bit = 0
	
as
	declare 
	@Res int,
	@StopRefuseFlag bit,
	@ClassDoc varchar(128)

	create table #Apptmp (DocIDINt int, DocID varchar(128), UFM1 varchar(256),
		UFT8 varchar(1024), UFT2 varchar(1024), AmountDoc money, AmountDoc1 money, Currency varchar(64))

	select @NameAproval = dbo.PDX_SubstringReturn(@NameAproval, CHARINDEX('<',@NameAproval), charindex('>',@NameAproval))
	select @Res = @@error if @Res <> 0 goto Err
	
	select @StopRefuseFlag = StopRefuseFlag,
		@ClassDoc = DocType
	from dbo.PDXDocTypesConst
	where ConstName = 'RIK_CategoryName_KAZ_ACCRUAL'
	select @Res = @@error if @Res <> 0 goto Err

	insert into #Apptmp
		(DocIDINt,DocID, UFM1, UFT2, UFT8, Currency)
	SELECT D.DocIDINt,
		D.DocID, 
		U.Descr as UFM1,  
		D.Userfieldtext2, D.Userfieldtext8, D.Currency
	FROM dbo.Docs AS D 
	inner join dbo.SelectValueForUFM U on ClsConstName = 'RIK_CategoryName_KAZ_ACCRUAL'
		and UFM_Num = 1
		and Val = D.UserFieldMoney1
	WHERE D.ClassDoc = @ClassDoc
		AND CHARINDEX('<' + @NameAproval + '>', D.NameAproval) > 0 
		AND UPPER(ISNULL(D.IsActive, '')) = 'Y'
		AND NOT (ISNULL(D.StatusCompletion, '') IN ('1', '0')) 
		AND isnull(D.StatusDevelopment,'') <> '0'
		AND ltrim(rtrim(isnull(D.NameApproved,''))) = ''
		AND dbo.PDX_CompareReconcilationList(D.ListToReconcile, D.ListReconciled) = 1
		and dbo.PDX_fn_stopReconcilation (D.ListToReconcile, D.ListReconciled, @StopRefuseFlag) = 0
		and MONTH(D.UserFieldDate1) = MONTH(@Date)
		and year(D.UserFieldDate1) = year(@Date)
	select @Res = @@error if @Res <> 0 goto Err


	update X
		set AmountDoc = Y.Am, AmountDoc1 = Y.Am1
	from #Apptmp X
	inner join (
		select A.DocIDINt, SUM(case P.blnType when 0 then P.Amount else 0 end) as Am, SUM(case P.blnType when 1 then P.Amount else 0 end) as Am1
		from #Apptmp A
		inner join dbo.PDXAccrual P on P.DocIDInt = A.DocIDINt and P.isDel = 0
		group by A.DocIDInt) Y on X.DocIDINt = Y.DocIDINt

	If @Flg = 1
	begin
		update D
		set StatusDevelopment='4',
			DateApproved = @Date,
			NameApproved=D.NameAproval
		from #Apptmp A
		inner join dbo.Docs D on D.DocID = A.DocID
		select @Res = @@error if @Res <> 0 goto Err
		
		insert into Comments	
			(UserID,
			UserName,
			ContactUserName,
			ContactUserID,
			PartnerName,
			DocID,
			DateCreation,
			DateEvent,
			DateEventEnd,
			Address,
			Subject,
			Comment,
			CommentType,
			SpecialInfo,
			FileName,
			--KeyField,
			PartnerID,
			Version,
			GUID,
			GUIDPartner,
			GUIDUser,
			GUIDDoc,
			Amount,
			FileNameOriginal,
			RIK_CommentType)
		select
			dbo.PDX_SubstringReturn(@UserID, charindex('<',@UserID), charindex('>', @UserID)), -- UserID,
			ltrim(rtrim(replace(replace(@UserID,dbo.PDX_SubstringReturn(@UserID, charindex('<',@UserID), charindex('>', @UserID)),''),'"',''))),--UserName,
			null,--ContactUserName,
			null,--ContactUserID,
			null,--PartnerName,
			DocID,--DocID,
			getdate(),--DateCreation,
			null,--DateEvent,
			null,--DateEventEnd,
			null,--Address,
			null,--Subject,
			'Завершено Автоматически на дату ' + CONVERT(varchar(100), @Date, 104),--Comment,
			'APROVAL',--CommentType,
			'',-- SpecialInfo,
			null,--FileName,
			--KeyField,
			null,--PartnerID,
			null,--Version,
			newid(),--GUID,
			null,--GUIDPartner,
			null,--GUIDUser,
			null,--GUIDDoc,
			null,--Amount,
			null,--FileNameOriginal,
			null--RIK_CommentType
		FROM #Apptmp
		select @Res = @@error if @Res <> 0 goto Err
	end
	
	select * from #Apptmp order by DocID
	select @Res = @@error if @Res <> 0 goto Err
		
	drop table #Apptmp
OK:

	return @Res
Err:
	return @Res


GO
/****** Object:  StoredProcedure [dbo].[PDX_ACCR_Unload] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_ACCR_Unload] --ВЫГРУЗКА  ЗАЯВОК на начисление
	@Date datetime 
as

set nocount on

	declare @Result int
	set @Result = 0
	--set @Date to 1 minute earlier then the last exchange session to avoid any missed time intervals
	set @Date = dateadd(mi, -1, @Date)

	create table #ACCR
	(	
		TransferGUID uniqueidentifier,		--УНИКАЛЬНЫЙ ИД ЗАПИСИС. DocID - теоретически м.б. изменен
		DocID varchar(128),			--Рег. номер
		DateActive datetime,		--дата последней активации
		UserFieldText8 varchar(1024),		--Бизнес единица
		ID_UFT8 varchar(1024),			--Бизнес единица (код)
		[STATUS] tinyint,				--статус
		PartnerName varchar(512),		--Контрагент
		PNTaxID varchar(64),			--ИНН
		PortalID int,			--ИД КА на портале

		DocIDParent varchar(128),		--Основной договор
		ParentID varchar(128),			--Основной договор(номер на бумаге)

		UserFieldText2 varchar(1024),		--ЦФО
		ID_UFT2 varchar(1024),			--ЦФО(код)

		UserFieldText3 varchar(1024),		--Сценарий
		ID_UFT3 varchar(1024),			--Сценарий(код)
			
		UserFieldText4 varchar(1024),		--Объект
		ID_UFT4 varchar(1024),			--Объект(код)

		Currency varchar(12),			--Валюта
		CurrCode2 varchar(12),			--

		ID_UFM1 money,			--Вид начислений(код)
		UserFieldMoney1 varchar(1024) ,	--Вид начислений
		ID_UFM2 money,			--Ставка НДС(код)
		UserFieldMoney2 varchar(1024),	--Ставка НДС

		AmountWithNDS money,		--сумма с НДС
		AmountWithOutNDS money,	--сумма с НДС
		Oborot varchar(1024),				--статья оборотов
		ID_Oborot varchar(1024),			--статья оборотов(код)
		Grp varchar(1024),				--Номенклатурная группа
		ID_Grp varchar(1024),			--Номенклатурная группа(код)
		NZP money,				--Коэффициент НЗП
		AmountID int,			--ID (INT) сумме

		NameAproval varchar(96),		--Заявитель
		NameApp varchar(96),
		NameCreation varchar(96),		--Автор
		NameCr varchar(96),

		UserFieldDate3 datetime,		--Рег. дата
		UserFieldDate1 datetime,		--Дата закрытия работ
		DateApproved datetime,		--дата утверждения
		UserFieldText1 varchar(1024),		--Наименование листа согласования
		ListToReconcile  varchar(1024))		--Лист согласования
	

	insert into #ACCR
	exec PayDoxOP.[dbo].[PDX_ACCR_UnloadFromDB]
	@Date= @Date
	
	
	select * from #ACCR

	drop table #ACCR
	
set nocount off
	return @Result
Err:

set nocount off
		return @Result









GO
/****** Object:  StoredProcedure [dbo].[PDX_ACCR_UnloadFromDB] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



--drop proc [dbo].[PDX_ACCR_UnloadFromDB]
--go
CREATE proc [dbo].[PDX_ACCR_UnloadFromDB]
	@Date datetime
	
as
/*
ВСЕ ВОЗМОЖНЫЕ СТАТУСЫ - STATUS:
	-3 - ошибка в статусе
	-2 - отменен
	-1 - неактивен
	 0 - отказано в согласовании
	 1 - на согласовании
	 2 - утверждена
	 4 - отменена
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
данная процедура оперирует только статусами:
	-3 - ошибка в статусе
 	 0 - отказано в согласовании
	 1 - на согласовании
	 2 - утверждена
	 4 - отменена
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Процедура отбирает карточки документов "Заявка на оплату", которые были:
	АКТИВИРОВАНЫ - дата последней активации (DateActive из табл. Docs)
		(Изменения только полей карточке, загрузка файлов, написание комментариев к карточке не учитывается)
	ИЛИ
	ИЗМЕНЕНЫ - дата последнего изменения (DateLastModifacation из табл. Docs)
	ИЛИ
	УТВЕРЖДЕНЫ - дата последнего утверждения (DateApproved из табл. Docs)
после указанной даты (@Date)
    ИЛИ 
    ОТМЕНЕНЫ - статус отменено
В выборку также попадают документы, в которых после указанной даты (@Date) были отказы в согласовании.
Но если такой отказ был отозван(отправлено на повторное согласование или отказавший был исключен из ЛС), 
то карточка в выборку не попадает.
Это обусловлено тем, что нас интересует только ТЕКУЩИЙ(действительный) статус документа "отказано в согласоании".
Если отказ был отозван, то статус документа вернулся в состояние "требует согласования" и документ нас будет интересовать, 
если он попадает под DateActive/DateLastModification/DateApproved
	
Процедура возвращает след. данные:
TransferGUID,		--УНИКАЛЬНЫЙ ИД ЗАПИСИС. DocID - теоретически м.б. изменен
DocID,				--Рег. номер
DateActive,			--дата последней активации
UserFieldText8,		--Бизнес единица
ID_UFT8,			--Бизнес единица (код)
STATUS,				--статус
PartnerName,		--Контрагент
PNTaxID,			--ИНН
PortalID,			--ИД КА на портале

DocIDParent,		--Основной договор
ParentID,			--Основной договор(номер на бумаге)

UserFieldText2,		--ЦФО
ID_UFT2,			--ЦФО(код)

UserFieldText3,		--Сценарий
ID_UFT3,			--Сценарий(код)
	
UserFieldText4,		--Объект
ID_UFT4,			--Объект(код)

Currency,			--Валюта
CurrCode2,			--

ID_UFM1,			--Вид начислений(код)
UserFieldMoney1,	--Вид начислений
ID_UFM2,			--Ставка НДС(код)
UserFieldMoney2,	--Ставка НДС

AmountWithNDS,		--сумма с НДС
AmountWithOutNDS,	--сумма с НДС
Oborot,				--статья оборотов
ID_Oborot,			--статья оборотов(код)
Grp,				--Номенклатурная группа
ID_Grp,				--Номенклатурная группа(код)
NZP,				--Коэффициент НЗП
AmountID,			--ID (INT) сумме

NameAproval,		--Заявитель
NameApp,
NameCreation,		--Автор
NameCr,

UserFieldDate3,		--Рег. дата
UserFieldDate1,		--Дата закрытия работ
DateApproved,		--дата утверждения
UserFieldText1,		--Наименование листа согласования
ListToReconcile		--Лист согласования
*/
	
	declare  @Res int

	declare @DocID varchar(128),
		@StopRefuseFlag bit, @ConstName varchar(128)

	set nocount on

	create table #tbl_pay
		(DocIDInt int,
		DocID varchar(128),
		StatusDevelopment varchar(1),
		VisaRefuse bit,
		Flg bit default 0,
		DocIDParent varchar(128), 
		ParentID varchar(128), 
		PartnerName varchar(512),
		TaxID varchar(32),
		PortalID int,
		KeyField int,
		isDel bit)

	create table #del_summ
		(DocID varchar(128),
		Am1 money,
		SetID uniqueidentifier,
		Tx1 varchar(2048))
		
	declare @ErrList varchar(4000),
		@ClassName varchar(128)

	set @ConstName = 'RIK_CategoryName_KAZ_ACCRUAL'
	select @ClassName = DocType,
		@StopRefuseFlag = StopRefuseFlag 
	from dbo.PDXDocTypesConst
	where ConstName = @ConstName
	select @Res = @@error if @Res <> 0 goto Err

	select @Res = 0,@ErrList = ''
	
	--по датам из комментов
	--отказ в согласовании, причем только если этот отказ не был отозван
	insert into #tbl_pay
		(DocIDInt, DocID,	StatusDevelopment, VisaRefuse, DocIDParent, PartnerName)
	select distinct D.DocIDInt, D.DocID, D.StatusDevelopment, 
			case --условие, что отказ не был отозван (отзыв отказа - это или удалили из ЛС отказника или отменили его оказ в согл.)
				when isnull(D.ListReconciled,'') like '%-<%' 
						and isnull(D.ListToReconcile,'') like '%<' + C.UserID + '>%'
						and isnull(D.ListReconciled,'') like '%-<' + C.UserID + '>%'
					then 1 
				else 0 
			end, D.DocIDParent, D.PartnerName
	from dbo.Comments C
	inner join 	dbo.Docs D on C.DocIDInt = D.DocIDInt
		and D.ClassDoc = @ClassName --смотрим чтобы была нужная категория
		and Upper(isnull(D.isActive,'')) = 'Y' --активная карточка
		and isnull(D.StatusCompletion,'') <> '0' --неотмененая карточка (отмененные это отдельный блок)
		and case when isnull(ListReconciled,'') like '%-<%' then 1 else 0 end = 1
		and D.DateCreation >= @Date
	where Upper(isnull(C.CommentType,'')) = 'VISA' --берем отказ в согласовании
		and Upper(isnull(C.SpecialInfo,'')) = 'VISAOKREFUSE'
		and C.DateCreation >= @Date
	select @Res = @@error if @Res <> 0 goto Err

	--по датам из комментов
	--отправка на повторное согласование - смысл в том, чтобы "засечь" изменение статуса с "приостановлено-есть отказ" на "требует согласоание"
	--вариант когда при отмене стаус не меняется нам в принципе не интересен, но так как отделить эти ситуации невозможно - будем "брать" все
	insert into #tbl_pay
		(DocIDInt, DocID,	StatusDevelopment, VisaRefuse, DocIDParent, PartnerName)
	select distinct D.DocIDInt, D.DocID, D.StatusDevelopment, 
			dbo.PDX_fn_stopReconcilation(D.ListToReconcile, D.ListReconciled, @StopRefuseFlag),
			D.DocIDParent, D.PartnerName
	from dbo.Comments C
	inner join 	dbo.Docs D on C.DocIDInt = D.DocIDInt
		and D.ClassDoc = @ClassName --смотрим чтобы была нужная категория
		and Upper(isnull(D.isActive,'')) = 'Y' --активная карточка
		and isnull(D.StatusCompletion,'') <> '0' --неотмененая карточка (отмененные это отдельный блок)
		and D.DateCreation >= @Date
	where Upper(isnull(C.CommentType,'')) = 'VISA' --берем отказ в согласовании
		and Upper(isnull(C.SpecialInfo,'')) = 'PARTVISACANCEL'
		and C.DateCreation >= @Date
		and not exists(select 1 from #tbl_pay P where P.DocIDInt = D.DocIDInt and P.KeyField is null)--не повторяемся, если карточка отобралась через отказ
	select @Res = @@error if @Res <> 0 goto Err

	--по датам из картчоки
	insert into #tbl_pay
		(DocIDInt, DocID,	StatusDevelopment, VisaRefuse, DocIDParent, PartnerName)
	select distinct D.DocIDInt, D.DocID, D.StatusDevelopment, 
		dbo.PDX_fn_stopReconcilation(ListToReconcile, ListReconciled, @StopRefuseFlag), 
		D.DocIDParent, D.PartnerName
	from dbo.Docs D
	where D.ClassDoc = @ClassName --смотрим чтобы была нужная категория
	and (isnull(D.DateActive,D.DateLastModification) >= @Date or --отбираем по дате последней активаци
		isnull(D.DateLastModification, D.DateCreation) >= @Date or --отбираем по дате последнего изм-я
		isnull(D.DateApproved,'1900-01-01') >= @Date) --отбираем по дате утв-я
	and Upper(isnull(D.isActive,'')) = 'Y'--активная карточка
	and isnull(D.StatusCompletion,'') <> '0'	--неотмененая карточка (отмененные это отдельный блок)
	and not exists(select 1 from #tbl_pay P where P.DocIDInt = D.DocIDInt and P.KeyField is null)--не повторяемся, если карточка отобралась через отказ
	and D.DateCreation >= @Date
	select @Res = @@error if @Res <> 0 goto Err
	
	--по датам из комментов
	---отмена заявки
	insert into #tbl_pay
		(DocID,	StatusDevelopment, VisaRefuse, DocIDParent, PartnerName)
	select distinct D.DocID, D.StatusDevelopment, 
			dbo.PDX_fn_stopReconcilation(D.ListToReconcile, D.ListReconciled, @StopRefuseFlag),
			D.DocIDParent, D.PartnerName
	from dbo.Comments C
	inner join 	dbo.Docs D on C.DocID = D.DocID
		and D.ClassDoc = @ClassName --смотрим чтобы была нужная категория
		and Upper(isnull(D.isActive,'')) = 'Y' --активная карточка
		and isnull(D.StatusCompletion,'') = '0' --отмененая карточка
		and D.DateCreation >= @Date
	where Upper(isnull(C.CommentType,'')) = 'HISTORY' --берем отказ в согласовании
		and Upper(isnull(C.SpecialInfo,'')) = 'CANCELED'
		and C.DateCreation >= @Date
		and not exists(select 1 from #tbl_pay P where P.DocIDInt = D.DocIDInt and P.KeyField is null)--не повторяемся, если карточка отобралась через отказ
	select @Res = @@error if @Res <> 0 goto Err
	
	--по удалению сумм-детальной строки
	--сначала берем "удаленные", т.к. это "событие приоритетно" (здесь будет важен размер суммы = 0)
	insert into #tbl_pay
		(DocIDInt, DocID,	StatusDevelopment, VisaRefuse, DocIDParent, PartnerName,KeyField, isDel)
	select distinct D.DocIDInt, D.DocID, D.StatusDevelopment, 
		dbo.PDX_fn_stopReconcilation(ListToReconcile, ListReconciled, @StopRefuseFlag), 
		D.DocIDParent, D.PartnerName, T.KeyField, 1
	from dbo.PDXAccrual T
		inner join dbo.Docs D on D.DocIDInt = T.DocIDInt
			and  D.ClassDoc = @ClassName --смотрим чтобы была нужная категория
			and Upper(isnull(D.isActive,'')) = 'Y'--активная карточка
			and isnull(D.StatusCompletion,'') <> '0'	--неотмененая карточка (отмененные это отдельный блок)
			and D.DateCreation >= @Date
	where T.DLM >= @Date  --отбираем по дате последнего изм-я 
	and T.isDel = 1
	and not exists(select 1 from #tbl_pay P where P.DocIDInt = D.DocIDInt and P.KeyField = T.KeyField)--не повторяемся, если карточка отобралась через отказ
	select @Res = @@error if @Res <> 0 goto Err
	
	--по дате корректировке сумм
	--
	insert into #tbl_pay
		(DocIDInt, DocID,	StatusDevelopment, VisaRefuse, DocIDParent, PartnerName, KeyField, isDel)
	select distinct D.DocIDInt, D.DocID, D.StatusDevelopment, 
		dbo.PDX_fn_stopReconcilation(ListToReconcile, ListReconciled, @StopRefuseFlag), 
		D.DocIDParent, D.PartnerName, T.KeyField, 0
	from dbo.PDXAccrual T
		inner join dbo.Docs D on D.DocIDInt = T.DocIDInt
			and  D.ClassDoc = @ClassName --смотрим чтобы была нужная категория
			and Upper(isnull(D.isActive,'')) = 'Y'--активная карточка
			and isnull(D.StatusCompletion,'') <> '0'	--неотмененая карточка (отмененные это отдельный блок)
			and D.DateCreation >= @Date
	where T.DLM >= @Date  --отбираем по дате последнего изм-я
	and T.isDel = 0
	and not exists(select 1 from #tbl_pay P where P.DocIDInt = D.DocIDInt)--не повторяемся, если карточка отобралась через уделенные
	select @Res = @@error if @Res <> 0 goto Err
	

    /*************************************************************************************************/
    /*************************************************************************************************/
    /*************************************************************************************************/

	update P
		set ParentID = isnull(Par.DocIDIncoming,'')
	from #tbl_pay as P
	inner join dbo.Docs Par on Par.DocID = P.DocIDParent
	select @Res = @@error if @Res <> 0 goto Err
	
	update P
		set TaxID = isnull(PN.TaxID,''),
		PortalID = PN.PortalID
	from #tbl_pay as P
	left join dbo.Partners PN on PN.Name = P.PartnerName 
	select @Res = @@error if @Res <> 0 goto Err


	--тепер собираем информацию
	select distinct
		D.TransferGUID, --УНИКАЛЬНЫЙ ИД ЗАПИСИС. DocID - теоретически м.б. изменен
		D.DocID,  --Рег. номер
		isnull(isnull(D.DateActive, D.DateActivation), D.DateCreation) as DateActive, --дата последней активации

		D.UserFieldText8,  --Бизнес единица
		dbo.PDX_fn_pay_FirmGET(D.UserFieldText8) as ID_UFT8,
		
		case 
			when isnull(D.StatusCompletion,'') = '0'
				then 4 -- отменена
			when isnull(D.StatusDevelopment,'') = '4'
				and P.VisaRefuse = 1
				then -3 --в утвержденной карточке не может быть отказов в согласовании
			when isnull(D.StatusDevelopment,'') = '4'
				then 2 --утверждена
			when P.VisaRefuse = 1
				then 0 --отказано в согласовании
			else 1 --на соглаовании
		end as STATUS,
		--****************************************
		P.PartnerName,  --Отправитель\Получатель
		isnull(P.TaxID,'') as PNTaxID, --ИНН
		P.PortalID as PortalID,
		
		isnull(P.DocIDParent,'') as DocIDParent,  --Основной договор
		isnull(P.ParentID,'')as ParentID,

		--****************************************
		D.UserFieldText2,  --ЦФО
		dbo.PDX_fn_pay_CFOGET(D.UserFieldText2) as ID_UFT2,

/*************************/
		D.UserFieldText3, --Сценарий
		(Select ID from dbo.Scenariy where Descr = D.UserFieldText3) as ID_UFT3,
/**************************/
			
/**********изменение****************/
		D.UserFieldText4,  --код ИСР
		dbo.PDX_SubstringReturn(D.UserFieldText4,CHARINDEX('<',D.UserFieldText4),CHARINDEX('>',D.UserFieldText4)) as ID_UFT4,
	/**************************/
		--****************************************
		D.Currency,  --Валюта
		isnull(Curr.Code2,'') as CurrCode2,--

		D.UserFieldMoney1 as ID_UFM1,--Вид начислений(код)
		[dbo].[fnGetSelectValueForUFM](@ConstName,1, D.UserFieldMoney1) as UserFieldMoney1,--Вид начислений
		D.UserFieldMoney2 as ID_UFM2,--Ставка НДС(код)
		[dbo].[fnGetSelectValueForUFM](@ConstName,2, D.UserFieldMoney2) as UserFieldMoney2,--Ставка НДС
		
		case T.blnType when 0 then T.Amount else 0 end as AmountWithNDS, --сумма с НДС
		case T.blnType when 1 then T.Amount else 0 end as AmountWithOutNDS, --сумма с НДС
		isnull(T.Oborot,'') as Oborot, --статья оборотов
		dbo.PDX_SubstringReturn(T.Oborot,CHARINDEX('<',T.Oborot),CHARINDEX('>',T.Oborot)) as ID_Oborot,
		isnull(T.Grp,'') as Grp, --Номенклатурная группа
		dbo.PDX_SubstringReturn(T.Grp,CHARINDEX('<',T.Grp),CHARINDEX('>',T.Grp)) as ID_Grp,
		isnull(T.Koeff,0) as NZP, --Коэффициент НЗП
		T.KeyField as AmountID, --ID сумме
		
		D.NameAproval,  --Заявитель
		isnull(NA.Name,'') as NameApp,
		D.NameCreation,  --Автор
		isnull(NC.Name,'') as NameCr,

		D.UserFieldDate3,--Рег. дата
		D.UserFieldDate1, --Дата закрытия работ
		D.DateApproved, --дата утверждения
		D.UserFieldText1,  --Наименование листа согласования
		D.ListToReconcile  --Лист согласования
		
	from #tbl_pay P
	inner join dbo.Docs D on D.DocIDInt = P.DocIDInt
	inner join 
		(select X.DocIDInt, X.KeyField, X.Oborot, X.Grp, X.Koeff, X.Amount, X.blnType from dbo.PDXAccrual X 
					inner join #tbl_pay Z on X.DocIDInt = Z.DocIDInt
					and Z.KeyField is null  
					where X.isDel = 0
		union
		select X.DocIDInt, X.KeyField, X.Oborot, X.Grp, X.Koeff, 0 as Amount, X.blnType from dbo.PDXAccrual X 
					inner join #tbl_pay Z on X.DocIDInt = Z.DocIDInt and Z.KeyField = X.KeyField
					and Z.isDel = 1) as T
		on T.DocIDInt = D.DocIDInt
	left join dbo.CurrencyRates Curr on Curr.Code = D.Currency
	left join dbo.Users NA on D.NameAproval like '%<' + NA.UserID + '>%'
	left join dbo.Users NC on D.NameCreation like '%<' + NC.UserID + '>%'
	order by 2
	select @Res = @@error if @Res <> 0 goto Err

					
OK:
	set nocount off
	return @Res
Err:
	set nocount off
	return @Res











GO
/****** Object:  StoredProcedure [dbo].[PDX_Accrual_Change] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*
[KeyField] [int] IDENTITY(1,1) NOT NULL,
	[DocIDInt] [int] not NULL,
	[Oborot] varchar(1024) not null,
	Amount money null,
	Koeff money not null,
	Grp varchar(1024) not null,
	blnType bit not null,
*/
--drop proc [dbo].[PDX_Accrual_Change]
--go
CREATE proc [dbo].[PDX_Accrual_Change]
	@Oborot varchar(1024),
	@Am varchar(128),
	@Koeff varchar(128),
	@Grp varchar(1024),
	@DocID varchar(128),
	@blnType bit,
	@KF int,
	@NC varchar(128),
	@Act int, --1--ceate, 2-update,3 delete
	@Chk bit = 0
	
as
	declare  @Res int,
		@Descr varchar(512),
		@UserID varchar(96),
		@UserName varchar(96),
		@Amount money,
		@Koeff_ money,
		@DocIDInt int,
		@DelSetID uniqueidentifier

	declare @ErrList varchar(1024),
		/*@ParentID int,*/ @Cnt int, @flg tinyint

	select @Res = 0,@ErrList = ''

	select
		@DocID = ltrim(rtrim(isnull(@DocID,''))),
		@Am = ltrim(rtrim(replace(replace(replace(isnull(@Am,'0'),',','.'),SPACE(1),''),CHAR(160),''))),
		@Koeff = ltrim(rtrim(replace(replace(replace(isnull(@Koeff,'0'),',','.'),SPACE(1),''),CHAR(160),''))),
		@NC  = ltrim(rtrim(isnull(@NC,''))),
		@flg = 0
	select @Res = @@error if @Res <> 0 goto Err

/************************************
ПРОВЕРКИ ВВЕДЕННЫХ ЗНАЧЕНИЙ
*************************************/

If @Act <> 3
BEGIN
	select @DocIDInt = DocIDInt from dbo.Docs where DocID = @DocID and ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_ACCRUAL')
	If @DocID = '' or @DocIDInt is null
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Систамная ошибка! Некорректный ИД документа. Обратитесь к администратору СЭД.'
		goto NXT
	end
	
	If @Oborot = ''
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Укажите статью оборотов'
		goto NXT
	end
	else 
	begin
		set @flg = 0
		select top 1
			@flg = case when not Ch.KeyField IS null then 2 else 1 end
		from dbo.UserDir_Oborot O
		left join dbo.UserDir_Oborot Ch on Ch.ParentKeyField = O.KeyField
		where @Oborot like '%<' + O.Code + '>%'
		
		if @flg = 0
		begin
			select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
				'Указанная статья оборотов не существует'
			goto NXT
		end
		else if @flg = 2
		begin
			select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
				'Указанная статья оборотов не может быть выбрана'
			goto NXT
		end
	end
	
	If @Grp = ''
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Укажите номенклатурную группу'
		goto NXT
	end
	else 
	begin
		set @flg = 0
		select top 1
			@flg = case when not Ch.KeyField IS null then 2 else 1 end
		from dbo.UserDir_NomGrp O
		left join dbo.UserDir_NomGrp Ch on Ch.ParentKeyField = O.KeyField
		where @Grp like '%<' + O.Code + '>%'
		
		if @flg = 0
		begin
			select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
				'Указанная номенклатурная группа не существует'
			goto NXT
		end
		else if @flg = 2
		begin
			select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
				'Указанная номенклатурная группа не может быть выбрана'
			goto NXT
		end
	end
	
	If @Am = '' 
	begin
	  set @Amount = 0
	  select @Res = @@error if @Res <> 0 goto Err
	end
	else
	begin
	  if ISNUMERIC(@Am) = 1
	  begin
		set @Amount = CAST(@Am as money)
		select @Res = @@error if @Res <> 0 goto Err
	  end
	  else
	  begin
  		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'В поле сумма должно быть указано числовое значение'
		goto NXT
	  end 
	end
	if @Amount = 0
	begin
			select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
				'Укажите сумму'
			goto NXT
	end
	
	If @Koeff = '' 
	begin
	  set @Koeff_ = 0
	  select @Res = @@error if @Res <> 0 goto Err
	end
	else
	begin
	  if ISNUMERIC(@Koeff) = 1
	  begin
		set @Koeff_ = CAST(@Koeff as money)
		select @Res = @@error if @Res <> 0 goto Err
	  end
	  else
	  begin
  		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'В поле коэффициент НЗП должно быть указано числовое значение'
		goto NXT
	  end 
	end
	
	if not @Koeff_ between 0 and 100
	begin
  		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Указано некорректное значение Коэффициента НЗП (указжите значение от 0 до 100)'
		goto NXT
	end
END
/************************************/

NXT:

If @Chk = 0
begin --если это создание , то нужно генерить ошибкуесли она есть
	If @ErrList <> '' 
	begin
		RAISERROR (@ErrList, 16,1)
		goto Err
	end
end
else --если это проверка просто выводим сообщение, даже если оно пустое
begin
	select @ErrList as ErrList 
	select @Res = @@error if @Res <> 0 goto Err
end

IF @ErrList = '' and @Chk = 0
BEGIN
	if @Act = 2
	begin
		update dbo.[PDXAccrual]
			set 
				[DocIDInt] = @DocIDInt,
				[Oborot]  = @Oborot,
				Amount = @Amount,
				Koeff = @Koeff_,
				Grp = @Grp,
				blnType = @blnType,
				NLM = @NC,
				DLM = getdate()
		where KeyField = @KF
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 1
	begin
		insert into dbo.[PDXAccrual]
			(DocIDInt, Oborot, Amount,Koeff,Grp, blnType, NC, DC, NLM, DLM)
		values 
			(@DocIDInt, @Oborot, @Amount,@Koeff_,@Grp, @blnType, @NC, getdate(), @NC, getdate())
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 3
	begin
			update dbo.[PDXAccrual] set isdel = 1,DLM = GETDATE(), NLM = @NC where KeyField = @KF
			select @Res = @@error if @Res <> 0 goto Err
	
	end
END

OK:

	return @Res
Err:
	return @Res



GO
/****** Object:  StoredProcedure [dbo].[PDX_ACCRUAL_ExtCheck] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
--drop proc [dbo].[PDX_ACCRUAL_ExtCheck]
--go
CREATE proc [dbo].[PDX_ACCRUAL_ExtCheck]
	@DocID varchar(128),
	--@PN varchar(256) = null,
	@isContext bit = 0
	
as
declare 
	@Res int,
	@Mess varchar(1024), @ClassDoc varchar(128),
	@UFM1 money, @DocIDInt int, @PN varchar(512), @UFM2 money, @DocIDParent varchar(128)
	
	select @Res = 0
	select @Mess = ''

	declare @Tbl table (Val varchar(64), Pos int, Flag bit)
	
	select
		@ClassDoc = ClassDoc,
		@UFM1 	 = UserFieldMoney1,
		@DocIDInt = DocIDInt,
		@PN = PartnerName,
		@UFM2 = UserFieldMoney2,
		@DocIDParent = DocIDParent
	from dbo.Docs 
	where DocID = ltrim(rtrim(isnull(@DocID,'')))
	select @Res = @@error if @Res <> 0 goto Err

	if @UFM1 = 1 and (ISNULL(@PN,'') = '' or ISNULL(@DocIDParent,'') = '' or @UFM2 = 0)
		begin
			select @Mess = @Mess + 
				'<br><font color=red>ОШИБКА! </font> Вид начисления указан "Поставка/Услуги". Поля [Контрагент], [Договор], [Ставка НДС] должны быть заполнены.' 
			select @Res = @@error if @Res <> 0 goto Err
		end
	
	if @UFM1 = 2 and (ISNULL(@PN,'') <> '' or ISNULL(@DocIDParent,'') <> '' or @UFM2 > 0)
		begin
			select @Mess = @Mess + 
				'<br><font color=red>ОШИБКА! </font> Вид начисления указан "Расходы на собственные силы". Поля [Контрагент], [Договор], [Ставка НДС] должны быть пустыми.' 
			select @Res = @@error if @Res <> 0 goto Err
		end
	
	if @UFM1 = 1
	begin
		if exists (select 1 from dbo.[PDXAccrual] where DocIDInt = @DocIDInt and blnType = 1)
		begin
			select @Mess = @Mess + 
				'<br><font color=red>ОШИБКА! </font> Проверьте соответствие детальных строк виду начислений, указанному в карточке.</font>' 
			select @Res = @@error if @Res <> 0 goto Err
		end
	end
	else
	begin
		if exists (select 1 from dbo.[PDXAccrual] where DocIDInt = @DocIDInt and blnType = 0)
		begin
			select @Mess = @Mess + 
				'<br><font color=red>ОШИБКА! </font> Проверьте соответствие детальных строк виду начислений, указанному в карточке.</font>' 
			select @Res = @@error if @Res <> 0 goto Err
		end
	end
	
	if not exists (select 1 from dbo.[PDXAccrual] where DocIDInt = @DocIDInt)
	begin
			select @Mess = @Mess + 
				'<br><font color=red>ОШИБКА! </font> Документ должен содержать детальные строки.</font>' 
			select @Res = @@error if @Res <> 0 goto Err
	end
	else
	if exists (select 1 from dbo.[PDXAccrual] where DocIDInt = @DocIDInt and (Oborot is null or Oborot = '' or Amount = 0 or Amount is null or Koeff is null))
	begin
			select @Mess = @Mess + 
				'<br><font color=red>ОШИБКА! </font> Параметры [Статья оборотов], [Сумма], [Коэффициент НЗП] в детальных строках должны быть заполнены.</font>' 
			select @Res = @@error if @Res <> 0 goto Err
	end
	
	
	select @Mess = @Mess + case len(@Mess) when 0 then '' else '<br>' end
    select @Res = @@error if @Res <> 0 goto Err

OK:

	select @Mess as 'res'
	return @Res
Err:
	select @Mess  as 'res'
	return @Res










GO
/****** Object:  StoredProcedure [dbo].[PDX_AddNumberCalculate] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[PDX_AddNumberCalculate]

		@DocID varchar(128)

as

declare @DocIDInt int,
		@ClassDoc varchar(128),
		@DocDate varchar(128),
		@PartnerName varchar(128),
		@Counter int,
		@Number varchar(128),
		@Rand1 int,
		@Rand2 int,
		@isExists tinyint,
		@exDocDate varchar(128),
		@exPartnerName varchar(128),
		@exNumber varchar(128),
		@StatusOK bit

set @Number = ''
set @Counter = 0
set @isExists = 0
set @StatusOK = 0
select @DocIDInt = D.DocIDINt,
	@ClassDoc = D.ClassDoc,
	@PartnerName = D.UserFieldText8,
	@DocDate = case T.bDateActivation
				when 'Y' then D.DateActivation
				else D.UserFieldDate3 
			   end,
	@StatusOK = case when isnull(D.StatusDevelopment,'') IN ('0','4') and D.IsActive = 'Y' then 0 else 1 end
from dbo.Docs D
inner join dbo.DocTypes T on T.Name = D.ClassDoc
where D.DocID = @DocID

if @ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_OTHERS_DOG')
	and @StatusOK = 1
begin

	select top 1
	  @isExists = 1,
	  @exDocDate = DocDate,
	  @exPartnerName = PartnerName,
	  @exNumber = AddNumber
	from dbo.AddNumberForDocs
	where DocIDInt = @DocIDInt
	order by DateCreation desc

	if @isExists = 1 and 
		@PartnerName = @exPartnerName
		and @DocDate = @exDocDate
	begin
		set @Number = @exNumber
	end
	else
	begin
		if @PartnerName = 'Стролекс ООО'
		begin --C/счетчик-ГГГГ
			select top 1
				@Counter = NumCounter
			from dbo.AddNumberForDocs
			where PartnerName = @PartnerName
			order by NumCounter desc
			set @Counter = ISNULL(@Counter,0) + 1
			
			set @Number = 'C/' + CAST(@Counter as varchar(64)) + '-' + cast(YEAR(@DocDate) as varchar(4))
		end
		else if @PartnerName = 'Конкорд ООО'
		begin --13/11/471 год/месяц/счетчик
			select top 1
				@Counter = NumCounter
			from dbo.AddNumberForDocs
			where PartnerName = @PartnerName
				and YEAR(DocDate) = YEAR(@DocDate)
				and MONTH(DocDate) = MONTH(@DocDate)
			order by NumCounter desc
			set @Counter = ISNULL(@Counter,0) + 1
			
			set @Number = right(cast(YEAR(@DocDate) as varchar(4)),2) + '/' + right('0' + MONTH(@DocDate),2) + '/' + CAST(@Counter as varchar(64)) 
		end
		else if @PartnerName = 'Колор-Нева ООО'
		begin --2013/11/3-КН год/месяц/счетчик-КН
			select top 1
				@Counter = NumCounter
			from dbo.AddNumberForDocs
			where PartnerName = @PartnerName
				and YEAR(DocDate) = YEAR(@DocDate)
				and MONTH(DocDate) = MONTH(@DocDate)
			order by NumCounter desc
			set @Counter = ISNULL(@Counter,0) + 1
			
			set @Number = cast(YEAR(@DocDate) as varchar(4)) + '/' + right('0' + MONTH(@DocDate),2) + '/' + CAST(@Counter as varchar(64))+ '-КН'
		end
		else if @PartnerName = 'Свифт, ООО'
		begin --М2/361 [Т,М,О][1,2]/счетчик

			select top 1
				@Counter = NumCounter
			from dbo.AddNumberForDocs
			where PartnerName = @PartnerName
			order by NumCounter desc
			set @Counter = ISNULL(@Counter,0) + 1
			
			set @Rand1 = floor(RAND() *10/4)  --0,1,2
			set @Rand2 = floor(RAND() *10/5) + 1 --0+1,1+1
			
			set @Number = CASE @Rand1 
							when 0 then 'М'
							when 1 then 'Т'
							when 2 then 'О'
						  else 'Т' end + CAST(@Rand2 as CHAR(1)) + '/' + CAST(@Counter as varchar(64))
		end
		else if @PartnerName = 'Витарос-НЕВА ООО'
		begin --ВН/тов-514 ВН/тов/счетчик
			select top 1
				@Counter = NumCounter
			from dbo.AddNumberForDocs
			where PartnerName = @PartnerName
			order by NumCounter desc
			set @Counter = ISNULL(@Counter,0) + 1
			
			set @Number = 'ВН/тов/' + CAST(@Counter as varchar(64))
		end
		else if @PartnerName = 'Альт ООО'
		begin --2013/Асмр-14  год/Асмр-14
			select top 1
				@Counter = NumCounter
			from dbo.AddNumberForDocs
			where PartnerName = @PartnerName
				and YEAR(DocDate) = YEAR(@DocDate)
			order by NumCounter desc
			set @Counter = ISNULL(@Counter,0) + 1
			
			set @Number = cast(YEAR(@DocDate) as varchar(4)) + '/Асмр-' + CAST(@Counter as varchar(64))
		end
		else if @PartnerName = 'Альянс ООО (ИНН 7816558875)'
		begin --СМР-19/13/11  СМР-счетчик/год/месяц
			select top 1
				@Counter = NumCounter
			from dbo.AddNumberForDocs
			where PartnerName = @PartnerName
				and YEAR(DocDate) = YEAR(@DocDate)
				and MONTH(DocDate) = MONTH(@DocDate)
			order by NumCounter desc
			set @Counter = ISNULL(@Counter,0) + 1
			
			set @Number = 'СМР-' + CAST(@Counter as varchar(64)) + '/' + right(cast(YEAR(@DocDate) as varchar(4)),2) + '/' + right('0' + MONTH(@DocDate),2)
		end
		else if @PartnerName = 'Бриз ООО'
		begin --Б/65  Б/счетчик
			select top 1
				@Counter = NumCounter
			from dbo.AddNumberForDocs
			where PartnerName = @PartnerName
			order by NumCounter desc
			set @Counter = ISNULL(@Counter,0) + 1
			
			set @Number = 'Б/' + CAST(@Counter as varchar(64))
		end
		else if @PartnerName = 'ПТК Комплект ООО'
		begin --4т-ПТК/842  [1-4][з, и, к, м, о, п, т,э]-ПТК/счетчик
			select top 1
				@Counter = NumCounter
			from dbo.AddNumberForDocs
			where PartnerName = @PartnerName
			order by NumCounter desc
			set @Counter = ISNULL(@Counter,0) + 1
			
			
			set @Rand1 = floor(RAND() *100/30)+ 1  --0,1,2,3
			set @Rand2 = floor(RAND() *100/13) --0,1,2,3,4,5,6,7
			
			set @Number = CAST(@Rand1 as char(1)) + 
							case @Rand2
								when 0 then 'з'
								when 1 then 'и'
								when 2 then 'к'
								when 3 then 'м'
								when 4 then 'о'
								when 5 then 'п'
								when 6 then 'т'
								when 7 then 'э'
							else 'т' end + '-ПТК/' + CAST(@Counter as varchar(64))
		end
		else if @PartnerName = 'ПромЭнергоМаш ООО'
		begin --ПЭМ/19-11/2013  ПЭМ/счетчик-меяц/год
			select top 1
				@Counter = NumCounter
			from dbo.AddNumberForDocs
			where PartnerName = @PartnerName
				and YEAR(DocDate) = YEAR(@DocDate)
				and MONTH(DocDate) = MONTH(@DocDate)
			order by NumCounter desc
			set @Counter = ISNULL(@Counter,0) + 1
			
			set @Number = 'ПЭМ/' + CAST(@Counter as varchar(64)) + '-' + right('0'+cast(MONTH(@DocDate) as varchar(2)),2) + cast(YEAR(@DocDate) as varchar(4))
		end
		else if @PartnerName = 'TOSPEERO'
		begin --149/13/TAL  счетчик/год/TAL
			select top 1
				@Counter = NumCounter
			from dbo.AddNumberForDocs
			where PartnerName = @PartnerName
				and YEAR(DocDate) = YEAR(@DocDate)
			order by NumCounter desc
			set @Counter = ISNULL(@Counter,0) + 1
			
			set @Number = CAST(@Counter as varchar(64)) + '/' + right(cast(YEAR(@DocDate) as varchar(4)),2) + '/TAL'
		end
		else if @PartnerName = 'Ramendi Trading Ltd'
		begin --36/2013/11  счетчик/год/месяц
			select top 1
				@Counter = NumCounter
			from dbo.AddNumberForDocs
			where PartnerName = @PartnerName
				and YEAR(DocDate) = YEAR(@DocDate)
				and MONTH(DocDate) = MONTH(@DocDate)
			order by NumCounter desc
			set @Counter = ISNULL(@Counter,0) + 1
			
			set @Number = CAST(@Counter as varchar(64)) + '/' + cast(YEAR(@DocDate) as varchar(4)) + right('0'+cast(MONTH(@DocDate) as varchar(2)),2)
		end
		else if @PartnerName = 'Импульс ООО (ИНН 7816586294)'
		begin --ИМ-2014/01  ИМ-год/номер п/п
			select top 1
				@Counter = NumCounter
			from dbo.AddNumberForDocs
			where PartnerName = @PartnerName
				and YEAR(DocDate) = YEAR(@DocDate)
			order by NumCounter desc
			set @Counter = ISNULL(@Counter,0) + 1
			
			set @Number = 'ИМ-' + cast(YEAR(@DocDate) as varchar(4)) + '/' + dbo.PDX_FixLen(2,CAST(@Counter as varchar(64)))
		end		
		else 
		begin
			set @Number = '' --set @isExists = 50
		end
		
		if @Number <> '' or (@Number = '' and @exNumber <> '')
		begin
			insert dbo.AddNumberForDocs
				(DateCreation, DocIDInt,PartnerName, DocDate,NumCounter,AddNumber)
			values
				(getdate(), @DocIDInt, @PartnerName, @DocDate, @Counter, @Number)
		end
	end
end --if @ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_OTHERS_DOG')
--select @Number





GO
/****** Object:  StoredProcedure [dbo].[PDX_AG_ATT_UFD2] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_AG_ATT_UFD2]
		@Days int 
as
	declare @Result int

	create table #tmp 
		(DocID varchar(255), 
		UserID varchar(255),
		UserFieldDate1 datetime,
		UserFieldDate2 datetime,
		PartnerName varchar(512),
		Author varchar(1024),
		Description varchar(4000),
		NameAproval varchar(96),
		RCount int) --будет опряделять относится ли строка к окончательному результату
	
	declare @LocationPath varchar(8000),
			@FPos int,
			@EPos int,
			@OneValue varchar(255)
	

	create table #users 
		(UserID varchar(255),
		UserID2 varchar(255))

	select @Result = 0

	--список утвержденных документов 
	insert into #tmp 
		(DocID, UserID, UserFieldDate1, UserFieldDate2, PartnerName, Author,Description, NameAproval)
	select --distinct
		D.DocID, D.ListToView + d.Author, d.UserFieldDate1, d.UserFieldDate2, d.PartnerName, d.Author,d.Description, d.NameAproval
	from dbo.Docs D with (nolock) 
	where D.ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_ATTORNEY')
		and upper(isnull(D.isActive,'')) = 'Y' --активных
		and isnull(D.StatusCompletion,'') <> '0' --неотмененных
		and D.StatusDevelopment = '4' --утвержденных
		and convert(datetime,convert(varchar(100),D.UserFieldDate2,104),104) = dateadd(day,@Days,CAST(getdate()AS DATE))
	select @Result = @@error if @Result <> 0 goto Err

/**********************************************************/
--стандартная часть для агентов
/**********************************************************/
	--нужно отсечь пользователей, у которых уже нет доступа в СЭД
	
	insert into #users (UserID, UserID2)
	select distinct
		'<' + U.UserID + '>',
		case when convert(datetime,convert(varchar(100),getdate(),104),104) between isnull(convert(datetime,convert(varchar(100),U.DeputyDateFrom,104),104), convert(datetime,convert(varchar(100),getdate(),104),104)) and isnull(convert(datetime,convert(varchar(100),U.DeputyDateTo,104),104), convert(datetime,convert(varchar(100),getdate(),104),104))
		then isnull(U.DeputyID,'') else '' end
	from dbo.Users U 
	inner join #tmp as R on R.UserID like '%<' + U.UserID + '>%' 
	where U.StatusActive = '1' 
		and convert(datetime,convert(varchar(100),DateExpirationSecurity,104),104) >= convert(datetime,convert(varchar(100),getdate(),104),104)
	select @result = @@error if @result <> 0 goto Err

	--и неактивных замов 
	update R
		set UserID2 = ''
	from #users R
	inner join dbo.Users U on U.UserID = R.UserID2 and 
		(U.StatusActive <> '1' 
		or convert(datetime,convert(varchar(100),DateExpirationSecurity,104),104) < convert(datetime,convert(varchar(100),getdate(),104),104) )
	select @result = @@error if @result <> 0 goto Err

	update #users set UserID2 = '<' + UserID2 + '>' where isnull(UserID2,'') <> ''
	select @result = @@error if @result <> 0 goto Err

	--количество записей по пользователю
	update T
		set RCount = U.RCount
	from #tmp T
		inner join (select userid, count(*) as rcount from #tmp group by userid) as U on U.userid = T.userID
	select @Result = @@error if @Result <> 0 goto Err
/**********************************************************/
	
	select distinct
		T.DocID as DocID, replace(T.Description,char(13)+char(10),space(1)) as Description, 
		T.Author,T.UserFieldDate1,T.UserFieldDate2, T.PartnerName,T.NameAproval,
--***START-стандартные параметры	
		u.UserID, 
		U.UserID2, 
		T.RCount
--***END-------------------------
	from #tmp T
	inner join #users u on T.UserID like '%' + u.UserID+ '%'
	order by u.UserID, T.DocID
	select @Result = @@error if @Result <> 0 goto Err

	drop table #tmp
	drop table #users

	return @Result
Err:
	
	drop table #tmp
	drop table #users
	return @Result

GO
/****** Object:  StoredProcedure [dbo].[PDX_AG_ChangeDocAfterReconcile] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_AG_ChangeDocAfterReconcile]
	@DaysAgo int = 2,
	@UserID varchar(128) = '',
	@WithApproved bit = 0
as

	create table #tmp 
		(DocID varchar(255), 
		PartnerName varchar(255),
		DateLastModification datetime,
		Name varchar(255),
		UserID varchar(255),
		SD char(1),
		SC char(1),
		DateSigned datetime,
		ClassDoc varchar(255),
		NC varchar (128),
		LP varchar(1024),
		DateApproved datetime,
		StatusName varchar(128))

	create table #res  
		(DocID varchar(255), 
		UserName varchar(255), 
		VISADate Datetime)

	create table #Com  
		(DocID varchar(255), 
		CommentType varchar(255), 
		DateCreation datetime, 
		UserID varchar(128),		
		FileDateTime datetime,
		RCount int)

	declare @DocID varchar(255),
		@OneValue varchar(255),
		@ListReconciled varchar(4096),
		@result int

	create table #users 
		(UserID varchar(255),
		UserID2 varchar(255))

	select @result = 0

	If ltrim(rtrim(isnull(@UserID,''))) = ''
	begin --значит по подписке
		--список неутвержденных документов
		insert into #tmp 
			(DocID, PartnerName, DateLastModification, Name, UserID,
			SD,SC,DateSigned,ClassDoc, NC,LP,DateApproved,StatusName)
		select --distinct
			D.DocID, PartnerName, D.DateLastModification, D.Name, S.UserID,
			D.StatusDevelopment, D.StatusCompletion, D.DateSigned, D.ClassDoc,
			D.NameCreation, ltrim(rtrim(isnull(D.LocationPath,''))), D.DateApproved,
			dbo.REC_DocStatusRead(1,D.isActive, D.StatusCompletion, D.StatusDevelopment,
				D.ListToReconcile, D.ListReconciled, D.LocationPath) as StatusName
		from dbo.Docs D with (nolock) 
		inner join dbo.PDXSubscribe S on D.ListReconciled like '%<' + S.UserID + '>%' and S.Sub1 = 1
		where not (D.ClassDoc like 'Совет директоров / %'
				or D.ClassDoc like 'Инвестиционный комитет / %'
				or D.ClassDoc = 'Задачи'
				or D.ClassDoc = 'Корпоративное поручение')
			and upper(isnull(D.isActive,'')) = 'Y' --активных
			and isnull(D.StatusCompletion,'') <> '0' --неотмененных
			and not isnull(D.StatusDevelopment,'0') in ('0','4') --неотказных --неутвержденных
			and not D.ListToReconcile like '%(#!)%' --неприостановленных
			and not D.ListToReconcile like '%(#$)%' --незавершенных
			and D.ListReconciled like '%<%>%' --как минимум частично согласованных
		select @result = @@error if @result <> 0 goto Err
	end
	else
	begin --значит отчет по указаному пользователю
		select @UserID = case when @UserID like '%<%>%' 
							then dbo.PDX_SubstringReturn(@UserID,charindex('<',@UserID),charindex('>',@UserID,charindex('<',@UserID)+1))
							else ltrim(rtrim(isnull(@UserID,'')))
						end
		select @result = @@error if @result <> 0 goto Err

		insert into #tmp 
			(DocID, PartnerName, DateLastModification, Name, UserID,
			SD,SC,DateSigned,ClassDoc, NC,LP,DateApproved,StatusName)
		select --distinct
			D.DocID, PartnerName, D.DateLastModification, D.Name, @UserID,
			D.StatusDevelopment, D.StatusCompletion, D.DateSigned, D.ClassDoc,
			D.NameCreation, ltrim(rtrim(isnull(D.LocationPath,''))),D.DateApproved,
			dbo.REC_DocStatusRead(1,D.isActive, D.StatusCompletion, D.StatusDevelopment,
				D.ListToReconcile, D.ListReconciled, D.LocationPath) as StatusName
		from dbo.Docs D with (nolock) 
		where D.ListReconciled like '%<' + @UserID + '>%'
			and not (D.ClassDoc like 'Управляющий комитет / %'
				or D.ClassDoc like 'Инвестиционный комитет / %'
				or D.ClassDoc = 'Задачи'
				or D.ClassDoc = 'Корпоративное поручение')
			and upper(isnull(D.isActive,'')) = 'Y' --активных
			and isnull(D.StatusCompletion,'') <> '0' --неотмененных
			and not isnull(D.StatusDevelopment,'0') in ('0',case @WithApproved when 1 then '0' else '4' end) --неотказных --неутвержденных
			and not D.ListToReconcile like '%(#!)%' --неприостановленных
			and not D.ListToReconcile like '%(#$)%' --незавершенных
			and D.ListReconciled like '%<%>%' --как минимум частично согласованных
		select @result = @@error if @result <> 0 goto Err
	end

	--нас инетерсуют файлы с максимальной датой загрузки - отбираем их
	insert into #Com
		(DocID, CommentType, DateCreation, UserID)
	select 
		C.DocID, C.CommentType, max(DateCreation), ''
	from (select distinct DocID, DateApproved, SD from #tmp) T
	inner join dbo.Comments C on C.DocID = T.DocID and C.CommentType = 'FILE' 
        and C.Amount = case SD when '4' then C.Amount else 0 end --для уже утвержденных документов, нас интересуют все версии файлов в т.ч. и перечеркнуты так как возможно, что все на данный момент основные версии являются уже исключительно сканами (загружены после регистрации)
		and C.DateCreation < isnull(T.DateApproved,dateadd(day,1,getdate())) --по дате нас интересуют только файлы, которые были загружены до утверждения, либо если утверждения не было то берем заведомо большую дату, чтобы в отчете проанализировалось все
	group by C.DocID, C.CommentType
	select @result = @@error if @result <> 0 goto Err

	--нас инетерсуют данные по положительному согласованию из уже соогласовавших - отбираем их
	insert into #Com
		(DocID, CommentType, DateCreation, UserID)
	select
		C.DocID, C.CommentType, max(DateCreation), C.UserID
	from #tmp T	
	inner join dbo.Comments C on C.DocID = T.DocID and C.CommentType = 'VISA' and C.SpecialInfo = 'VISAOK'
		and T.UserID = C.UserID
	group by C.DocID, C.CommentType, C.UserID 
	select @result = @@error if @result <> 0 goto Err

	update T
		set FileDateTime = C.DateCreation
	from #Com T
	inner join #Com C on C.DocID = T.DocID and C.CommentType = 'FILE'
	where T.CommentType = 'VISA'
	select @result = @@error if @result <> 0 goto Err

	--удаляем ненужные данные (файлы и не удовлетворяющие данные по согласованию)
	delete from #Com where CommentType = 'FILE'
		or (CommentType = 'VISA' and (FILEDateTime is null or DateCreation >= FILEDateTime or datediff(day, FILEDateTime,getdate())>@DaysAgo ))
	select @result = @@error if @result <> 0 goto Err

/**********************************************************/
--стандартная часть для агентов
/**********************************************************/
	--нужно отсечь пользователей, у которых уже нет доступа в СЭД
	insert into #users (UserID, UserID2)
	select distinct
		R.UserID,
		case when convert(datetime,convert(varchar(100),getdate(),104),104) between isnull(convert(datetime,convert(varchar(100),U.DeputyDateFrom,104),104), convert(datetime,convert(varchar(100),getdate(),104),104)) and isnull(convert(datetime,convert(varchar(100),U.DeputyDateTo,104),104), convert(datetime,convert(varchar(100),getdate(),104),104))
		then isnull(U.DeputyID,'') else '' end
	from dbo.Users U 
	inner join (select distinct UserID from #Com) as R on U.UserID = R.UserID 
	where U.StatusActive = '1' 
		and convert(datetime,convert(varchar(100),DateExpirationSecurity,104),104) >= convert(datetime,convert(varchar(100),getdate(),104),104)
	select @result = @@error if @result <> 0 goto Err
	--и неактивных замов 
	update R
		set UserID2 = ''
	from #users R
	inner join dbo.Users U on U.UserID = R.UserID2 and 
		(U.StatusActive <> '1' 
		or convert(datetime,convert(varchar(100),DateExpirationSecurity,104),104) < convert(datetime,convert(varchar(100),getdate(),104),104) )
	select @result = @@error if @result <> 0 goto Err

	update #users set UserID2 = '<' + UserID2 + '>' where isnull(UserID2,'') <> ''
	select @result = @@error if @result <> 0 goto Err

	--количество записей по пользователю
	update T
		set RCount = U.RCount
	from #Com T
		inner join (select userid, count(*) as rcount from #Com group by userid) as U on U.userid = T.userID
	select @Result = @@error if @Result <> 0 goto Err
/**********************************************************/
	
	select --distinct
		R.DocID, T.Name, T.PartnerName, R.DateCreation as RecDate, R.FILEDateTime as FDate,
		datediff(hour,R.FILEDateTime,getdate()) as cnt,
--***START-стандартные параметры		
		'<' + R.UserID + '>' as UserID,
		U.UserID2, 
		R.RCount,
		T.SD as StatusDevelopment,
		T.SC as StatusCompletion,
		T.DateSigned,
		T.LP,
		T.ClassDoc,
		T.NC,
		T.StatusName
--***END-----------------------
	from #Com R 
	inner join (select distinct DocID, Name,PartnerName,
				SD,SC,DateSigned,StatusName,case when LP like '%+%' then 1 else 0 end as LP, ClassDoc, NC from #tmp) T on T.DocID = R.DocID 
	inner join #users U on U.UserID = R.UserID
	order by R.UserID, R.FILEDateTime desc--T.DocID
	select @result = @@error if @result <> 0 goto Err

	drop table #tmp
	drop table #com
	drop table #res
	drop table #users

	return @result
Err:
	
	drop table #tmp
	drop table #com
	drop table #res
	drop table #users
	return @result

GO
/****** Object:  StoredProcedure [dbo].[PDX_AG_CorpZadachi] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

create proc [dbo].[PDX_AG_CorpZadachi]
		@Type int --1-исполнителю,
					--2- контролеру 
as
	declare @Result int
	create table #tmp 
		(DocID varchar(255), 
		UserID varchar(255),
		StatusName varchar(50),
		Name varchar(255),
		Description varchar(1024),
		NameResponsible varchar(128),
		NameControl varchar(128),
		NameCreation varchar(128),
		DateCreation datetime,
		DateCompletion datetime,
		RCount int default 0) --будет опряделять относится ли строка к окончательному результату
	
	declare @LocationPath varchar(8000),
			@FPos int,
			@EPos int,
			@OneValue varchar(255)
	

	create table #users 
		(UserID varchar(255),
		UserID2 varchar(255))

	select @Result = 0

	insert into #tmp 
		(DocID,
		Name,
		UserID,
		StatusName,
		Description,
		NameResponsible,
		NameControl,
		NameCreation,
		DateCreation,
		DateCompletion)
	select 
		D.DocID, 
		cast(isnull(P.Name,'') + case isnull(len(ltrim(rtrim(P.Name))),0) when 0 then '' else '<br>' end + isnull(P.Description,'') as varchar(250)) + 
		case when len(isnull(P.Name,'') + case isnull(len(ltrim(rtrim(P.Name))),0) when 0 then '' else '<br>' end + isnull(P.Description,'')) > 250
			then '...' else '' end as ParentName,
		UC.UserID,
		case 
			when convert(datetime,convert(varchar(100),getdate(),104),104) <= D.DateCompletion 
				then 'исполняется' 
			else 'просрочен' 
		end as StatusName, 
		cast(D.Content as varchar(1024)),--D.Description, 
		D.NameResponsible,
		D.NameControl,
		D.NameCreation, 
		isnull(D.DateActive,D.DateCreation),--D.DateCreation, 
		D.DateCompletion
	from dbo.Docs D
		inner join dbo.Users UC on case @Type 
			when 1
				then D.NameResponsible
			when 2
				then D.NameControl
		end like '%<'+UC.UserID+'>%' 
		left join dbo.Docs P on P.DocID = D.DocIDParent 
	where not isnull(D.StatusCompletion,'') in ('1','0')
		and D.ClassDoc IN ('Корпоративное поручение') 
		--and convert(datetime,convert(varchar(100),getdate(),104),104) >= D.DateActivation 
		and Upper(D.isActive) = 'Y'
	select @result = @@error if @result <> 0 goto Err

/**********************************************************/
--стандартная часть для агентов
/**********************************************************/
	--нужно отсечь пользователей, у которых уже нет доступа в СЭД
	insert into #users (UserID, UserID2)
	select distinct
		'<' + U.UserID + '>',
		case when convert(datetime,convert(varchar(100),getdate(),104),104) between isnull(convert(datetime,convert(varchar(100),U.DeputyDateFrom,104),104), convert(datetime,convert(varchar(100),getdate(),104),104)) and isnull(convert(datetime,convert(varchar(100),U.DeputyDateTo,104),104), convert(datetime,convert(varchar(100),getdate(),104),104))
		then isnull(U.DeputyID,'') else '' end
	from dbo.Users U 
	inner join (select distinct UserID from #tmp) R on R.UserID=U.UserID --R.UserID like '%<' + U.UserID + '>%' 
	where U.StatusActive = '1' 
		and convert(datetime,convert(varchar(100),DateExpirationSecurity,104),104) >= convert(datetime,convert(varchar(100),getdate(),104),104)
	select @result = @@error if @result <> 0 goto Err
	--и неактивных замов 
	update R
		set UserID2 = ''
	from #users R
	inner join dbo.Users U on U.UserID = R.UserID2 and 
		(U.StatusActive <> '1' 
		or convert(datetime,convert(varchar(100),DateExpirationSecurity,104),104) < convert(datetime,convert(varchar(100),getdate(),104),104) )
	select @result = @@error if @result <> 0 goto Err

	update #users set UserID2 = '<' + UserID2 + '>' where isnull(UserID2,'') <> ''
	select @result = @@error if @result <> 0 goto Err

	--количество записей по пользователю
	update T
		set RCount = U.RCount
	from #tmp T
		inner join (select userid, count(*) as rcount from #tmp group by userid) as U on U.userid = T.userID
	select @Result = @@error if @Result <> 0 goto Err
/**********************************************************/
	
	select distinct
		T.DocID,
		T.StatusName,
		T.Name,
		T.Description,
		T.NameResponsible,
		T.NameControl,
		T.NameCreation,
		T.DateCreation,
		T.DateCompletion,
--***START-стандартные параметры	
		U.UserID, 
		U.UserID2, 
		T.RCount
--***END-------------------------
	from #tmp T
	inner join #users u on u.userid = '<'+T.UserID+'>'
	order by U.UserID, T.DateCompletion --,T.DocID
	select @Result = @@error if @Result <> 0 goto Err


	drop table #tmp
	drop table #users

	return @Result
Err:
	
	drop table #tmp
	drop table #users
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_AG_CutByRecDays] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_AG_CutByRecDays]
	@Days decimal(5,2)

as

declare @Result int
select @Result = 0


	create table #tmp (
		DocID varchar(128),
		ActDoc varchar(128),
		DateActive datetime,
		NameCreation varchar(128),
		Name varchar(255),
		PartnerName varchar(255),
		RCount int,
		UserID varchar(128))

	create table #users
		(UserID varchar(128),
		UserID2 varchar(128))


	--получение данных 
	--дату активации тащим из комментария
	--дату утверждения берем из карточки, еслиона null, то дальше будем ее тянуть из комментарией
	--а здесь если она не null сразу пытаемся отсечь ненужные данные
	insert into #tmp(DocID,ActDoc,DateActive,NameCreation, Name,PartnerName,UserID)
	select 
		D.DocID,D.ActDoc,
		convert(datetime,convert(varchar(100),C.DateCreation,104),104),
		D.NameCreation,D.Name,D.PartnerName,
		D.NameCreation
	from dbo.Docs D
	inner join 
		(select DocID,min(convert(datetime,convert(varchar(100),DateCreation,104),104)) as DateCreation
		from dbo.Comments 
		where commenttype = 'system'
			and (Comment like 'Документ активен%' or Comment like 'Document active%')
		group by DocID) as C on C.DocID = D.DocID
	where D.ClassDoc like 'Договоры / %'
		and upper(isnull(D.isActive,'')) = 'Y'
		/*and len(dbo.PDX_SubstringReturn(ActDoc,charindex('<',ActDoc),charindex('>',ActDoc))) <=4
		and not lower(ActDoc) like lower('Проект%')*/
		and not D.ActDoc in (
							'Системный<999N001>',
							'Проект<076E001>',
							'Проект<109C001>',
							'Проект<116C001>',
							'Проект<138B001>',
							'Проект<140C001>',
							--'Проект<446C001>',
							'Проект<506C001>',
							'Проект<106M001>',
							'Проект<449M001>',
							'Проект<451M001>',
							'Проект<451M002>',
							'Проект<456X001>',
							'Проект<501M001>',
							'Проект<501M002>',
							'Проект<440F001>',
							'Проект<440M001>',
							'Проект<440M002>'
							)

		and not isnull(D.StatusDevelopment,'') in ('0','4')
		and not isnull(D.StatusCompletion,'') in ('0')
		and datediff(day,C.DateCreation, getdate()) >= @Days
		and dbo.PDX_CompareReconcilationList(D.ListToReconcile,D.ListReconciled) <> 1 --полностью согласованные исключаем
	select @Result = @@error if @Result <> 0 goto Err

	/**********************************************************/
--стандартная часть для агентов
/**********************************************************/
	--нужно отсечь пользователей, у которых уже нет доступа в СЭД
	insert into #users (UserID, UserID2)
	select distinct
		R.UserID,
		case when convert(datetime,convert(varchar(100),getdate(),104),104) between isnull(convert(datetime,convert(varchar(100),U.DeputyDateFrom,104),104), convert(datetime,convert(varchar(100),getdate(),104),104)) and isnull(convert(datetime,convert(varchar(100),U.DeputyDateTo,104),104), convert(datetime,convert(varchar(100),getdate(),104),104))
		then isnull(U.DeputyID,'') else '' end
	from dbo.Users U 
	inner join (select distinct UserID from #tmp) R on R.UserID like '%<' + U.UserID + '>%' 
	where U.StatusActive = '1' 
		and convert(datetime,convert(varchar(100),DateExpirationSecurity,104),104) >= convert(datetime,convert(varchar(100),getdate(),104),104)
	select @result = @@error if @result <> 0 goto Err
	--и неактивных замов 
	update R
		set UserID2 = ''
	from #users R
	inner join dbo.Users U on U.UserID = R.UserID2 and 
		(U.StatusActive <> '1' 
		or convert(datetime,convert(varchar(100),DateExpirationSecurity,104),104) < convert(datetime,convert(varchar(100),getdate(),104),104) )
	select @result = @@error if @result <> 0 goto Err

	update #users set UserID2 = '<' + UserID2 + '>' where isnull(UserID2,'') <> ''
	select @result = @@error if @result <> 0 goto Err

	--количество записей по пользователю
	update T
		set RCount = U.RCount
	from #tmp T
		inner join (select userid, count(*) as rcount from #tmp group by userid) as U on U.userid = T.userID
	select @Result = @@error if @Result <> 0 goto Err
/**********************************************************/

/*
print 'start'
--ДЕАКТИВАЦИЯ ОТОБРАННЫХ ДАННЫХ
	update D
		set isActive = 'N'
	from dbo.Docs D 
	inner join #tmp T on T.DocID = D.DocID
	select @Result = @@error if @Result <> 0 goto Err

	select @Result = @@error if @Result <> 0 goto Err
print '1'
	delete C
	from dbo.Comments C
	inner join #tmp T on T.DocID = C.DocID 
	where C.CommentType = 'VISA'
	and C.SpecialInfo = 'VISAWAITING'

	insert into dbo.Comments
		(UserID,
		UserName,
		ContactUserName,
		ContactUserID,
		PartnerName,
		DocID,
		DateCreation,
		DateEvent,
		DateEventEnd,
		Address,
		Subject,
		Comment,
		CommentType,
		SpecialInfo,
		FileName,
		--KeyField,
		PartnerID,
		Version,
		GUID,
		GUIDPartner,
		GUIDUser,
		GUIDDoc,
		Amount,
		FileNameOriginal,
		RIK_CommentType)
	select
		'Admin',--UserID,
		'System Administrator',--UserName,
		null,--ContactUserName,
		null,--ContactUserID,
		null,--PartnerName,
		DocID,--DocID,
		getdate(),--DateCreation,
		null,--DateEvent,
		null,--DateEventEnd,
		null,--Address,
		null,--Subject,
		'Автоматическая деактивация карточки документа в связи с длительным сроком согласования документа',--Comment,
		'system',--CommentType,
		'',--SpecialInfo,
		null,--FileName,
		--KeyField,
		null,--PartnerID,
		null,--Version,
		newid(),--GUID,
		null,--GUIDPartner,
		null,--GUIDUser,
		null,--GUIDDoc,
		null,--Amount,
		null,--FileNameOriginal,
		null--RIK_CommentType
	from #tmp
	select @Result = @@error if @Result <> 0 goto Err


print 'end'
*/

	select distinct
		T.DocID,
		T.ActDoc,
		T.DateActive,
		T.Name,
		T.NameCreation,
		T.PartnerName,
		datediff(day,T.DateActive, getdate()) as DCount,
--***START-стандартные параметры	
		T.UserID as UserID, 
		isnull(U.UserID2,'<afonskaya>') as UserID2, 
		T.RCount
--***END-------------------------
	from #tmp T
	left join #users u on u.userid = T.UserID
	order by T.UserID, T.DocID
	select @Result = @@error if @Result <> 0 goto Err


	drop table #users
	drop table #tmp

	return @Result
Err:
	
	drop table #users
	drop table #tmp

	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_AG_DateCompletion] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

create proc [dbo].[PDX_AG_DateCompletion]
		@Days int 
as
	declare @Result int

	create table #tmp 
		(DocID varchar(255), 
		Name varchar(255),
		UserID varchar(255),
		PartnerName varchar(128),
		DocIDIncoming varchar(128),
		RCount int) --будет опряделять относится ли строка к окончательному результату
	
	declare @LocationPath varchar(8000),
			@FPos int,
			@EPos int,
			@OneValue varchar(255)
	

	create table #users 
		(UserID varchar(255),
		UserID2 varchar(255))

	select @Result = 0

	--список утвержденных документов 
	insert into #tmp 
		(DocID, Name, UserID, PartnerName,DocIDIncoming)
	select --distinct
		D.DocID, D.Name, D.NameCreation, D.PartnerName, D.DocIDIncoming
	from dbo.Docs D with (nolock) 
	where D.ClassDoc like 'Договоры /%'
		and upper(isnull(D.isActive,'')) = 'Y' --активных
		and isnull(D.StatusCompletion,'') <> '0' --неотмененных
		and D.StatusDevelopment = '4' --утвержденных
		and convert(datetime,convert(varchar(100),D.DateCompletion,104),104) = dateadd(day,@Days,convert(datetime,convert(varchar(100),getdate(),104),104))
	select @Result = @@error if @Result <> 0 goto Err

/**********************************************************/
--стандартная часть для агентов
/**********************************************************/
	--нужно отсечь пользователей, у которых уже нет доступа в СЭД
	/*insert into #users (UserID, UserID2)
	select distinct
		R.UserID,
		case when convert(datetime,convert(varchar(100),getdate(),104),104) between isnull(convert(datetime,convert(varchar(100),U.DeputyDateFrom,104),104), convert(datetime,convert(varchar(100),getdate(),104),104)) and isnull(convert(datetime,convert(varchar(100),U.DeputyDateTo,104),104), convert(datetime,convert(varchar(100),getdate(),104),104))
		then isnull(U.DeputyID,'') else '' end
	from #tmp R  
	inner join dbo.Users U on R.UserID like '%<' + U.UserID + '>%' and U.StatusActive = '1' 
		and convert(datetime,convert(varchar(100),DateExpirationSecurity,104),104) >= convert(datetime,convert(varchar(100),getdate(),104),104)
	select @result = @@error if @result <> 0 goto Err*/
	insert into #users (UserID, UserID2)
	select distinct
		R.UserID,
		case when convert(datetime,convert(varchar(100),getdate(),104),104) between isnull(convert(datetime,convert(varchar(100),U.DeputyDateFrom,104),104), convert(datetime,convert(varchar(100),getdate(),104),104)) and isnull(convert(datetime,convert(varchar(100),U.DeputyDateTo,104),104), convert(datetime,convert(varchar(100),getdate(),104),104))
		then isnull(U.DeputyID,'') else '' end
	from dbo.Users U 
	inner join (select distinct UserID from #tmp) as R on R.UserID like '%<' + U.UserID + '>%' 
	where U.StatusActive = '1' 
		and convert(datetime,convert(varchar(100),DateExpirationSecurity,104),104) >= convert(datetime,convert(varchar(100),getdate(),104),104)
	select @result = @@error if @result <> 0 goto Err

	--и неактивных замов 
	update R
		set UserID2 = ''
	from #users R
	inner join dbo.Users U on U.UserID = R.UserID2 and 
		(U.StatusActive <> '1' 
		or convert(datetime,convert(varchar(100),DateExpirationSecurity,104),104) < convert(datetime,convert(varchar(100),getdate(),104),104) )
	select @result = @@error if @result <> 0 goto Err

	update #users set UserID2 = '<' + UserID2 + '>' where isnull(UserID2,'') <> ''
	select @result = @@error if @result <> 0 goto Err

	--количество записей по пользователю
	update T
		set RCount = U.RCount
	from #tmp T
		inner join (select userid, count(*) as rcount from #tmp group by userid) as U on U.userid = T.userID
	select @Result = @@error if @Result <> 0 goto Err
/**********************************************************/
	
	select distinct
		T.DocID as DocID, replace(T.Name,char(13)+char(10),space(1)) as Name, 
		T.DocIDIncoming, T.PartnerName,
--***START-стандартные параметры	
		T.UserID, 
		U.UserID2, 
		T.RCount
--***END-------------------------
	from #tmp T
	inner join #users u on u.userid = T.UserID
	order by T.UserID, T.DocID
	select @Result = @@error if @Result <> 0 goto Err

	drop table #tmp
	drop table #users

	return @Result
Err:
	
	drop table #tmp
	drop table #users
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_AG_DocsNotInArchive] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

create proc [dbo].[PDX_AG_DocsNotInArchive]
		@Type int, --1 - создателю (>7 дней )
					--2 - подписывающему  (> 21 дня)
					--3 - регистратору(> 21 дня)
					--0 кол-во дней задано в переменной и это отчет, поэтому существуют ли поьзователи нас не интересует - выводим все
		@DCount int = 7,
		@ActDoc varchar(64)= ''
as
	declare @Result int

	create table #tmp 
		(DocID varchar(255), 
		Name varchar(255),
		DateApproved datetime,
		UserID varchar(255),
		NameCreation varchar(255),
		LocationPath varchar(1024),
		NameAproval varchar(255),
		DCount int,
		PartnerName varchar(128),
		RCount int,
		Type bit) --будет опряделять относится ли строка к окончательному результату
/*
	declare @Loc  table
		(LocationPath varchar(1024))*/
	
	declare @LocationPath varchar(8000),
			@FPos int,
			@EPos int,
			@OneValue varchar(255)
	

	create table #users 
		(UserID varchar(255),
		UserID2 varchar(255))

	select @Result = 0

	--список утвержденных документов и незарегистрированных
	insert into #tmp 
		(DocID, Name, DateApproved, NameCreation, LocationPath, NameAproval, UserID, DCount, Type, PartnerName)
	select --distinct
		D.DocID, D.Name, isnull(D.DateApproved, D.DateCreation), D.NameCreation, D.LocationPath, D.NameAproval, 
		case @Type when 1 then D.NameCreation when 2 then D.NameAproval else '' end, 
		datediff(day, isnull(D.DateApproved, D.DateCreation), getdate()), 0, D.PartnerName
	from dbo.Docs D with (nolock) 
	where D.ClassDoc like 'Договоры /%'
		and (@ActDoc = '' or D.ActDoc = @ActDoc)
		and upper(isnull(D.isActive,'')) = 'Y' --активных
		and isnull(D.StatusCompletion,'') <> '0' --неотмененных
		and D.StatusDevelopment = 4 --неутвержденных
		and isnull(D.NameApproved,'') <> ''
		and not isnull(D.LocationPath,'') like '%+%'
		and ltrim(rtrim(isnull(D.LocationPath,''))) <> ''

		and datediff(day, isnull(D.DateApproved, D.DateCreation), getdate()) > case @Type when 0 then isnull(@DCount,7) when 1 then 7 else 21 end
	select @Result = @@error if @Result <> 0 goto Err


	--регистраторов может быть несколько в одном поле, поэтому придется обрабатывать дополнительно
	if @Type = 3
	begin
		select @LocationPath = ''
		select @LocationPath = @LocationPath + LP
		from (
		select distinct replace(replace(ltrim(rtrim(isnull(LocationPath,''))), char(10),''),char(13),'') as LP
		from #tmp
		where replace(replace(ltrim(rtrim(isnull(LocationPath,''))), char(10),''),char(13),'') <> ''
		) as P
		select @Result = @@error if @Result <> 0 goto Err


		while @LocationPath like '%<%>%'
		begin
			select @FPos = charindex('<',@LocationPath)
			select @Result = @@error if @Result <> 0 goto Err
			select @EPos = charindex('>',@LocationPath, @FPos)
			select @Result = @@error if @Result <> 0 goto Err

			select @OneValue = '<' + dbo.PDX_SubstringReturn(@LocationPath, @FPos, @EPos) + '>'
			select @Result = @@error if @Result <> 0 goto Err
			select @LocationPath = replace(@LocationPath,@OneValue,'')--STUFF(@LocationPath,@FPos,len(@OneValue),'')
			select @Result = @@error if @Result <> 0 goto Err

			insert into #tmp 
				(DocID, Name, DateApproved, NameCreation, LocationPath, NameAproval, UserID, DCount, Type, PartnerName)
			select
				DocID, Name, DateApproved, NameCreation, LocationPath, NameAproval, @OneValue, DCount, 1, PartnerName
			from #tmp T
			where T.LocationPath like '%' + @OneValue + '%'
				and T.Type = 0
				--and not exists (select 1 from #tmp k where k.Type = 1 and k.UserID = @OneValue and k.DocID = T.DocID)
			select @Result = @@error if @Result <> 0 goto Err
		end
		
	end
	else
	begin
		update #tmp set Type = 1
		select @Result = @@error if @Result <> 0 goto Err
	end

	--если есть что-то на имя системного администратора, то игнорируем это
	delete from #tmp where UserID like '%<admin>%'
	select @Result = @@error if @Result <> 0 goto Err

/**********************************************************/
    If @Type <> 0 -- только если не отчет
    begin
		--нужно отсечь пользователей, у которых уже нет доступа в СЭД
		insert into #users (UserID, UserID2)
		select distinct
			R.UserID,
			case when convert(datetime,convert(varchar(100),getdate(),104),104) between isnull(convert(datetime,convert(varchar(100),U.DeputyDateFrom,104),104), convert(datetime,convert(varchar(100),getdate(),104),104)) and isnull(convert(datetime,convert(varchar(100),U.DeputyDateTo,104),104), convert(datetime,convert(varchar(100),getdate(),104),104))
			then isnull(U.DeputyID,'') else '' end
		from dbo.Users U 
		inner join (select distinct UserID from #tmp) R	on R.UserID like '%<' + U.UserID + '>%' 
		where U.StatusActive = '1' 
			and convert(datetime,convert(varchar(100),DateExpirationSecurity,104),104) >= convert(datetime,convert(varchar(100),getdate(),104),104)
		select @Result = @@error if @Result <> 0 goto Err
		--и неактивных замов 
		update R
			set UserID2 = ''
		from #users R
		inner join dbo.Users U on U.UserID = R.UserID2 and 
			(U.StatusActive <> '1' 
			or convert(datetime,convert(varchar(100),DateExpirationSecurity,104),104) < convert(datetime,convert(varchar(100),getdate(),104),104) )
		select @Result = @@error if @Result <> 0 goto Err
	
		update #users set UserID2 = '<' + UserID2 + '>' where isnull(UserID2,'') <> ''
		select @Result = @@error if @Result <> 0 goto Err
	end 
    else --если отчет берем всех кто встречается
    begin
		insert into #users (UserID, UserID2)
		select distinct R.UserID,'' from #tmp R  
		select @Result = @@error if @Result <> 0 goto Err
    end    
	
	update T
		set RCount = U.RCount
	from #tmp T
		inner join (select userid, count(*) as rcount from #tmp where type = 1 group by userid) as U on U.userid = T.userID
	where T.Type = 1
	select @Result = @@error if @Result <> 0 goto Err
/**********************************************************/

	select distinct
		T.DocID as strID, replace(T.Name,char(13)+char(10),space(1)) as Name, 
		T.PartnerName, 
		T.NameCreation, T.NameAproval, replace(T.LocationPath, char(13)+char(10),space(1)) as LocationPath, T.DCount, 
--***START-стандартные параметры	
		T.UserID, 
		U.UserID2,
		T.RCount
--***END------------------------
	from #tmp T
	inner join #users u on u.userid = T.UserID
	where T.Type = 1
	order by T.UserID, T.DocID
	select @Result = @@error if @Result <> 0 goto Err


	drop table #tmp
	drop table #users

	return @Result
Err:
	
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_AG_DogovorInfoToMaster] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_AG_DogovorInfoToMaster]
	@Days3 int,
	@Days4 int
as

declare @Result int
select @Result = 0

	declare @MSTR varchar(128)

	create table #tmp  
		(TypeOfRes varchar(255),
		DocID varchar(255),
		DateX datetime,
		Name varchar(255),
		Descr varchar(1024),
		NameCreation varchar(255),
		PartnerName varchar(512),
		ClassDoc varchar(255),
		rcount int,
		UserID varchar(255),
		Days int,
		Department varchar(512))
	
	declare @users table
		(UserID varchar(255),
		UserID2 varchar(255))

	declare @Masters table
		(UserID varchar(255), Flg bit default 0)

	insert into @Masters (UserID) values ('SvsrMaintenance')
	insert into @Masters (UserID) values ('SvsrEngineering')
	insert into @Masters (UserID) values ('SvsrIT')
	insert into @Masters (UserID) values ('SvsrRnD')
	insert into @Masters (UserID) values ('SvsrPersonnel')
	insert into @Masters (UserID) values ('SvsrProcurement')
	insert into @Masters (UserID) values ('SvsrCommon')
	insert into @Masters (UserID) values ('SvsrService')

	--соглаосвание
    insert into #tmp
		(TypeOfRes,DocID, DateX, Name, Descr, NameCreation, UserID, PartnerName, ClassDoc, Days, Department)
	select '0',
		D.DocID,
		min(C.DateCreation),
		D.Name,
		D.Description,
		D.NameCreation, 
		D.Author,
		D.PartnerName,
		D.ClassDoc,
		null,
		D.Department
	from dbo.Docs D
	inner join dbo.Comments C on C.DocID = D.DocID and 
		upper(C.Commenttype) = upper('system')
		and (C.Comment like 'Документ активен%' or C.Comment like 'Document active%')
	where D.ClassDoc like 'Договоры / %'
		and upper(isnull(D.isActive,'')) = 'Y'
		and not isnull(D.StatusCompletion,'') in ('0','1') --отказанные и исполненные не смотрим
		and not isnull(D.StatusDevelopment,'') in ('0','4')
	group by D.DocID,D.Name,D.Description,D.NameCreation, D.Author,D.PartnerName,D.ClassDoc,D.Department
	having min(C.DateCreation) between dateadd(Hour, -96, getdate()) and getdate()
	select @Result = @@error if @Result <> 0 goto Err

	--отказ, утверждение
    insert into #tmp
		(TypeOfRes,DocID, DateX, Name, Descr, NameCreation, UserID, PartnerName, ClassDoc, Days, Department)
	select case when D.NameApproved like '%-<%' then '1' else '2' end ,
		D.DocID,
		isnull(D.DateApproved, D.DateLastModification),
		D.Name,
		D.Description,
		D.NameCreation, 
		D.Author,
		D.PartnerName,
		D.ClassDoc,
		null,
		D.Department
	from dbo.Docs D
	where D.ClassDoc like 'Договоры / %'
		and upper(isnull(D.isActive,'')) = 'Y'
		and not isnull(D.StatusCompletion,'') in ('0','1') --отказанные и исполненные не смотрим
		and isnull(D.StatusDevelopment,'') in ('4','0')
		and isnull(D.DateApproved, D.DateLastModification) between dateadd(Hour, -96, getdate()) and getdate()
	select @Result = @@error if @Result <> 0 goto Err

	-- на согласовании более х дней
    while exists (select 1 from @Masters where Flg = 0)
	begin
		select top 1
			@MSTR = '<' + UserID + '>'
		from @Masters
		where Flg = 0
		select @Result = @@error if @Result <> 0 goto Err
			
	    insert into #tmp
			(TypeOfRes,DocID, DateX, Name, Descr, NameCreation, UserID, PartnerName, ClassDoc, Days,Department)
		exec dbo.PDX_REP_DG_DogovorByMaster
			@MasterName =@MSTR,
			@ActDoc ='',
			@Days =@Days3,
			@Flg =0,
			@ResType = 1
		select @Result = @@error if @Result <> 0 goto Err

		update @Masters
			set Flg = 1
		where UserID = replace(replace(@MSTR,'<',''),'>','')
		select @Result = @@error if @Result <> 0 goto Err
	end
	select @Result = @@error if @Result <> 0 goto Err

	--приостановлены
	insert into #tmp
		(TypeOfRes,DocID, DateX, Name, Descr, NameCreation, UserID, PartnerName, ClassDoc,Days,Department)
	exec dbo.PDX_AG_SuspendReconcilationReport
		@Type = 4,
		@FixCount = @Days4,
		@Access = 1,
		@ResType = 1
	select @Result = @@error if @Result <> 0 goto Err

	update #tmp
	set UserID = '<' + dbo.PDX_SubstringReturn(UserID, charindex('<',UserID), charindex('>',UserID)) + '>'
	where UserID like '%<%>%'
	select @Result = @@error if @Result <> 0 goto Err

/**********************************************************/
--стандартная часть для агентов
/**********************************************************/
	--нужно отсечь пользователей, у которых уже нет доступа в СЭД
	insert into @users (UserID, UserID2)
	select distinct
		R.UserID,
		case when convert(datetime,convert(varchar(100),getdate(),104),104) between isnull(convert(datetime,convert(varchar(100),U.DeputyDateFrom,104),104), convert(datetime,convert(varchar(100),getdate(),104),104)) and isnull(convert(datetime,convert(varchar(100),U.DeputyDateTo,104),104), convert(datetime,convert(varchar(100),getdate(),104),104))
		then isnull(U.DeputyID,'') else '' end
	from dbo.Users U 
	inner join (select distinct UserID from #tmp) R on R.UserID like '%<' + U.UserID + '>%' 
	where U.StatusActive = '1' 
		and convert(datetime,convert(varchar(100),DateExpirationSecurity,104),104) >= convert(datetime,convert(varchar(100),getdate(),104),104)
	select @Result = @@error if @Result <> 0 goto Err
	--и неактивных замов 
	update R
		set UserID2 = ''
	from @users R
	inner join dbo.Users U on U.UserID = R.UserID2 and 
		(U.StatusActive <> '1' 
		or convert(datetime,convert(varchar(100),DateExpirationSecurity,104),104) < convert(datetime,convert(varchar(100),getdate(),104),104) )
	select @Result = @@error if @Result <> 0 goto Err

	update @users set UserID2 = '<' + UserID2 + '>' where isnull(UserID2,'') <> ''
	select @Result = @@error if @Result <> 0 goto Err

	--количетсво записей
	update T
		set RCount = U.RCount
	from #tmp T
		inner join (select userid, count(*) as rcount from #tmp group by userid) as U on U.userid = T.userID
	select @Result = @@error if @Result <> 0 goto Err

/**********************************************************/

	select T.*, U.UserID2
	from #tmp T
	inner join @users U on U.UserID = T.UserID
	order by T.UserID, T.TypeOfRes, isnull(T.DateX,'1900-01-01'), isnull(Days,0), T.DocID
	select @Result = @@error if @Result <> 0 goto Err

	drop table #tmp
	return @Result
Err:
	
	drop table #tmp
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_AG_IKAgent] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

create proc [dbo].[PDX_AG_IKAgent]
		@Type int --1-согласующий
					--3- создатель
					--2 контролер/утверждающий
as
	declare @Result int

	create table #tmp 
		(DocID varchar(255), 
		UserID varchar(255),
		Description varchar(1024),
		NameCreation varchar(128),
		RecName varchar(64),
		ClassDoc varchar(128),
		DateS datetime,
		DateE datetime,
		RCount int default 0) --будет опряделять относится ли строка к окончательному результату
	
	create table #users 
		(UserID varchar(255),
		UserID2 varchar(255))

	select @Result = 0

	insert into #tmp 
		(DocID,
		ClassDoc,
		UserID,
		Description,
		NameCreation,
		RecName,
		DateS,
		DateE)
	select 
		D.DocID,D.ClassDoc,
		case
			when D.ClassDoc in ('Инвестиционный комитет / Вопрос','Инвестиционный комитет / Корректировка ИБ') and @Type = 3 
				then dbo.PDX_SubstringReturn(D.NameCreation, charindex('<',D.NameCreation), charindex('>',D.NameCreation)) 
			when D.ClassDoc in ('Инвестиционный комитет / Вопрос','Инвестиционный комитет / Корректировка ИБ') and @Type = 2 
				then dbo.PDX_SubstringReturn(D.NameControl, charindex('<',D.NameControl), charindex('>',D.NameControl)) 
			when D.ClassDoc in ('Инвестиционный комитет / Вопрос','Инвестиционный комитет / Корректировка ИБ') and @Type = 1
				then C.UserID 

			when D.ClassDoc in ('Инвестиционный комитет / Протокол','Инвестиционный комитет / Повестка') and @Type = 2 
				then dbo.PDX_SubstringReturn(D.NameControl, charindex('<',D.NameControl), charindex('>',D.NameControl)) 
			when D.ClassDoc in ('Инвестиционный комитет / Протокол','Инвестиционный комитет / Повестка') and @Type = 1
				then C.UserID 
			else null
		end as UserID, 
		D.Description, D.NameCreation,C.UserName, C.DateEvent, C.DateEventEnd 
	from Docs D 
	inner Join Comments C ON (D.DocID = C.DocID) and  C.CommentType='VISA' and C.SpecialInfo='VISAWAITING' 
		and C.DateEventEnd<GetDate()  
	where D.IsActive='Y' 
		and isnull(D.StatusCompletion,'') <> '0'  
		and not isnull(D.StatusDevelopment,'') in ('0','4')
		and D.ClassDoc like 'Инвестиционный комитет / %' 
	select @result = @@error if @result <> 0 goto Err

	delete from #tmp
	where ltrim(rtrim(isnull(UserID,'')))=''
	select @result = @@error if @result <> 0 goto Err


/**********************************************************/
--стандартная часть для агентов
/**********************************************************/
	--нужно отсечь пользователей, у которых уже нет доступа в СЭД
	insert into #users (UserID, UserID2)
	select distinct
		R.UserID,
		case when convert(datetime,convert(varchar(100),getdate(),104),104) between isnull(convert(datetime,convert(varchar(100),U.DeputyDateFrom,104),104), convert(datetime,convert(varchar(100),getdate(),104),104)) and isnull(convert(datetime,convert(varchar(100),U.DeputyDateTo,104),104), convert(datetime,convert(varchar(100),getdate(),104),104))
		then isnull(U.DeputyID,'') else '' end
	from dbo.Users U 
	inner join (select distinct UserID from #tmp) R on R.UserID = U.UserID 
	where U.StatusActive = '1' 
		and convert(datetime,convert(varchar(100),DateExpirationSecurity,104),104) >= convert(datetime,convert(varchar(100),getdate(),104),104)
	select @result = @@error if @result <> 0 goto Err
	--и неактивных замов 
	update R
		set UserID2 = ''
	from #users R
	inner join dbo.Users U on U.UserID = R.UserID2 and 
		(U.StatusActive <> '1' 
		or convert(datetime,convert(varchar(100),DateExpirationSecurity,104),104) < convert(datetime,convert(varchar(100),getdate(),104),104) )
	select @result = @@error if @result <> 0 goto Err

	update #users set UserID2 = '<' + UserID2 + '>' where isnull(UserID2,'') <> ''
	select @result = @@error if @result <> 0 goto Err

	--количество записей по пользователю
	update T
		set RCount = U.RCount
	from #tmp T
		inner join (select userid, count(*) as rcount from #tmp group by userid) as U on U.userid = T.userID
	select @Result = @@error if @Result <> 0 goto Err
/**********************************************************/
	
	select distinct
		T.DocID,
		T.ClassDoc,
		T.Description,
		T.NameCreation,
		T.DateS,
		T.DateE,
		T.RecName,
--***START-стандартные параметры	
		'<'+T.UserID+'>' as UserID, 
		U.UserID2, 
		T.RCount
--***END-------------------------
	from #tmp T
	inner join #users u on u.userid = T.UserID
	order by T.UserID, T.ClassDoc, T.DocID
	select @Result = @@error if @Result <> 0 goto Err


	drop table #tmp
	drop table #users

	return @Result
Err:
	
	drop table #tmp
	drop table #users
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_AG_ListToView] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[PDX_AG_ListToView]

as
	create table #tmp 
		(DocID varchar(128),
		ClassDoc varchar(255),
		UserID varchar(255),
		Descr varchar(512),
		NameCreation varchar(128),
		RCount int default 0) --будет опряделять относится ли строка к окончательному результату
	
	declare @ListToview varchar(4000),
		@DocID varchar(128),
		@OneValue varchar(1024)

	create table #users 
		(UserID varchar(255),
		UserID2 varchar(255))

	create table #tbl  
		(ListToView varchar(4000),
		DocID varchar(128),
		ClassDoc varchar(255),
		Name varchar(255),
		Description varchar(4000),
		NameCreation varchar(255),
		Flg bit default 0)


	declare @Cls1 varchar(255), 
			@Cls2 varchar(255), 
			@Cls_9 varchar(255), 
			@Cls_10 varchar(255),
			@LocationPath varchar(4000)

	select @Cls1 = dbo.PDX_CLSGrGet ('RIK_CategoryName_INVKOM_PRO'),
			@Cls2 = dbo.PDX_CLSGrGet ('RIK_CategoryName_SOVDIR_PRO'),

			@Cls_9 = dbo.PDX_CLSGet('RIK_CategoryName_VHOD_VNESH'),
			@Cls_10 = dbo.PDX_CLSGet('RIK_CategoryName_VHOD_VNUTR')


	INSERT INTO #tmp
		(DocID,
		ClassDoc,
		UserID,
		Descr,
		NameCreation)
	SELECT
		D.DocID, 
		D.ClassDoc, 
		dbo.PDX_SubstringReturn(D.NameAproval,charindex('<',D.NameAproval),charindex('>',D.NameAproval)), 
		D.Name,
		D.NameCreation
	FROM dbo.Docs AS D 
	WHERE UPPER(ISNULL(D.IsActive, '')) = 'Y'
		AND NOT (ISNULL(D.StatusCompletion, '') IN ('1', '0')) 
		AND isnull(D.StatusDevelopment,'') <> '0'
		AND ltrim(rtrim(isnull(D.NameApproved,''))) = ''
		AND dbo.PDX_CompareReconcilationList(D.ListToReconcile, D.ListReconciled) = 1
		AND (D.ClassDoc = @Cls_9 or D.ClassDoc = @Cls_10) 
		AND isnull(D.NameAproval,'') <> ''

	insert into #tbl
		(ListToView,
		DocID,
		ClassDoc,
		Name,
		Description,
		NameCreation)
	select 
		ListToView,
		DocID,
		ClassDoc,
		Name,
		Description,
		NameCreation
	from dbo.Docs 
	where isActive = 'Y' 
		and (isnull(NameAproval,'') = '' or isnull(NameApproved,'') <> '')
		and (isnull(LocationPath,'') = '' or isnull(LocationPath,'') like '%+%')
		AND NOT (ISNULL(StatusCompletion, '') IN ('1', '0')) 
		AND isnull(StatusDevelopment,'') <> '0'
		AND not (ClassDoc like @Cls1 + '%' or 
			ClassDoc like @Cls2 + '%')
		AND isnull(listtoview,'') <> ''
		AND isnull(listtoview,'') like '%>;%'

	INSERT INTO #tmp --ознакомление2
		(DocID,
		ClassDoc,
		UserID,
		Descr,
		NameCreation)
	select T.DocID, 
		T.ClassDoc,
		U.UserID,
		cast(case len(isnull(T.Name,'')) when 0 then T.Description else T.Name end as varchar(125)) +
			case when len(case isnull(len(T.Name),0) when 0 then T.Description else T.Name end) > 125 then ' ...' else '' end,
		T.NameCreation
	from #tbl T
	inner join dbo.Users U on T.ListToView like '%<' + U.UserID + '>;%'
		and U.StatusActive = '1' 
		and cast(DateExpirationSecurity as DATE) >= cast(getdate() as DATE)
	

/**********************************************************/
--стандартная часть для агентов
/**********************************************************/
	--нужно отсечь пользователей, у которых уже нет доступа в СЭД
	insert into #users (UserID, UserID2)
	select distinct
		'<' + U.UserID + '>',
		case when convert(datetime,convert(varchar(100),getdate(),104),104) between isnull(convert(datetime,convert(varchar(100),U.DeputyDateFrom,104),104), convert(datetime,convert(varchar(100),getdate(),104),104)) and isnull(convert(datetime,convert(varchar(100),U.DeputyDateTo,104),104), convert(datetime,convert(varchar(100),getdate(),104),104))
		then isnull(U.DeputyID,'') else '' end
	from dbo.Users U 
	inner join (select distinct UserID from #tmp) R on R.UserID = U.UserID
	where U.StatusActive = '1' 
		and convert(datetime,convert(varchar(100),DateExpirationSecurity,104),104) >= convert(datetime,convert(varchar(100),getdate(),104),104)
	--и неактивных замов 
	update R
		set UserID2 = ''
	from #users R
	inner join dbo.Users U on U.UserID = R.UserID2 and 
		(U.StatusActive <> '1' 
		or convert(datetime,convert(varchar(100),DateExpirationSecurity,104),104) < convert(datetime,convert(varchar(100),getdate(),104),104) )

	update #users set UserID2 = '<' + UserID2 + '>' where isnull(UserID2,'') <> ''

	--количество записей по пользователю
	update T
		set RCount = U.RCount
	from #tmp T
		inner join (select userid, count(*) as rcount from #tmp group by userid) as U on U.userid = T.userID
/**********************************************************/
	
	select distinct
		T.DocID,
		T.ClassDoc,
		T.UserID,
		T.Descr,
		T.NameCreation,
--***START-стандартные параметры	
		U.UserID, 
		U.UserID2, 
		T.RCount
--***END-------------------------
	from #tmp T
	inner join #users u on u.userid = '<'+T.UserID+'>'
	order by U.UserID, T.ClassDoc, T.DocID --,T.DocID


	drop table #tmp
	drop table #users
	drop table #tbl

GO
/****** Object:  StoredProcedure [dbo].[PDX_AG_NotApproved] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_AG_NotApproved]
		@Type int, --1 - создатель
					--2 - утверждающий
					--3 - регистратор
		@Days int = 5
as

declare @Result int
select @Result = 0


	declare @res table (
		DocID varchar(128),
		ActDoc varchar(64),
		Name varchar(255),
		NameCreation varchar(128),
		NameAproval varchar(128),
		LocationPath varchar(128),
		PartnerName varchar(255),
		UserID varchar(128),
		--UserID2 varchar(32),
		RCount int,
		DCount int)
		
	declare @stoprefuse table
		(DocType varchar(255),
		StopRefuseFlag bit)

	declare  @users table (UserID varchar(128), UserID2 varchar(128))

	insert into  @stoprefuse 
		(DocType,StopRefuseFlag)
	select DocType,StopRefuseFlag
	from dbo.PDXDocTypesConst
	select @Result = @@error if @Result <> 0 goto Err

	--данные по документам
	insert into @res (DocID,ActDoc, Name,NameCreation,NameAproval,LocationPath,UserID,RCount,PartnerName)
	select 
		D.DocID,D.ActDoc, D.Name,D.NameCreation,D.NameAproval,D.LocationPath,
		case @Type 
			when 1 
				then D.NameCreation
			when 2
				then D.NameAproval
			when 3
				then ''
		end,
		0,--RCount
		D.PartnerName
	from dbo.Docs D
		inner join @stoprefuse s on S.DocType = D.ClassDoc
	where upper(isnull(D.isActive,'')) = 'Y'
		and not isnull(D.StatusDevelopment,'') in ('0','4')
		and not isnull(D.StatusCompletion,'') in ('0','1')
		and D.ClassDoc like 'Договоры / %'
		and dbo.PDX_CompareReconcilationList(D.ListToReconcile,D.ListReconciled) = 1 --т.е. согласован
		and dbo.PDX_fn_stopReconcilation (D.ListToReconcile, D.ListReconciled, S.StopRefuseFlag) = 0
		and isnull(D.NameApproved,'')=''
		and not D.UserFieldText1 like '%Загрузка Архива%'
	order by D.NameCreation
	select @Result = @@error if @Result <> 0 goto Err

	update R 
		set DCount = datediff(day,X.DateCreation, getdate())
	from @res R
	inner join (
		select 
			C.DocID, max(C.DateCreation) as DateCreation
		from @res R
		inner join dbo.Comments C on C.DocID = R.DocID and C.CommentType = 'VISA'
			and SpecialInfo in ('VISAOK','VISAOKREFUSE')
		group by C.DocID) as X on X.DocID = R.DocID

	-- удаляем там где с момента узавершения согласования прошло меньше 5 дней
	delete R 
	from @res R
	where DCount < isnull(@Days,5)
	select @Result = @@error if @Result <> 0 goto Err

	--ищем текущих регистраторов
	If @Type = 3
	begin
	update R
			set UserID = U.Fld8
		from @res R 
		inner join dbo.PDXBranchSettings U on U.Fld1 = dbo.PDX_SubstringReturn(R.ActDoc,charindex('<',R.ActDoc), charindex('>',R.ActDoc))
		select @Result = @@error if @Result <> 0 goto Err

		update R
			set UserID = U.Fld8
		from @res R 
		inner join dbo.PDXBranchSettings U on U.Fld1 = left(dbo.PDX_SubstringReturn(R.ActDoc,charindex('<',R.ActDoc), charindex('>',R.ActDoc)),2)
		where R.UserID = ''
		select @Result = @@error if @Result <> 0 goto Err
		
	
		/*update R
			set UserID = U.Field4
		from @res R 
		inner join dbo.UserDirValues U on U.Field1 = dbo.PDX_SubstringReturn(R.ActDoc,charindex('<',R.ActDoc), charindex('>',R.ActDoc))
			and U.UDKeyField = 47
		select @Result = @@error if @Result <> 0 goto Err

		update R
			set UserID = U.Field4
		from @res R 
		inner join dbo.UserDirValues U on U.Field1 = left(dbo.PDX_SubstringReturn(R.ActDoc,charindex('<',R.ActDoc), charindex('>',R.ActDoc)),2)
			and U.UDKeyField = 47
		where R.UserID = ''
		select @Result = @@error if @Result <> 0 goto Err*/	
	end
	--update @res set UserID = dbo.PDX_SubstringReturn(UserID, charindex('<',UserID), charindex('>',UserID))
	--select @Result = @@error if @Result <> 0 goto Err	

	delete @res where ltrim(rtrim(isnull(UserID,''))) = ''
	select @Result = @@error if @Result <> 0 goto Err	

/**********************************************************/
--стандартная часть для агентов
/**********************************************************/
	--нужно отсечь пользователей, у которых уже нет доступа в СЭД
	insert into @users (UserID, UserID2)
	select distinct
		R.UserID,
		case when convert(datetime,convert(varchar(100),getdate(),104),104) between isnull(convert(datetime,convert(varchar(100),U.DeputyDateFrom,104),104), convert(datetime,convert(varchar(100),getdate(),104),104)) and isnull(convert(datetime,convert(varchar(100),U.DeputyDateTo,104),104), convert(datetime,convert(varchar(100),getdate(),104),104))
		then isnull(U.DeputyID,'') else '' end
	from dbo.Users U 
	inner join (select distinct UserID from @res) R on R.UserID like '%<' + U.UserID + '>%' 
	where U.StatusActive = '1' 
		and convert(datetime,convert(varchar(100),DateExpirationSecurity,104),104) >= convert(datetime,convert(varchar(100),getdate(),104),104)
	select @Result = @@error if @Result <> 0 goto Err

	--и неактивных замов 
	update R
		set UserID2 = ''
	from @users R
	inner join dbo.Users U on U.UserID = R.UserID2 and 
		(U.StatusActive <> '1' 
		or convert(datetime,convert(varchar(100),DateExpirationSecurity,104),104) < convert(datetime,convert(varchar(100),getdate(),104),104) )
	select @Result = @@error if @Result <> 0 goto Err

	update @users set UserID2 = '<' + UserID2 + '>' where isnull(UserID2,'') <> ''
	select @Result = @@error if @Result <> 0 goto Err

	--количество записей по пользователю
	update T
		set RCount = U.RCount
	from @res T
		inner join (select userid, count(*) as rcount from @res group by userid) as U on U.userid = T.userID
	select @Result = @@error if @Result <> 0 goto Err

/**********************************************************/
	
	select 
		T.DocID,
		T.Name,
		T.NameCreation,
		T.NameAproval,
		T.LocationPath,
		T.PartnerName,
		T.DCount,
--***START-стандартные параметры
		T.UserID,
		U.UserID2,
		T.RCount
--***END------------------------
	from @res T
	inner join @users U on U.UserID = T.UserID
	order by T.UserID, T.DocID
	select @Result = @@error if @Result <> 0 goto Err
	

	return @Result
Err:
	
	return @Result

GO
/****** Object:  StoredProcedure [dbo].[PDX_AG_NotPaid] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_AG_NotPaid]
		--@Type int, --1 - создатель
		@Days int = 3
as

declare @Result int
select @Result = 0


	declare @res table (
		DocID varchar(128),
		ActDoc varchar(64),
		Name varchar(255),
		Descr varchar(1024),
		NameCreation varchar(128),
		DocIDParent varchar(128),
		DocIDPrevious varchar(128),
		Currency varchar(100),
		Amount money,
		PartnerName varchar(255),
		UserID varchar(128),
		--UserID2 varchar(32),
		RCount int,
		DCount int)
		

	declare  @users table (UserID varchar(128), UserID2 varchar(128))

	--данные по документам
	insert into @res (DocID,ActDoc, Name,NameCreation,DocIDParent, DocIDPrevious, 
				Descr,Amount, Currency,UserID,RCount,PartnerName, DCount)
	select 
		D.DocID,D.ActDoc, D.Name,D.NameCreation,D.DocIDParent,D.DocIDPrevious,
		D.Description, D.AmountDoc,D.Currency, D.NameCreation,
		0,--RCount
		D.PartnerName,
		DATEDIFF(DAY,CONVERT(datetime,convert(varchar(100),D.DateApproved, 104),104),
			CONVERT(datetime,convert(varchar(100),GETDATE(), 104),104))
	from dbo.Docs D
	where upper(isnull(D.isActive,'')) = 'Y'
		and isnull(D.StatusDevelopment,'') = '4'
		and not isnull(D.StatusCompletion,'') in ('0','1')
		and D.ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_ORDPAY')
		and D.DateSigned is null
		and DATEDIFF(DAY,CONVERT(datetime,convert(varchar(100),D.DateApproved, 104),104),
			CONVERT(datetime,convert(varchar(100),GETDATE(), 104),104)) >= 3
	order by D.NameCreation
	select @Result = @@error if @Result <> 0 goto Err

	delete @res where ltrim(rtrim(isnull(UserID,''))) = ''
	select @Result = @@error if @Result <> 0 goto Err	

/**********************************************************/
--стандартная часть для агентов
/**********************************************************/
	--нужно отсечь пользователей, у которых уже нет доступа в СЭД
	insert into @users (UserID, UserID2)
	select distinct
		R.UserID,
		case when convert(datetime,convert(varchar(100),getdate(),104),104) between isnull(convert(datetime,convert(varchar(100),U.DeputyDateFrom,104),104), convert(datetime,convert(varchar(100),getdate(),104),104)) and isnull(convert(datetime,convert(varchar(100),U.DeputyDateTo,104),104), convert(datetime,convert(varchar(100),getdate(),104),104))
		then isnull(U.DeputyID,'') else '' end
	from dbo.Users U 
	inner join (select distinct UserID from @res) R on R.UserID like '%<' + U.UserID + '>%' 
	where U.StatusActive = '1' 
		and convert(datetime,convert(varchar(100),DateExpirationSecurity,104),104) >= convert(datetime,convert(varchar(100),getdate(),104),104)
	select @Result = @@error if @Result <> 0 goto Err

	--и неактивных замов 
	update R
		set UserID2 = ''
	from @users R
	inner join dbo.Users U on U.UserID = R.UserID2 and 
		(U.StatusActive <> '1' 
		or convert(datetime,convert(varchar(100),DateExpirationSecurity,104),104) < convert(datetime,convert(varchar(100),getdate(),104),104) )
	select @Result = @@error if @Result <> 0 goto Err

	update @users set UserID2 = '<' + UserID2 + '>' where isnull(UserID2,'') <> ''
	select @Result = @@error if @Result <> 0 goto Err

	--количество записей по пользователю
	update T
		set RCount = U.RCount
	from @res T
		inner join (select userid, count(*) as rcount from @res group by userid) as U on U.userid = T.userID
	select @Result = @@error if @Result <> 0 goto Err

/**********************************************************/
	
	select 
		T.DocID,
		T.Name,
		T.Descr,
		T.NameCreation,
		T.DocIDParent,
		T.DocIDPrevious,
		T.PartnerName,
		T.Amount,
		t.Currency,
		T.DCount,
--***START-стандартные параметры
		T.UserID,
		U.UserID2,
		T.RCount
--***END------------------------
	from @res T
	inner join @users U on U.UserID = T.UserID
	order by T.UserID, T.DocID
	select @Result = @@error if @Result <> 0 goto Err
	

	return @Result
Err:
	
	return @Result


GO
/****** Object:  StoredProcedure [dbo].[PDX_AG_PAYInActive] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

create proc [dbo].[PDX_AG_PAYInActive]
		@Type int, --1-создателю,
					--2- утвержд 
		@UQ_Key uniqueidentifier
as
	declare @Result int
	create table #tmp 
		(DocID varchar(255), 
		UserID varchar(255),
		Name varchar(255),
		Descr varchar(1024),
		NameCreation varchar(128),
		Amount money,
		Currency varchar(64),
		RCount int default 0,
		isDel bit default 0) --будет опряделять относится ли строка к окончательному результату
	
	create table #users 
		(UserID varchar(255),
		UserID2 varchar(255))

	select @Result = 0

	insert into #tmp 
		(DocID,
		Name,
		UserID,
		Descr,
		NameCreation,
		Amount,
		Currency,
		isDel)
	select 
		D.DocID, 
		D.Name,
		UC.UserID,
		case D.ClassDoc
			when dbo.PDX_CLSGet('RIK_CategoryName_FIN_PLNPAY')
				then 'Плановая Заявка'
			else 'Корректирующая Заявка'
		end + ' №' + DocID + ' от ' + convert(varchar(100), UserFieldDate3, 104) +
		case D.ClassDoc
			when dbo.PDX_CLSGet('RIK_CategoryName_FIN_PLNPAY')
				then ' (план. дата оплаты ' +convert(varchar(100), UserFieldDate1, 104) + ')'
			else ''
		end as Descr,
		D.NameCreation,
		D.AmountDoc,
		D.Currency,
		0
	from dbo.Docs D
		inner join dbo.Users UC on case @Type 
			when 1
				then D.NameCreation
			when 2
				then D.NameAproval
		end like '%<'+UC.UserID+'>%' 
	where not isnull(D.StatusCompletion,'') in ('1','0')
		and D.ClassDoc IN (dbo.PDX_CLSGet('RIK_CategoryName_FIN_CORPAY'),dbo.PDX_CLSGet('RIK_CategoryName_FIN_PLNPAY'))
		and Upper(D.isActive) = 'Y'
		and not (isnull(StatusDevelopment,'') in ('4','0'))
		and isnull(StatusCompletion,'') <> '0'
	select @result = @@error if @result <> 0 goto Err

	insert into #tmp 
		(DocID,
		Name,
		UserID,
		Descr,
		NameCreation,
		Amount,
		Currency,
		isDel)
	select 
		D.DocID, 
		D.Name,
		UC.UserID,
		case D.ClassDoc
			when dbo.PDX_CLSGet('RIK_CategoryName_FIN_PLNPAY')
				then 'Плановая Заявка'
			else 'Корректирующая Заявка'
		end + ' №' + D.DocID + ' от ' + convert(varchar(100), UserFieldDate3, 104) +
		case D.ClassDoc
			when dbo.PDX_CLSGet('RIK_CategoryName_FIN_PLNPAY')
				then ' (план. дата оплаты ' +convert(varchar(100), UserFieldDate1, 104) + ')'
			else ''
		end as Descr,
		D.NameCreation,
		D.AmountDoc,
		D.Currency,
		1
	from dbo.Comments C
	inner join dbo.Docs D on C.DocID = D.DocID	
		and D.ClassDoc IN (dbo.PDX_CLSGet('RIK_CategoryName_FIN_CORPAY'),dbo.PDX_CLSGet('RIK_CategoryName_FIN_PLNPAY'))
	inner join dbo.Users UC on case @Type 
			when 1
				then D.NameCreation
			when 2
				then D.NameAproval
		end like '%<'+UC.UserID+'>%' 
	where C.SpecialInfo  = cast(@UQ_Key as varchar(40))
		and C.CommentType = 'HISTORY'		
	select @result = @@error if @result <> 0 goto Err
	
/*********************************************/ 
    If exists (select 1 from #tmp where isDel = 0)
	begin
		delete C
		from dbo.Comments C
		inner join #tmp T on T.DocID = C.DocID
			and T.isDel = 0
		where C.CommentType = 'VISA'
			and C.CommentType = 'VISAWAITING'
		select @result = @@error if @result <> 0 goto Err

		Update D
			set isActive = 'N'
		from dbo.Docs D
		inner join #tmp T on T.DocID = D.DocID
			and T.isDel = 0
		select @result = @@error if @result <> 0 goto Err

		insert into dbo.Comments
			(UserID,
			UserName,
			ContactUserName,
			ContactUserID,
			PartnerName,
			DocID,
			DateCreation,
			DateEvent,
			DateEventEnd,
			Address,
			Subject,
			Comment,
			CommentType,
			SpecialInfo,
			FileName,
			--KeyField,
			PartnerID,
			Version,
			GUID,
			GUIDPartner,
			GUIDUser,
			GUIDDoc,
			Amount,
			FileNameOriginal,
			RIK_CommentType)
		select 
			'Admin',--UserID,
			'System Administrator',--UserName,
			null,--ContactUserName,
			null,--ContactUserID,
			null,--PartnerName,
			DocID,
			getdate(),--DateCreation,
			null,--DateEvent,
			null,--DateEventEnd,
			null,--Address,
			null,--Subject,
			'Автоматическая деактивация заявок в связи с окончанием финансового периода.',--Comment,
			'HISTORY',--CommentType,
			cast(@UQ_Key as varchar(40)),--SpecialInfo,
			null,--	FileName,
			--KeyField,
			null,--	PartnerID,
			null,--	Version,
			null,--	GUID,
			null,--	GUIDPartner,
			null,--	GUIDUser,
			null,--	GUIDDoc,
			null,--	Amount,
			null,--	FileNameOriginal,
			null--	RIK_CommentType
		from #tmp
		where isDel = 0
		select @result = @@error if @result <> 0 goto Err
	end
/*********************************************/

/**********************************************************/
--стандартная часть для агентов
/**********************************************************/
	--нужно отсечь пользователей, у которых уже нет доступа в СЭД
	insert into #users (UserID, UserID2)
	select distinct
		'<' + U.UserID + '>',
		case when convert(datetime,convert(varchar(100),getdate(),104),104) between isnull(convert(datetime,convert(varchar(100),U.DeputyDateFrom,104),104), convert(datetime,convert(varchar(100),getdate(),104),104)) and isnull(convert(datetime,convert(varchar(100),U.DeputyDateTo,104),104), convert(datetime,convert(varchar(100),getdate(),104),104))
		then isnull(U.DeputyID,'') else '' end
	from dbo.Users U 
	inner join (select distinct UserID from #tmp) R on R.UserID=U.UserID --R.UserID like '%<' + U.UserID + '>%' 
	where U.StatusActive = '1' 
		and convert(datetime,convert(varchar(100),DateExpirationSecurity,104),104) >= convert(datetime,convert(varchar(100),getdate(),104),104)
	select @result = @@error if @result <> 0 goto Err
	--и неактивных замов 
	update R
		set UserID2 = ''
	from #users R
	inner join dbo.Users U on U.UserID = R.UserID2 and 
		(U.StatusActive <> '1' 
		or convert(datetime,convert(varchar(100),DateExpirationSecurity,104),104) < convert(datetime,convert(varchar(100),getdate(),104),104) )
	select @result = @@error if @result <> 0 goto Err

	update #users set UserID2 = '<' + UserID2 + '>' where isnull(UserID2,'') <> ''
	select @result = @@error if @result <> 0 goto Err

	--количество записей по пользователю
	update T
		set RCount = U.RCount
	from #tmp T
		inner join (select userid, count(*) as rcount from #tmp group by userid) as U on U.userid = T.userID
	select @Result = @@error if @Result <> 0 goto Err
/**********************************************************/
	
	select distinct
		T.DocID,
		T.Name,
		T.Descr,
		T.NameCreation,
		T.Amount,
		T.Currency,
--***START-стандартные параметры	
		U.UserID, 
		U.UserID2, 
		T.RCount
--***END-------------------------
	from #tmp T
	inner join #users u on u.userid = '<'+T.UserID+'>'
	order by U.UserID, T.DocID
	select @Result = @@error if @Result <> 0 goto Err


	drop table #tmp
	drop table #users

	return @Result
Err:
	
	drop table #tmp
	drop table #users
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_AG_payStatusSet] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[PDX_AG_payStatusSet]
	
as
	declare @Result int
	create table #tmp 
		(DocID varchar(128),
		ClassDoc varchar(255),
		UserID varchar(255),
		Descr varchar(512),
		NameCreation varchar(128),
		DateSigned datetime,
		DateCreation datetime,
		NC_Comm varchar(96),
		RCount int default 0) --будет опряделять относится ли строка к окончательному результату
	
	create table #users 
		(UserID varchar(255),
		UserID2 varchar(255))

	declare @Cls1 varchar(255), @DT datetime, @DT0 datetime, @DTFr datetime, @DT1 datetime, @DTTo datetime
	
	set @DT0 = cast(GETDATE() as date)
	
	set @DTFr = dateadd(minute,25,dateadd(hour,7, @DT0)) --7:25
	set @DTTo = dateadd(minute,35,dateadd(hour,22, @DT0))--22:35
	
	set @DT1 = dateadd(minute,10,@DTFr) --7:35
	
--робот будет работать с 7:30 до 22:30 (так настроен джоб)
--в момент первого запуска данные собираются с 22:30 предыдущего дня	
	set @DT = case	
				when GETDATE() <= '2019-06-21 06:00'
					then dateadd(hour,-24, getdate())
				when GETDATE() <= @DT1 --первый запуск раньше 7:35
					then dateadd(minute,30,dateadd(hour,22, dateadd(day,-1, @DT0))) --с 22:30 предыдущего дня	
				else dateadd(MINUTE,-30, getdate()) --за последнии 30 минут
			end

	select @Cls1 = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_ORDPAY')--('RIK_CategoryName_FIN_ORDPAY')

	select @Result = 0

If GETDATE() <= '2019-06-21 06:00' or GETDATE() between @DTFr and @DTTo -- с 7:25 до 22:35  --погрешность в 5 минут нужна из-за возможной погрешности времени между sql и iis-м
begin
	INSERT INTO #tmp 
		(DocID,
		ClassDoc,
		UserID,
		Descr,
		NameCreation,
		DateSigned,
		NC_Comm,
		DateCreation)
	select 
		D.DocID,
		D.ClassDoc,
		dbo.PDX_SubstringReturn(D.NameCreation, charindex('<',D.NameCreation), charindex('>',D.NameCreation)),
		D.Name,
		D.NameCreation,
		D.DateSigned,
		C.UserName,
		C.DateCreation
	from dbo.Comments C
	inner join dbo.Docs D on D.DocID = C.DocID
		and D.ClassDoc = @Cls1
		and upper(isnull(D.isActive,'')) = 'Y'	
		and Year(isnull(D.DateSigned,'1900-01-01')) <> 1900
	where Upper(C.CommentType) = 'HISTORY'
		and Upper(C.SpecialInfo) = 'PAYMENT'
		and C.DateCreation > =  @DT
	select @Result = @@error if @Result <> 0 goto Err
 
/**********************************************************/
--стандартная часть для агентов
/**********************************************************/
	--нужно отсечь пользователей, у которых уже нет доступа в СЭД
	insert into #users (UserID, UserID2)
	select distinct
		'<' + U.UserID + '>',
		case when convert(datetime,convert(varchar(100),getdate(),104),104) between isnull(convert(datetime,convert(varchar(100),U.DeputyDateFrom,104),104), convert(datetime,convert(varchar(100),getdate(),104),104)) and isnull(convert(datetime,convert(varchar(100),U.DeputyDateTo,104),104), convert(datetime,convert(varchar(100),getdate(),104),104))
		then isnull(U.DeputyID,'') else '' end
	from dbo.Users U 
	inner join (select distinct UserID from #tmp) R on R.UserID = U.UserID
	where U.StatusActive = '1' 
		and convert(datetime,convert(varchar(100),DateExpirationSecurity,104),104) >= convert(datetime,convert(varchar(100),getdate(),104),104)
	select @result = @@error if @result <> 0 goto Err
	--и неактивных замов 
	update R
		set UserID2 = ''
	from #users R
	inner join dbo.Users U on U.UserID = R.UserID2 and 
		(U.StatusActive <> '1' 
		or convert(datetime,convert(varchar(100),DateExpirationSecurity,104),104) < convert(datetime,convert(varchar(100),getdate(),104),104) )
	select @result = @@error if @result <> 0 goto Err

	update #users set UserID2 = '<' + UserID2 + '>' where isnull(UserID2,'') <> ''
	select @result = @@error if @result <> 0 goto Err

	--количество записей по пользователю
	update T
		set RCount = U.RCount
	from #tmp T
		inner join (select userid, count(*) as rcount from #tmp group by userid) as U on U.userid = T.userID
	select @Result = @@error if @Result <> 0 goto Err
/**********************************************************/
end	
	select distinct
		T.DocID,
		T.ClassDoc,
		T.Descr,
		T.NameCreation,
		T.DateSigned,
		T.NC_Comm,
		T.DateCreation,
--***START-стандартные параметры	
		U.UserID, 
		U.UserID2, 
		T.RCount
--***END-------------------------
	from #tmp T
	inner join #users u on u.userid = '<'+T.UserID+'>'
	order by U.UserID, T.ClassDoc, T.DocID --,T.DocID
	select @Result = @@error if @Result <> 0 goto Err


	drop table #tmp
	drop table #users
	return @Result
Err:
	
	drop table #tmp
	drop table #users
	return @Result




GO
/****** Object:  StoredProcedure [dbo].[PDX_AG_ReconcilationHold] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

create proc [dbo].[PDX_AG_ReconcilationHold]
		@Type int 
			--1 - создателю
			--2 - утверждающему
			--3 - согласующему
as
	declare @Result int

	create table #users
		(UserID varchar(128),
		UserID2 varchar(128))

	create table #Results
		(UserID varchar(128),
		--UserID2 varchar(128),
		StrID varchar(128),
		SName varchar(255),
		PartnerName varchar(255),
		ReconcileName varchar(128),
		DateStart datetime,
		DateEnd datetime,
		RCount int)

	select @Result = 0


	--данные 
	insert into #Results
		(UserID, StrID, SName, PartnerName, ReconcileName, DateStart, DateEnd, RCount)
	Select
		case @Type 
			when 1
				then dbo.PDX_SubstringReturn(D.NameCreation,charindex('<',D.NameCreation),charindex('>',D.NameCreation))
			when 2
				then dbo.PDX_SubstringReturn(D.NameAproval,charindex('<',D.NameAproval),charindex('>',D.NameAproval))
			when 3
				then C.UserID
		end as UserID,
		D.DocID,
		case len(isnull(D.Name,'')) 
			when 0 
				then cast(isnull(D.Description,'') as varchar(250)) + case when len(isnull(D.Description,'')) > 250 then '...' else '' end
			else isnull(D.Name,'')
		end,
		D.PartnerName,
		C.UserName,
		C.DateEvent,
		C.DateEventEnd,
		1
	from dbo.Docs D
	inner Join dbo.Comments C ON D.DocID = C.DocID 
		and C.CommentType='VISA' 
		and C.SpecialInfo='VISAWAITING' 
		and C.DateEventEnd<GetDate() 
		and not D.ListReconciled like '%<' + C.UserID + '>%' --этим отсекаем левые(ошибки ПД) счетчики
		and D.ListToReconcile like '%<' + C.UserID + '>%' --этим отсекаем левые(ошибки ПД) счетчики
	where upper(isnull(D.IsActive,''))='Y' 
		and not isnull(D.StatusCompletion,'') in ('0','1') --не исполнено и не отменео
		and isnull(D.StatusDevelopment,'') <> '0' --не отказано в утверждении
		and not (D.ClassDoc like 'Совет директоров /%' 
			or D.ClassDoc like 'Инвестиционный комитет / %')
	select @Result = @@error if @Result <> 0 goto Err

	delete from #Results
	where ltrim(rtrim(isnull(UserID,''))) = ''
	select @Result = @@error if @Result <> 0 goto Err
	
	
/**********************************************************/
--стандартная часть для агентов
/**********************************************************/
	--нужно отсечь пользователей, у которых уже нет доступа в СЭД
	insert into #users (UserID, UserID2)
	select distinct
		R.UserID,
		case when convert(datetime,convert(varchar(100),getdate(),104),104) between isnull(convert(datetime,convert(varchar(100),U.DeputyDateFrom,104),104), convert(datetime,convert(varchar(100),getdate(),104),104)) and isnull(convert(datetime,convert(varchar(100),U.DeputyDateTo,104),104), convert(datetime,convert(varchar(100),getdate(),104),104))
		then isnull(U.DeputyID,'') else '' end
	from dbo.Users U 
	inner join (select distinct UserID from #Results) as R on U.UserID = R.UserID 
	where U.StatusActive = '1' 
		and convert(datetime,convert(varchar(100),DateExpirationSecurity,104),104) >= convert(datetime,convert(varchar(100),getdate(),104),104)
	select @result = @@error if @result <> 0 goto Err
	--и неактивных замов 
	update R
		set UserID2 = ''
	from #users R
	inner join dbo.Users U on U.UserID = R.UserID2 and 
		(U.StatusActive <> '1' 
		or convert(datetime,convert(varchar(100),DateExpirationSecurity,104),104) < convert(datetime,convert(varchar(100),getdate(),104),104) )
	select @result = @@error if @result <> 0 goto Err

	update #users set UserID2 = '<' + UserID2 + '>' where isnull(UserID2,'') <> ''
	select @result = @@error if @result <> 0 goto Err

	--количество записей по пользователю
	update T
		set RCount = U.RCount
	from #Results T
		inner join (select userid, count(*) as rcount from #Results group by userid) as U on U.userid = T.userID
	select @Result = @@error if @Result <> 0 goto Err
/**********************************************************/

	select 
--***START-стандартные параметры	
		'<'+R.UserID+'>' as UserID,
		U.UserID2,
		R.RCount,
--***END--------------------------
		R.StrID,
		R.SName,
		R.PartnerName,
		R.ReconcileName,
		R.DateStart,
		R.DateEnd
	from #Results R 	
	inner join #users U on U.UserID = R.UserID
	order by R.UserID, R.StrID
	select @Result = @@error if @Result <> 0 goto Err
	
	drop table #users
	drop table #Results

	return @Result
Err:
	
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_AG_SDAgent] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

create proc [dbo].[PDX_AG_SDAgent]
		@Type int  --1 - исполнителю не просроченные
					--2 - исполнителю просроченные
					--3 контролеру неназначенные
as
	declare @Result int

	create table #tmp 
		(DocID varchar(255), 
		UserID varchar(255),
		Description varchar(1024),
		NameCreation varchar(128),
		NameResponsible varchar(128),
		DocIDParent varchar(128),
		DateCompletion datetime,
		RCount int default 0) 
	
	create table #users 
		(UserID varchar(255),
		UserID2 varchar(255))

	select @Result = 0

	insert into #tmp 
		(DocID,
		UserID,
		Description,
		NameCreation,
		NameResponsible,
		DocIDParent,
		DateCompletion)
	select 
		V.DocID, 
		case when (@Type = 1 and V.DateCompletion < getdate()) or (@Type = 2 and V.DateCompletion >= getdate())
				then V.NameResponsible
			when @Type = 3 and ltrim(rtrim(isnull(V.NameResponsible,''))) = ''
				then V.NameControl
			else null
		end,
		V.Description,
		V.NameCreation,
		V.NameResponsible,
		V.DocIDParent,
		V.DateCompletion
	from dbo.Docs V
	inner join dbo.Docs P on P.DocID = V.DocIDParent 
		and P.ClassDoc = 'Совет директоров / Повестка' 
		and isnull(ltrim(rtrim(P.StatusCompletion)),'') = '' 
		and lower(P.IsActive) = 'y' and P.StatusCompletion <> '0' 
	where V.ClassDoc = 'Совет директоров / Вопрос' 
		and isnull(ltrim(rtrim(V.StatusCompletion)),'') = '' 
		and lower(V.IsActive) = 'y' and V.StatusCompletion <> '0'
		
		and (
			(@Type = 1 and V.DateCompletion < getdate())
			or (@Type = 2 and V.DateCompletion >= getdate())
			or (@Type = 3 and ltrim(rtrim(isnull(V.NameResponsible,''))) = '')
		)

	select @result = @@error if @result <> 0 goto Err

	delete from #tmp 
	where ltrim(rtrim(isnull(UserID,''))) = ''
	select @result = @@error if @result <> 0 goto Err

/**********************************************************/
--стандартная часть для агентов
/**********************************************************/
	--нужно отсечь пользователей, у которых уже нет доступа в СЭД
	insert into #users (UserID, UserID2)
	select distinct
		R.UserID,
		case when convert(datetime,convert(varchar(100),getdate(),104),104) between isnull(convert(datetime,convert(varchar(100),U.DeputyDateFrom,104),104), convert(datetime,convert(varchar(100),getdate(),104),104)) and isnull(convert(datetime,convert(varchar(100),U.DeputyDateTo,104),104), convert(datetime,convert(varchar(100),getdate(),104),104))
		then isnull(U.DeputyID,'') else '' end
	from dbo.Users U 
	inner join (select distinct UserID from #tmp) as R on R.UserID like '%<' + U.UserID + '>%' 
	where U.StatusActive = '1' 
		and convert(datetime,convert(varchar(100),DateExpirationSecurity,104),104) >= convert(datetime,convert(varchar(100),getdate(),104),104)
	select @result = @@error if @result <> 0 goto Err
	--и неактивных замов 
	update R
		set UserID2 = ''
	from #users R
	inner join dbo.Users U on U.UserID = R.UserID2 and 
		(U.StatusActive <> '1' 
		or convert(datetime,convert(varchar(100),DateExpirationSecurity,104),104) < convert(datetime,convert(varchar(100),getdate(),104),104) )
	select @result = @@error if @result <> 0 goto Err

	update #users set UserID2 = '<' + UserID2 + '>' where isnull(UserID2,'') <> ''
	select @result = @@error if @result <> 0 goto Err

	--количество записей по пользователю
	update T
		set RCount = U.RCount
	from #tmp T
		inner join (select userid, count(*) as rcount from #tmp group by userid) as U on U.userid = T.userID
	select @Result = @@error if @Result <> 0 goto Err
/**********************************************************/
	
	select distinct
		T.DocID,
		T.Description,
		T.NameCreation,
		T.NameResponsible,
		T.DocIDParent,
		T.DateCompletion,--convert(varchar(100),T.DateCompletion,104) + ' ' + convert(varchar(100),T.DateCompletion,108) as DateCompletion,
--***START-стандартные параметры	
		T.UserID as UserID, 
		U.UserID2, 
		T.RCount
--***END-------------------------
	from #tmp T
	inner join #users u on u.userid = T.UserID
	order by T.UserID, T.DocID
	select @Result = @@error if @Result <> 0 goto Err


	drop table #tmp
	drop table #users

	return @Result
Err:
	
	drop table #tmp
	drop table #users
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_AG_Zadachi] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_AG_Zadachi]
		@Type int --1-исполнителю,
					--2- контролеру ,
					--3 - соисполнителям
as
	declare @Result int
	create table #tmp 
		(DocID varchar(255), 
		UserID varchar(1024),
		StatusName varchar(50),
		Name varchar(255),
		Description varchar(4000),
		NameResponsible varchar(128),
		NameControl varchar(128),
		NameCreation varchar(128),
		Correspondent varchar(4000),
		DateCreation datetime,
		DateCompletion datetime,
		RCount int default 0) --будет опряделять относится ли строка к окончательному результату
	
	declare @LocationPath varchar(8000),
			@FPos int,
			@EPos int,
			@OneValue varchar(255)
	

	create table #users 
		(UserID varchar(255),
		UserID2 varchar(255))

	select @Result = 0

	insert into #tmp 
		(DocID,
		Name,
		UserID,
		StatusName,
		Description,
		NameResponsible,
		NameControl,
		NameCreation,
		Correspondent,
		DateCreation,
		DateCompletion)
	select 
		D.DocID, 
		P.Name,
		case @Type 
			when 1
				then D.NameResponsible
			when 2
				then D.NameControl
			when 3
				then D.ListToView
		end,
		case 
			when convert(datetime,convert(varchar(100),getdate(),104),104) <= D.DateCompletion 
				then 'исполняется' 
			else 'просрочен' 
		end as StatusName, 
		D.Description, 
		D.NameResponsible,
		D.NameControl,
		D.NameCreation, 
		D.Correspondent,
		D.DateCreation, 
		D.DateCompletion
	from dbo.Docs D
		left join dbo.Docs P on P.DocID = D.DocIDParent 
	where not isnull(D.StatusCompletion,'') in ('1','0')
		and D.ClassDoc IN ('Задачи') 
		and convert(datetime,convert(varchar(100),getdate(),104),104) >= D.UserFieldDate3 
		and Upper(D.isActive) = 'Y'
	select @result = @@error if @result <> 0 goto Err

/**********************************************************/
--стандартная часть для агентов
/**********************************************************/
	--нужно отсечь пользователей, у которых уже нет доступа в СЭД
	insert into #users (UserID, UserID2)
	select distinct
		U.UserID,
		case when convert(datetime,convert(varchar(100),getdate(),104),104) between isnull(convert(datetime,convert(varchar(100),U.DeputyDateFrom,104),104), convert(datetime,convert(varchar(100),getdate(),104),104)) and isnull(convert(datetime,convert(varchar(100),U.DeputyDateTo,104),104), convert(datetime,convert(varchar(100),getdate(),104),104))
		then isnull(U.DeputyID,'') else '' end
	from dbo.Users U 
	inner join (select distinct UserID from #tmp) as R on R.UserID like '%<' + U.UserID + '>%' 
	where U.StatusActive = '1' 
		and convert(datetime,convert(varchar(100),DateExpirationSecurity,104),104) >= convert(datetime,convert(varchar(100),getdate(),104),104)
	select @result = @@error if @result <> 0 goto Err

	--и неактивных замов 
	update R
		set UserID2 = ''
	from #users R
	inner join dbo.Users U on U.UserID = R.UserID2 and 
		(U.StatusActive <> '1' 
		or convert(datetime,convert(varchar(100),DateExpirationSecurity,104),104) < convert(datetime,convert(varchar(100),getdate(),104),104) )
	select @result = @@error if @result <> 0 goto Err

	update #users set UserID2 = '<' + UserID2 + '>' where isnull(UserID2,'') <> ''
	select @result = @@error if @result <> 0 goto Err
	update #users set UserID = '<' + UserID + '>' where isnull(UserID,'') <> ''
	select @result = @@error if @result <> 0 goto Err

	--количество записей по пользователю
	update T
		set RCount = U.RCount
	from #tmp T
		inner join (select userid, count(*) as rcount from #tmp group by userid) as U on U.userid = T.userID
	select @Result = @@error if @Result <> 0 goto Err
/**********************************************************/

	select distinct
		T.DocID,
		T.StatusName,
		T.Name,
		T.Description,
		T.NameResponsible,
		T.NameControl,
		T.NameCreation,
		T.Correspondent,
		T.DateCreation,
		T.DateCompletion,
--***START-стандартные параметры	
		U.UserID, 
		U.UserID2, 
		T.RCount
--***END-------------------------
	from #tmp T
	inner join #users u on T.UserID like '%' + u.userid + '%'
	order by U.UserID, T.DocID
	select @Result = @@error if @Result <> 0 goto Err


	drop table #tmp
	drop table #users

	return @Result
Err:
	
	drop table #tmp
	drop table #users
	return @Result

GO
/****** Object:  StoredProcedure [dbo].[PDX_AGLOG_Insert] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_AGLOG_Insert]
	@DocID varchar(255),
	@UserID varchar(128),
	@AGType varchar(128),
	@Descr varchar(255),
	@KeyID uniqueidentifier
	
as
	declare 
	@Res int

    If not exists (select 1 from dbo.PDXAgentLog where DocID = @DocID and UserID = @UserID and KeyID = @KeyID and Descr = @Descr)
	begin
		insert into dbo.PDXAgentLog 
			(SetID,
			DateCreation,
			AGType,
			DocID,
			UserID,
			Descr,
			KeyID,
			Processed)
		values 
			(NewID(),--SetID,
			getdate(),--DateCreation,
			@AGType,
			@DocID,
			@UserID,
			@Descr,
			@KeyID,
			0)--Processed)
		select @Res = @@error if @Res <> 0 goto Err
	end
	select @Res = @@error if @Res <> 0 goto Err

OK:

	return @Res
Err:
	return @Res
GO
/****** Object:  StoredProcedure [dbo].[PDX_AGLOG_Processed] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_AGLOG_Processed]
	@AGType varchar(128),
	@KeyID uniqueidentifier
	
as
	declare 
	@Res int

	update dbo.PDXAgentLog 
		set Processed = 1
	where AGType = @AGType
	and KeyID = @KeyID
	and Processed = 0
	select @Res = @@error if @Res <> 0 goto Err

OK:

	return @Res
Err:
	return @Res
GO
/****** Object:  StoredProcedure [dbo].[PDX_ArrayToTable] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[PDX_ArrayToTable]
	@Separator1 varchar(10),
	@Separator2 varchar(10),
	@Value varchar(4096)
as

	declare @Pos1 int, @Pos2 int, /*@Result int,*/ @Pos int,@Flag bit

	select /*@Result = 0, */@Pos = 0

	--будем разбирать строку по одному или двум разделителем (смотря сколько из них передано)
	--Flag - будет указывать был ли между значениями Enter

	declare @restbl table (Val varchar(1024),KeyFld int identity, Pos int, Flag bit)

	select @Separator1 = ltrim(rtrim(isnull(@Separator1,''))),
			@Separator2 = ltrim(rtrim(isnull(@Separator2,''))),
			@Value = ltrim(rtrim(isnull(@Value,'')))
	--select @Result = @@error if @Result <> 0 goto Err

	--если не указан разделитель , выходим из процедуры
	if @Separator1 = '' and @Separator2 = '' goto OK

	--если указан один разделитель, преобразуем ситуацию так, чтобы можно было воспользоваться алгоритмом по 2-м разделителям
	if (@Separator1 = '' and @Separator2 <> '') or (@Separator2 = '' and @Separator1 <> '') or (@Separator2 = @Separator1)
	begin
		select @Separator1 = case @Separator1 when '' then @Separator2 else @Separator1 end,
			   @Separator2 = case @Separator2 when '' then @Separator1 else @Separator2 end
		--select @Result = @@error if @Result <> 0 goto Err


		select @Value = case when @Value like @Separator1 + '%' then '' else @Separator1 end +
							@Value + case when @Value like '%' + @Separator1 then '' else @Separator1 end
		--select @Result = @@error if @Result <> 0 goto Err
	end

	--разбираем строку
	while @Value like '%'+@Separator1+'%'+@Separator2+'%'
	begin
		select @Pos1 = charindex(@Separator1,@Value),
				@Pos2 = charindex(@Separator2, @Value, @Pos1 + 1)
		--select @Result = @@error if @Result <> 0 goto Err

		--задваиваем разделитель в конце подстроки, чтоы следующий разбор получился
		if @Separator1 = @Separator2 --если у нас исходная ситуация с одним разделителем
		begin 
			select @Value = STUFF(@Value,@Pos2,len(@Separator1), @Separator1+@Separator1)
			--select @Result = @@error if @Result <> 0 goto Err
		end
		
		--параметр flag у первого значения всегда = 1, в остальных случаях подчиняется данному условию
		If case when substring(@Value,1,@Pos1) like '%'+char(13)+char(10)+'%' then 1 else 0 end = 1
			or not exists (select 1 from @restbl)
		begin
			select @Pos = @Pos + 1,
					@Flag = 1
			--select @Result = @@error if @Result <> 0 goto Err
		end
		else
		begin
			select @Flag = case when substring(@Value,1,@Pos1) like '%'+char(13)+char(10)+'%' then 1 else 0 end 
			--select @Result = @@error if @Result <> 0 goto Err
		end
		--select @Result = @@error if @Result <> 0 goto Err

		--сохраняем значение в таблице
		insert into @restbl (Val, Flag, Pos)
		values (cast(dbo.PDX_SubstringReturn(@Value,@Pos1,@Pos2) as varchar(1024)),
				@Flag,--case when substring(@Value,1,@Pos1) like '%'+char(13)+char(10)+'%' then 1 else 0 end,
				@Pos)
		--select @Result = @@error if @Result <> 0 goto Err

		--оставляем от value, только "необработанную" часть
		select @Value = STUFF(@Value,1,@Pos2, '')
		--select @Result = @@error if @Result <> 0 goto Err
	end		
	--select @Result = @@error if @Result <> 0 goto Err
	

	--доделка по параметру flag, если на одном уровне есть параметр с флагом= 0, то все значения на этом уровлне должны быть с флагом 0
	update R
		set Flag = X.Flag
	from @restbl R
	inner join (
		select distinct Pos, Flag from @restbl where Flag = 0
				) X on X.Pos = R.Pos
	--select @Result = @@error if @Result <> 0 goto Err
OK:

	select Val,Pos,Flag from @restbl order by Pos
	--select @Result = @@error if @Result <> 0 goto Err
	--drop table @restbl

	--return @Result
--Err:
	
	--drop table @restbl
	--return @Result

GO
/****** Object:  StoredProcedure [dbo].[PDX_ATT_ExtCheck] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_ATT_ExtCheck]
	@DocID varchar(128),
	@isContext bit = 0
	
as
declare 
	@Res int,
	@Mess varchar(1024), @PN varchar(512),
	@ActDoc varchar(128),@ActDocPN varchar(128), @DocIDInt int,
	@DOCS_PN varchar(128), @ClassDoc varchar(128)
	
	select @Res = 0
	select @Mess = ''

	declare @Tbl table (Val varchar(64), Pos int, Flag bit)
	
	select
		@ActDoc = ActDoc,
		@DocIDInt = DocIDInt,
		@PN = rtrim(PartnerName),
		@ClassDoc = ClassDoc
	from dbo.Docs 
	where DocID = ltrim(rtrim(isnull(@DocID,'')))
	select @Res = @@error if @Res <> 0 goto Err

	select top 1
		@DOCS_PN = RUSName
	from dbo.PDXUserSettingDocTypes
	where DocType = @ClassDoc
		and FieldName = 'PartnerName'

	set @DOCS_PN = ISNULL(@DOCS_PN,'')
	if @DOCS_PN = '' set @DOCS_PN = 'Контрагент'
	
	if ISNULL(@PN,'') <> ''
	begin
		select
			@ActDocPN = ActDoc
		from dbo.Partners
		where Name = @PN
	end
	
	IF @ActDoc <> @ActDocPN
	begin	
			select @Mess = @Mess + 
				'<br><font color=red>ОШИБКА! </font> ' + @DOCS_PN + ': значение [' + @PN + '] в справочнике не существует ' 
			select @Res = @@error if @Res <> 0 goto Err
	end
	
	select @Mess = @Mess + case len(@Mess) when 0 then '' else '<br>' end
    select @Res = @@error if @Res <> 0 goto Err

OK:

	select @Mess as 'res'
	return @Res
Err:
	select @Mess  as 'res'
	return @Res










GO
/****** Object:  StoredProcedure [dbo].[PDX_ATTLPGet] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

create proc [dbo].[PDX_ATTLPGet]
	@UserID varchar(128)=null,
	@Department varchar(512)=null,
	@Field varchar(255)

as
	declare @strres varchar(1024),
		@Result int,
		@onevalue varchar(1024),
		@Pos int,
		--@Department varchar(512),
		@i int

	select @Result = 0

	declare @tmp table (UName varchar(255), Dept varchar(512), i int identity, i1 int default 0)
	declare @tmp1 table (LocationPath varchar(255),Dept varchar(512), i int identity)

	select @strres = ''
	
	select @UserID = ltrim(rtrim(isnull(@UserID,''))),
			@Department = ltrim(rtrim(isnull(@Department,'')))

	if not (@UserID = '' and @Department = '')
	begin
		/*if @UserID like '%<%>%'	
		begin
			select @UserID = dbo.PDX_SubstringReturn(@UserID,charindex('<',@UserID),charindex('>',@UserID))
			select @Result = @@error if @Result <> 0 goto Err
		end*/
	
		If @Department = '' and @UserID <> ''
		begin
			select @Department = Department 
			from dbo.Users
			where UserID = @UserID
			select @Result = @@error if @Result <> 0 goto Err
		
			select @Department = ltrim(rtrim(isnull(@Department,'')))
			select @Result = @@error if @Result <> 0 goto Err
		end

		If @Department <> ''
		begin
			If @Field = 'DocLocationPath'
			begin --регистратор конкретного подразделения
				insert into @tmp1 (LocationPath, Dept)
				select top 1 ltrim(rtrim(isnull(ATT_Register,''))), ltrim(rtrim(Name))
				from dbo.Departments
				where (ltrim(rtrim(@Department)) like ltrim(rtrim(Name)) + '%'
					or ltrim(rtrim(@Department))+'/' like ltrim(rtrim(Name)) + '%')
					and ltrim(rtrim(isnull(ATT_Register,''))) <> ''
				order by Name desc
				select @Result = @@error if @Result <> 0 goto Err
			end
			/*else --все регистраторы Предприятия
			begin
				select @Pos = 0 --"получить" предприятие из подразделения подписанта
				select @Pos = charindex('/',@Department+'/',charindex('/',@Department+'/')+1)
				select @Result = @@error if @Result <> 0 goto Err
				if @Pos > 0	
				begin
					select @Department = substring(@Department,1,@Pos)
					select @Result = @@error if @Result <> 0 goto Err
				end 

				insert into @tmp1 (LocationPath, Dept)
				select ltrim(rtrim(isnull(ATT_Register,''))),ltrim(rtrim(Name)) 
				from dbo.Departments
				where ltrim(rtrim(Name)) like ltrim(rtrim(@Department)) + '%'
					and ltrim(rtrim(isnull(ATT_Register,''))) <> ''
				select @Result = @@error if @Result <> 0 goto Err
			end*/

			while exists (select 1 from @tmp1)
			begin
				select top 1
					@strres = LocationPath,
					@Department = Dept,
					@i = i
				from @tmp1
				select @Result = @@error if @Result <> 0 goto Err

				while @strres <> ''
				begin
					select @Pos = 0, @onevalue = '',-- @strres = space(1) + @strres
						@strres = case when @strres like char(13)+char(10) + '%' then substring(@strres,3,len(@strres)) else @strres end
					select @Result = @@error if @Result <> 0 goto Err
			
			        select @Pos = charindex(char(13)+char(10),@strres)
					select @Result = @@error if @Result <> 0 goto Err
			
			        If @Pos > 1
					begin
						select @onevalue = ltrim(rtrim(isnull(substring(@strres,1,@Pos),'')))
						select @Result = @@error if @Result <> 0 goto Err
					end
					else 
					begin
						select @onevalue = @strres
						select @Result = @@error if @Result <> 0 goto Err
					end
			
					if @onevalue<>''
					begin
						select @strres = ltrim(rtrim(replace(@strres,@onevalue,'')))
						select @Result = @@error if @Result <> 0 goto Err
					end		
				
					insert into @tmp (UName, Dept) values (@onevalue, @Department)
					select @Result = @@error if @Result <> 0 goto Err								
				end
				
				delete from @tmp1 where i = @i 
				select @Result = @@error if @Result <> 0 goto Err	
			end
		end
	end

	update @tmp
		set Uname = ltrim(rtrim(replace(replace(UName,char(13),''),char(10),'')))
	select @Result = @@error if @Result <> 0 goto Err

	--для красивого отбражения нам в конец нужно всегда подставлять пустую строку	
	delete from @tmp where Uname = ''
	select @Result = @@error if @Result <> 0 goto Err
	insert into @tmp (Uname, i1) values ('', 1)
	select @Result = @@error if @Result <> 0 goto Err
	insert into @tmp (Uname, i1) values ('', 1)
	select @Result = @@error if @Result <> 0 goto Err

	--select UName as  LP, min(i) as i from @tmp group by Uname order by 2
	select Uname, Dept from @tmp order by i1, Dept, i
	select @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:

	return @Result

GO
/****** Object:  StoredProcedure [dbo].[PDX_BankGuarantee_Change] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE proc [dbo].[PDX_BankGuarantee_Change]
	@DocID varchar(128),
	@DateBG datetime = null,
	@Bank varchar(512) = null,
	@Amount varchar(128) = null,
	@Text1 varchar(1024) = null,
	@Text2 varchar(1024) = null,
	@NC varchar(128) = null,
	@Act int, --1--ceate, 2-update,3 delete
	@Chk bit = 0
	
as
	declare  @Res int,
		@TransferGUID uniqueidentifier,
		@Amount_1 money

	declare @ErrList varchar(1024),
		/*@ParentID int,*/ @Cnt int

	select @Res = 0,@ErrList = ''

	select
		@DocID = ltrim(rtrim(isnull(@DocID,''))),
		@Bank = ltrim(rtrim(isnull(@Bank,''))),
		@Text1 = ltrim(rtrim(isnull(@Text1,''))),
		@Text2 = ltrim(rtrim(isnull(@Text2,''))),
		@Amount = ltrim(rtrim(replace(replace(isnull(@Amount,'0'),',','.'),SPACE(1),''))),
		@NC  = ltrim(rtrim(isnull(@NC,'')))
	select @Res = @@error if @Res <> 0 goto Err

/************************************
ПРОВЕРКИ ВВЕДЕННЫХ ЗНАЧЕНИЙ
*************************************/
	select
		@TransferGUID = TransferGUID
	from dbo.Docs
	where DocID = @DocID
	

If @Act = 2
BEGIN
	If @DocID = '' or @TransferGUID is null
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Системная ошибка! Некорректный ИД документа. Обратитесь к администратору СЭД.'
		goto NXT
	end
	
	if not exists(select 1 from dbo.Partners where Name = @Bank)
		begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Указанный в поле "Банк-Гарант" контрагент не существует'
		goto NXT
	end
	
	If @Text1 = ''
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Введите значение в поле "Обеспечение"'
		goto NXT
	end

	If len(@Text1) >= 1024 
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Превышена максимально допустимая длина поля "Обеспечение" (всего - ' + cast(len(@Text1) as varchar(100)) + ', макс. - 1024)'
		goto NXT
	end

	If len(@Text2) >= 1024 
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Превышена максимально допустимая длина поля "Прочие условия" (всего - ' + cast(len(@Text2) as varchar(100)) + ', макс. - 1024)'
		goto NXT
	end
	
	If @Amount = '' 
	begin
	  set @Amount_1 = 0
	  select @Res = @@error if @Res <> 0 goto Err
	end
	else
	begin
	  if ISNUMERIC(@Amount) = 1
	  begin
		set @Amount_1 = CAST(@Amount as money)
		select @Res = @@error if @Res <> 0 goto Err
	  end
	  else
	  begin
  		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'В поле "Комиссия" должно быть указано числовое значение'
		goto NXT
	  end 
	end
END
/************************************/

NXT:

If @Chk = 0
begin --если это создание , то нужно генерить ошибкуесли она есть
	If @ErrList <> '' 
	begin
		RAISERROR (@ErrList, 16,1)
		goto Err
	end
end
else --если это проверка просто выводим сообщение, даже если оно пустое
begin
	select @ErrList as ErrList 
	select @Res = @@error if @Res <> 0 goto Err
end

IF @ErrList = '' and @Chk = 0
BEGIN
	if @Act = 2
	begin
		update dbo.PDX_BankGuarantee
			set 
				DateBG = @DateBG,
				Bank = @Bank,
				Amount = @Amount_1,
				Text1 = @Text1,
				Text2 = @Text2,
				nlm = @NC,
				DLM = getdate()
		where TransferGUID = @TransferGUID
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 1 and not @TransferGUID is null
	begin
		insert into dbo.PDX_BankGuarantee
			(TransferGUID, DateBG, Bank, Amount, Text1, Text2, NLM, DLM)
		values 
			(@TransferGUID, @DateBG, @Bank, @Amount_1, @Text1, @Text2, @NC, getdate())
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 3 and not @TransferGUID is null
	begin
		delete from dbo.PDX_BankGuarantee where TransferGUID = @TransferGUID
	end
END
	select @Res = @@error if @Res <> 0 goto Err

OK:

	return @Res
Err:
	return @Res



GO
/****** Object:  StoredProcedure [dbo].[PDX_Calendar_Change] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_Calendar_Change]
--	@CID uniqueidentifier,
	@Date datetime,
	@HourFrom int,
	@MinFrom int,
	@HourTo int,
	@MinTo int,
	@isWD bit,
	@SetID uniqueidentifier,
	@NC varchar(128),
	@Act int, --1--ceate, 2-update,3 delete
	@Chk bit = 0
	
as
	declare  @Res int

	declare @UserID varchar(16),
			@ErrList varchar(1024),
			@Cls varchar(1024),
			@ErrorStr varchar(1024),
			@ClassGr varchar(128)

	select @Res = 0,@ErrList = ''
	


	select
		@HourFrom = isnull(@HourFrom,0),
		@MinFrom = isnull(@MinFrom,0),
		@HourTo = isnull(@HourTo,0),
		@MinTo = isnull(@MinTo,0),
		@Date = convert(datetime,convert(varchar(50),isnull(@Date,'1900-01-01'),104),104),
		@NC  = ltrim(rtrim(isnull(@NC,'')))
	select @Res = @@error if @Res <> 0 goto Err


/************************************
ПРОВЕРКИ ВВЕДЕННЫХ ЗНАЧЕНИЙ
*************************************/
If @Act = 3
begin
			select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
				'Удаление невозможно. Используйте флажок "Рабочий день"'
			goto NXT	
end
If @Act = 1
begin
			select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
				'Создание невозможно. Используйте флажок "Рабочий день"'
			goto NXT
end


If @isWD =0--сброс времени на выходной день
begin
	select @HourFrom = 0,
			@HourTo = 0,
			@MinFrom = 0,
			@MinTo = 0
	select @Res = @@error if @Res <> 0 goto Err
end

IF @Date >= convert(datetime,convert(varchar(50),getdate(),104),104)
BEGIN
	If @HourFrom > @HourTo or
		(@HourFrom = @HourTo and @isWD = 1 and @MinFrom >= @MinTo)
	begin
			select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
				'Время начала рабочего дня должно быть больше времени окончания'
			select @Res = @@error if @Res <> 0 goto Err
	end

	If exists (select 1 from dbo.PDXTimeTable where Date = @Date --and Calendar = @CID 
				and SetID <> isnull(@SetID,'00000000-0000-0000-0000-000000000000'))
	begin
			select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
				'Рабочий график на указанную дату уже сформирован'
			select @Res = @@error if @Res <> 0 goto Err		
	end
	
	/*IF not exists (select 1 from dbo.PDXCalendar where SetID = @CID)
	begin
			select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
				'Указанный календарь не существует'
			select @Res = @@error if @Res <> 0 goto Err		
	end*/

END
ELSE
BEGIN
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Нельзя исправить календарь за прошедший период.'
	select @Res = @@error if @Res <> 0 goto Err
END


/************************************/

NXT:

If @Chk = 0
begin --если это создание , то нужно генерить ошибкуесли она есть
	If @ErrList <> '' 
	begin
		RAISERROR (@ErrList, 16,1)
		goto Err
	end
end
else --если это проверка просто выводим сообщение, даже если оно пустое
begin
	select @ErrList as ErrList 
	select @Res = @@error if @Res <> 0 goto Err
end

IF @ErrList = '' and @Chk = 0
BEGIN
	if @Act = 2
	begin
		update dbo.PDXTimeTable
			set 
				--Calendar = @CID, 
				isWorkDay = @isWD,
				Date = @Date,
				HourFrom = @HourFrom, 
				MinFrom = @MinFrom, 
				HourTo = @HourTo, 
				MinTo = @MinTo, 
				NLM = @NC,
				DLM = getdate()
		where SetID = @SetID
		select @Res = @@error if @Res <> 0 goto Err
	end
END
	select @Res = @@error if @Res <> 0 goto Err

OK:

	return @Res
Err:
	return @Res
GO
/****** Object:  StoredProcedure [dbo].[PDX_ChangeActDoc] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_ChangeActDoc]
	@ID int,
	@ClassDoc varchar(1024),
	@CheckPartner bit,
	@NLM varchar(255)
	
as
declare 	
	@Mess varchar(1024), @ClassDoc1 varchar(1024), @Name varchar(128)
	set @ClassDoc1 = ''
	set @Mess = ''
	
	select
		@Name = Name
	from dbo.Activities
	where ID = @ID
	
	select @ClassDoc1 = @ClassDoc1 + case @ClassDoc1 when '' then '' else CHAR(13) + CHAR(10) end + Name
	from (
		select Name
		from dbo.DocTypes
		where char(13) + char(10) + @ClassDoc + char(13) + char(10) like '%' + char(13) + char(10) + Name + char(13) + char(10) + '%'
			or char(13) + char(10) + @ClassDoc + char(13) + char(10) like '%' + char(13) + char(10) + Name + ' ' + char(13) + char(10) + '%'
		union
		select
			Name
		from (
			select distinct left(Name, CHARINDEX('/', Name)) as Name
			from dbo.DocTypes
			where Name like '%/%') as X	
		where char(13) + char(10) + @ClassDoc + char(13) + char(10) like '%' + char(13) + char(10) + Name + char(13) + char(10) + '%'
			or char(13) + char(10) + @ClassDoc + char(13) + char(10) like '%' + char(13) + char(10) + Name + ' ' + char(13) + char(10) + '%'		
	) as Y order by Name
	
	update dbo.Activities
		set ClassDoc = @ClassDoc1,
		CheckPartner = @CheckPartner,
		NLM = @NLM,
		DLM = GETDATE()
	where ID = @ID

	select @Mess as Mess, @Name as Name
GO
/****** Object:  StoredProcedure [dbo].[PDX_ChangeAuthor] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_ChangeAuthor]
	@DocID varchar(128),
	@UserName varchar(128),
	@FieldName varchar(128),
	@OldValues varchar(255),
	@NewValue varchar(255),
	@ClassDoc varchar(255)
	
as
declare 
	@Res int,
	@Mess varchar(1024),
	@Resp int,
	@Code varchar(255),
	@stmp varchar(50)

	select @Res = 0
	select @Mess = '',
			@Resp = 0

	select @OldValues = ltrim(rtrim(isnull(@OldValues,'')))
	select @NewValue = ltrim(rtrim(isnull(@NewValue,'')))

	if @NewValue <> '' and not @NewValue like '%<%>%'
	begin	
		select @Mess = 'Изменение значения ' + @FieldName + ': Выбрано некорректное значение' 
		goto OK
	end
	
	if not exists (select 1 from dbo.Docs where DocID = @DocID and ClassDoc = @ClassDoc)--существует 
	begin	
		select @Mess = 'Изменение значения ' + @FieldName + ': Указанный документ не существует' 
		goto OK
	end

	if @NewValue = @OldValues
	begin
		select @Mess = 'Изменение значения ' + @FieldName + ': Указанное значение совпадает с текущим' 
		goto OK
	end

	if @NewValue <> '' and not exists (select 1 from dbo.Users where @NewValue like '%<' + UserID + '>%')
	begin
		select @Mess = 'Изменение значения ' + @FieldName + ': Указанный пользователь не существует' 
		goto OK
	end

	if @ClassDoc like 'Договоры /%'
	begin

		select @Code = 
			case when ActDoc like '%<>%' 
				then ltrim(rtrim(replace(ActDoc,'<>',''))) 
				else dbo.PDX_SubstringReturn(ActDoc,charindex('<',ActDoc),charindex('>',ActDoc)) 
			end
		from dbo.Docs where DocID = @DocID
		select @Res = @@error if @Res <> 0 goto Err

		if isnull(@Code,'') <> '' and not exists (select 1 from dbo.PDXBranchSettings where Fld1 = @Code)
		begin
			select @Code = left(@Code,2)
			select @Res = @@error if @Res <> 0 goto Err
		end
		select @Res = @@error if @Res <> 0 goto Err

		select @stmp = char(13)+char(10)
		if not exists (
	        select 1
			from dbo.PDXBranchSettings V with (nolock) where V.Fld9
				like '%' + case when @NewValue like '%<%>%' then '<' +
				 dbo.pdx_substringreturn(@NewValue,charindex('<',@NewValue),charindex('>',@NewValue)) 
				+ '>' else @NewValue end + '%'
				and @stmp+V.Fld9+@stmp like case @NewValue when '' then '%'+@stmp+@stmp+'%' else @stmp+V.Fld9+@stmp end
				and V.Fld1 = @Code)
		begin 
			select @Mess = 'Изменение значения ' + @FieldName + ': Указанное значение в справочнике не существует' 
			goto OK
		end
		select @Res = @@error if @Res <> 0 goto Err

	end

	update dbo.Docs
		set Author = @NewValue
	where DocID = @DocID
	select @Res = @@error if @Res <> 0 goto Err

	insert into dbo.Comments
		(UserID,
		UserName,
		ContactUserName,
		ContactUserID,
		PartnerName,
		DocID,
		DateCreation,
		DateEvent,
		DateEventEnd,
		Address,
		Subject,
		Comment,
		CommentType,
		SpecialInfo,
		FileName,
		--KeyField,
		PartnerID,
		Version,
		GUID,
		GUIDPartner,
		GUIDUser,
		GUIDDoc,
		Amount)
	values (
		dbo.PDX_SubstringReturn(@OldValues,charindex('<',@OldValues), charindex('>',@OldValues)),--UserID,
		replace(dbo.PDX_SubstringReturn('_'+@OldValues+'<',charindex('_','_'+@OldValues+'<'), charindex('<','_'+@OldValues+'<')),'"',''),-- UserName,
		null,--ContactUserName,
		null,--ContactUserID,
		null,--PartnerName,
		@DocID,--DocID,
		getdate(),--DateCreation,
		null,--DateEvent,
		null,--DateEventEnd,
		'',--Address,
		null,--Subject,
		'Изменение значения ' + @FieldName + ': ' + @NewValue + ' / ' + @UserName,--Comment,
		'VISA',--CommentType,
		'master',--SpecialInfo,
		null,--FileName,
		--KeyField,
		null,--PartnerID,
		null,--Version,
		NewID(),--GUID,
		null,--GUIDPartner,
		null,--GUIDUser,
		null,--GUIDDoc,
		null)--Amount)
	select @Res = @@error if @Res <> 0 goto Err

	select @Mess = 'Изменение значения ' + @FieldName + ': ' + @NewValue,
			@Resp = 1
	select @Res = @@error if @Res <> 0 goto Err

OK:

	select @Mess as 'res', @Resp as 'ires'
	return @Res
Err:
	select @Mess  as 'res', @Resp as 'ires'
	return @Res
GO
/****** Object:  StoredProcedure [dbo].[PDX_ChangePartnersInDGC] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_ChangePartnersInDGC]
	@DocID varchar(128),
	@UserName varchar(96),
	@UserID varchar(96),
	@Roles varchar(255)
	
as
declare 
	@Res int, @PN varchar(512), @UFT8 varchar(512), @DocIDInt int

	select @Res = 0
	
	set @Roles = ISNULL(@Roles,'')
	set @Roles = case @Roles when '' then '' else ' / ' end + @Roles

	select
		@PN = N.PN,
		@UFT8 = N.UFT8,
		@DocIDInt = D.DocIDInt
	from dbo.Docs D
	inner join dbo.DocsNSI N on D.DocIDInt = N.DocIDInt
	where D.DocID = @DocID

	update dbo.DocsNSI
		set PN = @UFT8,
		UFT8 = @PN
	where DocIDInt = @DocIDInt
	select @Res = @@error if @Res <> 0 goto Err

	insert into dbo.Comments
		(UserID,
		UserName,
		ContactUserName,
		ContactUserID,
		PartnerName,
		DocID,
		DateCreation,
		DateEvent,
		DateEventEnd,
		Address,
		Subject,
		Comment,
		CommentType,
		SpecialInfo,
		FileName,
		--KeyField,
		PartnerID,
		Version,
		GUID,
		GUIDPartner,
		GUIDUser,
		GUIDDoc,
		Amount)
	values (
		@UserID,
		@UserName,
		null,--ContactUserName,
		null,--ContactUserID,
		null,--PartnerName,
		@DocID,--DocID,
		getdate(),--DateCreation,
		null,--DateEvent,
		null,--DateEventEnd,
		'',--Address,
		null,--Subject,
		'Изменение контрагентов: ' + @UFT8 + ' - ' + @PN + @Roles,--Comment,
		'HISTORY',--CommentType,
		'master',--SpecialInfo,
		null,--FileName,
		--KeyField,
		null,--PartnerID,
		null,--Version,
		NewID(),--GUID,
		null,--GUIDPartner,
		null,--GUIDUser,
		null,--GUIDDoc,
		null)--Amount)
	select @Res = @@error if @Res <> 0 goto Err

OK:

	return @Res
Err:
	return @Res



GO
/****** Object:  StoredProcedure [dbo].[PDX_CheckField_VM] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE  proc [dbo].[PDX_CheckField_VM]
	@DocID varchar(250),
	@ClassDoc varchar(2000),
	--@FirstInRList varchar(1024) = '',
	--@LastInRList varchar(1024) = '',
	@Type int,
	@SQLStatement varchar(8000) = null out
as
	-- 0 - OnCre
	-- 1 - OnAct
	-- 2 - OnApr
	-- 3 - OnReg
	-- 4 - SAVE

	--declare @Result int
	--set @Result = 0

	declare @Field varchar(255),
		@RUSField varchar(255),
		@FieldType int,
		@ConstName varchar(1000),
		@FromRecL varchar(8000)
		
	create table #ResultTbl
		(Result varchar(8000))	
	--select @Result = @@error if @Result <> 0 goto Err
	/*if (exists (select 1 from dbo.Docs with (nolock) where DocID = @DocID
				and lower(isActive) <> 'y') and @Type in (0,1)) --это чтобы надеактивизацию не срабатывало
		or not @Type in (0,1)  
	begin*/
		select @SQLStatement = ''
		--select @Result = @@error if @Result <> 0 goto Err

	--ПРОВЕРКА НА ОБЯЗАТЕЛЬНОСТЬ ЗАПОЛНЕНИЯ
		--получаем список обязательных для заполнения полей в данном состоянии
		DECLARE ListOfField CURSOR FOR 
		SELECT case lower(FieldName)
				when lower('DocResult')
					then 'Result'
				when lower('Docrank')
					then 'Rank'
				else FieldName
			   end, FieldType,RUSName
		from dbo.PDXUserSettingDocTypes with (nolock)
		where case @Type 
				when 0 then OnCre
				when 1 then OnAct
				when 2 then OnApr
				when 3 then OnReg
			    else -1
			  end = 1
			and DocType = @ClassDoc
		order by OrderIndex
		--select @Result = @@error if @Result <> 0 goto Err
		
		OPEN ListOfField
		--select @Result = @@error if @Result <> 0 goto Err
		FETCH NEXT FROM ListOfField 
		INTO @Field, @FieldType,@RUSField
		--select @Result = @@error if @Result <> 0 goto Err
	
		--в цикле проверяем поля на "заполненность"
		WHILE @@FETCH_STATUS = 0
		begin
			select
				@SQLStatement = @SQLStatement +
			case len(@SQLStatement) when 0 then '' else '+' end + 
			--проверка поля на "заполненость"
			case
				when @FieldType = 0
					then 'case when [' + @Field + '] = 0'
				when @FieldType in (1,4) --текст, ссылка на документ
					then 'case when isnull(len(rtrim(ltrim(replace(replace([' + @Field + '],''<(#!)>'',''''),''(#!)'','''')))),0)=0'  
				when @FieldType = 2 --дата 
					then 'case when year([' + @Field + '])=1900 or [' + @Field + '] is null'
				when @FieldType = 3 -- сумма
					then 'case when [' + @Field + '] is null'
				when @FieldType = 5 --битовое поле (ntext)
					then 'case when DATALENGTH(['+ @Field + ']) = 0'
			end + 
			--сообщение об ошибке
			' then ''<font color=red>ОШИБКА! </font>Поле [' + @RUSField + '] не может быть пустым<BR>'' else '''' end'
			--select @Result = @@error if @Result <> 0 goto Err
	
			FETCH NEXT FROM ListOfField 
			INTO @Field, @FieldType,@RUSField
			--select @Result = @@error if @Result <> 0 goto Err
		end
		--select @Result = @@error if @Result <> 0 goto Err
	
		CLOSE ListOfField
	    DEALLOCATE ListOfField
	
--выполняем основные проверки
		if isnull(len(@SQLStatement),0) <> 0 
		begin
			--формируем окончательный запрос на проверку
			select @SQLStatement = 'select ' + @SQLStatement + --replace(@SQLStatement,'*',char(10) + char(13)) + 
				' from dbo.Docs D with (nolock) where DocID = ''' + @DocID + ''''
			--select @Result = @@error if @Result <> 0 goto Err
		
			--print @SQLStatement
			insert into #ResultTbl
				(Result)
			exec (@SQLStatement)
			--select @Result = @@error if @Result <> 0 goto Err
		end

		if @Type = 1  --пока у нас вообще работает только активация
		begin

			--проверки по ЛС
			/*exec @Result = dbo.PDX_ReconcilationListCheck
				@DocID = @DocID,
				@ClassDoc =@ClassDoc,
				@Type = @Type,
				@IsActive = null,
				@isDS = null, 
				@RList = null,
				@RLName = null,
				@FirstInRList = @FirstInRList,
				@LastInRList = @LastInRList,
				@ReturnSelect = 0,
				@FromRecL = @FromRecL out
			if @Result <> 0 goto Err
			exec @Result = dbo.PDX_ReconcilationListCheck
				@DocID = @DocID,
				@ClassDoc =@ClassDoc,
				@Type = @Type,
				@ActDoc = null,
				@IsActive = null,
				@RList = null,
				@RLName = null,
				@FirstInRList = @FirstInRList,
				@LastInRList = @LastInRList,
				@ReturnSelect = 0,
				@FromRecL = @FromRecL out
			if @Result <> 0 goto Err*/

			exec /*@Result =*/ dbo.PDX_ReconcilationListRules
				@DocID =@DocID,
				@Type =@Type,				
				@isActive = null, 
				@ClassDoc =@ClassDoc,
				@ActDoc= null,
				@NameAproval ='',
				@UFT2= null,
				@RList  = null,--ЛС
				@RLName = null, --наименование ЛС,
				@Parametr1 =null,
				@Parametr2 =null,
				@Parametr3 =null,
				@ReturnSelect  = 0,
				@FromRecL = @FromRecL out 
			--if @Result <> 0 goto Err


			insert into #ResultTbl
				(Result) 
			select @FromRecL
			--select @Result = @@error if @Result <> 0 goto Err
			
		end
	/*end*/
/*
	--еще избавимся от лишних записей "основная версия документ изменен"
	update dbo.Comments
		set Comment = replace(Comment,'Основная версия документа, файл заменен' + char(13) + char(10),'')
	where DocID = @DocID
		and CommentType = 'VISA'
		and Comment like '%Основная версия документа, файл заменен%'
		--and isnull(FileName,'') <> ''
	select @Result = @@error if @Result <> 0 goto Err
*/

	select @SQLStatement = ''
	select @SQLStatement = @SQLStatement + Result 
	from #ResultTbl
	--select @Result = @@error if @Result <> 0 goto Err
	select @SQLStatement
	--select @Result = @@error if @Result <> 0 goto Err

	drop table #ResultTbl
	--return --@Result
--Err:
	
	--drop table #ResultTbl
	--return --@Result





GO
/****** Object:  StoredProcedure [dbo].[PDX_CheckLTRByAccounter] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_CheckLTRByAccounter]
	@DocID varchar(128)
as

declare @LTRName varchar(256),
@PN1 varchar(1024), @PN2 varchar(1024), @BE varchar(1024),@PN3 varchar(1024),
@ClassDoc varchar(128), @ConstName varchar(128)

declare @tmp table (ACcounter varchar(128), Val varchar(1024), Typ tinyint)

	select 
		@ClassDoc = ClassDoc,
		@PN1 = UserFieldText8,
		@PN2 = PartnerName,
		@PN3 = UserFieldText6,
		@BE = UserFieldText8,
		@LTRName = UserFieldText1
	from dbo.Docs
	where DocID = @DocID

	select @ConstName = ConstName
	from dbo.PDXDocTypesConst				
	where DocType = @ClassDoc
	
	if exists (select top 1 1
				from dbo.UserDirValues V
				inner join [dbo].[PDX_AccounterUserList]() L on V.Field2 like '%<' + L.UserID + '>%'
				where V.UDKeyField in (34,219)
				and char(13) + char(10) + V.Field3 + char(13) + char(10) like '%' + char(13) + char(10) + @ClassDoc + char(13) + char(10) + '%'
				and V.Field1 = @LTRName)
	begin				
		If @ConstName = 'RIK_CategoryName_KAZ_ORDPAY'
		begin		
			insert into @tmp (ACcounter,Val, Typ)
			select 
				Accounter, @BE, 1
			from dbo.PDX_pay_Firms
			where Name = @BE
				and ISNULL(Accounter,'') like '%<%>%'
		end
		else If @ConstName in ('RIK_CategoryName_DOGOVORY_L',
								'RIK_CategoryName_DOGOVORY_H',
								'RIK_CategoryName_DOGOVORY_Z',
								'RIK_CategoryName_DOGOVORY_X',
								'RIK_CategoryName_DOGOVORY_F',
								'RIK_CategoryName_DOGOVORY_T',
								'RIK_CategoryName_DOGOVORY_B',
								'RIK_CategoryName_DOGOVORY_M',
								'RIK_CategoryName_DOGOVORY_P',
								'RIK_CategoryName_DOGOVORY_S',
								'RIK_CategoryName_DOGOVORY_C',
								'RIK_CategoryName_DOGOVORY_E',
								'RIK_CategoryName_DOGOVORY_Y')
		begin		
			insert into @tmp (ACcounter,Val, Typ)
			select 
				AccountingManagerName, Name, 2
			from dbo.Partners
			where Name in (@PN1,@PN2)
				and ISNULL(AccountingManagerName,'') like '%<%>%'
			union
			select 
				AccountingManagerName, Name, 2
			from dbo.Partners
			where char(13) + char(10) + @PN3 + CHAR(13) + CHAR(10) like '%' + CHAR(13) + CHAR(10) + Name + CHAR(13) + CHAR(10) + '%'
				and ISNULL(AccountingManagerName,'') like '%<%>%'
		end
	end
		
	select
		dbo.User_PaydoxLoginByParam(U.UserID, U.Name) as UserName, U.UserID, 2 as RLPos, T.Val, T.Typ
	from @tmp T
	inner join dbo.Users U on T.ACcounter like '%<' + U.UserID + '>%'
		and U.StatusActive in ('-','1')
		and U.DateExpirationSecurity >= GETDATE()
		and not Permitions like '%*%'



GO
/****** Object:  StoredProcedure [dbo].[PDX_CheckUsersInGroups] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_CheckUsersInGroups]
	--@DocID varchar(128),
	@UserList varchar(1024),
	@Correspondent varchar(1024),
	@OnlyGroups char(1) = 'N' --из всего @UserList-а нужны только группы
as
	declare @Result int
	set @Result = 0

	declare @Grname varchar(255),
			@CLS varchar(255),
			@FullCLS varchar(4096),
			@Cnt int
	create table #usertbl (UserID varchar(96), UserName varchar(96), Groups varchar(255), 
							isActive bit, AccessByGroup bit default 0, ClassDoc varchar(4096),
							UGroup varchar(255) default '', EmptyGroup int,
							DeputyID varchar(64), isDeputy bit default 0, OrigName varchar(96))
--EmptyGroup = 0 - у группы нет доступа
--EmptyGroup = 1 - в группе нет пользователей
	create table #GrList (GrName varchar(255))
	create table #CLS (UserID varchar(96), CLS varchar(255), FullCLS varchar(4096), Flg bit default 0)

	If upper(@OnlyGroups) <> 'Y'
	begin
		--получаем список пользователей с доступными им группами  и инф-ей об их "активности"
		insert into #usertbl
			(UserID, UserName, Groups, isActive, ClassDoc, DeputyID)
		select
			UserID, Name, UPPER(UserGroups), 
				case when StatusActive = '1' 
							and convert(datetime, convert(varchar(100),DateExpirationSecurity, 104), 104) >= convert(datetime, convert(varchar(100),getdate(), 104), 104)
					then 1
					else 0
				end, char(13)+char(10) + ltrim(rtrim(ClassDoc)) + char(13)+char(10),
			case when convert(datetime, convert( varchar(100), getdate(),104), 104) between
					convert(datetime, convert( varchar(100), isnull(DeputyDateFrom, getdate()),104), 104) and convert(datetime, convert( varchar(100), isnull(DeputyDateTo, getdate()),104), 104)
				then ltrim(rtrim(isnull(DeputyID,'')))
				else ''
			end
		from dbo.Users 
		where @UserList like '%<' + UserID + '>%'
			and ltrim(rtrim(isnull(UserID,''))) <> ''
		select @Result = @@error if @Result <> 0 goto Err
	end
	
/*************************************************************************/
	select @GrName = '', @UserList = UPPER(@UserList)
	select @Result = @@error if @Result <> 0 goto Err

	--получаем список групп, которые указаны в Рассылке
	If @UserList like '%#%#%'
	begin --получаем первую встречающуюся группу
		select @GrName = dbo.PDX_SubstringReturn(@UserList, charindex('#',@UserList), charindex('#',@UserList,charindex('#',@UserList)+1))
		select @Result = @@error if @Result <> 0 goto Err

		while @GrName <> ''--если группа найдена
		begin --сохранем ее в табл
			insert into #GrList (GrName) values ('#'+@GrName+'#')
			select @Result = @@error if @Result <> 0 goto Err
			--удаляем ее из общего списка
			select @UserList = replace(@UserList,'#'+@GrName+'#',''),
					@GrName = ''
			select @Result = @@error if @Result <> 0 goto Err
			--ищем след. группу
			If @UserList like '%#%#%'
			begin	
				select @GrName = dbo.PDX_SubstringReturn(@UserList, charindex('#',@UserList), charindex('#',@UserList,charindex('#',@UserList)+1))
				select @Result = @@error if @Result <> 0 goto Err
			end
			--если группа нашлась, но оказалось, что такая группа уже существует в табл
			--значит произошла какая-то непредвиденная ошибка и обработку нужно закончить
			if exists (select 1 from #GrList where GrName = '#'+@GrName+'#')
			begin
				select @GrName = ''
			end
			select @Result = @@error if @Result <> 0 goto Err
		end
	end

	--группы, которых не существует в рассылке
	insert into #usertbl
		(UGroup, Groups, isActive, ClassDoc, EmptyGroup)
	select
		GrName, '', 0, '', 0 --будем для них выводить сообщение, что доступа нет
	from #GrList
	where not @Correspondent like '%' + GrName + '%'
	select @Result = @@error if @Result <> 0 goto Err
	
	--группы "разбитые" на пользователей
	insert into #usertbl
		(UserID, UserName, Groups, isActive, ClassDoc, UGroup, AccessByGroup, DeputyID)
	select
		U.UserID, U.Name, '', 1, '', G.GrName, 1,
		case when convert(datetime, convert( varchar(100), getdate(),104), 104) between
				convert(datetime, convert( varchar(100), isnull(DeputyDateFrom, getdate()),104), 104) and convert(datetime, convert( varchar(100), isnull(DeputyDateTo, getdate()),104), 104)
			then ltrim(rtrim(isnull(DeputyID,'')))
			else ''
		end
	from #GrList G
	inner join dbo.Users U on U.UserGroups like  '%' + G.GrName + '%'
		and U.StatusActive = '1' 
		and convert(datetime, convert(varchar(100),DateExpirationSecurity, 104), 104) >= convert(datetime, convert(varchar(100),getdate(), 104), 104)
		and ltrim(rtrim(isnull(U.UserID,''))) <> ''
	where @Correspondent like '%' + G.GrName + '%'
	select @Result = @@error if @Result <> 0 goto Err

	--а еще группы по которым нет активных пользователей
	insert into #usertbl
		(UGroup, Groups, isActive, ClassDoc, EmptyGroup)
	select
		L.GrName, '', 0, '', 1 --будем для них выводить сообщение, что доступа нет
	from #GrList L
	where not exists (select 1 from #usertbl U where U.UGroup = L.GrName)
	select @Result = @@error if @Result <> 0 goto Err


/**************************************************************************/
    --все прямые адресаты найдены, теперь
	--заместителей (только активных) переносим в "основной список" с пометкой (чтобы на клиенте их доступ не проверять)
	insert into #usertbl	
		(UserID, UserName, Groups, isActive, ClassDoc, isDeputy, OrigName, 
		UGroup, AccessByGroup)--про группы наследуем от замещаемого
	select 
		U.DeputyID, X.Name, '', 1, char(13)+char(10) + ltrim(rtrim(U.ClassDoc)) + char(13)+char(10), 1, U.UserName,
		U.UGroup, U.AccessByGroup
	from #usertbl U
		inner join dbo.Users X on X.UserID = U.DeputyID
			and X.StatusActive = '1' 
			and convert(datetime, convert(varchar(100),X.DateExpirationSecurity, 104), 104) >= convert(datetime, convert(varchar(100),getdate(), 104), 104)
	where ltrim(rtrim(isnull(U.DeputyID,''))) <> ''
	select @Result = @@error if @Result <> 0 goto Err


/*************************************************************************/
	select @GrName = '', @Correspondent = UPPER(@Correspondent)
	select @Result = @@error if @Result <> 0 goto Err
	
	delete from #GrList
	select @Result = @@error if @Result <> 0 goto Err

	--получаем список групп, которые указаны в Рассылке
	If @Correspondent like '%#%#%'
	begin --получаем первую встречающуюся группу
		select @GrName = dbo.PDX_SubstringReturn(@Correspondent, charindex('#',@Correspondent), charindex('#',@Correspondent,charindex('#',@Correspondent)+1))
		select @Result = @@error if @Result <> 0 goto Err

		while @GrName <> ''--если группа найдена
		begin --сохранем ее в табл
			insert into #GrList (GrName) values ('#'+@GrName+'#')
			select @Result = @@error if @Result <> 0 goto Err
			--удаляем ее из общего списка
			select @Correspondent = replace(@Correspondent,'#'+@GrName+'#',''),
					@GrName = ''
			select @Result = @@error if @Result <> 0 goto Err
			--ищем след. группу
			If @Correspondent like '%#%#%'
			begin	
				select @GrName = dbo.PDX_SubstringReturn(@Correspondent, charindex('#',@Correspondent), charindex('#',@Correspondent,charindex('#',@Correspondent)+1))
				select @Result = @@error if @Result <> 0 goto Err
			end
			--если группа нашлась, но оказалось, что такая группа уже существует в табл
			--значит произошла какая-то непредвиденная ошибка и обработку нужно закончить
			if exists (select 1 from #GrList where GrName = '#'+@GrName+'#')
			begin
				select @GrName = ''
			end
			select @Result = @@error if @Result <> 0 goto Err
		end
	end
/**************************************************************************/

	--определяем имеет ли кто-то доступ через группы
	update U
		set AccessByGroup = 1
	from #usertbl U
	inner join #GrList L on U.Groups like '%' + L.GrName+ '%'
	where AccessByGroup = 0
	select @Result = @@error if @Result <> 0 goto Err
	
	--ищем еслть ли у отобранных активных пользователей "не раскрытые" категории
	insert into #CLS (CLS)
	select distinct X.CLS
	from #usertbl U
	inner join (
		select distinct
			left(Name, charindex('/',Name)) as CLS
		from dbo.DocTypes
		where Name like '%/%') X on U.ClassDoc like '%' + char(13)+char(10) + X.CLS + char(13)+char(10) + '%'
	where isActive = 1
		and ltrim(rtrim(isnull(ClassDoc,''))) <> ''
	select @Result = @@error if @Result <> 0 goto Err

	--на всякий случай проверяем на "пустоты"
	delete from #CLS where ltrim(rtrim(isnull(CLS,''))) = ''
	select @Result = @@error if @Result <> 0 goto Err

	--раскрываем найденные группы категорий
	while exists (select 1 from #CLS)
	begin
		select top 1
			@CLS = CLS,
			@FullCLS = char(13)+char(10)	
		from #CLS 
		select @Result = @@error if @Result <> 0 goto Err

		--собираем категории
		select @FullCLS = @FullCLS + Name + char(13)+char(10)
		from dbo.DocTypes 
		where Name like @CLS + '%'
		order by Name
		select @Result = @@error if @Result <> 0 goto Err

		--меняем группу на категорию у пользователя
		update #usertbl
			set ClassDoc = replace(ClassDoc,char(13)+char(10) + @CLS + char(13)+char(10), @FullCLS)
		where ClassDoc like  '%' + char(13)+char(10) + @CLS + char(13)+char(10) + '%'
			and isActive = 1
		select @Result = @@error if @Result <> 0 goto Err

		--удаляем обработанную группу
		delete from #CLS where CLS = @CLS
		select @Result = @@error if @Result <> 0 goto Err
	end
	select @Result = @@error if @Result <> 0 goto Err
	
	select @Cnt = count(*)
	from #usertbl
	where not UserID is null
	select @Result = @@error if @Result <> 0 goto Err

	select 
		X.UserID,
		X.Password,
		X.Name,
		X.Phone,
		X.PhoneCell,
		X.EMail,
		X.ICQ,
		X.Department,
		X.ActDoc,
		U.ClassDoc,
		X.CompanyDoc,
		X.PartnerName,
		X.Reporttypes,
		X.Position,
		X.IDentification,
		X.IDNo,
		X.IDIssuedBy,
		X.IDIssueDate,
		X.IDExpDate,
		X.BirthDate,
		X.PostAddress,
		X.CorporateIDNo,
		X.AddInfo,
		X.UserRole,
		X.PossibleRoles,
		X.ReadSecurityLevel,
		X.WriteSecurityLevel,
		X.ExtIntSecurityLevel,
		X.DateExpirationSecurity,
		X.StatusActive,
		X.DateCreation,
		X.NameCreation,
		X.DateLastModification,
		X.NameLastModification,
		X.Permitions,
		X.InOffice,
		X.ReasonOutOfOffice,
		X.Comment,
		X.KeyField,
		X.GUID,
		X.DeputyName,
		X.DeputyID,
		X.DeputyDateFrom,
		X.DeputyDateTo,
		X.ListUserRight,
		X.UserGroups,
		U.isActive,
		U.AccessByGroup,
		U.UGroup,
		@Cnt as Cnt,
		U.EmptyGroup,
		U.OrigName,
		U.isDeputy
	from #usertbl U
	left join dbo.Users X on X.UserID = U.UserID
	order by isnull(U.UGroup,''),isnull(U.OrigName,X.Name), X.Name
	select @Result = @@error if @Result <> 0 goto Err

	drop table #GrList
	drop table #usertbl
	drop table #CLS

	return @Result
Err:
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_CheckVisaAmount] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_CheckVisaAmount]
	@DocID varchar(128) 
as
	declare @UList varchar(4096)
	set @UList = ''
	
	;with X as (
		select L.LogEntryUserID as UserID, MAX(L.LogEntryID) as maxKF, D.AmountDoc, D.UserFieldMoney1
		from dbo.Docs D
		inner join dbo.PDXLogDocs L on L.DocIDInt = D.DocIDInt
			and d.ListReconciled like '%<' + L.LogEntryUserID + '>%'
		where D.DocID = @DocID
		group by L.LogEntryUserID, D.AmountDoc,D.UserFieldMoney1
	)
	select 
		@UList = @UList + case LEN(@UList) when 0 then '' else ',' end  +
		'"' + dbo.PDX_FIObyFullNameGet(U.Name) + '" <' + L.LogEntryUserID + '>;'
	from X
	inner join dbo.PDXLogDocs L on L.LogEntryID = X.maxKF
	inner join [dbo].[PDX_FinanceUserList]() F on F.UserID = L.LogEntryUserID
	inner join dbo.Users U on U.UserID = L.LogEntryUserID
	where X.AmountDoc <> L.AmountDoc or X.UserFieldMoney1 <> L.UserFieldMoney1

	if @UList <> ''
	begin
		select '<font color=red>ОШИБКА! </font>В связи с изменением Cуммы или НДС в документе верните карточку на пересогласование следующим сотрудникам: ' + @UList + '. Согласование отменяется по кнопке "Повторное согласование"'
	end
	else
	begin
		select ''
	end
/*
Для изменения суммы верните документ на пересогласование следующим сотрудникам: ...(указание фамилий тех финансистов, которые согласовали документ). Согласование отменяется по кнопке "Повторное согласование"
*/




GO
/****** Object:  StoredProcedure [dbo].[PDX_CheckVisaData] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_CheckVisaData]
	@DocID varchar(128) 
as
	declare @UList varchar(4096)
	set @UList = ''
	
	;with X as (
		select L.LogEntryUserID as UserID, MAX(L.LogEntryID) as maxKF, D.DateActivation
		from dbo.Docs D
		inner join dbo.PDXLogDocs L on L.DocIDInt = D.DocIDInt
			and d.ListReconciled like '%<' + L.LogEntryUserID + '>%'
		where D.DocID = @DocID
		group by L.LogEntryUserID, D.DateActivation
	)
	select 
		@UList = @UList + case LEN(@UList) when 0 then '' else ',' end  +
		'"' + dbo.PDX_FIObyFullNameGet(U.Name) + '" <' + L.LogEntryUserID + '>;'
	from X
	inner join dbo.PDXLogDocs L on L.LogEntryID = X.maxKF
	inner join (
			select UserID from [dbo].[PDX_LowUserList]() 
			union 
			select UserID from [dbo].[PDX_FinanceUserList]()
			) as F on F.UserID = L.LogEntryUserID
	inner join dbo.Users U on U.UserID = L.LogEntryUserID
	where X.DateActivation <> L.DateActivation 

	if @UList <> ''
	begin
		select '<font color=red>ОШИБКА! </font>В связи с изменением «Рег. даты» в документе верните карточку на пересогласование следующим сотрудникам: ' + @UList + '. Согласование отменяется по кнопке "Повторное согласование"'
	end
	else
	begin
		select ''
	end
/*
Для изменения суммы верните документ на пересогласование следующим сотрудникам: ...(указание фамилий тех финансистов, которые согласовали документ). Согласование отменяется по кнопке "Повторное согласование"
*/





GO
/****** Object:  StoredProcedure [dbo].[PDX_CommonReport] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_CommonReport]
as
	declare @Result int
	set @Result = 0
	
	declare
		@DocType varchar(255),
		@oi INT,
		@SQLStatement varchar(8000),
		@SelectList varchar(8000),
		@count int

	create table #Category
		(DocType varchar(255),
		OI int identity,
		isCk bit default 0)

	create table #ResTable 
		(FieldName varchar(255), 
		RUSName varchar(255), 
		OI int, 
		DocType varchar(255))

	insert into #ResTable
		(FieldName , 
		RUSName,
		OI,
		DocType)
	select
		FieldName , 
		RUSName,
		OrderIndex,
		DocType
	from dbo.PDXUserSettingDocTypes	
	select @Result = @@error if @Result <> 0 goto Err
	/******************/
	insert into #ResTable
		(FieldName , 
		RUSName,
		OI,
		DocType)
	select
		' LETTER', 
		Letter,
		null,
		DocType
	from dbo.PDXDocTypesConst
	select @Result = @@error if @Result <> 0 goto Err
	insert into #ResTable
		(FieldName , 
		RUSName,
		OI,
		DocType)
	select
		' NUMBERFORMAT', 
		NumberFormat,
		null,
		DocType
	from dbo.PDXDocTypesConst
	select @Result = @@error if @Result <> 0 goto Err
	insert into #ResTable
		(FieldName , 
		RUSName,
		OI,
		DocType)
	select
		' CHILDFORMAT', 
		ChildFormat,
		null,
		DocType
	from dbo.PDXDocTypesConst
	select @Result = @@error if @Result <> 0 goto Err
	insert into #ResTable
		(FieldName , 
		RUSName,
		OI,
		DocType)
	select
		' REGFORMAT', 
		RegFormat,
		null,
		DocType
	from dbo.PDXDocTypesConst
	select @Result = @@error if @Result <> 0 goto Err
/*****************/

	insert into #Category	
		(DocType)
	select distinct
		DocType
	from #ResTable
	order by DocType
	select @Result = @@error if @Result <> 0 goto Err

	select @SQLStatement = ''
	select @Result = @@error if @Result <> 0 goto Err
	while exists (select 1 from #Category where isCk = 0)
	begin
		select top 1
			@DocType = DocType,
			@OI = OI
		from #Category
		where isCk = 0
		order by OI
		select @Result = @@error if @Result <> 0 goto Err			
		
		--формируем строку, кот. расчитывает сумму по компании
		select @SQLStatement = @SQLStatement +
		case @SQLStatement when '' then '' else ', ' end + char(10) +
		'max(case C.OI when ' + cast(@OI as varchar(10)) + ' then P.RUSName else '''' end) as [' + replace(@DocType,'.','_') + '],' + 
		'max(case C.OI when ' + cast(@OI as varchar(10)) + ' then P.OI else null end) as [' + cast(@OI as varchar(10)) + ']'
		select @Result = @@error if @Result <> 0 goto Err

		update #Category set isCk = 1
		where DocType = @DocType
		select @Result = @@error if @Result <> 0 goto Err
	end
	select @Result = @@error if @Result <> 0 goto Err
	
	
	if @SQLStatement <> ''
	begin 
		--если вообще есть данные, то формируем запрос
		--из ранее полученных заготовок и исполняем его - получая результат
		select
			@SQLStatement = 
		'select *' + 
		' from (select P.FieldName, ' +
		@SQLStatement + ' from #ResTable as P inner join #Category C on C.DocType = P.DocType 
		group by P.FieldName) P1 ' +
		' order by P1.FieldName'
		select @Result = @@error if @Result <> 0 goto Err

		print @SQLStatement
		exec (@SQLStatement)
		select @Result = @@error if @Result <> 0 goto Err
	end

	drop table #Category
	select @Result = @@error if @Result <> 0 goto Err
	drop table #ResTable
	select @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_ContractByDate_Get] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[PDX_ContractByDate_Get] 
	@Date datetime
AS
BEGIN
	SET NOCOUNT ON;
	
    
create table #tbl (
	[DocID] varchar(128)
      ,[GUID] uniqueidentifier
      ,[DocIDadd]  varchar(128)
      ,[DocIDIncoming] varchar(128)
      ,[DocIDParent] varchar(128)
      ,[DocIDPrevious] varchar(128)
      ,[Author] varchar(1024)
      ,[Correspondent] varchar(4000)
      ,[Resolution] varchar(1024)
      ,[History] varchar(1024)
      ,[Result] varchar(1024)
      ,[PercentCompletion] int
      ,[Department] varchar(255)
      ,[Name] varchar(255)
      ,[Description] varchar(1024)
      ,[LocationURL] varchar(128)
      ,[LocationPaper] varchar(128)
      ,[FileNamePrefix] varchar(255)
      ,[FileName] varchar(255)
      ,[FileNameNameLastModif1ication] varchar(1024)
      ,[FileNameDateLastAccessed] datetime
      ,[FileNameDateLastModification] datetime
      ,[LocationPath] varchar(1024)
      ,[ExtInt] char(1)
      ,[PartnerName]varchar(128)
      ,[StatusDevelopment] char(1)
      ,[StatusPayment] char(2)
      ,[StatusArchiv] char(1)
      ,[StatusCompletion] char(1)
      ,[StatusDelivery] char(1)
      ,[TypeDoc] char(1)
      ,[ClassDoc] varchar(64)
      ,[ActDoc] varchar(64)
      ,[InventoryUnit] varchar(64)
      ,[PaymentMethod] varchar(64)
      ,[AmountDoc] money
      ,[QuantityDoc] real
      ,[DateActivation] datetime
      ,[SecurityLevel] tinyint
      ,[DateCreation] datetime
      ,[DateCompletion] datetime
      ,[DateCompleted] datetime
      ,[DateExpiration] datetime
      ,[NameCreation]  varchar(96)
      ,[NameAproval] varchar(96)
      ,[NameApproved] varchar(96)
      ,[DateApproved] datetime
      ,[ListToEdit] varchar(1024)
      ,[ListToReconcile] varchar(1024)
      ,[ListReconciled] varchar(1024)
      ,[NameResponsible] varchar(96)
      ,[NameControl] varchar(96)
      ,[NameLastModification] varchar(96)
      ,[DateLastModification] datetime
      ,[UserFieldText1] varchar(1024)
      ,[UserFieldText2] varchar(1024)
      ,[UserFieldText3] varchar(1024)
      ,[UserFieldText4] varchar(1024)
      ,[UserFieldText5] varchar(1024)
      ,[UserFieldText6] varchar(1024)
      ,[UserFieldText7] varchar(1024)
      ,[UserFieldText8] varchar(1024)
      ,[UserFieldMoney1] money
      ,[UserFieldMoney2] money
      ,[UserFieldDate1] datetime
      ,[UserFieldDate2] datetime
      ,[UserFieldDate3] datetime
      ,[UserFieldDate4] datetime
      ,[UserFieldDate5] datetime
      ,[UserFieldDate6] datetime
      ,[UserFieldDate7] datetime
      ,[UserFieldDate8] datetime
      ,[IsActive] varchar(1)
      ,[DateActive] datetime
      ,[BusinessProcessStep] varchar(255)
      ,[ExtPassword] varchar(48)
      ,[DateSigned] datetime
      ,[Currency] varchar(12)
      ,[CurrencyRate] money
      ,[Rank] varchar(64)
      ,[ListToView] varchar(4000)
      ,[Content] ntext
      ,[License] nvarchar(18)
      ,[TransferGUID] uniqueidentifier
      ,[DocIDInt] int
      ,CurrCode2 varchar(12)
	  ,NameApp varchar(128)
	  ,NameCr varchar(128)
	  ,NameResp varchar(128)
	  ,RegDate_first datetime
	  ,RegDate_last datetime
	  ,Reg_Count int
	  ,ID_UFT7 varchar(64)
	  ,ID_UFT2 int
	  ,CFO  varchar(10) 
	  ,isGP bit
	  ,GP decimal(5,2))
	  
	 
	 insert into #tbl
	  exec PayDoxOP.[dbo].[PDX_ContractByDate_GetFromDB] @Date = @Date 
	  
	  
	  select * from #tbl
	  drop table #tbl 
END










GO
/****** Object:  StoredProcedure [dbo].[PDX_ContractByDate_GetFromDB] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[PDX_ContractByDate_GetFromDB] 
	@Date datetime
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	declare @RegDate_first datetime,
			@RegDate_last datetime,
			@Reg_Count int,
			@ClassDoc varchar(128)
			
	select @ClassDoc = 'Договоры / %'
	
	;with dcs as (
	select 
		DocIDInt
	from dbo.Docs D
	where (D.DateLastModification >= @Date
		or D.DateActive >= @Date
		or D.DateApproved >= @Date)
		and D.ClassDoc like @ClassDoc
	union	
	select 
		D.DocIDInt
	from dbo. Comments C
	inner join dbo.Docs D on D.DocIDInt = C.DocIDInt
		and D.ClassDoc like @ClassDoc
	where C.CommentType = 'HISTORY'
		and C.DateCreation >= @Date
		)
		
	SELECT D.[DocID]
      ,D.[GUID]
      ,D.[DocIDadd]
      ,D.[DocIDIncoming]
      ,D.[DocIDParent]
      ,D.[DocIDPrevious]
      ,D.[Author]
      ,D.[Correspondent]
      ,D.[Resolution]
      ,D.[History]
      ,D.[Result]
      ,D.[PercentCompletion]
      ,D.[Department]
      ,D.[Name]
      ,D.[Description]
      ,D.[LocationURL]
      ,D.[LocationPaper]
      ,D.[FileNamePrefix]
      ,D.[FileName]
      ,D.[FileNameNameLastModification]
      ,D.[FileNameDateLastAccessed]
      ,D.[FileNameDateLastModification]
      ,D.[LocationPath]
      ,D.[ExtInt]
      ,D.[PartnerName]
      ,D.[StatusDevelopment]
      ,D.[StatusPayment]
      ,D.[StatusArchiv]
      ,D.[StatusCompletion]
      ,D.[StatusDelivery]
      ,D.[TypeDoc]
      ,D.[ClassDoc]
      ,D.[ActDoc]
      ,D.[InventoryUnit]
      ,D.[PaymentMethod]
      ,D.[AmountDoc]
      ,D.[QuantityDoc]
      ,D.[DateActivation]
      ,D.[SecurityLevel]
      ,D.[DateCreation]
      ,D.[DateCompletion]
      ,D.[DateCompleted]
      ,D.[DateExpiration]
      ,D.[NameCreation]
      ,D.[NameAproval]
      ,D.[NameApproved]
      ,D.[DateApproved]
      ,D.[ListToEdit]
      ,D.[ListToReconcile]
      ,D.[ListReconciled]
      ,D.[NameResponsible]
      ,D.[NameControl]
      ,D.[NameLastModification]
      ,D.[DateLastModification]
      ,D.[UserFieldText1]
      ,D.[UserFieldText2]
      ,D.[UserFieldText3]
      ,D.[UserFieldText4]
      ,D.[UserFieldText5]
      ,D.[UserFieldText6]
      ,D.[UserFieldText7]
      ,D.[UserFieldText8]
      ,D.[UserFieldMoney1]
      ,D.[UserFieldMoney2]
      ,D.[UserFieldDate1]
      ,D.[UserFieldDate2]
      ,D.[UserFieldDate3]
      ,D.[UserFieldDate4]
      ,D.[UserFieldDate5]
      ,D.[UserFieldDate6]
      ,D.[UserFieldDate7]
      ,D.[UserFieldDate8]
      ,D.[IsActive]
      ,D.[DateActive]
      ,D.[BusinessProcessStep]
      ,D.[ExtPassword]
      ,D.[DateSigned]
      ,D.[Currency]
      ,D.[CurrencyRate]
      ,D.[Rank]
      ,D.[ListToView]
      ,D.[Content]
      ,D.[License]
      ,D.[TransferGUID]
      ,D.DocIDInt
      ,isnull(Curr.Code2,'') as CurrCode2
	  ,isnull(NA.Name,'') as NameApp
	  ,isnull(NC.Name,'') as NameCr
	  ,isnull(NR.Name,'') as NameResp
	  ,@RegDate_first as RegDate_first
	  ,@RegDate_last as RegDate_last
	  ,@Reg_Count AS Reg_Count,
	  dbo.PDX_SubstringReturn(D.UserFieldText7,CHARINDEX('<',D.UserFieldText7),CHARINDEX('>',D.UserFieldText7)) as ID_UFT7,
	  V.IntKeyField as ID_UFT2,
	  [dbo].[PDX_fn_pay_CFOGET] (F.CFO) as CFO,
	  cast(case F.ExistGPPercent when '1' then 1 else 0 end as bit) as isGP,
	  F.GPPercent as GP
  FROM dcs 
  inner join [dbo].[Docs] as D on D.DocIDInt = dcs.DocIDInt
  left join dbo.CurrencyRates Curr on Curr.Code = D.Currency
  left join dbo.Users NA on NA.UserID = dbo.PDX_SubstringReturn(D.NameAproval, CHARINDEX('<',D.NameAproval), charindex('>',D.NameAproval))--D.NameAproval like '%<' + NA.UserID + '>%'
  left join dbo.Users NC on NC.UserID = dbo.PDX_SubstringReturn(D.NameCreation, CHARINDEX('<',D.NameCreation), charindex('>',D.NameCreation))--D.NameCreation like '%<' + NC.UserID + '>%'
  left join dbo.Users NR on NR.UserID = dbo.PDX_SubstringReturn(D.NameResponsible, CHARINDEX('<',D.NameResponsible), charindex('>',D.NameResponsible))--D.NameResponsible like '%<' + NR.UserID + '>%'  
  left join dbo.UserDirValues V on V.UDKeyField = 30 and V.Field1 = D.UserFieldText2
  left join dbo.[DocsCFO] F on F.DocIDInt = D.DocIDInt

END








GO
/****** Object:  StoredProcedure [dbo].[PDX_ContractEditors_Change] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_ContractEditors_Change]
	@ClassDoc varchar(128),
	@ActDoc varchar(64),
	@Users varchar(1024),
	@ID uniqueidentifier,
	@NC varchar(128),
	@Act int, --1--ceate, 2-update,3 delete
	@Chk bit = 0
	
as
	declare  @Res int

	declare @ErrList varchar(1024), @ClsGr varchar(128)

	select @Res = 0,@ErrList = ''
	


	select
		@ClassDoc = ltrim(rtrim(isnull(@ClassDoc,''))),
		@ActDoc = ltrim(rtrim(isnull(@ActDoc,''))),
		@Users = ltrim(rtrim(isnull(@Users,''))),
		@NC  = ltrim(rtrim(isnull(@NC,'')))
	select @Res = @@error if @Res <> 0 goto Err

    set @ClsGr = dbo.PDX_CLSGrGet(@ClassDoc)

/************************************
ПРОВЕРКИ ВВЕДЕННЫХ ЗНАЧЕНИЙ
*************************************/
If @ClassDoc = ''
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Укажите категорию или группу категорий'
	goto NXT
end

If @ActDoc = ''
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Укажите вид деятельности'
	goto NXT
end

If @Users = ''
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Укажите пользователей'
	goto NXT
end

/*
If exists (select 1 from dbo.PDXContractEditors where dbo.PDX_CLSGrGet(ClassDoc) = @ClsGr and ActDoc = @ActDoc
		and ID <> isnull(@ID,'{00000000-0000-0000-0000-000000000000}'))
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Список редакторов для данной категории или группы категорий по указанному виду деят-ти уже существует'
	select @Res = @@error if @Res <> 0 goto Err		
end
*/
/************************************/

NXT:

If @Chk = 0
begin --если это создание , то нужно генерить ошибкуесли она есть
	If @ErrList <> '' 
	begin
		RAISERROR (@ErrList, 16,1)
		goto Err
	end
end
else --если это проверка просто выводим сообщение, даже если оно пустое
begin
	select @ErrList as ErrList 
	select @Res = @@error if @Res <> 0 goto Err
end

IF @ErrList = '' and @Chk = 0
BEGIN
	if @Act = 2
	begin
		update dbo.PDXContractEditors
			set 
				ClassDoc = @ClassDoc,
				ActDoc = @ActDoc,
				Users = @Users,
				NLM = @NC,
				DLM = getdate()
		where ID = @ID
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 1
	begin
		insert into dbo.PDXContractEditors
			(ClassDoc, ActDoc, Users, NLM, DLM)
		values 
			(@ClassDoc, @ActDoc, @Users, @NC, getdate())
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 3
	begin
		delete from dbo.PDXContractEditors where ID = @ID
		select @Res = @@error if @Res <> 0 goto Err
	end
END
	select @Res = @@error if @Res <> 0 goto Err

OK:

	return @Res
Err:
	return @Res



GO
/****** Object:  StoredProcedure [dbo].[PDX_CopyCategory] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_CopyCategory]
	@DocType varchar(255),
	@NewDocType varchar(255)
as
	declare @Result int
	set @Result = 0
	declare @ErrorStr varchar(255)

	if exists (select 1 from dbo.PDXUserSettingDocTypes where DocType = @NewDocType)
	begin
		select @ErrorStr = '[' + @NewDocType + '] имеет свою структуру. Удалите ее сначала.'
		raiserror (@ErrorStr, 16,1)
		select @Result = @@error goto Err
	end
	select @Result = @@error if @Result <> 0 goto Err

	insert into dbo.PDXUserSettingDocTypes
		(DocType,
		FieldName,
		RUSName,
		FieldType,
		DirType,
		OrderIndex,	
		OnCre,
		OnAct,
		OnApr,
		OnReg,
		Descr,
		Remark)
	select	
		@NewDocType,
		FieldName,
		RUSName,
		FieldType,
		DirType,
		OrderIndex,	
		OnCre,
		OnAct,
		OnApr,
		OnReg,
		Descr,
		Remark
	from dbo.PDXUserSettingDocTypes
	where DocType = @DocType
	select @Result = @@error if @Result <> 0 goto Err

	update dbo.PDXDocTypesConst
		set Remark = (select Remark from dbo.PDXDocTypesConst where DocType = @DocType)
	where DocType = @NewDocType
	select @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_CopyPayBUDG] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

create proc [dbo].[PDX_CopyPayBUDG]
	@DocID varchar(128),
	@NewDocID varchar(128),
	@UserID varchar(96),
	@Roles varchar(255)
	
as
declare 
	 @DocIDInt int,@NewDocIDInt int, @NC varchar(128),
	@ClassDoc varchar(128), @NewClassDoc varchar(128)

	select @DocIDInt = DocIDINt,@ClassDoc = ClassDoc from dbo.Docs where DocID = @DocID
	select @NewDocIDInt = DocIDINt, @NewClassDoc = ClassDoc from dbo.Docs where DocID = @NewDocID
	
	If dbo.PDX_CLSConstGet(@ClassDoc) = 'RIK_CategoryName_KAZ_BUDG' and dbo.PDX_CLSConstGet(@NewClassDoc) = 'RIK_CategoryName_KAZ_BUDG' 
	begin
				
		set @Roles = ISNULL(@Roles,'')
		set @Roles = case @Roles when '' then '' else ' / ' end + @Roles

		select @NC = dbo.User_PaydoxLogin(@UserID) + @Roles
		
		if not exists (select 1 from dbo.[DocsPayBudget] where DocIDInt = @NewDocIDInt)
		begin
			insert into dbo.[DocsPayBudget]
				([Description], [Status], [KPP],[KBK],[OKTMO],[TaxPeriod], [Year],[Month],[Purpose],[VAT],[Amount], DocIDInt, NC, DC, NLM, DLM)
			select 
				[Description], [Status], [KPP],[KBK],[OKTMO],[TaxPeriod], [Year],[Month],[Purpose],[VAT],[Amount], @NewDocIDInt, @NC, GETDATE(), @NC, getdate()
			from 	dbo.[DocsPayBudget]
			where DocIDInt = @DocIDInt
		end
	end



GO
/****** Object:  StoredProcedure [dbo].[PDX_CorporateAgree] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_CorporateAgree]
	@DocID varchar(128),
	@UserID varchar(16),
	@UserName varchar(128)
	--@BP varchar(100)
as
	declare @Result int
	set @Result = 0
	declare @DateCom datetime,
			@Str varchar(1024),
			@Str1 varchar(1024),
			@BP varchar(16),
			@PMName varchar(64)
	
	declare @tmp table (BPName varchar(128), OI int identity)
	declare @cur table (BPName varchar(128), OI int identity)

	--узнаем требуется ли одобрение
	select @PMName = ''
	select @PMName = isnull(PaymentMethod,'')
	from dbo.Docs 
	where DocID = @DocID and ClassDoc like 'Договоры /%'
	select @Result = @@error if @Result <> 0 goto Err
	
	-- определяем схему одобрения
	select @BP = ''
	if @PMName <> '' 
	begin
		select @BP = ltrim(rtrim(isnull(Account,'')))
		from dbo.PayMethods
		where Name = @PMName
		select @Result = @@error if @Result <> 0 goto Err

		--если схема задана
		If @BP <> ''
		begin
			if @BP like '%I%' begin insert into @tmp(BPName) values ('Управляющий комитет по ИСБ') end 
			if @BP like '%U%' begin insert into @tmp(BPName) values ('Правление РГМ') end 
			if @BP like '%R%' begin insert into @tmp(BPName) values ('Комитет по вопросам исключительной компетенции (RMC)') end 
			if @BP like '%S%' begin insert into @tmp(BPName) values ('Совет директоров ОК РУСАЛ') end 
			if @BP like '%D%' begin insert into @tmp(BPName) values ('Независимые директора ОК РУСАЛ') end 
	
			--строка для коммента по новой схеме
			select @Str1 = ''
			select @Str1 = @Str1 + case len(@str1) when 0 then '' else ' - ' end + '[' + BPName + ']'
			from @tmp
			order by OI
			select @Result = @@error if @Result <> 0 goto Err
		end
	end

	--получаем список существующих BP	
	insert into @cur (BPName)
	select Subject
	from dbo.Comments
	where DocID = @DocID 
		and CommentType = 'BUSINESSPROCESS'
		and Version = 'BPSTEPNAME'
		and SpecialInfo = ''
	select @Result = @@error if @Result <> 0 goto Err

	--если есть отличия в существующей и заданной схемах, то удаляем "старье"
	if exists (select 1 from @tmp t full join @cur r on t.bpname = r.bpname where t.bpname is null or r.bpname is null)
	begin
		If @BP = '' --отмена одобрения
		begin
			select @Str = ''
			select @Str = @Str + case len(@str) when 0 then '' else ' * ' end + '[' + Subject + ' - ' + 
			case Version when 1 then 'ОДОБРЕНО' when 2 then 'ОТКЛОНЕНО' when 3 then 'ТРЕБУЕТ РАССМОТРЕНИЯ СД ОК РУСАЛ' else 'ошибка' end + ']'
			from dbo.Comments where CommentType = 'BUSINESSPROCESS'
				and SpecialInfo = 'BPOK'
				and DocID = @DocID
			order by DateCreation
			select @Result = @@error if @Result <> 0 goto Err
	
			select @Str = 'Отозвано одобрение сделки. Прошедшее одобрение: ' + @Str
			select @Result = @@error if @Result <> 0 goto Err			
			insert into dbo.Comments
				(UserID,
				UserName,
				ContactUserName,ContactUserID,PartnerName,
				DocID,
				DateCreation,
				DateEvent,DateEventEnd,Address,Subject,
				Comment,
				CommentType,
				SpecialInfo,FileName,PartnerID,Version,GUID,GUIDPartner,GUIDUser,GUIDDoc,Amount,FileNameOriginal)
			values
				('Admin',
				'System Admininstrator',
				null,null,'',
				@DocID,--DocID,
				getdate(),--DateCreation,
				null,null,'','',
				@Str,--Comment,
				'VISA',--CommentType,
				'',null,null,null,NewID(),null,null,null,null,null)
			select @Result = @@error if @Result <> 0 goto Err

		end
		else	--изменени/добавление схемы
		begin
			select @Str = ''
			select @Str = @Str + case len(@str) when 0 then '' else ' - ' end + '[' + BPName + ']'
			from @cur
			order by OI
			select @Result = @@error if @Result <> 0 goto Err
			
			If not exists (select 1 from @cur)
			begin --добавление
				select @Str = 'Инициировано одобрение сделки по схеме: ' + @Str1
				select @Result = @@error if @Result <> 0 goto Err	
			end
			else --изменение 
			begin
				select @Str = 'Изменение схемы одобрения. Было: ' + @Str + '. Стало: ' + @Str1
				select @Result = @@error if @Result <> 0 goto Err	
			end 
			select @Result = @@error if @Result <> 0 goto Err	
		end

		--удаление старого
		If exists (select 1 from @cur)
		begin
	 		delete C
			from dbo.Comments C 
			inner join @cur R on R.BPName = C.Subject
			where C.CommentType = 'BUSINESSPROCESS'
				and C.DocID = @DocID
			select @Result = @@error if @Result <> 0 goto Err
		end

		If @BP <> ''
		begin
			select @DateCom = getdate()
		
			insert into dbo.Comments
				(UserID,
				UserName,
				ContactUserName,
				ContactUserID,
				PartnerName,
				DocID,
				DateCreation,
				DateEvent,
				DateEventEnd,
				Address,
				Subject,
				Comment,
				CommentType,
				SpecialInfo,
				FileName,
				--KeyField,
				PartnerID,
				Version,
				GUID,
				GUIDPartner,
				GUIDUser,
				GUIDDoc,
				Amount,
				FileNameOriginal)
			select
				@UserID,
				@UserName,
				null,--ContactUserName
				null,--ContactUserID
				'',--!!!!PartnerName
				@DocID,
				dateadd(millisecond,10*OI, @DateCom),--DateCreation
				null,--DateEvent
				null,--DateEventEnd
				'',--Address
				BPName,--Subject
				'',--Comment
				'BUSINESSPROCESS',--CommentType
				'',--SpecialInfo
				null,--FileName
				--KeyField
				null,--PartnerID
				'BPSTEPNAME',--Version
				NewID(),--GUID
				null,--GUIDPartner
				null,--GUIDUser
				null,--GUIDDoc
				0,--Amount
				null--FileNameOriginal
			from @tmp
			select @Result = @@error if @Result <> 0 goto Err
				
			insert into dbo.Comments
				(UserID,
				UserName,
				ContactUserName,ContactUserID,PartnerName,
				DocID,
				DateCreation,
				DateEvent,DateEventEnd,Address,Subject,
				Comment,
				CommentType,
				SpecialInfo,FileName,PartnerID,Version,GUID,GUIDPartner,GUIDUser,GUIDDoc,Amount,FileNameOriginal)
			values
				('Admin',
				'System Admininstrator',
				null,null,'',
				@DocID,--DocID,
				getdate(),--DateCreation,
				null,null,'','',
				@Str,--Comment,
				'VISA',--CommentType,
				'',null,null,null,NewID(),null,null,null,null,null)
			select @Result = @@error if @Result <> 0 goto Err		
		end

	end
	
	return @Result
Err:
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_CorpSetting_Get] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[PDX_CorpSetting_Get]
	@Field varchar(255),
	@ClassDoc varchar(255),
	@ActDoc varchar(255)

as
	declare @strres varchar(4000),
		@Result int

	select @Result = 0

	--create table #tmp(UName varchar(255))
	select @strres = ''
	

	select @strres = 
	case 
		when @Field = 'DocNameAproval' and @ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_OTHERS_TMC') 
			then Fld12 
		when @Field = 'DocNameAproval' and @ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_OTHERS_TRP') 
			then Fld9 
		when @Field = 'DocNameAproval' and @ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_OTHERS_ZPR') 
			then Fld11
		when @Field = 'DocNameAproval' and @ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_OTHERS_MOB') 
			then Fld10 
		when @Field  = 'DocLocationPath' and @ClassDoc like dbo.PDX_CLSGrGet('RIK_CategoryName_DOGOVORY_B') + '%'
			then Fld8 
		when @Field  = 'DocNameAproval' and @ClassDoc like dbo.PDX_CLSGrGet('RIK_CategoryName_DOGOVORY_B') + '%'
			then Fld3
		when @Field  = 'DocLocationPath' and @ClassDoc like dbo.PDX_CLSGrGet('RIK_CategoryName_RASPDOC_PR') + '%'
			then Fld6 
	end 
	from dbo.PDXBranchSettings 
	where Fld1 = case when @ActDoc like '%<>%' 
					then ltrim(rtrim(replace(@ActDoc,'<>','')))  
					else dbo.PDX_SubstringReturn(@ActDoc, charindex('<',@ActDoc),charindex('>',@ActDoc)) 
	 			 end 
	select @Result = @@error if @Result <> 0 goto Err

    select @strres = ltrim(rtrim(isnull(@strres,'')))
	select @Result = @@error if @Result <> 0 goto Err

	if @strres = '' and not @ActDoc like '%<>%' 
	begin
		select @strres = 
		case @Field 
			when 'DocAuthor' 
				then Fld9 
			when 'DocLocationPath' 
				then Fld8 
			when 'DocNameAproval'
				then Fld3
		end
		from dbo.PDXBranchSettings 
		where Fld1 = left(dbo.PDX_SubstringReturn(@ActDoc, charindex('<',@ActDoc),charindex('>',@ActDoc)) ,2)
		select @Result = @@error if @Result <> 0 goto Err	
	end

	select @strres = ltrim(rtrim(isnull(@strres,'') ))
	select @Result = @@error if @Result <> 0 goto Err
	
	if @strres <> ''
	begin
		--select @strres = 'insert into #tmp(UName)values(''' + replace(@strres,char(13)+char(10),''') insert into #tmp(UName)values(''') + ''')'
		--select @strres = 'select ''' + replace(@strres,char(13)+char(10),''' as Fld, ''+'' as flg union  select ''') + ''' as Fld, ''+'' as flg  order by 1 desc'
		select @strres = 'select ''' + replace(@strres,char(13)+char(10),''' as Fld, ''+'' as flg union  select ''') + ''' as Fld, ''+'' as flg  order by 1'
		select @Result = @@error if @Result <> 0 goto Err
    end
	else
	begin
		select @strres = 'select '''' as Fld, ''+'' as flg'
	end

	print @strres
	exec(@strres)
	select @Result = @@error if @Result <> 0 goto Err

	/*select Uname as Fld from #tmp
	select @Result = @@error if @Result <> 0 goto Err*/

	return @Result
Err:
	--drop table #tmp

	return @Result




GO
/****** Object:  StoredProcedure [dbo].[PDX_CorrespLPGet] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_CorrespLPGet]
	@UserID varchar(128)=null,
	@Department varchar(512)=null,
	@Field varchar(255)

as
	declare @strres varchar(1024),
		@Result int,
		@onevalue varchar(1024),
		@Pos int,
		--@Department varchar(512),
		@i int

	select @Result = 0

	declare @tmp table (UName varchar(255), Dept varchar(512), i int identity, i1 int default 0)
	declare @tmp1 table (LocationPath varchar(255),Dept varchar(512), i int identity)

	select @strres = ''
	
	select @UserID = ltrim(rtrim(isnull(@UserID,''))),
			@Department = ltrim(rtrim(isnull(@Department,'')))

	if not (@UserID = '' and @Department = '')
	begin
		/*if @UserID like '%<%>%'	
		begin
			select @UserID = dbo.PDX_SubstringReturn(@UserID,charindex('<',@UserID),charindex('>',@UserID))
			select @Result = @@error if @Result <> 0 goto Err
		end*/
	
		If @Department = '' and @UserID <> ''
		begin
			select @Department = Department 
			from dbo.Users
			where UserID = @UserID
			select @Result = @@error if @Result <> 0 goto Err
		
			select @Department = ltrim(rtrim(isnull(@Department,'')))
			select @Result = @@error if @Result <> 0 goto Err
		end

		If @Department <> ''
		begin
			If @Field = 'DocLocationPath'
			begin --регистратор конкретного подразделения
				insert into @tmp1 (LocationPath, Dept)
				select top 1 ltrim(rtrim(isnull(LocationPath,''))), ltrim(rtrim(Name))
				from dbo.Departments
				where (ltrim(rtrim(@Department)) like ltrim(rtrim(Name)) + '%'
					or ltrim(rtrim(@Department))+'/' like ltrim(rtrim(Name)) + '%')
					and ltrim(rtrim(isnull(LocationPath,''))) <> ''
				order by Name desc
				select @Result = @@error if @Result <> 0 goto Err
			end
			else --все регистраторы Предприятия
			begin
				select @Pos = 0 --"получить" предприятие из подразделения подписанта
				select @Pos = charindex('/',@Department+'/',charindex('/',@Department+'/')+1)
				select @Result = @@error if @Result <> 0 goto Err
				if @Pos > 0	
				begin
					select @Department = substring(@Department,1,@Pos)
					select @Result = @@error if @Result <> 0 goto Err
				end 

				insert into @tmp1 (LocationPath, Dept)
				select ltrim(rtrim(isnull(LocationPath,''))),ltrim(rtrim(Name)) 
				from dbo.Departments
				where ltrim(rtrim(Name)) like ltrim(rtrim(@Department)) + '%'
					and ltrim(rtrim(isnull(LocationPath,''))) <> ''
				select @Result = @@error if @Result <> 0 goto Err
			end

			while exists (select 1 from @tmp1)
			begin
				select top 1
					@strres = LocationPath,
					@Department = Dept,
					@i = i
				from @tmp1
				select @Result = @@error if @Result <> 0 goto Err

				while @strres <> ''
				begin
					select @Pos = 0, @onevalue = '',-- @strres = space(1) + @strres
						@strres = case when @strres like char(13)+char(10) + '%' then substring(@strres,3,len(@strres)) else @strres end
					select @Result = @@error if @Result <> 0 goto Err
			
			        select @Pos = charindex(char(13)+char(10),@strres)
					select @Result = @@error if @Result <> 0 goto Err
			
			        If @Pos > 1
					begin
						select @onevalue = ltrim(rtrim(isnull(substring(@strres,1,@Pos),'')))
						select @Result = @@error if @Result <> 0 goto Err
					end
					else 
					begin
						select @onevalue = @strres
						select @Result = @@error if @Result <> 0 goto Err
					end
			
					if @onevalue<>''
					begin
						select @strres = ltrim(rtrim(replace(@strres,@onevalue,'')))
						select @Result = @@error if @Result <> 0 goto Err
					end		
				
					insert into @tmp (UName, Dept) values (@onevalue, @Department)
					select @Result = @@error if @Result <> 0 goto Err								
				end
				
				delete from @tmp1 where i = @i 
				select @Result = @@error if @Result <> 0 goto Err	
			end
		end
	end

	update @tmp
		set Uname = ltrim(rtrim(replace(replace(UName,char(13),''),char(10),'')))
	select @Result = @@error if @Result <> 0 goto Err

	--для красивого отбражения нам в конец нужно всегда подставлять пустую строку	
	delete from @tmp where Uname = ''
	select @Result = @@error if @Result <> 0 goto Err
	insert into @tmp (Uname, i1) values ('', 1)
	select @Result = @@error if @Result <> 0 goto Err
	insert into @tmp (Uname, i1) values ('', 1)
	select @Result = @@error if @Result <> 0 goto Err

	--select UName as  LP, min(i) as i from @tmp group by Uname order by 2
	select Uname, Dept from @tmp order by i1, Dept, i
	select @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:

	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_CorrespondentRules_Change] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_CorrespondentRules_Change]
	@ADoc varchar(256),
	@ClassDoc varchar(256),
	@Dept varchar(256),
	@GrName varchar(1024),
	@Users varchar(1024),
	@oDef int,
	@notSL4 int,
	@SetID uniqueidentifier,
	@NC varchar(128),
	@Act int, --1--ceate, 2-update,3 delete
	@Chk bit = 0
	
as
	declare  @Res int

	declare @ErrList varchar(1024),
			@ErrorStr varchar(1024)

	select @Res = 0,@ErrList = ''
	declare @tbl table (Val varchar(1024), Pos int, Flag bit, Val2 varchar(128))
	
	select
		@ADoc = ltrim(rtrim(isnull(@ADoc,''))),
		@ClassDoc = ltrim(rtrim(isnull(@ClassDoc,''))),
		@Dept = ltrim(rtrim(isnull(@Dept,''))),
		@GrName = ltrim(rtrim(isnull(@GrName,''))),
		@Users = ltrim(rtrim(isnull(@Users,''))),
		@oDef = case when ISNULL(@oDef,0)>1 then 1 else ISNULL(@oDef,0) end,
		@notSL4 = case when ISNULL(@notSL4,0)>1 then 1 else ISNULL(@notSL4,0) end
	select @Res = @@error if @Res <> 0 goto Err


/************************************
ПРОВЕРКИ ВВЕДЕННЫХ ЗНАЧЕНИЙ
*************************************/
If @Act in (1,2)
begin

	If @ADoc <> '' and not exists (select 1 from dbo.Activities where Name = @ADoc)
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Выбран не существующий вид дея-ти.'
		goto NXT
	end
	
	If @ClassDoc = '' or not exists (select 1 from dbo.DocTypes where Name like @ClassDoc + '%')
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Не указана категория или выбрана не существующая категория.'
		goto NXT
	end
	else
	begin
        If @ADoc = '' and isnull((select case when min(upper(bActDoc))=max(upper(bActDoc)) and min(upper(bActDoc)) = 'Y' then 1 else 0 end from dbo.DocTypes where Name like @ClassDoc + '%'),0) <> 0
		begin
			select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Для выбранной категории должен обязательно быть указан вид деятельности.'
			goto NXT
		end
		select @Res = @@error if @Res <> 0 goto Err
	end
	
	/*If @Dept <> '' and isnull((select case when min(upper(bDepartment))=max(upper(bDepartment)) and min(upper(bDepartment)) = 'Y' then 1 else 0 end from dbo.DocTypes where Name like @ClassDoc + '%'),0) = 0
	begin
      select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Для указанной категории не может быть задано подразделение.'
		goto NXT
	end
	else*/ If @Dept <> '' and not exists(select 1 from Departments where Name like @Dept+'%')
	begin
      select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Указано несуществующее подразделение.'
		goto NXT
	end
	
	/*If @GrName = '' or not exists(select 1 from dbo.UserGroups where Name = replace(replace(@GrName,'<#',''),'#>',''))
	begin
      select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Не указан группа пользователей или указана не существующая группа.'
		goto NXT
	end*/
	
	If @GrName = '' and @Users = ''
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Должна быть указана хотя бы одна группа или один пользователь.'
		goto NXT
	end
	
	if @GrName <> ''
	begin
		insert into @Tbl(Val,Pos,Flag)
		exec dbo.PDX_ArrayToTable
			@Separator1 ='<',
			@Separator2 ='>',
			@Value = @GrName
		select @Res = @@error if @Res <> 0 goto Err
		
		update T	
			set Pos = null
		from @tbl T
		left join dbo.UserGroups U on '#' + U.Name + '#' = T.Val
		where U.GUID is null
		select @Res = @@error if @Res <> 0 goto Err
		
		if exists (select 1 from @tbl where Pos is null)
		begin 
			select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Группа пользователей [' + Val + '] не существует.' 
			from @tbl where Pos is null
			select @Res = @@error if @Res <> 0 goto Err
			delete from @tbl where Pos is null
			select @Res = @@error if @Res <> 0 goto Err
			--goto NXT
		end
		
		select @GrName = ''
		select @GrName  = @GrName + case len(@GrName) when 0 then '' else CHAR(13)+CHAR(10) end + '<' + Val + '>' 
		from @tbl
		select @Res = @@error if @Res <> 0 goto Err
	end
	delete from @tbl
	select @Res = @@error if @Res <> 0 goto Err
	
	if @Users <> ''
	begin
		insert into @Tbl(Val,Pos,Flag)
		exec dbo.PDX_ArrayToTable
			@Separator1 ='<',
			@Separator2 ='>',
			@Value = @Users
		select @Res = @@error if @Res <> 0 goto Err
	
		update T	
			set Pos = case when U.UserID is null then null else Pos end,
			Val2 = U.Name
		from @tbl T
		left join dbo.Users U on U.UserID = T.Val
			and U.DateExpirationSecurity > convert(datetime, convert(varchar(100), GETDATE(), 104), 104)
			and U.StatusActive = '1'
			and not U.Permitions like '%*%'
		--where U.UserID is null
		select @Res = @@error if @Res <> 0 goto Err
		
		if exists (select 1 from @tbl where Pos is null)
		begin 
			select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Пользователь [' + Val + '] не существует.' 
			from @tbl where Pos is null
			select @Res = @@error if @Res <> 0 goto Err
			delete from @tbl where Pos is null
			select @Res = @@error if @Res <> 0 goto Err
			--goto NXT
		end
		select @Users = ''
		select @Users  = @Users + case len(@Users) when 0 then '' else CHAR(13)+CHAR(10) end + '"' + dbo.PDX_FIObyFullNameGet(Val2) + '" <' + Val + '>;' 
		from @tbl
		select @Res = @@error if @Res <> 0 goto Err
	end	
end

/************************************/

NXT:
	
If @Chk = 0
begin --если это создание , то нужно генерить ошибкуесли она есть
	If @ErrList <> '' 
	begin
		RAISERROR (@ErrList, 16,1)
		goto Err
	end
end
else --если это проверка просто выводим сообщение, даже если оно пустое
begin
	select @ErrList as ErrList 
	select @Res = @@error if @Res <> 0 goto Err
end

IF @ErrList = '' and @Chk = 0
BEGIN
	if @Act = 1
	begin
		insert into dbo.PDXCorrespondentRules
			(SetID,
			ActDoc,
			ClassDoc,
			Department,
			GroupsName,
			Users,			
			onlyDefault,
			notForSL4,			
			NC,
			DC,
			NLM,
			DLM)
		values
			(NEWID(),
			@ADoc,
			@ClassDoc,
			@Dept,
			ltrim(rtrim(@GrName)),
			ltrim(rtrim(@Users)),
			@oDef,
			@notSL4,
			@NC,
			getdate(),
			@NC,
			getdate())
		select @Res = @@error if @Res <> 0 goto Err

	end
	else
	if @Act = 2
	begin
		update dbo.PDXCorrespondentRules
			set 
				ActDoc = @ADoc,
				ClassDoc = @ClassDoc,
				Department= @Dept,
				GroupsName = ltrim(rtrim(@GrName)),	
				Users = ltrim(rtrim(@Users)),		
				onlyDefault = @oDef,
				notForSL4 = @notSL4,			
				NLM = @NC,
				DLM = getdate()
		where SetID = @SetID
		select @Res = @@error if @Res <> 0 goto Err
	end
	else
	If @Act = 3
	begin
		delete dbo.PDXCorrespondentRules 
		where SetID = @SetID	
		select @Res = @@error if @Res <> 0 goto Err
	end

END
	select @Res = @@error if @Res <> 0 goto Err

OK:

	return @Res
Err:
	return @Res
GO
/****** Object:  StoredProcedure [dbo].[PDX_CorrespondentRules_Get] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_CorrespondentRules_Get]
	@ADoc varchar(256),
	@ClassDoc varchar(256),
	@Dept varchar(256),
	@LTR varchar(1024) = ''
as
	declare  @Res int

	declare @ErrList varchar(1024),
			@ErrorStr varchar(1024)

	select @Res = 0,@ErrList = ''
	declare @tbl table (OI smallint, notForSL4 int, onlyDefault int, Position varchar(256))
	
	If @ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_ORDPAY')
	begin
		insert into @tbl
		exec [dbo] .[PDX_KAZForSend_Get]
		@LTR  = @LTR,
		@ClassDoc =@ClassDoc
		
	end
	
	select
		@ADoc = ltrim(rtrim(isnull(@ADoc,''))),
		@ClassDoc = ltrim(rtrim(isnull(@ClassDoc,''))),
		@Dept = ltrim(rtrim(isnull(@Dept,'')))
	select @Res = @@error if @Res <> 0 goto Err

	select 0,R.notForSL4, R.onlyDefault, '"' + dbo.PDX_FIObyFullNameGet(U.Name) + '" <' + U.UserID + '>;' as 'Position'
	from dbo.PDXCorrespondentRules R
	inner join dbo.Users U on R.Users like '%<' + U.UserID + '>%'
		and U.DateExpirationSecurity > CONVERT(datetime, convert(varchar(100), getdate(), 104), 104)
		and U.StatusActive = '1'
		and not U.Permitions like '%*%'
	where (R.ClassDoc = '' or @ClassDoc like R.ClassDoc + '%')
		and (R.ActDoc = '' or R.ActDoc = @ADoc)
		and (R.Department = '' or @Dept like R.Department + '%')
	union
	select 1,R.notForSL4, R.onlyDefault, '<#' + G.Name + '#>' as 'Position'
	from dbo.PDXCorrespondentRules R
	inner join dbo.UserGroups G on R.GroupsName like '%<#' + G.Name + '#>%'
	where (R.ClassDoc = '' or @ClassDoc like R.ClassDoc + '%')
		and (R.ActDoc = '' or R.ActDoc = @ADoc)
		and (R.Department = '' or @Dept like R.Department + '%')
	union 
	select OI, notForSL4, onlyDefault, Position from @tbl
	order by 1,4
	select @Res = @@error if @Res <> 0 goto Err
	

		
	select @Res = @@error if @Res <> 0 goto Err

OK:

	return @Res
Err:
	return @Res

GO
/****** Object:  StoredProcedure [dbo].[PDX_CovDocsBack] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[PDX_CovDocsBack]
--Возвращает документы выделенные в отдельное хранилище. Всё в двух базах.
as
	
declare @Result int, @cnt int
set @Result = 0

begin tran ttt

--возвращаем документы в первой базе
Exec [dbo].[PDX_DocsMoveIN]

OK:
commit tran ttt

	return @Result
ERR:
rollback tran ttt

	return @Result



GO
/****** Object:  StoredProcedure [dbo].[PDX_CovDocsRemove] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE proc [dbo].[PDX_CovDocsRemove]
--Собирает документы для переноса и запускает перенос. Всё в двух базах.
as
	
declare @Result int, @cnt int, @DT datetime
set @Result = 0
set @DT = GETDATE()

begin tran ttt


/* Задача 
1) категория договоров "типа U"
2) Рабочие согласования    ВСЕ
3) Платежи по документам категории U (Базовый лист согласования)
4) Все платежи по счетам типа С
*/

--чистим список ИДов, которые надо передать
delete from dbo.Docs_ForMove    

--спец.запросом заполняем таблицу ИДов, которые надо передать
insert into dbo.Docs_ForMove (DocID, DocIDInt, DateCreation)  
select D.docid,D.DocIDInt, @DT  from dbo.Docs D where
(--1) категория договоров "типа U"
D.ClassDoc='Прочие / Договоры')
Or
D.classdoc = 'Рабочее согласование' --2) Рабочие согласования    ВСЕ
Or
D.classdoc = 'Платежи(Н) / Заявка на начисление' -- 2018-01-28 Платежи(Н) / Заявка на начисление    ВСЕ
Or
(--3) Платежи по документам категории U 
--3а) Платежи по листу согласования содержащему слова Типа С
 --4) Все платежи по счетам типа С
D.Classdoc in ('Платежи / Заявка на оплату',
'Платежи / Корректирующая заявка',
'Платежи / Плановая заявка',
'Платежи(Н) / Заявка на оплату',
'Платежи(Н) / Корректирующая заявка',
'Платежи(Н) / Плановая заявка',
'Платежи(Н) / Платежи в бюджет')
and (
(Select ClassDoc from dbo.Docs X where X.DocID = D.DocIDParent) = 'Прочие / Договоры'--D.DocIDParent like '%U%'--3) Платежи по документам категории U 
OR exists (select top 1 1 from  dbo.PDX_pay_Accounts A where A.Name=D.Userfieldtext6 and A.Class=1)--4) Все платежи по счетам типа С
OR D.UserFieldText1 like '%Типа С%'--3а) Платежи по листу согласования содержащему слова Типа С
)
)

union
select D.docid,D.DocIDInt, @DT
from dbo.Docs D where
--*************************************************
--ОТБОР по ЦФО и БЕ
(
	D.ClassDoc in (
		'Платежи / Заявка на оплату',
		'Платежи / Плановая заявка',
		'Платежи(Н) / Заявка на оплату',
		'Платежи(Н) / Плановая заявка',
		'Платежи(Н) / Платежи в бюджет')
	and 
	(
		D.UserFieldText2 = 'Строительство' --ЦФО
	)
)
--*************************************************
--ОТБОР по исх/треб ЦФО и БЕ
OR
(
	D.ClassDoc in (
		'Платежи / Корректирующая заявка',
		'Платежи(Н) / Корректирующая заявка')
	and 
	(
		D.UserFieldText2 = 'Строительство' --ИСх ЦФО
		or D.UserFieldText3 = 'Строительство' --Треб ЦФО
	)
)
--*************************************************

union  /*2018-01-28 */
select D.docid,D.DocIDInt, @DT
from dbo.Docs D 
inner join dbo.DocsPLNTBL P on P.DocIDInt = D.DocIDInt
inner join dbo.PDX_pay_Accounts A on A.Name = P.Account and A.Class=1 --Плановый бюджет, где есть строки по счетам типа С
where D.ClassDoc = 'Платежи(Н) / Плановый бюджет'

--передаем документы и чисти таблицу передаваемых ИДОв
Exec [dbo].[PDX_DocsMoveOut]


OK:
commit tran ttt

	return @Result
ERR:
rollback tran ttt

	return @Result



GO
/****** Object:  StoredProcedure [dbo].[PDX_CreateDoc] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_CreateDoc]
	@DocID varchar(128) out,
	@Error varchar(4096) out,

	@DocIDadd varchar(128) = '',
	@DocIDIncoming varchar(128) = '',
	@DocIDParent varchar(128) = '', --родит. док-т
	@DocIDPrevious varchar(128) = '',
	@Author varchar(1024) = '',
	@Correspondent varchar(1024) = '',
	--@Resolution varchar(1024) = null,
	--@History varchar(1024) = '',
	--@Result varchar(1024) = '',
	--@PercentCompletion int = null,
	@Department varchar(128) = '', --подразделение 
	@Name  varchar(255) = '', --заголовок
	@Description varchar(1024) = '', --предмет
	--@LocationURL varchar(128) = null,
	--@LocationPaper varchar(128) = null,
	--@FileNamePrefix varchar(255) = '',
	--@FileName varchar(255) = '',
	--@FileNameNameLastModification varchar(1024) = '',
	--@FileNameDateLastAccessed datetime = getdate(),
	--@FileNameDateLastModification datetime = getdate(),
	@LocationPath varchar(1024) = '',
	--@ExtInt char(1) = '',
	@PartnerName  varchar(128) = '',
	@StatusDevelopment char(1) = 1, --на согласовании = 2
	@StatusPayment varchar(2) = '',
	--@StatusArchiv char(1) = '',
	@StatusCompletion char(1) = '',
	--@StatusDelivery char(1) = null,
	--@TypeDoc char(1) = '',
	@ClassDoc varchar(64) = '',
	@ActDoc varchar(64) = '',
	--@InventoryUnit varchar(64) = '',
	--@PaymentMethod  varchar(64) = '',
	@AmountDoc money = 0,
	@QuantityDoc real = 0,
	@DateActivation datetime = null,
	@SecurityLevel tinyint = 1, --общедоступный
	@DateCreation datetime = '1900-02-01 00:00:00.000',
	@DateCompletion datetime = '1900-02-01 00:00:00.000',
	@DateCompleted datetime = null,
	@DateExpiration datetime = '1900-02-01 00:00:00.000',
	@NameCreation varchar(96) = '' out,
	@NameAproval varchar(96) = '',
	@NameApproved varchar(96) = '',
	@DateApproved datetime = null,
	@ListToEdit varchar(1024) = '',
	@ListToReconcile varchar(1024) = '',
	@ListReconciled varchar(1024) = '',
	@NameResponsible  varchar(96) = '',
	@NameControl varchar(96) = '',
	--@NameLastModification varchar(96) = '',
	--@DateLastModification datetime = getdate(),
	@UserFieldText1 varchar(1024) = '',--Наименование листа согласования
	@UserFieldText2 varchar(1024) = '',--Вид договора
	@UserFieldText3 varchar(1024) = '',--Сторона 1
	@UserFieldText4 varchar(1024) = '',--Проект
	@UserFieldText5 varchar(1024) = '',--Подписывающий 2
	@UserFieldText6 varchar(1024) = '',--Дополнительные контрагенты -
	@UserFieldText7 varchar(1024) = '',--Коды Инвест.Мероприятий - 
	@UserFieldText8 varchar(1024) = '',--Контрагент 2
	@UserFieldMoney1 money = 0,--в т.ч. НДС
	@UserFieldMoney2 money = 0,
	@UserFieldDate1 datetime = '1900-02-01 00:00:00.000',
	@UserFieldDate2 datetime = '1900-02-01 00:00:00.000',
	@UserFieldDate3 datetime = '1900-02-01 00:00:00.000',
	@UserFieldDate4 datetime = '1900-02-01 00:00:00.000',
	@UserFieldDate5 datetime = '1900-02-01 00:00:00.000',
	@UserFieldDate6 datetime = '1900-02-01 00:00:00.000',
	@UserFieldDate7 datetime = '1900-02-01 00:00:00.000',
	@UserFieldDate8 datetime = '1900-02-01 00:00:00.000',
	@IsActive varchar(1) = 'N',
	@DateActive datetime = null,
	--@BusinessProcessStep varchar(255) = '',
	--@ExtPassword varchar(48) = '',
	@DateSigned datetime = null,
	@Currency varchar(12) = '',
	--@CurrencyRate money = null,
	@Rank varchar(64) = '',
	@ListToView varchar(1024) = '',
	@Content ntext = ''

	
as
declare 
	@Res int,
	@FileNamePrefix varchar(255),
	@FileName1 varchar(255),
	@FileNameNameLastModification varchar(1024),
	@FileNameDateLastAccessed datetime,
	@FileNameDateLastModification datetime,
	@InventoryUnit varchar(64),
	@BusinessProcessStep varchar(255),
	@CurrencyRate money,
	@LS varchar(1024),
	@UserName varchar(128),
	@F varchar(128),	
	@N varchar(128),
	@O varchar(128),
	
	@Resolution varchar(1024),
	@History varchar(1024),
	@Result varchar(1024),
	@PercentCompletion int,
	@LocationURL varchar(128),
	@LocationPaper varchar(128),
	@ExtInt char(1),
	@StatusArchiv char(1),
	@StatusDelivery char(1),
	@TypeDoc char(1),
	@PaymentMethod  varchar(64),
	@ExtPassword varchar(48),
	
	@ClsGr varchar(128),
	@LSName varchar(256)

select @Res = 0

select 
	@Resolution = null,
	@History  = '',
	@Result = '',
	@PercentCompletion = null,
	@LocationURL = null,
	@LocationPaper = null,
	@ExtInt = '',
	@StatusArchiv = '',
	@StatusDelivery = null,
	@TypeDoc = '',
	@StatusDelivery = null,
	@TypeDoc = '',
	@InventoryUnit = '',
	@PaymentMethod = '',
	@ExtPassword = ''
	
	declare @Dep varchar(255),
			@DocDate datetime,
			@OrderIndex varchar(50),
			@RealDocID varchar(128)

	select @RealDocID = ltrim(rtrim(isnull(@DocID,'')))
	select @Res = @@error if @Res <> 0 goto Err

	select @Error = ''
	select @Res = @@error if @Res <> 0 goto Err

	if not exists (select * from dbo.DocTypes where Name = @ClassDoc)
	begin
		select @Error = 'Указана недопустимая категория документа.'
		goto Err
	end
	
	select @ClsGr = case when @ClassDoc like '%/%' then LEFT(@ClassDoc, CHARINDEX('/', @ClassDoc)) else @ClassDoc end
	select @Res = @@error if @Res <> 0 goto Err

	if ISNULL(@ActDoc,'') = '' and not exists (select * from dbo.Activities where Name = @ActDoc 
		and (ltrim(rtrim(ClassDoc)) + CHAR(13) + CHAR(10) like '%' + @ClassDoc + CHAR(13) + CHAR(10) + '%' 
		or ltrim(rtrim(ClassDoc)) + CHAR(13) + CHAR(10) like '%' + @ClsGr + CHAR(13) + CHAR(10) + '%'))
		and (select top 1
				case when ActDoc like '%' +@ActDoc+'%' OR ActDoc like '%"ALL"%' 
					then 1 
					else 0 
				end from dbo.Users where @NameCreation like '%<' + UserID + '>%') = 1
	begin
		select @Error = 'Указан недопустимый Вид деят-ти.'
		goto Err
	end

	select @DocIDadd = ''
	select @Res = @@error if @Res <> 0 goto Err

-------------------------------------------------------------------------
	select @NameCreation = ltrim(rtrim(isnull(@NameCreation,'')))
	select @Res = @@error if @Res <> 0 goto Err
	select @NameCreation = case when @NameCreation like '%<%>%'
								then dbo.PDX_SubstringReturn(@NameCreation, CHARINDEX('<',@NameCreation), charindex('>',@NameCreation))
								else @NameCreation
							end
	select @Res = @@error if @Res <> 0 goto Err

	select @UserName = ''
	select @UserName = Name from dbo.Users where UserID = @NameCreation
		and StatusActive = '1'
		and convert(datetime, CONVERT(varchar(100), DateExpirationSecurity, 104), 104) >= convert(datetime, CONVERT(varchar(100), GETDATE(), 104), 104)
		and not Permitions like '%*%'
	select @Res = @@error if @Res <> 0 goto Err

	if @NameCreation = '' or ltrim(rtrim(isnull(@UserName,''))) = ''
	begin
		select @NameCreation = '"System Administrator" <Admin>;'
		select @Res = @@error if @Res <> 0 goto Err
	end
	else
	begin
		select @NameCreation = '"' + dbo.PDX_FIObyFullNameGet(@UserName) + '" <' + @NameCreation + '>;'
		select @Res = @@error if @Res <> 0 goto Err
	end
	select @Res = @@error if @Res <> 0 goto Err
	
	--параметры для рассчета номера
	
	If @ClassDoc like dbo.PDX_CLSGrGet('RIK_CategoryName_RASPDOC_PR') + '%'
	begin
		select @DocDate = getdate(),
			 @OrderIndex = '',
			 @Dep = '',
			 @StatusDevelopment = ISNULL(@StatusDevelopment,''),
			 @SecurityLevel = ISNULL(@SecurityLevel,'1')
		select @Res = @@error if @Res <> 0 goto Err
		
		--если ВД не указан - берем его из настроек пользователя
		if ISNULL(@ActDoc,'') = '' 
		begin
			select
				@ActDoc = left(ActDoc+CHAR(13)+CHAR(10),CHARINDEX(CHAR(13)+CHAR(10), ActDoc+CHAR(13)+CHAR(10))-1)
			from dbo.Users where @NameCreation like '%<' + UserID + '>%'
			select @Res = @@error if @Res <> 0 goto Err
		  
			if not exists (select * from dbo.Activities where Name = @ActDoc 
				and (ltrim(rtrim(ClassDoc)) + CHAR(13) + CHAR(10) like '%' + @ClassDoc + CHAR(13) + CHAR(10) + '%' 
				or ltrim(rtrim(ClassDoc)) + CHAR(13) + CHAR(10) like '%' + @ClsGr + CHAR(13) + CHAR(10) + '%'))
			begin
				set @ActDoc = ''
				select @Res = @@error if @Res <> 0 goto Err
			end	  
			select @Res = @@error if @Res <> 0 goto Err
		end
		
	end
	else
	begin
		select @Error = 'Указанная категория документов данной процедурой не обрабатывается.!'
		goto Err
	end
	
	exec @Res = dbo.PDX_NC_NumberCalculate
		@Activity = @ActDoc, --вид деят-ти
		@Department = @Dep, --подразделение 
		--!!!!подразделение М.Б. задано с ключевым словом "<BYUSER:>" - это значит, что подразделение определяется через переданного в этой переменной пользователя
		@ParentDocID = @DocIDParent, --номер родит. 
		@ClassDoc =@ClassDoc,--категория
	
		@DocDate = @DocDate,--дата
		@OrderIndex = @OrderIndex, --пользовательский счетчик/код  (задается через интерфейс) - может быть дополнен 0 до определенного кол-ва знаков
		@isReg = 0,	--признак расчета рег. номера
	
		@OldDocID = '',--старый номер документа (тот, который хотим изменить/проверить: при регистрации это введенный регистратором номер, иначе введенный пользователем номер)
		@RealDocID = @RealDocID,--тот номер под которым в данный момент находится документ в системе
		@StatusActive = @isActive,--статус активный
		@PreviousDocID = @DocIDPrevious, --для проверки предыдущей версии (новый номер д.б. = Prev + 1)? для этого значение должно быть указано в формате "<CHK:>номер док-та"
		@Error = @Error out , --сообщение об ошибке
		@DocID = @DocID out, --рассчитанный номер документа
		--параметры для формирования сообщений об ошибке
		@s_Activity = null,
		@s_Department = null,
		@s_OrderIndex  = null,
		@s_PreviousDocID = null,
		@s_ParentDocID  = null
	if @Res <> 0 goto Err

    if @DocIDadd = '' 
	begin
		select @DocIDadd = @DocID
		select @Res = @@error if @Res <> 0 goto Err
	end

	--произошла ошибка при расчете номера
	if isnull(@Error,'') <> '' 
	begin
		goto Err
	end

	if exists (select 1 from dbo.Docs where DocID = @DocID)
	begin
		select @Error = 'Документ с указанными параметрами в PayDox уже существует.'
		goto Err		
	end

	select @FileNamePrefix = cast(replace(cast(NEWID() as varchar(40)),'-','') as varchar(24))
	select @Res = @@error if @Res <> 0 goto Err

	select @FileName1 = ''
	select @Res = @@error if @Res <> 0 goto Err

	select @FileNameNameLastModification = ''
	select @Res = @@error if @Res <> 0 goto Err

	select @FileNameDateLastAccessed = null
	select @Res = @@error if @Res <> 0 goto Err

	select @FileNameDateLastAccessed = null
	select @Res = @@error if @Res <> 0 goto Err

	select @InventoryUnit = ''
	select @Res = @@error if @Res <> 0 goto Err

	select @BusinessProcessStep = ''
	select @Res = @@error if @Res <> 0 goto Err

	select @CurrencyRate = null
	select @Res = @@error if @Res <> 0 goto Err

	select @UserFieldText1 = ltrim(rtrim(isnull(@UserFieldText1,'')))
	select @Res = @@error if @Res <> 0 goto Err

	select @LS = null, @LSName = null
	select @LS = case 
					when Field4 like '%' + @ActDoc + '%'
						and Field3 like '%' + @ClassDoc + '%'
						then isnull(Field2 ,'')
					else '' end,
		@LSName = case 
					when Field4 like '%' + @ActDoc + '%'
						and Field3 like '%' + @ClassDoc + '%'
						then Field1
					else '' end
	from dbo.UserDirValues where UDKeyField =34 
		and Field1 = @UserFieldText1
	select @Res = @@error if @Res <> 0 goto Err

	If @LSName = ''--значит нашелся по названию, но не подходит по настройкам
	begin
		select @UserFieldText1 = '',
				@ListToReconcile = ''
		select @Res = @@error if @Res <> 0 goto Err
	end
	else
	begin
		select @ListToReconcile = ISNULL(@LS,'')
		select @Res = @@error if @Res <> 0 goto Err
	end

	--первого/последнего согласующего
	select 
		@ListToReconcile = case RLPos when 1 then UserName + CHAR(13) + CHAR(10) else '' end +
			@ListToReconcile + case RLPos when 0 then CHAR(13) + CHAR(10) + UserName else '' end				
	from dbo.PDXReconcilationRules
	where @ClassDoc like ClassDoc + '%'
		and ActDoc = @ActDoc
		and CONVERT(datetime, CONVERT(varchar(100), getdate(), 104), 104) between DateFrom and DateTo
		and not NotAppr like '%<' + dbo.PDX_SubstringReturn(@NameAproval, CHARINDEX('<', @NameAproval), CHARINDEX('>', @NameAproval)) + '>%'
		and RLPos in (0,1)
	select @Res = @@error if @Res <> 0 goto Err

-------------------------------------------------------------------------
	select @NameAproval = ltrim(rtrim(isnull(@NameAproval,'')))
	select @Res = @@error if @Res <> 0 goto Err

	select @NameAproval = case when @NameAproval like '%<%>%'
								then dbo.PDX_SubstringReturn(@NameAproval, CHARINDEX('<',@NameAproval), charindex('>',@NameAproval))
								else @NameAproval
							end
	select @Res = @@error if @Res <> 0 goto Err

	select @UserName = ''
	select @UserName = Name from dbo.Users where UserID = @NameAproval
		and StatusActive = '1'
		and convert(datetime, CONVERT(varchar(100), DateExpirationSecurity, 104), 104) >= convert(datetime, CONVERT(varchar(100), GETDATE(), 104), 104)
		and not Permitions like '%*%'
	select @Res = @@error if @Res <> 0 goto Err
	
	if @NameAproval = '' or ltrim(rtrim(isnull(@UserName,''))) = ''
	begin
		select @NameAproval = '"System Administrator" <Admin>;'
		select @Res = @@error if @Res <> 0 goto Err
	end
	else
	begin
		select @NameAproval = '"' + dbo.PDX_FIObyFullNameGet(@UserName) + '" <' + @NameAproval + '>;'
		select @Res = @@error if @Res <> 0 goto Err
	end
	select @Res = @@error if @Res <> 0 goto Err
-------------------------------------------------------------------------
	select @NameResponsible = ltrim(rtrim(isnull(@NameResponsible,'')))
	select @Res = @@error if @Res <> 0 goto Err

	select @NameResponsible = case when @NameResponsible like '%<%>%'
								then dbo.PDX_SubstringReturn(@NameResponsible, CHARINDEX('<',@NameResponsible), charindex('>',@NameResponsible))
								else @NameResponsible
							end
	select @Res = @@error if @Res <> 0 goto Err

	select @UserName = ''
	select @UserName = Name from dbo.Users where UserID = @NameResponsible
		and StatusActive = '1'
		and convert(datetime, CONVERT(varchar(100), DateExpirationSecurity, 104), 104) >= convert(datetime, CONVERT(varchar(100), GETDATE(), 104), 104)
		and not Permitions like '%*%'
	select @Res = @@error if @Res <> 0 goto Err

	if @NameResponsible = '' or ltrim(rtrim(isnull(@UserName,''))) = ''
	begin
		select @NameResponsible = '"System Administrator" <Admin>;'
		select @Res = @@error if @Res <> 0 goto Err
	end
	else
	begin
		select @NameResponsible = '"' + dbo.PDX_FIObyFullNameGet(@UserName) + '" <' + @NameResponsible + '>;'
		select @Res = @@error if @Res <> 0 goto Err
	end
	select @Res = @@error if @Res <> 0 goto Err
-------------------------------------------------------------------------

	If @ClassDoc like dbo.PDX_CLSGrGet('RIK_CategoryName_RASPDOC_PR')+'%'
	begin
		--и др. параметры, зависящие от категории
		select @LocationPath = Fld6
		from dbo.PDXBranchSettings
		where case 
				when @ActDoc like '%<>%' then ltrim(rtrim(LEFT(@ActDoc, CHARINDEX('<', @ActDoc))))
				else dbo.PDX_SubstringReturn (@ActDoc, charindex('<',@ActDoc), charindex('>',@ActDoc))
			  end = Fld1
		select @Res = @@error if @Res <> 0 goto Err
		
		if @Rank = ''
		begin
			select top 1 @Rank = Field1
			from dbo.UserDirValues 
			where UDKeyField = 46
				and @ClassDoc like Field3 + '%'
				and ISNUMERIC(Field2) = 1
			order by CAST(Field2 as int) desc
			select @Res = @@error if @Res <> 0 goto Err
		end
		
		select @ListToEdit = ISNULL(@ListToEdit,'')
		If not @ListToEdit like '%<' + dbo.PDX_SubstringReturn(@NameCreation, CHARINDEX('<',@NameCreation), CHARINDEX('>', @NameCreation)) + '>%'
		begin
			select @ListToEdit = @ListToEdit + case @ListToEdit when '' then '' else CHAR(13) + CHAR(10) end + @NameCreation
			select @Res = @@error if @Res <> 0 goto Err
		end
		select @Res = @@error if @Res <> 0 goto Err
		
		--первого согласующего
		select @UserName=''
		select top 1
			@UserName = UserName		
		from dbo.PDXReconcilationRules
		where @ClassDoc like ClassDoc + '%'
		and ActDoc = @ActDoc
		and CONVERT(datetime, CONVERT(varchar(100), getdate(), 104), 104) between DateFrom and DateTo
		and not NotAppr like '%<' + dbo.PDX_SubstringReturn(@NameAproval, CHARINDEX('<', @NameAproval), CHARINDEX('>', @NameAproval)) + '>%'
		and RLPos in (1)
		select @Res = @@error if @Res <> 0 goto Err
	
		If not @ListToEdit like '%<' + dbo.PDX_SubstringReturn(@UserName, CHARINDEX('<',@UserName), CHARINDEX('>', @UserName)) + '>%'
		begin
			select @ListToEdit = @ListToEdit + case @ListToEdit when '' then '' else CHAR(13) + CHAR(10) end + @UserName
			select @Res = @@error if @Res <> 0 goto Err
		end
		select @Res = @@error if @Res <> 0 goto Err

		select @DateActivation = CONVERT(datetime, convert(varchar(100), isnull(@DateActivation, GETDATE()), 104), 104),
			@UserFieldDate1 = CONVERT(datetime, convert(varchar(100), isnull(@UserFieldDate1, GETDATE()), 104), 104)
		select @Res = @@error if @Res <> 0 goto Err
		
		if @Department = '' or @Department = '<ByUser:>'
		begin
			select
				@Department = Department
			from dbo.Users
			where UserID = dbo.PDX_SubstringReturn(@NameCreation, charindex('<', @NameCreation), charindex('>', @NameCreation))
			select @Result = @@error if @Result <> 0 goto Err
		end
	end

	insert into dbo.Docs
		(DocID,
		GUID,
		DocIDadd,
		DocIDIncoming,
		DocIDParent,
		DocIDPrevious,
		Author,
		Correspondent,
		Resolution,
		History,
		Result,
		PercentCompletion,
		Department,
		Name,
		Description,
		LocationURL,
		LocationPaper,
		FileNamePrefix,
		FileName,
		FileNameNameLastModification,
		FileNameDateLastAccessed,
		FileNameDateLastModification,
		LocationPath,
		ExtInt,
		PartnerName,
		StatusDevelopment,
		StatusPayment,
		StatusArchiv,
		StatusCompletion,
		StatusDelivery,
		TypeDoc,
		ClassDoc,
		ActDoc,
		InventoryUnit,
		PaymentMethod,
		AmountDoc,
		QuantityDoc,
		DateActivation,
		SecurityLevel,
		DateCreation,
		DateCompletion,
		DateCompleted,
		DateExpiration,
		NameCreation,
		NameAproval,
		NameApproved,
		DateApproved,
		ListToEdit,
		ListToReconcile,
		ListReconciled,
		NameResponsible,
		NameControl,
		NameLastModification,
		DateLastModification,
		UserFieldText1,
		UserFieldText2,
		UserFieldText3,
		UserFieldText4,
		UserFieldText5,
		UserFieldText6,
		UserFieldText7,
		UserFieldText8,
		UserFieldMoney1,
		UserFieldMoney2,
		UserFieldDate1,
		UserFieldDate2,
		UserFieldDate3,
		UserFieldDate4,
		UserFieldDate5,
		UserFieldDate6,
		UserFieldDate7,
		UserFieldDate8,
		IsActive,
		DateActive,
		BusinessProcessStep,
		ExtPassword,
		DateSigned,
		Currency,
		CurrencyRate,
		Rank,
		ListToView,
		Content)
	values
		(
		@DocID,--DocID,
		NewID(),--GUID,
		@DocIDadd,--DocIDadd,
		@DocIDIncoming,--DocIDIncoming,
		@DocIDParent,--DocIDParent,
		@DocIDPrevious,--DocIDPrevious,
		@Author,--Author,
		@Correspondent,--Correspondent,
		@Resolution,--Resolution,
		@History,--History,
		@Result,--Result,
		@PercentCompletion,--PercentCompletion,
		@Department,--Department,
		@Name,--Name,
		@Description,--Description,
		@LocationURL,--LocationURL,
		@LocationPaper,--LocationPaper,
		@FileNamePrefix,--FileNamePrefix,
		@FileName1,--FileName,
		@FileNameNameLastModification,-- FileNameNameLastModification,
		@FileNameDateLastAccessed, --FileNameDateLastAccessed,
		@FileNameDateLastModification, --FileNameDateLastModification,
		@LocationPath, --LocationPath,
		@ExtInt,-- ExtInt,
		@PartnerName,-- PartnerName,
		@StatusDevelopment, -- StatusDevelopment,
		@StatusPayment,-- StatusPayment,
		@StatusArchiv,-- StatusArchiv,
		@StatusCompletion,-- StatusCompletion,
		@StatusDelivery,-- StatusDelivery,
		@TypeDoc,-- TypeDoc,
		@ClassDoc,-- ClassDoc,
		@ActDoc,-- ActDoc,
		@InventoryUnit,-- InventoryUnit,
		@PaymentMethod,-- PaymentMethod,
		@AmountDoc,-- AmountDoc,
		@QuantityDoc,-- QuantityDoc,
		@DateActivation,--DateActivation,
		@SecurityLevel,-- SecurityLevel,
		@DateCreation,-- DateCreation,
		@DateCompletion,-- DateCompletion,
		@DateCompleted,-- DateCompleted,
		@DateExpiration, --DateExpiration,
		@NameCreation, --NameCreation,
		@NameAproval, --NameAproval,
		@NameApproved, --NameApproved
		@DateApproved, --DateApproved
		@ListToEdit, -- ListToEdit
		@ListToReconcile, --ListToReconcile
		@ListReconciled, --ListReconciled
		@NameResponsible, -- NameResponsible
		@NameControl, -- NameControl
		@NameCreation, --NameLastModification,
		@DateCreation,--DateLastModification,
		@UserFieldText1, --UserFieldText1
		@UserFieldText2, -- UserFieldText2
		@UserFieldText3,  --UserFieldText3
		@UserFieldText4, --UserFieldText4
		@UserFieldText5, -- UserFieldText5
		@UserFieldText6, -- UserFieldText6
		@UserFieldText7, -- UserFieldText7
		@UserFieldText8, -- UserFieldText8
		@UserFieldMoney1, --UserFieldMoney1
		@UserFieldMoney2,--UserFieldMoney2
		@UserFieldDate1, --UserFieldDate1
		@UserFieldDate2, --UserFieldDate2
		@UserFieldDate3,--UserFieldDate3
		@UserFieldDate4, --UserFieldDate4
		@UserFieldDate5, --UserFieldDate5
		@UserFieldDate6, --UserFieldDate6
		@UserFieldDate7, --UserFieldDate7
		@UserFieldDate8, --UserFieldDate8
		@IsActive, -- IsActive
		@DateActive, --DateActive
		@BusinessProcessStep, --BusinessProcessStep
		@ExtPassword, -- ExtPassword
		@DateSigned, --DateSigned
		@Currency, --Currency
		@CurrencyRate, --CurrencyRate
		@Rank, --Rank
		@ListToView, --ListToView
		@Content -- Content
		)
	select @Res = @@error if @Res <> 0 goto Err

	insert into dbo.Comments
		(UserID,
		UserName,
		ContactUserName,
		ContactUserID,
		PartnerName,
		DocID,
		DateCreation,
		DateEvent,
		DateEventEnd,
		Address,
		Subject,
		Comment,
		CommentType,
		SpecialInfo,
		FileName,
		--KeyField,
		PartnerID,
		Version,
		GUID,
		GUIDPartner,
		GUIDUser,
		GUIDDoc,
		Amount)
	values (
		substring(@NameCreation,
					charindex('<',@NameCreation),
					charindex('>',@NameCreation)-charindex('<',@NameCreation)-1),--UserID,
		replace(substring(@NameCreation,1,charindex('<',@NameCreation)-1),'"',''),-- UserName,
		null,--ContactUserName,
		null,--ContactUserID,
		null,--PartnerName,
		@DocID,--DocID,
		getdate(),--DateCreation,
		null,--DateEvent,
		null,--DateEventEnd,
		'',--Address,
		null,--Subject,
		'Автоматическая загрузка карточки в систему',--Comment,
		'system',--CommentType,
		null,--SpecialInfo,
		null,--FileName,
		--KeyField,
		null,--PartnerID,
		null,--Version,
		null,--GUID,
		null,--GUIDPartner,
		null,--GUIDUser,
		null,--GUIDDoc,
		0)--Amount)
	select @Res = @@error if @Res <> 0 goto Err
	
OK:
	return @Res
Err:
	
	return @Res
GO
/****** Object:  StoredProcedure [dbo].[PDX_CreateRD] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_CreateRD]
	@DocID varchar(128) out,
	@Error varchar(4096) out,

	@DocIDPrevious varchar(128) = '',
	@Correspondent varchar(1024) = '',
	@Department varchar(128) = '', --подразделение 
	@Name  varchar(255) = '', --заголовок
	@Description varchar(1024) = '', --предмет
	@ClassDoc varchar(64) = '',
	@ActDoc varchar(64) = '',
	@NameCreation varchar(96) = '' out,
	@NameAproval varchar(96) = '',
	@ListToEdit varchar(1024) = '',
	@ListToReconcile varchar(1024) = '',
	@UserFieldText4 varchar(1024) = '',--Проект
	@UserFieldDate1 datetime = '1900-02-01 00:00:00.000',
	@Rank varchar(64) = '',
	@ListToView varchar(1024) = ''

	
as
declare 
	@Res int,
	@dt datetime
	
	select @dt = GETDATE()
	
	If not @ClassDoc like dbo.PDX_CLSGrGet('RIK_CategoryName_RASPDOC_PR')+'%'
	begin
		select @Error = 'Указанная категория документов данной процедурой не обрабатывается.!'
		goto Err
	end
	
	exec [dbo].[PDX_CreateDoc]
		@DocID				= @DocID out,
		@Error				= @Error out,

		@DocIDPrevious		= @DocIDPrevious,--предш. док-т
		@Correspondent		= @Correspondent,--список рассылки
		@Department			= @Department,--подразделение
		@Name				= @Name,--заголовок
		@Description		= @Description, --Приложения
		@StatusDevelopment  = '',  --статус разработки
		@ClassDoc			= @ClassDoc,
		@ActDoc				= @ActDoc,--Вид деятельности
		@DateActivation		= @dt,--Дата подписания
		@SecurityLevel		= 1, --Уровень доступа
		@DateCreation		= @dt, --дата создания
		@NameCreation		= @NameCreation out,--Автор
		@NameAproval		= @NameAproval,--Имя подписывающего
		@ListToEdit			= @ListToEdit,--Список имеющих право редактирования д-та
		@ListToReconcile	= @ListToReconcile,--Лист согласования
		@UserFieldText4		= @UserFieldText4,--Проект
		@UserFieldDate1		= @UserFieldDate1,--Дата ввода в действие
		--@IsActive			= 'N',
		@Rank				= @Rank,--Срочность
		@ListToView			= @ListToView--Список ознакомления
	select @Res = @@error if @Res <> 0 goto Err
	
OK:
	return @Res
Err:
	
	return @Res
GO
/****** Object:  StoredProcedure [dbo].[PDX_CreateSDProtocol] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_CreateSDProtocol]
	@DocID varchar(128),
	@NewDocID varchar(128),
	@NameCreation varchar(255),
	@Predsedatel varchar(255),
	@Secretar varchar(255),
	@ClassDocPr varchar(255),
	@ClassDocPv varchar(255),
	@ClassDocR varchar(255),
	@ClassDocV varchar(255)
	
as
declare 
	@Res int,
	@FileNamePrefix varchar(255),
	@FileName1 varchar(255),
	@FileNameNameLastModification varchar(1024),
	@FileNameDateLastAccessed datetime,
	@FileNameDateLastModification datetime,
	/*@InventoryUnit varchar(64),
	@BusinessProcessStep varchar(255),
	@CurrencyRate money,
	*/@Date datetime
	
	
select @Res = 0
	select @FileNamePrefix = cast(replace(cast(NEWID() as varchar(40)),'-','') as varchar(24))
	select @Res = @@error if @Res <> 0 goto Err

	select @FileName1 = ''
	select @Res = @@error if @Res <> 0 goto Err

	select @FileNameNameLastModification = ''
	select @Res = @@error if @Res <> 0 goto Err

	select @FileNameDateLastAccessed = null
	select @Res = @@error if @Res <> 0 goto Err

	select @FileNameDateLastAccessed = null
	select @Res = @@error if @Res <> 0 goto Err

	/*select @InventoryUnit = ''
	select @Res = @@error if @Res <> 0 goto Err

	select @BusinessProcessStep = ''
	select @Res = @@error if @Res <> 0 goto Err

	select @CurrencyRate = null
	select @Res = @@error if @Res <> 0 goto Err

	*/select @Date = '1900-02-01 00:00:00.000'
	select @Res = @@error if @Res <> 0 goto Err

	if exists (select 1 from dbo.Docs where DocID = @DocID and ClassDoc = @ClassDocPv)--существует повестка
	begin
		if not exists (select 1 from dbo.Docs where DocIDParent = @DocID
						and ClassDoc = @ClassDocPr)
		begin --протокол
			insert into dbo.Docs
				(DocID,
				GUID,
				DocIDadd,
				DocIDIncoming,
				DocIDParent,
				DocIDPrevious,
				Author,
				Correspondent,
				Resolution,
				History,
				Result,
				PercentCompletion,
				Department,
				Name,
				Description,
				LocationURL,
				LocationPaper,
				FileNamePrefix,
				FileName,
				FileNameNameLastModification,
				FileNameDateLastAccessed,
				FileNameDateLastModification,
				LocationPath,
				ExtInt,
				PartnerName,
				StatusDevelopment,
				StatusPayment,
				StatusArchiv,
				StatusCompletion,
				StatusDelivery,
				TypeDoc,
				ClassDoc,
				ActDoc,
				InventoryUnit,
				PaymentMethod,
				AmountDoc,
				QuantityDoc,
				DateActivation,
				SecurityLevel,
				DateCreation,
				DateCompletion,
				DateCompleted,
				DateExpiration,
				NameCreation,
				NameAproval,
				NameApproved,
				DateApproved,
				ListToEdit,
				ListToReconcile,
				ListReconciled,
				NameResponsible,
				NameControl,
				NameLastModification,
				DateLastModification,
				UserFieldText1,
				UserFieldText2,
				UserFieldText3,
				UserFieldText4,
				UserFieldText5,
				UserFieldText6,
				UserFieldText7,
				UserFieldText8,
				UserFieldMoney1,
				UserFieldMoney2,
				UserFieldDate1,
				UserFieldDate2,
				UserFieldDate3,
				UserFieldDate4,
				UserFieldDate5,
				UserFieldDate6,
				UserFieldDate7,
				UserFieldDate8,
				IsActive,
				DateActive,
				BusinessProcessStep,
				ExtPassword,
				DateSigned,
				Currency,
				CurrencyRate,
				Rank,
				ListToView,
				Content)
			select
				@NewDocID,--DocID,
				NewID(),--GUID,
				'',--DocIDAdd,--DocIDadd,
				'',--DocIDIncoming,--DocIDIncoming,
				@DocID,--DocIDParent,
				'',--DocIDPrevious,--DocIDPrevious,
				Author,--Author,
				Correspondent,--!!!!Correspondent,
				null,--Resolution,--Resolution,
				'',--,--History,--History,
				'',--Result,--Result,
				null,--PercentCompletion,--PercentCompletion,
				Department,--Department,
				'',--Name,--Name,
				Description,--!!!!!!!!!!!111Description,
				null,--LocationURL,--LocationURL,
				null,--LocationPaper,--LocationPaper,
				@FileNamePrefix,--FileNamePrefix,
				@FileName1,--FileName,
				@FileNameNameLastModification,-- FileNameNameLastModification,
				@FileNameDateLastAccessed, --FileNameDateLastAccessed,
				@FileNameDateLastModification, --FileNameDateLastModification,
				null,--LocationPath, --LocationPath,
				'',--ExtInt,-- ExtInt,
				'',--PartnerName,-- PartnerName,
				'1',--@StatusDevelopment, -- StatusDevelopment,
				'',--@StatusPayment,-- StatusPayment,
				'',--@StatusArchiv,-- StatusArchiv,
				'',--@StatusCompletion,-- StatusCompletion,
				null,--@StatusDelivery,-- StatusDelivery,
				'',--TypeDoc,-- TypeDoc,
				@ClassDocPr,--@ClassDoc,-- ClassDoc,
				'',--ActDoc,-- ActDoc,
				'',--InventoryUnit,-- InventoryUnit,
				'',--PaymentMethod,-- PaymentMethod,
				0,--AmountDoc,-- AmountDoc,
				0,--QuantityDoc,-- QuantityDoc,
				@Date,--DateActivation,--DateActivation,
				'4',--@SecurityLevel,-- SecurityLevel,
				getdate(),--@DateCreation,-- DateCreation,
				DateCompletion,-- DateCompletion,
				null,--@DateCompleted,-- DateCompleted,
				@Date,--DateExpiration, --DateExpiration,
				@NameCreation, --NameCreation,
				@Predsedatel,--@NameAproval, --NameAproval,
				null,--@NameApproved, --NameApproved
				null,--@DateApproved, --DateApproved
				'',--ListToEdit, -- ListToEdit
				'',--@ListToReconcile, --ListToReconcile
				'',--@ListReconciled, --ListReconciled
				'',--NameResponsible, -- NameResponsible
				NameControl, -- NameControl
				@NameCreation, --NameLastModification,
				getdate(),--DateLastModification,
				'',--@UserFieldText1, --UserFieldText1
				'',--@UserFieldText2, -- UserFieldText2
				'',--@UserFieldText3,  --UserFieldText3
				'',--@UserFieldText4, --UserFieldText4
				'',--@UserFieldText5, -- UserFieldText5
				'',--@UserFieldText6, -- UserFieldText6
				'',--@UserFieldText7, -- UserFieldText7
				'',--@UserFieldText8, -- UserFieldText8
				0,--@UserFieldMoney1, --UserFieldMoney1
				0,--@UserFieldMoney2,--UserFieldMoney2
				@Date,--@UserFieldDate1, --UserFieldDate1
				@Date,--@UserFieldDate2, --UserFieldDate2
				@Date,--@UserFieldDate3,--UserFieldDate3
				@Date,--@UserFieldDate4, --UserFieldDate4
				@Date,--@UserFieldDate5, --UserFieldDate5
				@Date,--@UserFieldDate6, --UserFieldDate6
				@Date,--@UserFieldDate7, --UserFieldDate7
				@Date,--@UserFieldDate8, --UserFieldDate8
				'Y',--@IsActive, -- IsActive
				null,--@DateActive, --DateActive
				'',--BusinessProcessStep, --BusinessProcessStep
				'',--@ExtPassword, -- ExtPassword
				null,--@DateSigned, --DateSigned
				'',--Currency, --Currency
				null,--CurrencyRate, --CurrencyRate
				'',--Rank, --Rank
				'',--ListToView, --ListToView
				''--Content -- Content
			from dbo.Docs 
			where DocID = @DocID
			select @Res = @@error if @Res <> 0 goto Err
		
			--решения
			insert into dbo.Docs
				(DocID,
				GUID,
				DocIDadd,
				DocIDIncoming,
				DocIDParent,
				DocIDPrevious,
				Author,
				Correspondent,
				Resolution,
				History,
				Result,
				PercentCompletion,
				Department,
				Name,
				Description,
				LocationURL,
				LocationPaper,
				FileNamePrefix,
				FileName,
				FileNameNameLastModification,
				FileNameDateLastAccessed,
				FileNameDateLastModification,
				LocationPath,
				ExtInt,
				PartnerName,
				StatusDevelopment,
				StatusPayment,
				StatusArchiv,
				StatusCompletion,
				StatusDelivery,
				TypeDoc,
				ClassDoc,
				ActDoc,
				InventoryUnit,
				PaymentMethod,
				AmountDoc,
				QuantityDoc,
				DateActivation,
				SecurityLevel,
				DateCreation,
				DateCompletion,
				DateCompleted,
				DateExpiration,
				NameCreation,
				NameAproval,
				NameApproved,
				DateApproved,
				ListToEdit,
				ListToReconcile,
				ListReconciled,
				NameResponsible,
				NameControl,
				NameLastModification,
				DateLastModification,
				UserFieldText1,
				UserFieldText2,
				UserFieldText3,
				UserFieldText4,
				UserFieldText5,
				UserFieldText6,
				UserFieldText7,
				UserFieldText8,
				UserFieldMoney1,
				UserFieldMoney2,
				UserFieldDate1,
				UserFieldDate2,
				UserFieldDate3,
				UserFieldDate4,
				UserFieldDate5,
				UserFieldDate6,
				UserFieldDate7,
				UserFieldDate8,
				IsActive,
				DateActive,
				BusinessProcessStep,
				ExtPassword,
				DateSigned,
				Currency,
				CurrencyRate,
				Rank,
				ListToView,
				Content)
			select
				@NewDocID + '-' + replicate('0',2-len(cast(QuantityDoc as varchar(100)))) + cast(QuantityDoc as varchar(100)),--DocID,
				NewID(),--GUID,
				'',--DocIDAdd,--DocIDadd,
				'',--DocIDIncoming,--DocIDIncoming,
				@NewDocID,--DocIDParent,
				DocID,--DocIDPrevious,--DocIDPrevious,
				Author,--!!!!!!!Author,
				Correspondent,--!!!!Correspondent,
				'',--Resolution,--Resolution,
				History,--History,
				null,--Result,--Result,
				null,--PercentCompletion,--PercentCompletion,
				'',--Department,
				'',--Name,
				Description,--!!!!!!!!!!!111Description,
				null,--,--LocationURL,
				null,--LocationPaper,--LocationPaper,
				@FileNamePrefix,--FileNamePrefix,
				@FileName1,--FileName,
				@FileNameNameLastModification,-- FileNameNameLastModification,
				@FileNameDateLastAccessed, --FileNameDateLastAccessed,
				@FileNameDateLastModification, --FileNameDateLastModification,
				null, --LocationPath,
				'',-- ExtInt,
				'',-- PartnerName,
				'1',--@StatusDevelopment, -- StatusDevelopment,
				'',--@StatusPayment,-- StatusPayment,
				'',--@StatusArchiv,-- StatusArchiv,
				'',--@StatusCompletion,-- StatusCompletion,
				null,--@StatusDelivery,-- StatusDelivery,
				TypeDoc,-- TypeDoc,
				@ClassDocR,--@ClassDoc,-- ClassDoc,
				'',-- ActDoc,
				'',--InventoryUnit,-- InventoryUnit,
				'',--PaymentMethod,-- PaymentMethod,
				0,--AmountDoc,-- AmountDoc,
				QuantityDoc,-- QuantityDoc,
				@Date,--DateActivation,--DateActivation,
				'1',--@SecurityLevel,-- SecurityLevel,
				getdate(),--@DateCreation,-- DateCreation,
				@Date,--DateCompletion,-- DateCompletion,
				null,--@DateCompleted,-- DateCompleted,
				@Date,--DateExpiration, --DateExpiration,
				@NameCreation, --NameCreation,
				'',--@NameAproval, --NameAproval,
				null,--@NameApproved, --NameApproved
				null,--@DateApproved, --DateApproved
				ListToEdit, -- ListToEdit
				'',--@ListToReconcile, --ListToReconcile
				'',--@ListReconciled, --ListReconciled
				'',--NameResponsible, -- NameResponsible
				@Secretar,--NameControl, -- NameControl
				@NameCreation, --NameLastModification,
				getdate(),--DateLastModification,
				UserFieldText2,--@UserFieldText1, --UserFieldText1
				'',--@UserFieldText2, -- UserFieldText2
				'',--@UserFieldText3,  --UserFieldText3
				'',--@UserFieldText4, --UserFieldText4
				'',--@UserFieldText5, -- UserFieldText5
				'',--@UserFieldText6, -- UserFieldText6
				'',--@UserFieldText7, -- UserFieldText7
				'',--@UserFieldText8, -- UserFieldText8
				0,--@UserFieldMoney1, --UserFieldMoney1
				0,--@UserFieldMoney2,--UserFieldMoney2
				@Date,--@UserFieldDate1, --UserFieldDate1
				@Date,--@UserFieldDate2, --UserFieldDate2
				@Date,--@UserFieldDate3,--UserFieldDate3
				@Date,--@UserFieldDate4, --UserFieldDate4
				@Date,--@UserFieldDate5, --UserFieldDate5
				@Date,--@UserFieldDate6, --UserFieldDate6
				@Date,--@UserFieldDate7, --UserFieldDate7
				@Date,--@UserFieldDate8, --UserFieldDate8
				'Y',--@IsActive, -- IsActive
				null,--@DateActive, --DateActive
				'',--BusinessProcessStep, --BusinessProcessStep
				'',--@ExtPassword, -- ExtPassword
				null,--@DateSigned, --DateSigned
				Currency, --Currency
				null,--CurrencyRate, --CurrencyRate
				'',--Rank, --Rank
				replace(ListToView,'>-;','>;'),--ListToView, --ListToView
				''--Content -- Content
			from dbo.Docs 
			where DocIDParent = @DocID
				and ClassDoc = @ClassDocV
			select @Res = @@error if @Res <> 0 goto Err
			
			select '' as res, '' as DocID
			select @Res = @@error if @Res <> 0 goto Err
		end
		else
		begin	
			select 
				'Протокол к этой повестке уже существует' as res,
				DocID
			from dbo.Docs where DocIDParent = @DocID
						and ClassDoc = @ClassDocPr
			select @Res = @@error if @Res <> 0 goto Err
		end
	end
	else
	begin	
		select 'Указанный документ не существует' as re
		select @Res = @@error if @Res <> 0 goto Err		
	end
	

	return @Res
Err:
	
	return @Res
GO
/****** Object:  StoredProcedure [dbo].[PDX_DeleteDocDetails] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[PDX_DeleteDocDetails]			
	@DocID varchar(128)
as

	delete C
	from dbo.PDXSHCode C
	inner join dbo.Docs D on D.DocIDInt = C.DocIDInt
	where D.DocID = @DocID
	
	
	delete C
	from dbo.DocsCFO C
	inner join dbo.Docs D on D.DocIDInt = C.DocIDInt
	where D.DocID = @DocID
	
	
	delete C
	from dbo.PayStatusDetails C
	inner join dbo.Docs D on D.DocIDInt = C.DocIDInt
	where D.DocID = @DocID

	delete C
	from dbo.PDXAccrual C
	inner join dbo.Docs D on D.DocIDInt = C.DocIDInt
	where D.DocID = @DocID

	delete C
	from dbo.PDXTrip C
	inner join dbo.Docs D on D.DocIDInt = C.DocIDInt
	where D.DocID = @DocID
	
	delete C
	from dbo.PDXZPR C
	inner join dbo.Docs D on D.DocIDInt = C.DocIDInt
	where D.DocID = @DocID


GO
/****** Object:  StoredProcedure [dbo].[PDX_DeptListBP] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_DeptListBP]

as

declare @Result int
select @Result = 0

declare @tmp table (Name varchar(512))

	--список подразделений
	insert into @tmp(Name)
	select 
		Name + case right(Name,1) when '/' then '' else '/' end as Name 
	from dbo.Departments where ltrim(rtrim(isnull(FullCode,'')))<>'' 
	
	--удаляем узлы для которых есть большая детализация... иначе дерево некорректно строится	
	delete y from @tmp y
	where exists(select 1 from @tmp x where x.name like y.name + '%' and len(x.name)>len(y.name))
	select @Result = @@error if @Result <> 0 goto Err

	select ltrim(rtrim(Name)) as name from @tmp order by 1
	select @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:
	
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_DeputyDel] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

/*drop  proc [dbo].[PDX_DeputyDel]
go*/

CREATE proc [dbo].[PDX_DeputyDel]
	@UserID varchar(128),
	@UserName varchar(128),
	@ForUserID varchar(128)
as

--declare @Result int
--select @Result = 0
	--select @Result = @@error if @Result <> 0 goto Err
	declare @DepUserID varchar(128), @DepName varchar(128)
	select
		@DepUserID = DeputyID,
		@DepName = DeputyName
	from dbo.Users
	where UserID = @ForUserID
	
	update dbo.Users
		set DeputyID = null,
		DeputyName = null,
		DeputyDateFrom = null,
		DeputyDateTo = null
	where UserID = @ForUserID
	
	insert into dbo.Comments
		(UserID,
		UserName,
		ContactUserName,
		ContactUserID,
		PartnerName,
		DocID,
		DateCreation,
		DateEvent,
		DateEventEnd,
		Address,
		Subject,
		Comment,
		CommentType,
		SpecialInfo,
		FileName,
		--KeyField,
		PartnerID,
		Version,
		GUID,
		GUIDPartner,
		GUIDUser,
		GUIDDoc,
		Amount,
		FileNameOriginal,
		RIK_CommentType)
	values
		(@UserID,--UserID,
		@UserName, --UserName,
		NULL,--ContactUserName,
		@ForUserID,--ContactUserID,
		NULL,--PartnerName,
		'',--DocID,
		getdate(),--DateCreation,
		NULL,--DateEvent,
		NULL,--DateEventEnd,
		NULL,--Address,
		NULL,--Subject,
		'Удалить информацию о заместителе: "' + @DepName + '" <' + @DepUserID + '>;',--Comment,
		'system',--CommentType,
		'',--SpecialInfo,
		NULL,--FileName,
		--KeyField,
		NULL,--PartnerID,
		NULL,--Version,
		newid(),--GUID,
		NULL,--GUIDPartner,
		NULL,--GUIDUser,
		NULL,--GUIDDoc,
		NULL,--Amount,
		NULL,--FileNameOriginal,
		NULL)--RIK_CommentType)

--	return @Result
--Err:
	
--	return @Result



GO
/****** Object:  StoredProcedure [dbo].[PDX_DG_ExtCheck] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE proc [dbo].[PDX_DG_ExtCheck]
	@DocID varchar(128),
	--@PN varchar(256) = null,
	@isContext bit = 0
	
as
declare 
	@Res int,
	@Mess varchar(1024), @ClassDoc varchar(128),
	@PhoneNo varchar(128), @ActDoc varchar(128), @CFO varchar(1024), @DocIDInt int,
	@EGP char(1), @GP decimal(5,2)
	
	select @Res = 0
	select @Mess = ''

	declare @Tbl table (Val varchar(64), Pos int, Flag bit)
	
	select
		@ClassDoc = ClassDoc,
		@ActDoc = ActDoc,
		@DocIDInt = DocIDInt/*,
		@PN = case @isContext 
				when 0 then PartnerName
				else @PN
			  end*/
	from dbo.Docs 
	where DocID = ltrim(rtrim(isnull(@DocID,'')))
	select @Res = @@error if @Res <> 0 goto Err

	select top 1
		@CFO = CFO,
		@EGP = ExistGPPercent,
		@GP = GPPercent
	from dbo.DocsCFO
	where DocIDInt = @DocIDInt
	
	set @CFO = ltrim(ISNULL(@CFO,''))
	set @EGP = case @EGP when '1' then '1' else '0' end
	set @GP = ISNULL(@GP,'0')
	
	If @ActDoc in ('1ГСК<31>',  
					'ИМС<56>',  
					 'Итан <55>',  
					 'КК <42>',  
					 'КСК<09>',  
					 'ОП <41>',  
					 'ОР <43>',  
					 'Порт Вера <52>',  
					 'Прочие<05>',  
					 'РА<11>',  
					 'РИ Энерджи<07>',  
					 'РИ<01>',  
					 'РИД <46>',  
					 'РК<06>',  
					 'РМК<12>',  
					 'РП<02>',  
					 'РС<03>',  
					 'РСС <45>',  
					 'РТ <44>',  
					 'РСт<53>',  
					 'РЭ<04>',  
					 'РЭС<57>',  
					 'СГС<54>',
					 'Сторонние<08>',
					 'СЭ<47>',
					 'Лидс<61>',
					 'Образ жизни<25>')
	begin
		if @CFO = ''
		begin
			select @Mess = @Mess + 
				'<br><font color=red>ОШИБКА! </font> Укажите ЦФО (раздел [Договоры. Дополнительная информация]).</font>' 
			select @Res = @@error if @Res <> 0 goto Err
		end
		else if not exists (select 1 from dbo.PDX_pay_CFO where Name = @CFO) 
		begin
			select @Mess = @Mess + 
				'<br><font color=red>ОШИБКА! </font> Значение [' + @CFO + '] в справочнике ЦФО не существует (раздел [Договоры. Дополнительная информация]).</font>' 
			select @Res = @@error if @Res <> 0 goto Err
		end
	end
	else
	begin
		if @CFO <> ''
		begin
			select @Mess = @Mess + 
				'<br><font color=red>ОШИБКА! </font> Очистите поле [ЦФО] (раздел [Договоры. Дополнительная информация]).</font>' 
			select @Res = @@error if @Res <> 0 goto Err
		end
	end

	If @ActDoc in ('РС<03>') AND @ClassDoc in (dbo.PDX_CLSGet('RIK_CategoryName_DOGOVORY_C'))
	begin
		if @EGP = '0'
		begin
			select @Mess = @Mess + 
				'<br><font color=red>ОШИБКА! </font> Укажите процент ген.подряда (раздел [Договоры. Дополнительная информация]).</font>' 
			select @Res = @@error if @Res <> 0 goto Err
		end
	end
	else
	begin
		if @EGP = '1' or @GP > 0
		begin
			select @Mess = @Mess + 
				'<br><font color=red>ОШИБКА! </font> Документ не должен содержать процент ген.подряда (раздел [Договоры. Дополнительная информация]).</font>' 
			select @Res = @@error if @Res <> 0 goto Err
		end
	end
 
/*
	
	if @ClassDoc like dbo.PDX_CLSGrGet('RIK_CategoryName_DOGOVORY_X') + '%'
		and ltrim(ISNULL(@PN,'')) <> ''
	begin
		select @PhoneNo = rtrim(ltrim(isnull(SalesManagerPhoneNo,'')))
		from dbo.Partners
		where Name = @PN
		select @Res = @@error if @Res <> 0 goto Err
		
		if not @PhoneNo is null
		begin
			select @Mess = @Mess + 
				'<br><font color=red>ОШИБКА! </font> У контрагента [' + @PN + '] не указан телефон фин.службы. Предоставьте администратору СЭД информацию для внесения в справочник контрагентов.</font>' 
			select @Res = @@error if @Res <> 0 goto Err
		end
	end
	*/
	select @Mess = @Mess + case len(@Mess) when 0 then '' else '<br>' end
    select @Res = @@error if @Res <> 0 goto Err

OK:

	select @Mess as 'res'
	return @Res
Err:
	select @Mess  as 'res'
	return @Res















GO
/****** Object:  StoredProcedure [dbo].[PDX_DGNSI_ExtCheck] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_DGNSI_ExtCheck]
	@DocID varchar(128),
	@UFT6 varchar(1024) = null,
	@Descr varchar(1024) = null,
	@DocIDParent varchar(128) = null,
	@isContext bit = 0
	
as
declare 
	@Res int,
	@Mess varchar(1024), @ClassDoc varchar(128),
	
	@PN varchar(128), @UFT8 varchar(128), @UFT2 varchar(1024), @DocIDInt int,
	@Currency varchar(12), @Percent money
	
	select @Res = 0
	select @Mess = ''

	declare @Tbl table (Val varchar(64), Pos int, Flag bit)
	
	select
		@ClassDoc = D.ClassDoc,
		@UFT6 = case @isContext 
				 when 0 then UserFieldText6
				else @UFT6
				end,
		@Descr =  case @isContext 
				    when 0 then Description
					else @Descr
					end,
		@DocIDParent = case @isContext 
				       when 0 then D.DocIDParent
					   else @DocIDParent
					   end,
		@DocIDInt = D.DocIDInt,
		@PN = N.PN,
		@UFT2 = N.UFT2,
		@UFT8 = N.UFT8,
		@Currency = N.Currency,
		@Percent = N.[Percent]
	from dbo.Docs D
	left join dbo.DocsNSI N on D.DocIDInt = N.DocIDInt
	where D.DocID = ltrim(rtrim(isnull(@DocID,'')))
	
    set @PN = ltrim(rtrim(ISNULL(@PN,'')))
    set @UFT2 = ltrim(rtrim(ISNULL(@UFT2,'')))
    set @UFT8 = ltrim(rtrim(ISNULL(@UFT8,'')))
    set @Currency = ltrim(rtrim(ISNULL(@Currency,'')))
    set @Percent = ISNULL(@Percent,0)

	select @Descr = ISNULL(@Descr,''),
		@UFT6 = ISNULL(@UFT6,''),
		@DocIDParent = ISNULL(@DocIDParent,'')
	
	if @ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_OTHERS_DGC') and @UFT6 <> ''  and @DocIDParent <> ''
	begin   
		/*if lower(@UFT6) = 'добавление'
		begin
			if exists (select 1 from dbo.Docs
						where ClassDoc = @ClassDoc
							and IsActive = 'Y'
							and DocIDParent = @DocIDParent
							and DocID <> @DocID
							and lower(UserFieldText6) = lower(@UFT6))
			begin
				select @Mess = @Mess + 
					'<br><font color=red>ОШИБКА! </font> Уже есть карточка на добавление договора ' + @DocIDParent + ' в НСИ. Измените тип операции на «Редактирование» или «Удаление»</font>' 
				select @Res = @@error if @Res <> 0 goto Err
			end
		end
		else*/if lower(@UFT6) <> 'добавление'
		begin
			/*if not exists (select 1 from dbo.Docs
						where ClassDoc = @ClassDoc
							and IsActive = 'Y'
							and DocIDParent = @DocIDParent
							and DocID <> @DocID
							and lower(UserFieldText6) = lower('добавление'))
			begin
				select @Mess = @Mess + 
					'<br><font color=red>ОШИБКА! </font> Операция редактирования/удаления невозможна, пока нет ни одной записи о добавлении договора ' + @DocIDParent + ' в НСИ</font>' 
				select @Res = @@error if @Res <> 0 goto Err
			end--если нет ошибки в типе операции
			else */If lower(@UFT6) = 'редактирование'
			begin
				if @Descr = ''
				begin
					select @Mess = @Mess + 
						'<br><font color=red>ОШИБКА! </font> Не заполнено поле «Комментарий». Укажите в поле «Комментарий», что требуется отредактировать в договоре.</font>' 
					select @Res = @@error if @Res <> 0 goto Err
				end
			end
	    
		end
	end
	
	if @PN = ''
	begin
		select @Mess = @Mess + 
			'<br><font color=red>ОШИБКА! </font> В поле [Организация] не может быть пустым.</font>' 
	end
    else if not exists (select 1 from dbo.Partners where Name = @PN)
	begin		
		select @Mess = @Mess + 
			'<br><font color=red>ОШИБКА! </font> В поле [Организация] указано несуществующее значение.</font>' 
	end
    if @UFT8 = ''
	begin
		select @Mess = @Mess + 
			'<br><font color=red>ОШИБКА! </font> В поле [Контрагент] не может быть пустым.</font>' 
	end
    else if not exists (select 1 from dbo.Partners where Name = @UFT8)
	begin		
		select @Mess = @Mess + 
			'<br><font color=red>ОШИБКА! </font> В поле [Контрагент] указано несуществующее значение.</font>' 
	end
    if @UFT2 = ''
	begin
		select @Mess = @Mess + 
			'<br><font color=red>ОШИБКА! </font> В поле [Вид договора] не может быть пустым.</font>' 
	end
    else if not exists (select 1 from dbo.UserDirValues where UDKeyField = 30 and Field1 = @UFT2)
	begin		
		select @Mess = @Mess + 
			'<br><font color=red>ОШИБКА! </font> В поле [Вид договора] указано несуществующее значение.</font>' 
	end
    if @Currency = ''
	begin
		select @Mess = @Mess + 
			'<br><font color=red>ОШИБКА! </font> В поле [Валюта] не может быть пустым.</font>' 
	end
    else if not exists (select 1 from dbo.CurrencyRates where Code = @Currency)
	begin		
		select @Mess = @Mess + 
			'<br><font color=red>ОШИБКА! </font> В поле [Валюта] указано несуществующее значение.</font>' 
	end
	
    if not @Percent between 0 and 100
	begin		
		select @Mess = @Mess + 
			'<br><font color=red>ОШИБКА! </font> В поле [Процент зачета аванса] указано некорректное значение.</font>' 
	end
 
 
 
	select @Mess = @Mess + case len(@Mess) when 0 then '' else '<br>' end
    select @Res = @@error if @Res <> 0 goto Err

OK:

	select @Mess as 'res'
	return @Res
Err:
	select @Mess  as 'res'
	return @Res









GO
/****** Object:  StoredProcedure [dbo].[PDX_DocsMoveIN] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[PDX_DocsMoveIN]
	
as
	
declare @Result int,@cnt int
set @Result = 0

begin tran ttt

if exists (select top 1 1 from dbo.Docs D 
		inner join dbo.Docs_Move M on D.DocID = M.DocID)
begin 
select 'ошибка переноса - совпадение DocID в архиве и текущей базе'
goto Err
end

select @cnt = count(*) from dbo.Docs_Move D

set identity_insert dbo.Docs ON
insert into dbo.Docs
(	[DocID],
	[GUID],
	[DocIDadd],
	[DocIDIncoming],
	[DocIDParent],
	[DocIDPrevious],
	[Author],
	[Correspondent],
	[Resolution],
	[History],
	[Result],
	[PercentCompletion],
	[Department],
	[Name],
	[Description],
	[LocationURL],
	[LocationPaper],
	[FileNamePrefix] ,
	[FileName] ,
	[FileNameNameLastModification],
	[FileNameDateLastAccessed],
	[FileNameDateLastModification],
	[LocationPath],
	[ExtInt],
	[PartnerName],
	[StatusDevelopment],
	[StatusPayment],
	[StatusArchiv],
	[StatusCompletion],
	[StatusDelivery],
	[TypeDoc],
	[ClassDoc],
	[ActDoc],
	[InventoryUnit],
	[PaymentMethod] ,
	[AmountDoc],
	[QuantityDoc],
	[DateActivation],
	[SecurityLevel],
	[DateCreation] ,
	[DateCompletion] ,
	[DateCompleted],
	[DateExpiration],
	[NameCreation],
	[NameAproval],
	[NameApproved],
	[DateApproved] ,
	[ListToEdit],
	[ListToReconcile] ,
	[ListReconciled] ,
	[NameResponsible],
	[NameControl] ,
	[NameLastModification] ,
	[DateLastModification] ,
	[UserFieldText1] ,
	[UserFieldText2] ,
	[UserFieldText3] ,
	[UserFieldText4] ,
	[UserFieldText5] ,
	[UserFieldText6] ,
	[UserFieldText7] ,
	[UserFieldText8] ,
	[UserFieldMoney1] ,
	[UserFieldMoney2] ,
	[UserFieldDate1] ,
	[UserFieldDate2] ,
	[UserFieldDate3] ,
	[UserFieldDate4],
	[UserFieldDate5] ,
	[UserFieldDate6] ,
	[UserFieldDate7] ,
	[UserFieldDate8] ,
	[IsActive] ,
	[DateActive] ,
	[BusinessProcessStep] ,
	[ExtPassword] ,
	[DateSigned] ,
	[Currency],
	[CurrencyRate] ,
	[Rank] ,
	[ListToView] ,
	[Content] ,
	[License] ,
	[TransferGUID],
	[DocIDInt],
	[DocID_AddNumber] )
select 
	D.[DocID],
	D.[GUID],
	D.[DocIDadd],
	D.[DocIDIncoming],
	D.[DocIDParent],
	D.[DocIDPrevious],
	D.[Author],
	D.[Correspondent],
	D.[Resolution],
	D.[History],
	D.[Result],
	D.[PercentCompletion],
	D.[Department],
	D.[Name],
	D.[Description],
	D.[LocationURL],
	D.[LocationPaper],
	D.[FileNamePrefix] ,
	D.[FileName] ,
	D.[FileNameNameLastModification],
	D.[FileNameDateLastAccessed],
	D.[FileNameDateLastModification],
	D.[LocationPath],
	D.[ExtInt],
	D.[PartnerName],
	D.[StatusDevelopment],
	D.[StatusPayment],
	D.[StatusArchiv],
	D.[StatusCompletion],
	D.[StatusDelivery],
	D.[TypeDoc],
	D.[ClassDoc],
	D.[ActDoc],
	D.[InventoryUnit],
	D.[PaymentMethod] ,
	D.[AmountDoc],
	D.[QuantityDoc],
	D.[DateActivation],
	D.[SecurityLevel],
	D.[DateCreation] ,
	D.[DateCompletion] ,
	D.[DateCompleted],
	D.[DateExpiration],
	D.[NameCreation],
	D.[NameAproval],
	D.[NameApproved],
	D.[DateApproved] ,
	D.[ListToEdit],
	D.[ListToReconcile] ,
	D.[ListReconciled] ,
	D.[NameResponsible],
	D.[NameControl] ,
	D.[NameLastModification] ,
	D.[DateLastModification] ,
	D.[UserFieldText1] ,
	D.[UserFieldText2] ,
	D.[UserFieldText3] ,
	D.[UserFieldText4] ,
	D.[UserFieldText5] ,
	D.[UserFieldText6] ,
	D.[UserFieldText7] ,
	D.[UserFieldText8] ,
	D.[UserFieldMoney1] ,
	D.[UserFieldMoney2] ,
	D.[UserFieldDate1] ,
	D.[UserFieldDate2] ,
	D.[UserFieldDate3] ,
	D.[UserFieldDate4],
	D.[UserFieldDate5] ,
	D.[UserFieldDate6] ,
	D.[UserFieldDate7] ,
	D.[UserFieldDate8] ,
	D.[IsActive] ,
	D.[DateActive] ,
	D.[BusinessProcessStep] ,
	D.[ExtPassword] ,
	D.[DateSigned] ,
	D.[Currency],
	D.[CurrencyRate] ,
	D.[Rank] ,
	D.[ListToView] ,
	D.[Content] ,
	D.[License] ,
	D.[TransferGUID],
	D.[DocIDInt],
	D.[DocID_AddNumber]
from dbo.Docs_Move D
select @Result = @@error if @Result <> 0 goto Err
set identity_insert dbo.Docs OFF


set identity_insert dbo.Comments ON
insert into dbo.Comments
(	[UserID],
	[UserName],
	[ContactUserName],
	[ContactUserID] ,
	[PartnerName] ,
	[DocID] ,
	[DateCreation] ,
	[DateEvent] ,
	[DateEventEnd] ,
	[Address] ,
	[Subject] ,
	[Comment] ,
	[CommentType] ,
	[SpecialInfo] ,
	[FileName] ,
	[KeyField] ,
	[PartnerID],
	[Version] ,
	[GUID] ,
	[GUIDPartner],
	[GUIDUser],
	[GUIDDoc] ,
	[Amount] ,
	[FileNameOriginal] ,
	[RIK_CommentType] )
select
	C.[UserID],
	C.[UserName],
	C.[ContactUserName],
	C.[ContactUserID] ,
	C.[PartnerName] ,
	C.[DocID] ,
	C.[DateCreation] ,
	C.[DateEvent] ,
	C.[DateEventEnd] ,
	C.[Address] ,
	C.[Subject] ,
	C.[Comment] ,
	C.[CommentType] ,
	C.[SpecialInfo] ,
	C.[FileName] ,
	C.[KeyField] ,
	C.[PartnerID],
	C.[Version] ,
	C.[GUID] ,
	C.[GUIDPartner],
	C.[GUIDUser],
	C.[GUIDDoc] ,
	C.[Amount] ,
	C.[FileNameOriginal] ,
	C.[RIK_CommentType] 
from dbo.Comments_Move C
select @Result = @@error if @Result <> 0 goto Err
set identity_insert dbo.Comments OFF

set identity_insert dbo.PayDetails ON
insert into dbo.PayDetails
(	[ID],
	[TransferGUID] ,
	[Amount],
	[Date],
	[RequestID],
	[bDocID],
	[DC],
	[DLM] )
select
	M.[ID],
	M.[TransferGUID] ,
	M.[Amount],
	M.[Date],
	M.[RequestID],
	M.[bDocID],
	M.[DC],
	M.[DLM] 
from dbo.PayDetails_Move M
select @Result = @@error if @Result <> 0 goto Err
set identity_insert dbo.PayDetails OFF

insert into dbo.PDXDocDetails
	([SetID],
	[DocID],
	[ClassDoc],
	[Tx1],
	[Tx2],
	[Tx3],
	[Tx4],
	[Tx5],
	[TxL1],
	[TxL2],
	[Dt1],
	[Dt2],
	[Dt3],
	[Dt4] ,
	[Dt5],
	[Am1],
	[Am2],
	[Am3],
	[Am4],
	[Am5],
	[Bl1],
	[Bl2],
	[Bl3] ,
	[Bl4] ,
	[Bl5] ,
	[NC] ,
	[DC],
	[NLM],
	[DLM])
select
	M.[SetID],
	M.[DocID],
	M.[ClassDoc],
	M.[Tx1],
	M.[Tx2],
	M.[Tx3],
	M.[Tx4],
	M.[Tx5],
	M.[TxL1],
	M.[TxL2],
	M.[Dt1],
	M.[Dt2],
	M.[Dt3],
	M.[Dt4] ,
	M.[Dt5],
	M.[Am1],
	M.[Am2],
	M.[Am3],
	M.[Am4],
	M.[Am5],
	M.[Bl1],
	M.[Bl2],
	M.[Bl3] ,
	M.[Bl4] ,
	M.[Bl5] ,
	M.[NC] ,
	M.[DC],
	M.[NLM],
	M.[DLM]
from dbo.PDXDocDetails_Move M 
select @Result = @@error if @Result <> 0 goto Err

insert into [dbo].[PayStatusDetails](
	[DocIDInt],
	[FinStatus],
	[Comment],
	[DC],
	[DLM],
	[NC],
	[NLM])
select
	[DocIDInt],
	[FinStatus],
	[Comment],
	[DC],
	[DLM],
	[NC],
	[NLM]
from [dbo].[PayStatusDetails_Move]

set identity_insert dbo.PDXZPR ON
insert into [dbo].[PDXZPR](
	[KeyField],
	[DocIDInt] ,
	[AVIA],
	[VISA],
	[VIP] ,
	[HOTEL],
	[INSURE],
	[TRANSFER],
	[NC],
	[DC],
	[NLM],
	[DLM])
select
	[KeyField],
	[DocIDInt] ,
	[AVIA],
	[VISA],
	[VIP] ,
	[HOTEL],
	[INSURE],
	[TRANSFER],
	[NC],
	[DC],
	[NLM],
	[DLM]
from [dbo].[PDXZPR_Move]
set identity_insert dbo.PDXZPR OFF


set identity_insert dbo.PDXTrip ON
insert into [dbo].[PDXTrip](
	[KeyField],
	[DocIDInt],
	[AVIA],
	[VISA],
	[VIP],
	[HOTEL],
	[INSURE],
	[TRANSFER],
	[Obj],
	[NC],
	[DC],
	[NLM],
	[DLM])
select
	[KeyField],
	[DocIDInt],
	[AVIA],
	[VISA],
	[VIP],
	[HOTEL],
	[INSURE],
	[TRANSFER],
	[Obj],
	[NC],
	[DC],
	[NLM],
	[DLM]
from [dbo].[PDXTrip_Move]
set identity_insert dbo.PDXTrip OFF


set identity_insert dbo.PDXAccrual ON
insert into [dbo].[PDXAccrual](
	[KeyField],
	[DocIDInt],
	[Oborot],
	[Amount],
	[Koeff],
	[Grp],
	[isDel],
	[blnType],
	[NC],
	[DC],
	[NLM],
	[DLM])
select
	[KeyField],
	[DocIDInt],
	[Oborot],
	[Amount],
	[Koeff],
	[Grp],
	[isDel],
	[blnType],
	[NC],
	[DC],
	[NLM],
	[DLM]
from [dbo].[PDXAccrual_Move]
set identity_insert dbo.PDXAccrual OFF


insert into [dbo].[DocsCFO](
	[DocIDInt],
	[CFO],
	[DC],
	[DLM],
	[NC],
	[NLM],
	[ExistGPPercent],
	[GPPercent],
	[ExistAvans],
	[AvansPercent] )
select
    [DocIDInt],
	[CFO],
	[DC],
	[DLM],
	[NC],
	[NLM],
	[ExistGPPercent],
	[GPPercent],
	[ExistAvans],
	[AvansPercent] 
from [dbo].[DocsCFO_Move]

insert into [dbo].[DocsPayBudget](
	[DocIDInt],
	[Description],
	[Status] ,
	[KPP] ,
	[KBK] ,
	[OKTMO],
	[TaxPeriod],
	[Year],
	[Month],
	[Amount],
	[Purpose],
	[VAT],
	[DC],
	[DLM],
	[NC],
	[NLM])
select
	[DocIDInt],
	[Description],
	[Status] ,
	[KPP] ,
	[KBK] ,
	[OKTMO],
	[TaxPeriod],
	[Year],
	[Month],
	[Amount],
	[Purpose],
	[VAT],
	[DC],
	[DLM],
	[NC],
	[NLM]
from [dbo].[DocsPayBudget_Move]
	

insert into [dbo].[DocsPLNTBL](
	--[ID],
	[DocIDInt],
	[PN],
	[Intrn],
	[Obj],
	[Item],
	[Name],
	[PayCID],
	[CustomerCID],
	[Account],
	[Jan],
	[Feb],
	[Mar],
	[Apr],
	[May],
	[Jun],
	[Jul],
	[Aug],
	[Sep],
	[Oct],
	[Nov],
	[Dec],
	[DC],
	[NC],
	[DLM],
	[NLM])
select
	--[ID],
	[DocIDInt],
	[PN],
	[Intrn],
	[Obj],
	[Item],
	[Name],
	[PayCID],
	[CustomerCID],
	[Account],
	[Jan],
	[Feb],
	[Mar],
	[Apr],
	[May],
	[Jun],
	[Jul],
	[Aug],
	[Sep],
	[Oct],
	[Nov],
	[Dec],
	[DC],
	[NC],
	[DLM],
	[NLM]
from [dbo].[DocsPLNTBL_Move]
	
	
insert into [dbo].[DocsNSI](
	[DocIDInt],
	[DocIDParent],
	[PN],
	[UFT8],
	[Descr],
	[Currency],
	[UFT2],
	[Percent],
	[DocDate],
	[NLM],
	[DLM])
select
	[DocIDInt],
	[DocIDParent],
	[PN],
	[UFT8],
	[Descr],
	[Currency],
	[UFT2],
	[Percent],
	[DocDate],
	[NLM],
	[DLM]
from [dbo].[DocsNSI_Move]

delete from dbo.[DocsNSI_Move]
select @Result = @@error if @Result <> 0 goto Err

delete from dbo.[DocsPLNTBL_Move]
select @Result = @@error if @Result <> 0 goto Err

delete from dbo.[DocsPayBudget_Move]
select @Result = @@error if @Result <> 0 goto Err

delete from dbo.[DocsCFO_Move]
select @Result = @@error if @Result <> 0 goto Err

delete from dbo.[PDXAccrual_Move]
select @Result = @@error if @Result <> 0 goto Err

delete from dbo.[PDXTrip_Move]
select @Result = @@error if @Result <> 0 goto Err

delete from dbo.[PDXZPR_Move]
select @Result = @@error if @Result <> 0 goto Err

delete from dbo.[PayStatusDetails_Move]
select @Result = @@error if @Result <> 0 goto Err

delete from dbo.PayDetails_Move
select @Result = @@error if @Result <> 0 goto Err

delete from dbo.PDXDocDetails_Move
select @Result = @@error if @Result <> 0 goto Err

delete from dbo.Comments_Move
select @Result = @@error if @Result <> 0 goto Err

delete from dbo.Docs_Move
select @Result = @@error if @Result <> 0 goto Err

select 'перенесено - ' + CAST(@cnt as varchar(100)) + ' документов'


OK:
commit tran ttt

	return @Result
ERR:
rollback tran ttt

	return @Result




GO
/****** Object:  StoredProcedure [dbo].[PDX_DocsMoveOut] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_DocsMoveOut]
	
as
	
declare @Result int, @cnt int
set @Result = 0

begin tran ttt

select @cnt = COUNT(*)
from dbo.Docs_ForMove M 
inner join dbo.Docs D on M.DocID = D.DocID

insert into dbo.Docs_Move
(	[DocID],
	[GUID],
	[DocIDadd],
	[DocIDIncoming],
	[DocIDParent],
	[DocIDPrevious],
	[Author],
	[Correspondent],
	[Resolution],
	[History],
	[Result],
	[PercentCompletion],
	[Department],
	[Name],
	[Description],
	[LocationURL],
	[LocationPaper],
	[FileNamePrefix] ,
	[FileName] ,
	[FileNameNameLastModification],
	[FileNameDateLastAccessed],
	[FileNameDateLastModification],
	[LocationPath],
	[ExtInt],
	[PartnerName],
	[StatusDevelopment],
	[StatusPayment],
	[StatusArchiv],
	[StatusCompletion],
	[StatusDelivery],
	[TypeDoc],
	[ClassDoc],
	[ActDoc],
	[InventoryUnit],
	[PaymentMethod] ,
	[AmountDoc],
	[QuantityDoc],
	[DateActivation],
	[SecurityLevel],
	[DateCreation] ,
	[DateCompletion] ,
	[DateCompleted],
	[DateExpiration],
	[NameCreation],
	[NameAproval],
	[NameApproved],
	[DateApproved] ,
	[ListToEdit],
	[ListToReconcile] ,
	[ListReconciled] ,
	[NameResponsible],
	[NameControl] ,
	[NameLastModification] ,
	[DateLastModification] ,
	[UserFieldText1] ,
	[UserFieldText2] ,
	[UserFieldText3] ,
	[UserFieldText4] ,
	[UserFieldText5] ,
	[UserFieldText6] ,
	[UserFieldText7] ,
	[UserFieldText8] ,
	[UserFieldMoney1] ,
	[UserFieldMoney2] ,
	[UserFieldDate1] ,
	[UserFieldDate2] ,
	[UserFieldDate3] ,
	[UserFieldDate4],
	[UserFieldDate5] ,
	[UserFieldDate6] ,
	[UserFieldDate7] ,
	[UserFieldDate8] ,
	[IsActive] ,
	[DateActive] ,
	[BusinessProcessStep] ,
	[ExtPassword] ,
	[DateSigned] ,
	[Currency],
	[CurrencyRate] ,
	[Rank] ,
	[ListToView] ,
	[Content] ,
	[License] ,
	[TransferGUID],
	[DocIDInt],
	[DocID_AddNumber] )
select 
	D.[DocID],
	D.[GUID],
	D.[DocIDadd],
	D.[DocIDIncoming],
	D.[DocIDParent],
	D.[DocIDPrevious],
	D.[Author],
	D.[Correspondent],
	D.[Resolution],
	D.[History],
	D.[Result],
	D.[PercentCompletion],
	D.[Department],
	D.[Name],
	D.[Description],
	D.[LocationURL],
	D.[LocationPaper],
	D.[FileNamePrefix] ,
	D.[FileName] ,
	D.[FileNameNameLastModification],
	D.[FileNameDateLastAccessed],
	D.[FileNameDateLastModification],
	D.[LocationPath],
	D.[ExtInt],
	D.[PartnerName],
	D.[StatusDevelopment],
	D.[StatusPayment],
	D.[StatusArchiv],
	D.[StatusCompletion],
	D.[StatusDelivery],
	D.[TypeDoc],
	D.[ClassDoc],
	D.[ActDoc],
	D.[InventoryUnit],
	D.[PaymentMethod] ,
	D.[AmountDoc],
	D.[QuantityDoc],
	D.[DateActivation],
	D.[SecurityLevel],
	D.[DateCreation] ,
	D.[DateCompletion] ,
	D.[DateCompleted],
	D.[DateExpiration],
	D.[NameCreation],
	D.[NameAproval],
	D.[NameApproved],
	D.[DateApproved] ,
	D.[ListToEdit],
	D.[ListToReconcile] ,
	D.[ListReconciled] ,
	D.[NameResponsible],
	D.[NameControl] ,
	D.[NameLastModification] ,
	D.[DateLastModification] ,
	D.[UserFieldText1] ,
	D.[UserFieldText2] ,
	D.[UserFieldText3] ,
	D.[UserFieldText4] ,
	D.[UserFieldText5] ,
	D.[UserFieldText6] ,
	D.[UserFieldText7] ,
	D.[UserFieldText8] ,
	D.[UserFieldMoney1] ,
	D.[UserFieldMoney2] ,
	D.[UserFieldDate1] ,
	D.[UserFieldDate2] ,
	D.[UserFieldDate3] ,
	D.[UserFieldDate4],
	D.[UserFieldDate5] ,
	D.[UserFieldDate6] ,
	D.[UserFieldDate7] ,
	D.[UserFieldDate8] ,
	D.[IsActive] ,
	D.[DateActive] ,
	D.[BusinessProcessStep] ,
	D.[ExtPassword] ,
	D.[DateSigned] ,
	D.[Currency],
	D.[CurrencyRate] ,
	D.[Rank] ,
	D.[ListToView] ,
	D.[Content] ,
	D.[License] ,
	D.[TransferGUID] ,
	D.[DocIDInt],
	D.[DocID_AddNumber]
from dbo.Docs_ForMove M 
inner join dbo.Docs D on M.DocID = D.DocID

select @Result = @@error if @Result <> 0 goto Err

insert into dbo.Comments_Move
(	[UserID],
	[UserName],
	[ContactUserName],
	[ContactUserID] ,
	[PartnerName] ,
	[DocID] ,
	[DateCreation] ,
	[DateEvent] ,
	[DateEventEnd] ,
	[Address] ,
	[Subject] ,
	[Comment] ,
	[CommentType] ,
	[SpecialInfo] ,
	[FileName] ,
	[KeyField] ,
	[PartnerID],
	[Version] ,
	[GUID] ,
	[GUIDPartner],
	[GUIDUser],
	[GUIDDoc] ,
	[Amount] ,
	[FileNameOriginal] ,
	[RIK_CommentType] )
select
	C.[UserID],
	C.[UserName],
	C.[ContactUserName],
	C.[ContactUserID] ,
	C.[PartnerName] ,
	C.[DocID] ,
	C.[DateCreation] ,
	C.[DateEvent] ,
	C.[DateEventEnd] ,
	C.[Address] ,
	C.[Subject] ,
	C.[Comment] ,
	C.[CommentType] ,
	C.[SpecialInfo] ,
	C.[FileName] ,
	C.[KeyField] ,
	C.[PartnerID],
	C.[Version] ,
	C.[GUID] ,
	C.[GUIDPartner],
	C.[GUIDUser],
	C.[GUIDDoc] ,
	C.[Amount] ,
	C.[FileNameOriginal] ,
	C.[RIK_CommentType] 
from dbo.Docs_ForMove M
inner join dbo.Comments C on M.DocID = C.DocID
select @Result = @@error if @Result <> 0 goto Err

insert into dbo.PayDetails_Move
(	[ID],
	[TransferGUID] ,
	[Amount],
	[Date],
	[RequestID],
	[bDocID],
	[DC],
	[DLM] )
select
	M.[ID],
	M.[TransferGUID] ,
	M.[Amount],
	M.[Date],
	M.[RequestID],
	M.[bDocID],
	M.[DC],
	M.[DLM] 
from dbo.Docs_ForMove X
inner join dbo.Docs D on D.DocID = X.DocID
inner join dbo.PayDetails M on M.TransferGUID = D.TransferGUID
select @Result = @@error if @Result <> 0 goto Err

insert into dbo.PDXDocDetails_Move
	([SetID],
	[DocID],
	[ClassDoc],
	[Tx1],
	[Tx2],
	[Tx3],
	[Tx4],
	[Tx5],
	[TxL1],
	[TxL2],
	[Dt1],
	[Dt2],
	[Dt3],
	[Dt4] ,
	[Dt5],
	[Am1],
	[Am2],
	[Am3],
	[Am4],
	[Am5],
	[Bl1],
	[Bl2],
	[Bl3] ,
	[Bl4] ,
	[Bl5] ,
	[NC] ,
	[DC],
	[NLM],
	[DLM])
select
	M.[SetID],
	M.[DocID],
	M.[ClassDoc],
	M.[Tx1],
	M.[Tx2],
	M.[Tx3],
	M.[Tx4],
	M.[Tx5],
	M.[TxL1],
	M.[TxL2],
	M.[Dt1],
	M.[Dt2],
	M.[Dt3],
	M.[Dt4] ,
	M.[Dt5],
	M.[Am1],
	M.[Am2],
	M.[Am3],
	M.[Am4],
	M.[Am5],
	M.[Bl1],
	M.[Bl2],
	M.[Bl3] ,
	M.[Bl4] ,
	M.[Bl5] ,
	M.[NC] ,
	M.[DC],
	M.[NLM],
	M.[DLM]
from dbo.Docs_ForMove D
inner join dbo.PDXDocDetails M on D.DocID = M.DocID
select @Result = @@error if @Result <> 0 goto Err

insert into [dbo].[PayStatusDetails_Move]
(	[DocIDInt],
	[FinStatus],
	[Comment],
	[DC],
	[DLM],
	[NC],
	[NLM])
select
	M.[DocIDInt],
	M.[FinStatus],
	M.[Comment],
	M.[DC],
	M.[DLM],
	M.[NC],
	M.[NLM]
from dbo.Docs_ForMove D
inner join dbo.PayStatusDetails M on D.DocIDInt = M.DocIDInt
select @Result = @@error if @Result <> 0 goto Err

insert into [dbo].[PDXZPR_Move]
(	[KeyField],
	[DocIDInt] ,
	[AVIA],
	[VISA],
	[VIP] ,
	[HOTEL],
	[INSURE],
	[TRANSFER],
	[NC],
	[DC],
	[NLM],
	[DLM])
select
	M.[KeyField],
	M.[DocIDInt] ,
	M.[AVIA],
	M.[VISA],
	M.[VIP] ,
	M.[HOTEL],
	M.[INSURE],
	M.[TRANSFER],
	M.[NC],
	M.[DC],
	M.[NLM],
	M.[DLM]
from dbo.Docs_ForMove D
inner join dbo.PDXZPR M on D.DocIDInt = M.DocIDInt
select @Result = @@error if @Result <> 0 goto Err

insert into [dbo].[PDXTrip_Move]
	([KeyField],
	[DocIDInt],
	[AVIA],
	[VISA],
	[VIP],
	[HOTEL],
	[INSURE],
	[TRANSFER],
	[NC],
	[DC],
	[NLM],
	[DLM])
select
	M.[KeyField],
	M.[DocIDInt],
	M.[AVIA],
	M.[VISA],
	M.[VIP],
	M.[HOTEL],
	M.[INSURE],
	M.[TRANSFER],
	M.[NC],
	M.[DC],
	M.[NLM],
	M.[DLM]
from dbo.Docs_ForMove D
inner join dbo.PDXTrip M on D.DocIDInt = M.DocIDInt
select @Result = @@error if @Result <> 0 goto Err

insert into [dbo].[PDXAccrual_Move]
	([KeyField],
	[DocIDInt],
	[Oborot],
	[Amount],
	[Koeff],
	[Grp],
	[isDel],
	[blnType],
	[NC],
	[DC],
	[NLM],
	[DLM])
select
	M.[KeyField],
	M.[DocIDInt],
	M.[Oborot],
	M.[Amount],
	M.[Koeff],
	M.[Grp],
	M.[isDel],
	M.[blnType],
	M.[NC],
	M.[DC],
	M.[NLM],
	M.[DLM]
from dbo.Docs_ForMove D
inner join dbo.PDXAccrual M on D.DocIDInt = M.DocIDInt
select @Result = @@error if @Result <> 0 goto Err

insert into [dbo].[DocsCFO_Move]
	([DocIDInt],
	[CFO],
	[DC],
	[DLM],
	[NC],
	[NLM],
	[ExistGPPercent],
	[GPPercent],
	[ExistAvans],
	[AvansPercent] )
select
	M.[DocIDInt],
	M.[CFO],
	M.[DC],
	M.[DLM],
	M.[NC],
	M.[NLM],
	M.[ExistGPPercent],
	M.[GPPercent] ,
	M.[ExistAvans],
	M.[AvansPercent]
from dbo.Docs_ForMove D
inner join dbo.DocsCFO M on D.DocIDInt = M.DocIDInt
select @Result = @@error if @Result <> 0 goto Err

insert into [dbo].[DocsPayBudget_Move]
	([DocIDInt],
	[Description],
	[Status] ,
	[KPP] ,
	[KBK] ,
	[OKTMO],
	[TaxPeriod],
	[Year],
	[Month],
	[Amount],
	[Purpose],
	[VAT],
	[DC],
	[DLM],
	[NC],
	[NLM])
select
	M.[DocIDInt],
	M.[Description],
	M.[Status] ,
	M.[KPP] ,
	M.[KBK] ,
	M.[OKTMO],
	M.[TaxPeriod],
	M.[Year],
	M.[Month],
	M.[Amount],
	M.[Purpose],
	M.[VAT],
	M.[DC],
	M.[DLM],
	M.[NC],
	M.[NLM]
from dbo.Docs_ForMove D
inner join dbo.DocsPayBudget M on D.DocIDInt = M.DocIDInt
select @Result = @@error if @Result <> 0 goto Err

insert into [dbo].[DocsPLNTBL_Move]
	([ID],
	[DocIDInt],
	[PN],
	[Intrn],
	[Obj],
	[Item],
	[Name],
	[PayCID],
	[CustomerCID],
	[Account],
	[Jan],
	[Feb],
	[Mar],
	[Apr],
	[May],
	[Jun],
	[Jul],
	[Aug],
	[Sep],
	[Oct],
	[Nov],
	[Dec],
	[DC],
	[NC],
	[DLM],
	[NLM])
select
	M.[ID],
	M.[DocIDInt],
	M.[PN],
	M.[Intrn],
	M.[Obj],
	M.[Item],
	M.[Name],
	M.[PayCID],
	M.[CustomerCID],
	M.[Account],
	M.[Jan],
	M.[Feb],
	M.[Mar],
	M.[Apr],
	M.[May],
	M.[Jun],
	M.[Jul],
	M.[Aug],
	M.[Sep],
	M.[Oct],
	M.[Nov],
	M.[Dec],
	M.[DC],
	M.[NC],
	M.[DLM],
	M.[NLM]
from dbo.Docs_ForMove D
inner join dbo.DocsPLNTBL M on D.DocIDInt = M.DocIDInt
select @Result = @@error if @Result <> 0 goto Err


insert into [dbo].[DocsNSI_Move]
	([DocIDInt],
	[DocIDParent],
	[PN],
	[UFT8],
	[Descr],
	[Currency],
	[UFT2],
	[Percent],
	[DocDate],
	[NLM],
	[DLM])
select
	M.[DocIDInt],
	M.[DocIDParent],
	M.[PN],
	M.[UFT8],
	M.[Descr],
	M.[Currency],
	M.[UFT2],
	M.[Percent],
	M.[DocDate],
	M.[NLM],
	M.[DLM]
from dbo.Docs_ForMove D
inner join dbo.DocsNSI M on D.DocIDInt = M.DocIDInt
select @Result = @@error if @Result <> 0 goto Err


delete from M
from dbo.Docs_ForMove D
inner join dbo.DocsPLNTBL M on D.DocIDInt = M.DocIDInt
select @Result = @@error if @Result <> 0 goto Err

delete from M
from dbo.Docs_ForMove D
inner join dbo.DocsNSI M on D.DocIDInt = M.DocIDInt
select @Result = @@error if @Result <> 0 goto Err

delete from M
from dbo.Docs_ForMove D
inner join dbo.DocsPayBudget M on D.DocIDInt = M.DocIDInt
select @Result = @@error if @Result <> 0 goto Err

delete from M
from dbo.Docs_ForMove D
inner join dbo.DocsCFO M on D.DocIDInt = M.DocIDInt
select @Result = @@error if @Result <> 0 goto Err

delete from M
from dbo.Docs_ForMove D
inner join dbo.PDXAccrual M on D.DocIDInt = M.DocIDInt
select @Result = @@error if @Result <> 0 goto Err

delete from M
from dbo.Docs_ForMove D
inner join dbo.PDXTrip M on D.DocIDInt = M.DocIDInt
select @Result = @@error if @Result <> 0 goto Err

delete from M
from dbo.Docs_ForMove D
inner join dbo.PDXZPR M on D.DocIDInt = M.DocIDInt
select @Result = @@error if @Result <> 0 goto Err


delete from M
from dbo.Docs_ForMove D
inner join dbo.PayStatusDetails M on D.DocIDInt = M.DocIDInt
select @Result = @@error if @Result <> 0 goto Err

delete from M
from dbo.Docs_ForMove X
inner join dbo.Docs D on D.DocID = X.DocID
inner join dbo.PayDetails M on M.TransferGUID = D.TransferGUID
select @Result = @@error if @Result <> 0 goto Err

delete from M
from dbo.Docs_ForMove D
inner join dbo.PDXDocDetails M on D.DocID = M.DocID
select @Result = @@error if @Result <> 0 goto Err

delete from C
from dbo.Docs_ForMove M
inner join dbo.Comments C on M.DocID = C.DocID
select @Result = @@error if @Result <> 0 goto Err

delete from D
from dbo.Docs_ForMove M 
inner join dbo.Docs D on M.DocID = D.DocID
select @Result = @@error if @Result <> 0 goto Err

delete from dbo.Docs_ForMove
select @Result = @@error if @Result <> 0 goto Err

select 'перенесено - ' + CAST(@cnt as varchar(100)) + ' документов'

OK:
commit tran ttt

	return @Result
ERR:
rollback tran ttt

	return @Result




GO
/****** Object:  StoredProcedure [dbo].[PDX_DocsPayBudget_Change] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_DocsPayBudget_Change]
	@DocID varchar(128),
	@Description [varchar](264),
	@Status [varchar](512) ,
	@KPP [varchar](128) ,
	@KBK [varchar](128) ,
	@OKTMO [varchar](128),
	@TaxPeriod [varchar](264),
	@Year [varchar](4) ,
	@Month [varchar](2),
	@Amount varchar(128),
	@Purpose varchar(255),
	@VAT varchar(255),
	@NC varchar(128),
	@Act int, --1--ceate, 2-update,3 delete
	@Chk bit = 0
	
as
	declare  @Res int, @DocIDInt int
	declare @ErrList varchar(1024), @Amount1 money

	select @Res = 0,@ErrList = ''

	select
		@DocID = ltrim(rtrim(isnull(@DocID,''))),
		@Description = ltrim(rtrim(isnull(@Description,''))),
		@Status = ltrim(rtrim(isnull(@Status,''))),
		@KPP = ltrim(rtrim(isnull(@KPP,''))),
		@KBK = ltrim(rtrim(isnull(@KBK,''))),
		@OKTMO = ltrim(rtrim(isnull(@OKTMO,''))),
		@TaxPeriod = ltrim(rtrim(isnull(@TaxPeriod,''))),
		@Year = ltrim(rtrim(isnull(@Year,''))),
		@Month = ltrim(rtrim(isnull(@Month,''))),
		@NC  = ltrim(rtrim(isnull(@NC,''))),
		@Purpose = ltrim(rtrim(isnull(@Purpose,''))),
		@VAT = ltrim(rtrim(isnull(@VAT,''))),
		@Amount = ltrim(rtrim(replace(replace(replace(isnull(@Amount,'0'),',','.'),SPACE(1),''),CHAR(160),'')))
		
	select @Res = @@error if @Res <> 0 goto Err

/************************************
ПРОВЕРКИ ВВЕДЕННЫХ ЗНАЧЕНИЙ
*************************************/
select
	@DocIDInt = DocIDInt
from dbo.Docs 
where DocID = @DocID
and ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_BUDG')

If @Act <> 3
BEGIN
	If @DocIDInt is null
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Систамная ошибка! Некорректный ИД документа. Обратитесь к администратору СЭД.'
		goto NXT
	end
	/*
	If @Description = ''
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Укажите Основание платежа'
		goto NXT
	end
	
	If @Type = ''
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Укажите Тип платежа'
		goto NXT
	end
	If @Status = ''
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Укажите Статус составителя'
		goto NXT
	end
	If @KPP = ''
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Укажите КПП'
		goto NXT
	end
	If @KBK = ''
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Укажите КБК'
		goto NXT
	end
	If @OKTMO = ''
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Укажите ОКТМО'
		goto NXT
	end
	If @TaxPeriod = ''
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Укажите Налоговый период'
		goto NXT
	end
	If @Year = ''
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Укажите Год периода'
		goto NXT
	end
	else if isnumeric(@Year) = 0
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Некорректно указан Год периода'
		goto NXT
	end
	else if not cast(@Year as int) between 2000 and 2050
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Некорректно указан Год периода (допустимое значение от 2000 г. до 2050 г.)'
		goto NXT
	end
	
	If  @Month = ''
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Укажите Месяц'
		goto NXT
	end*/

	if @Year <> '' and isnumeric(@Year) = 0
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Некорректно указан Год периода'
		goto NXT
	end
/*
	If @Purpose = ''
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Поле "Назначение платежного поручения" не может быть пустым'
		goto NXT
	end

	If @VAT = ''
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Поле "НДС" не может быть пустым'
		goto NXT
	end
	*/
	If len(@Purpose) >= 256 
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Превышена максимально допустимая длина "Назначение платежного поручения" (всего - ' + cast(len(@Purpose) as varchar(100)) + ', макс. - 255)'
		goto NXT
	end

	If @Amount = '' 
	begin
	  set @Amount1 = 0
	  select @Res = @@error if @Res <> 0 goto Err
	end
	else
	begin
	  if ISNUMERIC(@Amount) = 1
	  begin
		set @Amount1 = CAST(@Amount as money)
		select @Res = @@error if @Res <> 0 goto Err
	  end
	  else
	  begin
  		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'В поле сумма должно быть указано числовое значение'
		goto NXT
	  end 
	end
END
/************************************/

NXT:

If @Chk = 0
begin --если это создание , то нужно генерить ошибкуесли она есть
	If @ErrList <> '' 
	begin
		RAISERROR (@ErrList, 16,1)
		goto Err
	end
end
else --если это проверка просто выводим сообщение, даже если оно пустое
begin
	select @ErrList as ErrList 
	select @Res = @@error if @Res <> 0 goto Err
end

IF @ErrList = '' and @Chk = 0
BEGIN
	if @Act = 2
	begin
		update dbo.[DocsPayBudget]
			set 
				[Description] = @Description,
				[Status] = @Status,
				[KPP] = @KPP,
				[KBK] = @KBK,
				[OKTMO] = @OKTMO,
				[TaxPeriod] = @TaxPeriod,
				[Year] = @Year,
				[Month] = @Month,
				[Purpose] = @Purpose,
				[VAT] = @VAT,
				[Amount] = @Amount1,
				NLM = @NC,
				DLM = getdate()
		where DocIDInt = @DocIDInt
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 1
	begin
		insert into dbo.[DocsPayBudget]
			([Description], [Status], [KPP],[KBK],[OKTMO],[TaxPeriod], [Year],[Month],[Purpose],[VAT],[Amount], DocIDInt, NC, DC, NLM, DLM)
		values 
			(@Description,@Status,@KPP,@KBK,@OKTMO,@TaxPeriod,@Year,@Month,@Purpose,@VAT,@Amount1, @DocIDInt, @NC, getdate(), @NC, getdate())
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 3
	begin
		print 'no deletion'
	end
END
	select @Res = @@error if @Res <> 0 goto Err

OK:

	return @Res
Err:
	return @Res





GO
/****** Object:  StoredProcedure [dbo].[PDX_DocsPLNTBL_Change] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE proc [dbo].[PDX_DocsPLNTBL_Change]
	@DocID varchar(128),
	@PN varchar(128) = NULL,
	@Intrn varchar(10) = NULL,
	@Obj varchar(1024) = NULL,
	@Item varchar(1024) = NULL,
	@Name varchar(256) = NULL,
	@PayCID varchar(128) = NULL,
	@CustomerCID varchar(128) = NULL,
	@Account varchar(1024) = NULL,

	@Jan varchar(128) = NULL,
	@Feb varchar(128) = NULL,
	@Mar varchar(128) = NULL,
	@Apr varchar(128) = NULL,
	@May varchar(128) = NULL,
	@Jun varchar(128) = NULL,
	@Jul varchar(128) = NULL,
	@Aug varchar(128) = NULL,
	@Sep varchar(128) = NULL,
	@Oct varchar(128) = NULL,
	@Nov varchar(128) = NULL,
	@Dec varchar(128) = NULL,
	
	@ID int,
	@NC varchar(128) = NULL,
	@Act int, --1--ceate, 2-update,3 delete
	@Chk bit = 0
	
as
	declare  @DocIDInt int,
	
	@Jan2 money,
	@Feb2 money,
	@Mar2 money,
	@Apr2 money,
	@May2 money,
	@Jun2 money,
	@Jul2 money,
	@Aug2 money,
	@Sep2 money,
	@Oct2 money,
	@Nov2 money,
	@Dec2 money,
	@Intrn2 char(1),
	@Obj_code varchar(50),
	@Item_Code varchar(50),
	@UFT7 varchar(4),
	@Year int
	
	declare @ErrList varchar(1024), @Amount1 money

	select @ErrList = ''

	select
		@DocID = ltrim(rtrim(isnull(@DocID,''))),		
		@PN = ltrim(rtrim(isnull(@PN,''))),
		@Intrn = ltrim(rtrim(isnull(@Intrn,''))),
		@Obj = ltrim(rtrim(isnull(@Obj,''))),
		@Item = ltrim(rtrim(isnull(@Item,''))),
		@Name = ltrim(rtrim(isnull(@Name,''))),
		@PayCID = ltrim(rtrim(isnull(@PayCID,''))),
		@CustomerCID = ltrim(rtrim(isnull(@CustomerCID,''))),
		@Account = ltrim(rtrim(isnull(@Account,''))),
	
		@Jan = ltrim(rtrim(replace(replace(replace(isnull(@Jan,'0'),',','.'),SPACE(1),''),CHAR(160),''))),
		@Feb = ltrim(rtrim(replace(replace(replace(isnull(@Feb,'0'),',','.'),SPACE(1),''),CHAR(160),''))),
		@Mar = ltrim(rtrim(replace(replace(replace(isnull(@Mar,'0'),',','.'),SPACE(1),''),CHAR(160),''))),
		@Apr = ltrim(rtrim(replace(replace(replace(isnull(@Apr,'0'),',','.'),SPACE(1),''),CHAR(160),''))),
		@May = ltrim(rtrim(replace(replace(replace(isnull(@May,'0'),',','.'),SPACE(1),''),CHAR(160),''))),
		@Jun = ltrim(rtrim(replace(replace(replace(isnull(@Jun,'0'),',','.'),SPACE(1),''),CHAR(160),''))),
		@Jul = ltrim(rtrim(replace(replace(replace(isnull(@Jul,'0'),',','.'),SPACE(1),''),CHAR(160),''))),
		@Aug = ltrim(rtrim(replace(replace(replace(isnull(@Aug,'0'),',','.'),SPACE(1),''),CHAR(160),''))),
		@Sep = ltrim(rtrim(replace(replace(replace(isnull(@Sep,'0'),',','.'),SPACE(1),''),CHAR(160),''))),
		@Oct = ltrim(rtrim(replace(replace(replace(isnull(@Oct,'0'),',','.'),SPACE(1),''),CHAR(160),''))),
		@Nov = ltrim(rtrim(replace(replace(replace(isnull(@Nov,'0'),',','.'),SPACE(1),''),CHAR(160),''))),
		@Dec = ltrim(rtrim(replace(replace(replace(isnull(@Dec,'0'),',','.'),SPACE(1),''),CHAR(160),'')))
		

/************************************
ПРОВЕРКИ ВВЕДЕННЫХ ЗНАЧЕНИЙ
*************************************/
select
	@DocIDInt = DocIDInt,
	@UFT7 = cast(UserFieldText7 as varchar(4))
from dbo.Docs 
where DocID = @DocID
and ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_PLNTBL')

If @Act <> 3
BEGIN
	If @DocIDInt is null
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'<font color=red>ОШИБКА! </font> Системная ошибка! Некорректный ИД документа. Обратитесь к администратору СЭД.'
		goto NXT
	end
		
		
	if @PN <> ''
	begin
		if not exists (select 1 from dbo.Partners where Name = @PN)
		begin		
			select @ErrList = @ErrList + 
				'<font color=red>ОШИБКА! </font> В поле [Отправитель/Получатель] указано несуществующее значение.</font>' 
		end
	end	
		
	if @Obj <> ''
	begin
		set @Obj_code = dbo.PDX_SubstringReturn(@Obj, CHARINDEX('<',@Obj), CHARINDEX('>',@Obj))
		if not exists (select top 1 1 from dbo.UserDir_ISR where Code = @Obj_code)
		begin
			select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
				'<font color=red>ОШИБКА! </font> В поле [Объект] указано несуществующее значение.</font>' 
		end
	end
	
	set @Intrn2 = case @Intrn when 'ДА' then '1' when 'НЕТ' then '0' else '' end
	If @Intrn = ''
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'<font color=red>ОШИБКА! </font> Укажите значение признака "Внутр. обороты"'		
	end
	else If not @Intrn2 in ('1','0')
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'<font color=red>ОШИБКА! </font> Указано некорректное значение для признака "Внутр. обороты"'		
	end
	
	If @Item = ''
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'<font color=red>ОШИБКА! </font> Укажите Статью расходов'
	end
	else
	begin
		set @Year = 0
		if @UFT7 like '[0-9][0-9][0-9][0-9]' set @Year = CAST(@UFT7 as int)
		
		set @Item_code = dbo.PDX_SubstringReturn(@Item, CHARINDEX('<',@Item), CHARINDEX('>',@Item))
		
		if @Year <= 2015
		begin
			if not exists (select top 1 1 from dbo.PDX_pay_Items where Code = @Item_code)
			begin
				select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
					'<font color=red>ОШИБКА! </font> В поле [Статья расходов] указано несуществующее значение.</font>' 
			end
			
			if exists (select 1 from dbo.PDX_pay_Items where ParentID in (
			(select SetID from dbo.PDX_pay_Items where Code = @Item_code)))
			begin
				select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
						'<br><font color=red>ОШИБКА! </font> Статья расходов [' + @Item + '] не может быть указана (у нее есть "дочерние" элементы). Уточните статью расходов.</font>' 
			end
		end
		else
		begin
			if not exists (select top 1 1 from dbo.PDX_pay_Items2016 where Code = @Item_code)
			begin
				select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
					'<font color=red>ОШИБКА! </font> В поле [Статья расходов] указано несуществующее значение.</font>' 
			end
			
			if exists (select 1 from dbo.PDX_pay_Items2016 where ParentID in (
			(select SetID from dbo.PDX_pay_Items2016 where Code = @Item_code)))
			begin
				select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
						'<br><font color=red>ОШИБКА! </font> Статья расходов [' + @Item + '] не может быть указана (у нее есть "дочерние" элементы). Уточните статью расходов.</font>' 
			end	
		end
				
	end
	
	If @Name = ''
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'<font color=red>ОШИБКА! </font> Укажите Назначение платежа'
	end
	
	/*If @CustomerCID = ''
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'<font color=red>ОШИБКА! </font> Укажите № договора с Заказчиком'
	end
	else*/If @CustomerCID <> ''
	begin
		if not exists (select 1 from dbo.Docs where DocID = @CustomerCID and IsActive = 'Y' and ClassDoc like 'Договоры /%')
		begin
			select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
				'<font color=red>ОШИБКА! </font> Значение указанное в поле "№ договора с Заказчиком" не существует'
		end
	end
	
	if @PayCID <> ''
	begin
		if not exists (select 1 from dbo.Docs where DocID = @PayCID and IsActive = 'Y' and ClassDoc like 'Договоры /%')
		begin
			select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
				'<font color=red>ОШИБКА! </font> Значение указанное в поле "Оплата по договору №" не существует'
		end
	end
	
	If @Account = ''
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'<font color=red>ОШИБКА! </font> Укажите Счет'
	end
	else
	begin
		if not exists (select top 1 1 from dbo.PDX_pay_Accounts where Name = @Account)
		begin
			select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
				'<font color=red>ОШИБКА! </font> В поле [Счет] указано несуществующее значение.</font>' 
		end
	end
	
	If @Jan = '' set @Jan2 = 0
	If @Feb = '' set @Feb2 = 0
	If @Mar = '' set @Mar2 = 0
	If @Apr = '' set @Apr2 = 0
	If @May = '' set @May2 = 0
	If @Jun = '' set @Jun2 = 0
	If @Jul = '' set @Jul2 = 0
	If @Aug = '' set @Aug2 = 0
	If @Sep = '' set @Sep2 = 0
	If @Oct = '' set @Oct2 = 0
	If @Nov = '' set @Nov2 = 0
	If @Dec = '' set @Dec2 = 0
	
	if @Jan <> ''
	begin
	  if ISNUMERIC(@Jan) = 1
	  begin
		set @Jan2 = CAST(@Jan as money)
	  end
	  else
	  begin
  		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'<font color=red>ОШИБКА! </font> В поле "Январь" должно быть указано числовое значение'
		goto NXT
	  end 
	end
	
	if @Feb <> ''
	begin
	  if ISNUMERIC(@Feb) = 1
	  begin
		set @Feb2 = CAST(@Feb as money)
	  end
	  else
	  begin
  		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'<font color=red>ОШИБКА! </font> В поле "Февраль" должно быть указано числовое значение'
		goto NXT
	  end 
	end
		
	if @Mar <> ''
	begin
	  if ISNUMERIC(@Mar) = 1
	  begin
		set @Mar2 = CAST(@Mar as money)
	  end
	  else
	  begin
  		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'<font color=red>ОШИБКА! </font> В поле "Март" должно быть указано числовое значение'
		goto NXT
	  end 
	end
	
	if @Apr <> ''
	begin
	  if ISNUMERIC(@Apr) = 1
	  begin
		set @Apr2 = CAST(@Apr as money)
	  end
	  else
	  begin
  		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'<font color=red>ОШИБКА! </font> В поле "Апрель" должно быть указано числовое значение'
		goto NXT
	  end 
	end
	
	if @May <> ''
	begin
	  if ISNUMERIC(@May) = 1
	  begin
		set @May2 = CAST(@May as money)
	  end
	  else
	  begin
  		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'<font color=red>ОШИБКА! </font> В поле "Май" должно быть указано числовое значение'
		goto NXT
	  end 
	end
	
	if @Jun <> ''
	begin
	  if ISNUMERIC(@Jun) = 1
	  begin
		set @Jun2 = CAST(@Jun as money)
	  end
	  else
	  begin
  		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'<font color=red>ОШИБКА! </font> В поле "Июнь" должно быть указано числовое значение'
		goto NXT
	  end 
	end
	
	if @Jul <> ''
	begin
	  if ISNUMERIC(@Jul) = 1
	  begin
		set @Jul2 = CAST(@Jul as money)
	  end
	  else
	  begin
  		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'<font color=red>ОШИБКА! </font> В поле "Июль" должно быть указано числовое значение'
		goto NXT
	  end 
	end
	
	if @Aug <> ''
	begin
	  if ISNUMERIC(@Aug) = 1
	  begin
		set @Aug2 = CAST(@Aug as money)
	  end
	  else
	  begin
  		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'<font color=red>ОШИБКА! </font> В поле "Август" должно быть указано числовое значение'
		goto NXT
	  end 
	end
	
	if @Sep <> ''
	begin
	  if ISNUMERIC(@Sep) = 1
	  begin
		set @Sep2 = CAST(@Sep as money)
	  end
	  else
	  begin
  		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'<font color=red>ОШИБКА! </font> В поле "Сентябрь" должно быть указано числовое значение'
		goto NXT
	  end 
	end
	
	if @Oct <> ''
	begin
	  if ISNUMERIC(@Oct) = 1
	  begin
		set @Oct2 = CAST(@Oct as money)
	  end
	  else
	  begin
  		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'<font color=red>ОШИБКА! </font> В поле "Октябрь" должно быть указано числовое значение'
		goto NXT
	  end 
	end
	
	if @Nov <> ''
	begin
	  if ISNUMERIC(@Nov) = 1
	  begin
		set @Nov2 = CAST(@Nov as money)
	  end
	  else
	  begin
  		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'<font color=red>ОШИБКА! </font> В поле "Ноябрь" должно быть указано числовое значение'
		goto NXT
	  end 
	end
	
	if @Dec <> ''
	begin
	  if ISNUMERIC(@Dec) = 1
	  begin
		set @Dec2 = CAST(@Dec as money)
	  end
	  else
	  begin
  		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'<font color=red>ОШИБКА! </font> В поле "Декабрь" должно быть указано числовое значение'
		goto NXT
	  end 
	end
END
/************************************/

NXT:

If @Chk = 0
begin --если это создание , то нужно генерить ошибкуесли она есть
	If @ErrList <> '' 
	begin
		RAISERROR (@ErrList, 16,1)
		goto Err
	end
end
else --если это проверка просто выводим сообщение, даже если оно пустое
begin
	select @ErrList as ErrList 
end

IF @ErrList = '' and @Chk = 0
BEGIN
	if @Act = 2
	begin
		update dbo.DocsPLNTBL
			set 
				DocIDInt = @DocIDInt,
				PN = @PN,
				Intrn = @Intrn2,
				Obj = @Obj,
				Item = @Item,
				Name = @Name,
				PayCID = @PayCID,
				CustomerCID = @CustomerCID,
				Account = @Account,
				[Jan] = @Jan2,
				[Feb] = @Feb2,
				[Mar] = @Mar2,
				[Apr] = @Apr2,
				[May] = @May2,
				[Jun] = @Jun2,
				[Jul] = @Jul2,
				[Aug] = @Aug2 ,
				[Sep] = @Sep2,
				[Oct] = @Oct2,
				[Nov] = @Nov2,
				[Dec] = @Dec2,
				DC = GETDATE(),
				NC = @NC,
				NLM = @NC,
				DLM = getdate()
		where ID = @ID
	end

	If @Act = 1
	begin
		insert into dbo.DocsPLNTBL(
			DocIDInt,PN,Intrn,Obj,Item,Name,PayCID,CustomerCID,Account,
			[Jan],[Feb],[Mar],[Apr],[May],[Jun],[Jul],[Aug],[Sep],[Oct],[Nov],[Dec],
			DC,NC,DLM,NLM)
		values 
			(@DocIDInt,@PN,@Intrn2,@Obj,@Item,@Name,@PayCID,@CustomerCID,@Account,
			@Jan2,@Feb2,@Mar2,@Apr2,@May2,@Jun2,@Jul2,@Aug2,@Sep2,@Oct2,@Nov2,@Dec2,
			getdate(), @NC, getdate(), @NC)
	end

	If @Act = 3
	begin
		delete from  dbo.DocsPLNTBL where ID = @ID
	end
END
	
Err:


GO
/****** Object:  StoredProcedure [dbo].[PDX_DocToReconcile] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
create proc [dbo].[PDX_DocToReconcile]
	@UserID varchar(255)
as

declare @Result int
select @Result = 0

	SELECT  
		D.DocID, 
		D.ClassDoc, 
		C.UserID AS UserName, 
		D.Name AS Descr, 
        C.DateEvent,
		C.DateEventEnd
	FROM dbo.Docs AS D 
	INNER JOIN dbo.Comments AS C ON D.DocID = C.DocID 
			AND C.CommentType = 'VISA' 
			AND C.SpecialInfo = 'VISAWAITING' 
			AND C.UserID = @UserID
			AND CHARINDEX('<' + C.UserID + '>', D.ListToReconcile) > 0 
			AND CHARINDEX('<' + C.UserID + '>', D.ListReconciled) <= 0 
	WHERE UPPER(ISNULL(D.IsActive, '')) = 'Y'
		AND NOT (ISNULL(D.StatusCompletion, '') IN ('1', '0')) 
		AND D.StatusDevelopment <> 0
		AND NOT D.ListToReconcile like '%(#!)%'
		AND NOT D.ListToReconcile like '%(#$)%'
		AND CHARINDEX('<' + @UserID + '>', D.ListToReconcile) > 0 
		AND CHARINDEX('<' + @UserID + '>', D.ListReconciled) <= 0 		
	ORDER BY C.DateEvent
	select @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:
	
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_DogovorPoisk] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
create proc [dbo].[PDX_DogovorPoisk]
	@DateAF datetime = null,
	@DateAT datetime = null,
	@Type varchar(250) = '',
	@ActDoc varchar(250) = '',
	@Prj varchar(250) = '',
	@Code varchar(250) = '',
	@Name varchar(1024) = '',
	@IDInc varchar(250) = '',
	/*@DateBF datetime = null,
	@DateBT datetime = null,
	@DateEF datetime = null,
	@DateET datetime = null,*/
	@Partn varchar(1024) = '',
	@Appr varchar(250) = '',
	@Curr varchar(250) = '',
	@Am1 float = 0,
	@Am2 float = 0,	
	@Am3 float = 0,	
	@Am4 float = 0,
	@Curr1 varchar(250) = '',
	@Aut varchar(250)= '',
	@Dep varchar(250)= '',
	@Resp varchar(250)= '',
	@RecN varchar(250)= '',
	@Rec varchar(250)= '',
	@IDP varchar(250)= ''

as
	declare @Result int
	set @Result = 0
	
	declare @fAm1 float,@fAm2 float,@fAm3 float,@fAm4 float

	--select @Result = @@error if @Result <> 0 goto Err

	select * from Docs
	where /*(ClassDoc in (@ClassDoc))
	and*/ convert(datetime,convert(varchar(50),DateActivation,101),121) between @DateAF and @DateAT
	and (isnull(UserFieldText2,'') like '%' + @Type + '%' or @Type = '')
	and (isnull(ActDoc,'') like '%' + @ActDoc + '%' or @ActDoc = '')
	and (isnull(UserFieldText4,'') like '%' + @Prj + '%' or @Prj = '')
	and (isnull(UserFieldText7,'') like '%' + @Code + '%' or @Code = '')
	and (isnull(Name,'') like '%' + @Name + '%' or isnull(Description,'') like '%' + @Name + '%' or @Name = '')
	and (isnull(DocIdIncoming,'') like '%' + @IDInc + '%' or @IDInc = '')
	--and convert(datetime,convert(varchar(50),DateActivation,101),121) between @DateBF and @DateBT
	--and convert(datetime,convert(varchar(50),DateActivation,101),121) between @DateEF and @DateET
	and (isnull(PartnerName,'') like '%' + @Partn + '%' or isnull(UserFieldText8,'') like '%' + @Partn + '%' or isnull(UserFieldText6,'') like '%' + @Partn + '%' or @Partn = '')
	and (isnull(NameAproval,'') like '%' + @Appr + '%' or isnull(UserFieldText5,'') like '%' + @Appr + '%' or @Appr = '')
	and (isnull(Currency,'') like '%' + @Curr + '%' or @Curr = '')
	and (AmountDoc between @Am1 and @Am2 or (@Am1 = 0 and @Am2 =0))
	and (AmountDoc between @Am3 and @Am4 or (@Am3 = 0 and @Am4 =0))
	and (isnull(UserFieldText3,'') like '%' + @Curr1 + '%' or @Curr1 = '')
	and (isnull(Author,'') like '%' + @Aut + '%' or @Aut = '')
	and (isnull(Department,'') like '%' + @Dep + '%' or @Dep = '')
	and (isnull(NameResponsible,'') like '%' + @Resp + '%' or @Resp = '')
	and (isnull(UserFieldText1,'') like '%' + @RecN + '%' or @RecN = '')
	and (isnull(ListToReconcile,'') like '%' + @Rec + '%' or @Rec = '')
	and (isnull(DocIDParent,'') like '%' + @IDP + '%' or @IDP = '')

	and ClassDoc like 'Договоры / (%'
	--select @Result = @@error if @Result <> 0 goto Err
--DateCompletion


	--return @Result
--Err:
	--return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_DogovorSumCalc] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_DogovorSumCalc]
	@DocID varchar(128)
as
	declare @Result int
	set @Result = 0
	
	declare @DocIDParent varchar(128),
			@AmountDoc money,
			@IsExists bit,
			@NameTotal varchar(50),
			@NameTotalA varchar(50),
			@NameTotalS varchar(50),
			@MainDocID varchar(128),
			@Count int
	
	select
		@NameTotal  = 'ВСЕГО ЗАРЕГ.',
		@NameTotalA = 'ВСЕГО ПОДП.',
		@NameTotalS = 'ВСЕГО'

	declare @TmpDog table 
		(DocID varchar(255), 
		DocIDParent varchar(255),
		AmountDoc money,
		Currency varchar(255),
		/*FullAmount money,
		Currency2 varchar(255),
		FullAmountS money,
		Currency2S varchar(255),
		FullAmountA money,
		Currency2A varchar(255),*/
		StatusI int,
		Status varchar(255),
		OI int default 0,
		DateApp datetime,
		DateAct datetime,
		DateReg datetime,
		DateActivation datetime)
--StatusI
	-- = -1 неопределено
	-- = 0 отменен
	-- = 1 неактивен
	-- = 2 на согласовании
	-- = 3 утвержден
	-- = 4 зарегистрирован

	--формируем полный список документов, кот. будут учавствовать в расчете

	--попробуем "добраться" до самого верхнего
	select top 1
		@DocIDParent = DocIDParent,
		@MainDocID = DocID--case isnull(DocIDParent,'') when '' then DocID else DocIDParent end
	from dbo.Docs with (nolock)
	where DocID = @DocID
		and ClassDoc like 'Договоры / %'	
	select @Result = @@error if @Result <> 0 goto Err

	--и поднимаемся вверх
	while isnull(@DocIDParent,'') <> ''
	begin
		select
			@MainDocID = @DocIDParent,
			@DocIDParent = DocIDParent
		from dbo.Docs with (nolock)	
		where DocID = @DocIDParent
			and ClassDoc like 'Договоры / %'	
		select @Result = @@error if @Result <> 0 goto Err
	end

	if isnull(@MainDocID,'') <> ''
	begin
	--заносим в "результат" исходный документ
		insert into @TmpDog
			(DocID, DocIDParent, AmountDoc,Currency,StatusI, DateApp, DateAct, DateActivation)
		select 
			DocID, isnull(DocIDParent, ''), isnull(AmountDoc,0), Currency, 
			/*case
				when isnull(StatusCompletion,'') = '0'
					then 0 --отменен
				when isnull(StatusCompletion,'') <> '0'
					and isnull(upper(isActive),'') = 'Y'
					and StatusDevelopment = 4
					and isnull(LocationPath,'') like '%+%'
					then 4 --зарегистрирован
				when isnull(StatusCompletion,'') <> '0'
					and isnull(upper(isActive),'') = 'Y'
					and StatusDevelopment = 4
					and not isnull(LocationPath,'') like '%+%'
					and dbo.PDX_SubstringReturn(isnull(LocationPath,''),charindex('<',isnull(LocationPath,'')),charindex('>',isnull(LocationPath,''))) = ''
					then 5 --утвержден. не требует регистрации
				when isnull(StatusCompletion,'') <> '0'
					and isnull(upper(isActive),'') = 'Y'
					and StatusDevelopment = 4
					and not isnull(LocationPath,'') like '%+%'
					and dbo.PDX_SubstringReturn(isnull(LocationPath,''),charindex('<',isnull(LocationPath,'')),charindex('>',isnull(LocationPath,''))) <> ''
					then 3 --утвержден. требует регистрации
				when isnull(StatusCompletion,'') <> '0'
					and isnull(upper(isActive),'') = 'Y'
					and StatusDevelopment <> 4
					then 2 --  на соглаосвании
				when isnull(StatusCompletion,'') <> '0'
					and isnull(upper(isActive),'') <> 'Y'
					then 1 --неактивен
				else -1 --неопределено
			end,*/
			cast(dbo.REC_DocStatusRead (2,isActive,StatusCompletion,StatusDevelopment,ListToReconcile,ListReconciled,LocationPath) as int),
			DateApproved, DateActive, DateActivation
		from dbo.Docs with (nolock)
		where DocID = @MainDocID
			and ClassDoc like 'Договоры / %'		
		select @Result = @@error if @Result <> 0 goto Err

		--идем "вниз"
		select @Count = 1
		while @Count <> 0
		begin
			insert into @TmpDog
				(DocID, DocIDParent, AmountDoc, Currency, StatusI, DateApp, DateAct, DateActivation)
			select
				D.DocID, isnull(D.DocIDParent,''), isnull(D.AmountDoc,0), D.Currency, 
				/*case
					when isnull(D.StatusCompletion,'') = '0'
						then 0 --отменен
					when isnull(D.StatusCompletion,'') <> '0'
						and isnull(upper(D.isActive),'') = 'Y'
						and D.StatusDevelopment = 4
						and isnull(D.LocationPath,'') like '%+%'
						then 4 --зарегистрирован
					when isnull(D.StatusCompletion,'') <> '0'
						and isnull(upper(D.isActive),'') = 'Y'
						and D.StatusDevelopment = 4
						and not isnull(D.LocationPath,'') like '%+%'
						and dbo.PDX_SubstringReturn(isnull(D.LocationPath,''),charindex('<',isnull(D.LocationPath,'')),charindex('>',isnull(D.LocationPath,''))) = ''
						then 5 --утвержден. не требует регистрации
					when isnull(D.StatusCompletion,'') <> '0'
						and isnull(upper(D.isActive),'') = 'Y'
						and D.StatusDevelopment = 4
						and not isnull(D.LocationPath,'') like '%+%'
						and dbo.PDX_SubstringReturn(isnull(D.LocationPath,''),charindex('<',isnull(D.LocationPath,'')),charindex('>',isnull(D.LocationPath,''))) <> ''
						then 3 --утвержден. требует регистрации
					when isnull(D.StatusCompletion,'') <> '0'
						and isnull(upper(D.isActive),'') = 'Y'
						and D.StatusDevelopment <> 4
						then 2 --  на соглаосвании
					when isnull(D.StatusCompletion,'') <> '0'
						and isnull(upper(D.isActive),'') <> 'Y'
						then 1 --неактивен
					else -1 --неопределено
				end,*/
				cast(dbo.REC_DocStatusRead (2,D.isActive,D.StatusCompletion,D.StatusDevelopment,D.ListToReconcile,D.ListReconciled,D.LocationPath) as int),
				D.DateApproved, D.DateActive, D.DateActivation
			from dbo.Docs D with (nolock)
			inner join @TmpDog X on X.DocID = D.DocIDParent
			where D.ClassDoc like 'Договоры / %'
				and not exists (select 1 from @TmpDog T where T.DocID = D.DocID)
			select @Count = @@rowcount, @Result = @@error if @Result <> 0 goto Err		
		end

		--получаем полную сумму
		update T --получаем последнюю дату нажатия на кнопку "зарегистрировать/регистрация"
			set DateReg = R.DC
		from @TmpDog T
		inner join (
		select DocID, max(DateCreation) DC from dbo.Comments with (nolock) where CommentType = 'HISTORY'
			and Comment like 'Документ зарегистрирован , Информация изменена -%'
		group by DocID
		) R on R.DocID = T.DocID
		where T.StatusI = 6
		select @Result = @@error if @Result <> 0 goto Err	
	
		--показываем сумму по каждому документу
		update @TmpDog
			set
				/*Status = case StatusI
							when -1
								then 'неопределено.'
							when 0
								then 'отменен.'
							when 1
								then 'неактивен.'
							when 2
								then 'на согласовании.'
							when 3
								then 'утвержден. требует регистрации.'
							when 5
								then 'утвержден. не требует регистрации.'
							when 4
								then 'зарегистрирован.'
						end,*/
				Status = case StatusI
							when 0
								then 'Неактивен (черновик).'
							when -2
								then 'Отменен.'
							when -1
								then 'Отказано в подписании.'
							when 5
								then 'Подписан. Не требует регистрации.'
							when 4
								then 'Подписан. Требует регистрации.'
							when 6
								then 'Подписан. Зарегистрирован.'
							when 3
								then 'Требует подписания.'
							when 2	
								then 'На доработке (приостановлен).'
							when 1
								then 'Требует согласования.'
							else --when -3
								'НЕОПРЕДЕЛЕН'
						end,
				DateAct = case 
							when StatusI <= 3 
								then DateAct 
							when StatusI in (4,5) 
								then DateApp
							when StatusI >= 6
								then DateReg
							else null 
						  end,
				DateActivation = case when StatusI < 4 then null else DateActivation end
		select @Result = @@error if @Result <> 0 goto Err		

	end
	select @Result = @@error if @Result <> 0 goto Err		

	--сумма по документам на согласовании
	insert into @TmpDog
		(DocID, DocIDParent, AmountDoc, Currency, OI)
	select
		'',@NameTotalS + ' [' + Currency + ']:',sum(isnull(AmountDoc,0)), Currency, 1
	from @TmpDog
	where StatusI >= 1--неактивные, отмененые и отказные не рассматриваем
	group by Currency
	select @Result = @@error if @Result <> 0 goto Err		
	--сумма по утвержденным документам
	insert into @TmpDog
		(DocID, DocIDParent, AmountDoc, Currency, OI)
	select
		'',@NameTotalA + ' [' + Currency + ']:',sum(case when StatusI >= 4 then isnull(AmountDoc,0) else 0 end),Currency, 2
	from @TmpDog
	where StatusI >= 1 --неактивные и отмененые не рассматриваем
	group by Currency
	select @Result = @@error if @Result <> 0 goto Err		
	--сумма по зарегистрированным документам
	insert into @TmpDog
		(DocID, DocIDParent, AmountDoc, Currency, OI)
	select
		'',@NameTotal + ' [' + Currency + ']:',sum(case when StatusI >= 5 then isnull(AmountDoc,0) else 0 end), Currency, 3
	from @TmpDog
	where StatusI >= 1--неактивные и отмененые не рассматриваем
	group by Currency
	select @Result = @@error if @Result <> 0 goto Err		

	select
		DocID, DocIDParent, 
		convert(varchar(100),AmountDoc,1) + ' ' + Currency as 'AmountDoc',
		case when OI=0 and isnull(DocID,'')<>'' then '(' + isnull(convert(varchar(100),DateAct,104),'-') + ')' else '' end as DateAct, 
		case when OI=0 and isnull(DocID,'')<>'' then isnull(convert(varchar(100),DateActivation,104),'') else '' end as DateReg,
		Status, OI
	from @TmpDog
	where StatusI > 0 or StatusI is null--неактивные и отмененые не рассматриваем (и суммы не забываем)
	order by 
	case when OI = 0 and isnull(DocIDParent,'') = '' then 0 else 1 end,
	OI,DocID,DocIDParent
	select @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:
	return @Result

GO
/****** Object:  StoredProcedure [dbo].[PDX_EDS_BPLink] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_EDS_BPLink]
	@DocID varchar(128),
	@UserID varchar(128) = null,
	@UserName varchar(256) = null,
	--@Comment varchar(1024) = null,
	--@Comment2 varchar(1024) = null,
	@ExtDocID varchar(64),
	@ClassDoc varchar(255),
	@ClassLink varchar(255),
	@RIK_CT varchar(50) = null,
	@cre_flag bit
as

declare @Result int
select @Result = 0

declare @Comment varchar(1024) ,
		@Comment2 varchar(1024)

if isnull(@DocID,'') = ''
begin
	select '<font color=red>Ошибка!</font> Не указан исходный документ. Для устранения ошибки обратитесь к администратору СЭД.' as Err
	goto OK
end
select @Result = @@error if @Result <> 0 goto Err

if isnull(@ExtDocID,'') = ''
begin
	select '<font color=red>Ошибка!</font> Не указан документ-ссылка.' as Err
	goto OK
end
select @Result = @@error if @Result <> 0 goto Err

if isnull(@ClassDoc,'') = ''
begin
	select '<font color=red>Ошибка!</font> Не указана категория исходного документа. Для устранения ошибки обратитесь к администратору СЭД.' as Err
	goto OK
end
select @Result = @@error if @Result <> 0 goto Err

if isnull(@ClassLink,'') = ''
begin
	select '<font color=red>Ошибка!</font> Не указана категория документа-ссылки. Для устранения ошибки обратитесь к администратору СЭД.' as Err
	goto OK
end
select @Result = @@error if @Result <> 0 goto Err

If not exists (select 1 from dbo.Docs where DocID = @DocID and ClassDoc = @ClassDoc)
begin
	select '<font color=red>Ошибка!</font> Исходный документ не существует (или выбран документ недопустимой категории).' as Err
	goto OK
end
select @Result = @@error if @Result <> 0 goto Err

If not exists (select 1 from dbo.Docs where DocID = @ExtDocID and ClassDoc = @ClassLink)
begin
	select '<font color=red>Ошибка!</font> Документ, на который Вы ссылаетесь не существует (или выбран документ недопустимой категории).' as Err
	goto OK
end
select @Result = @@error if @Result <> 0 goto Err

If exists (select 1 from dbo.Comments where Subject = @ExtDocID
										and DocID = @DocID) 
begin
	select '<font color=red>Ошибка!</font> Указанная ссылка уже существует.' as Err
	goto OK
end
select @Result = @@error if @Result <> 0 goto Err


If exists (select 1 from dbo.Comments where Subject = @DocID
										and DocID = @ExtDocID) 
begin
	select '<font color=red>Ошибка!</font> Указанная обратная ссылка уже существует.' as Err
	goto OK
end
select @Result = @@error if @Result <> 0 goto Err

If not isnull(@RIK_CT,'') in ('RIK_LINK_IN','RIK_LINK_OUT')
begin
	select '<font color=red>Ошибка!</font> Указан недопустимый (rik)тип ссылки. Для устранения ошибки обратитесь к администратору СЭД.' as Err
	goto OK
end
select @Result = @@error if @Result <> 0 goto Err

If @cre_flag = 1 --если нужно создавать
begin
	
	if isnull(@UserID,'') = ''
	begin
		select '<font color=red>Ошибка!</font> Не указан логин пользователя. Для устранения ошибки обратитесь к администратору СЭД.' as Err
		goto OK
	end
	select @Result = @@error if @Result <> 0 goto Err

	if isnull(@UserName,'') = ''
	begin
		select '<font color=red>Ошибка!</font> Не указано имя пользователя. Для устранения ошибки обратитесь к администратору СЭД.' as Err
		goto OK
	end
	select @Result = @@error if @Result <> 0 goto Err

	/*if isnull(@Comment,'') = ''
	begin
		select '<font color=red>Ошибка!</font> Не указан комментарий.' as Err
		goto OK
	end
	select @Result = @@error if @Result <> 0 goto Err

	if isnull(@Comment2,'') = ''
	begin
		select '<font color=red>Ошибка!</font> Не указан обратный комментарий.' as Err
		goto OK
	end
	select @Result = @@error if @Result <> 0 goto Err*/

	select @Comment = case @RIK_CT when 'RIK_LINK_IN' then 'БП ПРИНИМАЮЩИЙ: ' when 'RIK_LINK_OUT' then 'БП ПЕРЕДАЮЩИЙ: ' else '' end + isnull(Name,'')
	from dbo.Docs where DocID = @ExtDocID
	select @Result = @@error if @Result <> 0 goto Err

	select @Comment2 = cast(isnull(Description,'') as varchar(1024))
	from dbo.Docs where DocID = @DocID
	select @Result = @@error if @Result <> 0 goto Err

	select @Comment = isnull(@Comment,''), @Comment2 = isnull(@Comment2,'')
	select @Result = @@error if @Result <> 0 goto Err

	insert into dbo.Comments
		(UserID,
		UserName,
		ContactUserName,
		ContactUserID,
		PartnerName,
		DocID,
		DateCreation,
		DateEvent,
		DateEventEnd,
		Address,
		Subject,
		Comment,
		CommentType,
		SpecialInfo,
		FileName,
		--KeyField,
		PartnerID,
		Version,
		GUID,
		GUIDPartner,
		GUIDUser,
		GUIDDoc,
		Amount,
		RIK_CommentType)
	values
		(@UserID,
		@UserName,
		null,--ContactUserName,
		null,--,
		'',--PartnerName,
		@DocID,
		getdate(),--DateCreation,
		null,--DateEvent,
		null,--DateEventEnd,
		'',--Address,
		@ExtDocID,--Subject,
		@Comment,--Comment,
		'LINK',--CommentType,
		'',--SpecialInfo,
		null,--FileName,
		--KeyField,
		null,--PartnerID,
		'',--Version,
		newID(),--GUID,
		null,--GUIDPartner,
		null,--GUIDUser,
		null,--GUIDDoc,
		0,--Amount)	
		@RIK_CT)
	select @Result = @@error if @Result <> 0 goto Err

	insert into dbo.Comments
		(UserID,
		UserName,
		ContactUserName,
		ContactUserID,
		PartnerName,
		DocID,
		DateCreation,
		DateEvent,
		DateEventEnd,
		Address,
		Subject,
		Comment,
		CommentType,
		SpecialInfo,
		FileName,
		--KeyField,
		PartnerID,
		Version,
		GUID,
		GUIDPartner,
		GUIDUser,
		GUIDDoc,
		Amount,
		RIK_CommentType)
	values
		(@UserID,
		@UserName,
		null,--ContactUserName,
		null,--,
		'',--PartnerName,
		@ExtDocID,
		getdate(),--DateCreation,
		null,--DateEvent,
		null,--DateEventEnd,
		'',--Address,
		@DocID,--Subject,
		@Comment2,--Comment,
		'LINK',--CommentType,
		'',--SpecialInfo,
		null,--FileName,
		--KeyField,
		null,--PartnerID,
		'',--Version,
		newID(),--GUID,
		null,--GUIDPartner,
		null,--GUIDUser,
		null,--GUIDDoc,
		0,--Amount)	
		null)
	select @Result = @@error if @Result <> 0 goto Err
end
	
	select '' as Err
	select @Result = @@error if @Result <> 0 goto Err

OK:
	return @Result
Err:
	
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_EDS_ExtLink] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_EDS_ExtLink]
	@DocID varchar(128),
	@Link varchar(1024),
	@UserID varchar(128),
	@UserName varchar(256),
	@Comment varchar(1024),
	@ExtDocID varchar(64)
as

declare @Result int
select @Result = 0

If exists (select 1 from dbo.Docs where DocID = @DocID)
begin
If not exists (select 1 from dbo.Comments where Subject = @Link
					and DocID = @DocID) 
	begin
	insert into dbo.Comments
		(UserID,
		UserName,
		ContactUserName,
		ContactUserID,
		PartnerName,
		DocID,
		DateCreation,
		DateEvent,
		DateEventEnd,
		Address,
		Subject,
		Comment,
		CommentType,
		SpecialInfo,
		FileName,
		--KeyField,
		PartnerID,
		Version,
		GUID,
		GUIDPartner,
		GUIDUser,
		GUIDDoc,
		Amount)
	values
		(@UserID,
		@UserName,
		null,--ContactUserName,
		null,--,
		'',--PartnerName,
		@DocID,
		getdate(),--DateCreation,
		null,--DateEvent,
		null,--DateEventEnd,
		'',--Address,
		@Link,--Subject,
		@Comment,--Comment,
		'LINK',--CommentType,
		'',--SpecialInfo,
		null,--FileName,
		--KeyField,
		null,--PartnerID,
		@ExtDocID,--'',--Version,
		newID(),--GUID,
		null,--GUIDPartner,
		null,--GUIDUser,
		null,--GUIDDoc,
		0)--Amount)
	
		select @Result = @@error if @Result <> 0 goto Err
	    select '0' as Err
	    select @Result = @@error if @Result <> 0 goto Err
	end
	else
	begin
	    select '2' as Err
	    select @Result = @@error if @Result <> 0 goto Err
	end
end
else
begin
   select '1' as Err
   select @Result = @@error if @Result <> 0 goto Err 
end
	return @Result
Err:
	
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_EDS_FinLink] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[PDX_EDS_FinLink]
	@DocID varchar(128),
	@UserID varchar(128) = null,
	@UserName varchar(256) = null,
	@ExtDocID varchar(64),
	@ClassDoc varchar(255),
	@ClassLink varchar(255),
	@cre_flag bit
as

declare @Result int
select @Result = 0

declare @Comment varchar(1024) ,
		@Comment2 varchar(1024),
		@UFT2 varchar(1024),
		@UFT5 varchar(1024),
		@Currency varchar(12)

if isnull(@DocID,'') = ''
begin
	select '<font color=red>Ошибка!</font> Не указан исходный документ. Для устранения ошибки обратитесь к администратору СЭД.' as Err
	goto OK
end
select @Result = @@error if @Result <> 0 goto Err

select @UFT2 = UserFieldText2,
		@UFT5 = UserFieldText5,
		@Currency = Currency
from dbo.Docs
where DocID = @DocID
select @Result = @@error if @Result <> 0 goto Err

if isnull(@ExtDocID,'') = ''
begin
	select '<font color=red>Ошибка!</font> Не указан документ-ссылка.' as Err
	goto OK
end
select @Result = @@error if @Result <> 0 goto Err

if isnull(@ClassDoc,'') = ''
begin
	select '<font color=red>Ошибка!</font> Не указана категория исходного документа. Для устранения ошибки обратитесь к администратору СЭД.' as Err
	goto OK
end
select @Result = @@error if @Result <> 0 goto Err

if isnull(@ClassLink,'') = ''
begin
	select '<font color=red>Ошибка!</font> Не указана категория документа-ссылки. Для устранения ошибки обратитесь к администратору СЭД.' as Err
	goto OK
end
select @Result = @@error if @Result <> 0 goto Err

If not exists (select 1 from dbo.Docs where DocID = @DocID and ClassDoc = @ClassDoc)
begin
	select '<font color=red>Ошибка!</font> Исходный документ не существует (или выбран документ недопустимой категории).' as Err
	goto OK
end
select @Result = @@error if @Result <> 0 goto Err

If not isnull(@ClassLink,'') in (dbo.PDX_CLSGet('RIK_CategoryName_FIN_PLNPAY'),dbo.PDX_CLSGet('RIK_CategoryName_FIN_CORPAY'))
begin
	select '<font color=red>Ошибка!</font> Вы ссылаетесь на документ недопустимой категории. Исправьте номер докмуента.' as Err
	goto OK
end
select @Result = @@error if @Result <> 0 goto Err

If not exists (select 1 from dbo.Docs where DocID = @ExtDocID and ClassDoc = @ClassLink)
begin
	select '<font color=red>Ошибка!</font> Документ, на который Вы ссылаетесь не существует (или выбран документ недопустимой категории).' as Err
	goto OK
end
else If not exists (select 1 from dbo.Docs where DocID = @ExtDocID and ClassDoc = @ClassLink
						and @UFT2 = case ClassDoc when dbo.PDX_CLSGet('RIK_CategoryName_FIN_CORPAY') then UserFieldText3 else UserFieldText2 end 
						and @UFT5 = case ClassDoc when dbo.PDX_CLSGet('RIK_CategoryName_FIN_CORPAY') then UserFieldText7 else UserFieldText5 end
						and MONTH(GETDATE()) = MONTH(case ClassDoc when dbo.PDX_CLSGet('RIK_CategoryName_FIN_CORPAY') then UserFieldDate3 else UserFieldDate1 end)
						and YEAR(GETDATE()) = YEAR(case ClassDoc when dbo.PDX_CLSGet('RIK_CategoryName_FIN_CORPAY') then UserFieldDate3 else UserFieldDate1 end)
						and @Currency = Currency)
begin
	select '<font color=red>Ошибка!</font> Документ, на который Вы ссылаетесь, не соответствует данному документу по ЦФО и/или статье расходов и/или валюте и/или не относится к текущему периоду.' as Err
	goto OK
end
select @Result = @@error if @Result <> 0 goto Err

If exists (select 1 from dbo.Comments where Subject = @ExtDocID
										and CommentType = 'LINK'
										and DocID = @DocID) 
begin
	select '<font color=red>Ошибка!</font> Ссылка на указанный документ уже существует.' as Err
	goto OK
end
select @Result = @@error if @Result <> 0 goto Err

If exists (select 1 from dbo.Comments where DocID = @DocID
				and CommentType = 'LINK'
				and ISNULL(RIK_CommentType,'') in (dbo.PDX_CLSGet('RIK_CategoryName_FIN_PLNPAY'),dbo.PDX_CLSGet('RIK_CategoryName_FIN_CORPAY'))) 
begin
	select '<font color=red>Ошибка!</font> В карточке может быть только одна типизированная ссылка на ПЗ или КЗ.' as Err
	goto OK
end
select @Result = @@error if @Result <> 0 goto Err


If @cre_flag = 1 --если нужно создавать
begin
	
	if isnull(@UserID,'') = ''
	begin
		select '<font color=red>Ошибка!</font> Не указан логин пользователя. Для устранения ошибки обратитесь к администратору СЭД.' as Err
		goto OK
	end
	select @Result = @@error if @Result <> 0 goto Err

	if isnull(@UserName,'') = ''
	begin
		select '<font color=red>Ошибка!</font> Не указано имя пользователя. Для устранения ошибки обратитесь к администратору СЭД.' as Err
		goto OK
	end
	select @Result = @@error if @Result <> 0 goto Err

	select @Comment = case @ClassLink when dbo.PDX_CLSGet('RIK_CategoryName_FIN_PLNPAY') then 'ПЛАНОВАЯ ЗАЯВКА: ' when dbo.PDX_CLSGet('RIK_CategoryName_FIN_CORPAY') then 'КОРРЕКТИРУЮЩАЯ ЗАЯВКА: ' else '' end + isnull(Name,'')
	from dbo.Docs where DocID = @ExtDocID
	select @Result = @@error if @Result <> 0 goto Err

	select @Comment = '#red#bold' +isnull(@Comment,'')
	select @Result = @@error if @Result <> 0 goto Err

	insert into dbo.Comments
		(UserID,
		UserName,
		ContactUserName,
		ContactUserID,
		PartnerName,
		DocID,
		DateCreation,
		DateEvent,
		DateEventEnd,
		Address,
		Subject,
		Comment,
		CommentType,
		SpecialInfo,
		FileName,
		--KeyField,
		PartnerID,
		Version,
		GUID,
		GUIDPartner,
		GUIDUser,
		GUIDDoc,
		Amount,
		RIK_CommentType)
	values
		(@UserID,
		@UserName,
		null,--ContactUserName,
		null,--,
		'',--PartnerName,
		@DocID,
		getdate(),--DateCreation,
		null,--DateEvent,
		null,--DateEventEnd,
		'',--Address,
		@ExtDocID,--Subject,
		@Comment,--Comment,
		'LINK',--CommentType,
		'',--SpecialInfo,
		null,--FileName,
		--KeyField,
		null,--PartnerID,
		'',--Version,
		newID(),--GUID,
		null,--GUIDPartner,
		null,--GUIDUser,
		null,--GUIDDoc,
		0,--Amount)	
		@ClassLink)
	select @Result = @@error if @Result <> 0 goto Err

end
	
	select '' as Err
	select @Result = @@error if @Result <> 0 goto Err

OK:
	return @Result
Err:
	
	return @Result



GO
/****** Object:  StoredProcedure [dbo].[PDX_EDS_KazLink] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_EDS_KazLink]
	@DocID varchar(128),
	@UserID varchar(128) = null,
	@UserName varchar(256) = null,
	@ExtDocID varchar(64),
	@ClassDoc varchar(255),
	@ClassLink varchar(255),
	@cre_flag bit
as

declare @Result int
select @Result = 0

declare @Comment varchar(1024) ,
		@Comment2 varchar(1024),
		@UFT2 varchar(1024),
		@UFT5 varchar(1024),
		@Currency varchar(12)

if isnull(@DocID,'') = ''
begin
	select '<font color=red>Ошибка!</font> Не указан исходный документ. Для устранения ошибки обратитесь к администратору СЭД.' as Err
	goto OK
end
select @Result = @@error if @Result <> 0 goto Err

select @UFT2 = UserFieldText2,
		@UFT5 = UserFieldText5,
		@Currency = Currency
from dbo.Docs
where DocID = @DocID
select @Result = @@error if @Result <> 0 goto Err

set @UFT5 = dbo.PDX_SubstringReturn(@UFT5, charindex('<', @UFT5), charindex('>', @UFT5))

if isnull(@ExtDocID,'') = ''
begin
	select '<font color=red>Ошибка!</font> Не указан документ-ссылка.' as Err
	goto OK
end
select @Result = @@error if @Result <> 0 goto Err

if isnull(@ClassDoc,'') = ''
begin
	select '<font color=red>Ошибка!</font> Не указана категория исходного документа. Для устранения ошибки обратитесь к администратору СЭД.' as Err
	goto OK
end
select @Result = @@error if @Result <> 0 goto Err

if isnull(@ClassLink,'') = ''
begin
	select '<font color=red>Ошибка!</font> Не указана категория документа-ссылки. Для устранения ошибки обратитесь к администратору СЭД.' as Err
	goto OK
end
select @Result = @@error if @Result <> 0 goto Err

If not exists (select 1 from dbo.Docs where DocID = @DocID and ClassDoc = @ClassDoc)
begin
	select '<font color=red>Ошибка!</font> Исходный документ не существует (или выбран документ недопустимой категории).' as Err
	goto OK
end
select @Result = @@error if @Result <> 0 goto Err

If not isnull(@ClassLink,'') in (dbo.PDX_CLSGet('RIK_CategoryName_KAZ_PLNPAY'),dbo.PDX_CLSGet('RIK_CategoryName_KAZ_CORPAY'), dbo.PDX_CLSGet('RIK_CategoryName_KAZ_PLNTBL'))
begin
	select '<font color=red>Ошибка!</font> Вы ссылаетесь на документ недопустимой категории. Исправьте номер документа.' as Err
	goto OK
end
select @Result = @@error if @Result <> 0 goto Err

--select @UFT5
If not exists (select 1 from dbo.Docs where DocID = @ExtDocID and ClassDoc = @ClassLink)
begin
	select '<font color=red>Ошибка!</font> Документ, на который Вы ссылаетесь не существует (или выбран документ недопустимой категории).' as Err
	goto OK
end
/*else If not exists (select 1 from dbo.Docs where DocID = @ExtDocID and ClassDoc = @ClassLink
						and @UFT2 = case ClassDoc when dbo.PDX_CLSGet('RIK_CategoryName_KAZ_CORPAY') then UserFieldText3 else UserFieldText2 end 
						--and @UFT5 = case ClassDoc when dbo.PDX_CLSGet('RIK_CategoryName_KAZ_CORPAY') then UserFieldText7 else UserFieldText5 end
						and case ClassDoc when dbo.PDX_CLSGet('RIK_CategoryName_KAZ_CORPAY') then UserFieldText7 else UserFieldText5 end like '%<' + @UFT5 + '>%'
						and MONTH(GETDATE()) = MONTH(case ClassDoc when dbo.PDX_CLSGet('RIK_CategoryName_KAZ_CORPAY') then UserFieldDate3 else UserFieldDate1 end)
						and YEAR(GETDATE()) = YEAR(case ClassDoc when dbo.PDX_CLSGet('RIK_CategoryName_KAZ_CORPAY') then UserFieldDate3 else UserFieldDate1 end)
						and @Currency = Currency)
begin
	select '<font color=red>Ошибка!</font> Документ, на который Вы ссылаетесь, не соответствует данному документу по ЦФО и/или статье расходов и/или валюте и/или не относится к текущему периоду.' as Err
	goto OK
end*/
select @Result = @@error if @Result <> 0 goto Err

If exists (select 1 from dbo.Comments where Subject = @ExtDocID
										and CommentType = 'LINK'
										and DocID = @DocID) 
begin
	select '<font color=red>Ошибка!</font> Ссылка на указанный документ уже существует.' as Err
	goto OK
end
select @Result = @@error if @Result <> 0 goto Err

If exists (select 1 from dbo.Comments where DocID = @DocID
				and CommentType = 'LINK'
				and ISNULL(RIK_CommentType,'') in (dbo.PDX_CLSGet('RIK_CategoryName_KAZ_PLNPAY'),dbo.PDX_CLSGet('RIK_CategoryName_KAZ_CORPAY'),
				dbo.PDX_CLSGet('RIK_CategoryName_KAZ_PLNTBL'))) 
begin
	select '<font color=red>Ошибка!</font> В карточке может быть только одна типизированная ссылка на ПЗ, КЗ или ПБ.' as Err
	goto OK
end
select @Result = @@error if @Result <> 0 goto Err


If @cre_flag = 1 --если нужно создавать
begin
	
	if isnull(@UserID,'') = ''
	begin
		select '<font color=red>Ошибка!</font> Не указан логин пользователя. Для устранения ошибки обратитесь к администратору СЭД.' as Err
		goto OK
	end
	select @Result = @@error if @Result <> 0 goto Err

	if isnull(@UserName,'') = ''
	begin
		select '<font color=red>Ошибка!</font> Не указано имя пользователя. Для устранения ошибки обратитесь к администратору СЭД.' as Err
		goto OK
	end
	select @Result = @@error if @Result <> 0 goto Err

	select @Comment = case @ClassLink 
						when dbo.PDX_CLSGet('RIK_CategoryName_KAZ_PLNPAY') then 'ПЛАНОВАЯ ЗАЯВКА: ' 
						when dbo.PDX_CLSGet('RIK_CategoryName_KAZ_CORPAY') then 'КОРРЕКТИРУЮЩАЯ ЗАЯВКА: ' 
						when dbo.PDX_CLSGet('RIK_CategoryName_KAZ_PLNTBL') then 'ПЛАНОВЫЙ БЮДЖЕТ: ' 
						else '' end + 
						case @ClassLink 
						when dbo.PDX_CLSGet('RIK_CategoryName_KAZ_PLNTBL') then 'от ' + convert(varchar(100),UserFieldDate3,104)
						else isnull(Name,'')
						end
						
	from dbo.Docs where DocID = @ExtDocID
	select @Result = @@error if @Result <> 0 goto Err

	select @Comment = '#red#bold' +isnull(@Comment,'')
	select @Result = @@error if @Result <> 0 goto Err

	insert into dbo.Comments
		(UserID,
		UserName,
		ContactUserName,
		ContactUserID,
		PartnerName,
		DocID,
		DateCreation,
		DateEvent,
		DateEventEnd,
		Address,
		Subject,
		Comment,
		CommentType,
		SpecialInfo,
		FileName,
		--KeyField,
		PartnerID,
		Version,
		GUID,
		GUIDPartner,
		GUIDUser,
		GUIDDoc,
		Amount,
		RIK_CommentType)
	values
		(@UserID,
		@UserName,
		null,--ContactUserName,
		null,--,
		'',--PartnerName,
		@DocID,
		getdate(),--DateCreation,
		null,--DateEvent,
		null,--DateEventEnd,
		'',--Address,
		@ExtDocID,--Subject,
		@Comment,--Comment,
		'LINK',--CommentType,
		'',--SpecialInfo,
		null,--FileName,
		--KeyField,
		null,--PartnerID,
		'',--Version,
		newID(),--GUID,
		null,--GUIDPartner,
		null,--GUIDUser,
		null,--GUIDDoc,
		0,--Amount)	
		@ClassLink)
	select @Result = @@error if @Result <> 0 goto Err

end
	
	select '' as Err
	select @Result = @@error if @Result <> 0 goto Err

OK:
	return @Result
Err:
	
	return @Result







GO
/****** Object:  StoredProcedure [dbo].[PDX_ExtDataExists] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
create proc [dbo].[PDX_ExtDataExists]
	@ClassDoc varchar(255),
	@DocID varchar(128)
as
	declare @Result int
	set @Result = 0

	declare @DataSource varchar(255),
		@GUID varchar(40),
		@Comment varchar(255),
		@SQLStatement varchar(2000)
	declare @Tmp table 	
		(GUID varchar(40),
		Comment varchar(255))

	create table #Res 
		(Message varchar(255))

	select
		@DataSource = ltrim(rtrim(isnull(DataSource,'')))
	from dbo.DocTypes with (nolock)
	where Name = @ClassDoc
	select @Result = @@error if @Result <> 0 goto Err

	if isnull(@DataSource,'') <> '' 
	begin
		insert into @Tmp
			(GUID, Comment)
		select
			cast(GUID as varchar(40)), Comments
		from dbo.ExtData with (nolock)
		where @DataSource like '%' + cast(GUID as varchar(40))  + '%'
			and isnull(Comments,'') <> ''
			and isnull(charindex(' ',ltrim(rtrim(isnull(Comments,'')))),0) = 0
		select @Result = @@error if @Result <> 0 goto Err
--select * from @Tmp	
		while exists (select 1 from @Tmp)
		begin
			select top 1
				@GUID = GUID, @Comment = Comment
			from @Tmp
			select @Result = @@error if @Result <> 0 goto Err
				
			--формируем окончательный запрос на проверку
			select @SQLStatement = 'select 1' +
				' from ' + @Comment + ' with (nolock) where DocID = ''' + @DocID + ''''
			select @Result = @@error if @Result <> 0 goto Err
		
			print @SQLStatement
			insert into #Res
				(Message)
			exec (@SQLStatement)
			select @Result = @@error if @Result <> 0 goto Err
	
			if exists (select 1 from #Res)
			begin
				select 'Невозможно произвести изменения в связи с наличием внешних данных. Удалите внешние ссылки вручную, затем произведите необходимые изменения и создайте внешние ссылки заново.' as 'Err'
				select @Result = @@error if @Result <> 0 goto Err
				goto OK
			end

			delete @Tmp where GUID = @GUID
			select @Result = @@error if @Result <> 0 goto Err
		end
	end

--	select @Result = @@error if @Result <> 0 goto Err
	select '' as 'Err'
OK:
	drop table #Res
	return @Result
Err:
	drop table #Res
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_ExternalLinkCreate] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
create proc [dbo].[PDX_ExternalLinkCreate]
	@DocID varchar(128),
	@DocNumber varchar(128),
	@Comment varchar(1024),
	@GUID varchar(40),
	@PDName varchar(128),
	@PDAddress varchar(128),
	@UserID varchar(128) = null


as
	declare @Result int,
		@Err varchar(128),
		@sDocID varchar(128),
		@sName varchar(255)

	select  @Err = 'Ошибка! Обратитесь к администратору СЭД.'
	select @Result = @@error if @Result <> 0 goto Err
	
	select @UserID = isnull(@UserID,'unknown(external)')
	select @Result = @@error if @Result <> 0 goto Err
	
	If isnull(@DocID ,'') = ''
	begin
		select @Err = 'Ошибка! Не указан рег. номер документа-назначения.Обратитесь к администратору СЭД.'
		select @Result = @@error if @Result <> 0 goto Err
	end
	else
	If isnull(@DocNumber ,'') = ''
	begin
		select @Err = 'Ошибка! Не указан рег. номер документа-источника.Обратитесь к администратору СЭД.'
		select @Result = @@error if @Result <> 0 goto Err
	end
	else
	If isnull(@PDName ,'') = ''
	begin
		select @Err = 'Ошибка! Не указано название СЭД.Обратитесь к администратору СЭД.'
		select @Result = @@error if @Result <> 0 goto Err
	end
	else
	If isnull(@PDAddress ,'') = ''
	begin
		select @Err = 'Ошибка! Не указан адрес СЭД.Обратитесь к администратору СЭД.'
		select @Result = @@error if @Result <> 0 goto Err
	end
	else
	If isnull(cast(@GUID as varchar(40)),'') = ''
	begin
		select @Err = 'Ошибка! Не указан идентификатор источника.Обратитесь к администратору СЭД.'
		select @Result = @@error if @Result <> 0 goto Err
	end
	else
	if not exists (select 1 from dbo.Docs with (nolock) 
					where DocID = @DocID)
	begin
		select @Err = 'Ошибка! Указанный документ-назначение не существует.'
		select @Result = @@error if @Result <> 0 goto Err
	end
	else
	if not exists (select 1 from dbo.PDXLinkToPD 
						where PDName = @PDName
						and DocNumber = @DocNumber
						and DocID = @DocID)
	begin	
		insert into dbo.PDXLinkToPD 
			(DocID, DocNumber, PDName, PDAddress, GUID, NameCreation, DateCreation,
			NameLastModification, DateLastModification, Comment,RComment, ExtGUID)
		values
			(@DocID, @DocNumber, @PDName, @PDAddress, NewID(), @UserID, getdate(),
			@UserID, getdate(), replace(@Comment,'_',' '),'-', @GUID)
		select @Result = @@error if @Result <> 0 goto Err


		select @Err = 'Обратная ссылка создана успешно.',
			@sDocID = DocID,
			@sName = Name
		from dbo.Docs with (nolock)
		where DocID = @DocID
		select @Result = @@error if @Result <> 0 goto Err
	end
	else
	begin
		select @Err = 'Внимание! Обратная ссылка уже существует.'
		select @Result = @@error if @Result <> 0 goto Err
	end
	select @Result = @@error if @Result <> 0 goto Err
	/*if exists (select 1 from dbo.PDXLinkToPD where ExtGUID = cast(@GUID as uniqueidentifier) and PDName = @PDName)
	begin
		update dbo.PDXLinkToPD
		set
			@
		where ExtGUID = cast(@GUID as uniqueidentifier) and PDName = @PDName
	end
	else
	begin
	end	
	select @Result = @@error if @Result <> 0 goto Err
*/

	select @Err as 'Message', @sDocID as 'DocID', @sName as 'Name'

	return @Result
Err:
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_ExtraTaskAccess] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[PDX_ExtraTaskAccess]
	@DocID varchar(128),
	@UserID varchar (96)
	
as
	declare  @Res int, @isOK int, @cnt int, @rcnt int, @ClassDoc varchar(128), @ClsTask varchar(128),
	@ClsContr varchar(128)
	
	select @isOK = 0, @cnt = 0, @rcnt = 1

	declare @DC TABLE (DocID varchar(128),
	NC varchar(96), NCntr varchar(96),
	LtV varchar(4096), NR varchar(96), LTE varchar(1024),cnt int,Corr varchar(4096),
	LTR varchar(1024))
	
	
	set @ClsTask = dbo.PDX_CLSGet('RIK_CategoryName_SYSZADACHI')
	set @ClsContr = dbo.PDX_CLSGrGet('RIK_CategoryName_DOGOVORY_B')

/************************************/
--проверим через задачи
		insert into @DC
			(DocID, NC, NCntr, NR, LtV, LTE, Corr, cnt)
		select 
			DocID, NameCreation, NameControl, NameResponsible, ListToView, ListToEdit, Correspondent,@cnt
		from Docs
		where DocIDParent = @DocID
		and ClassDoc = @ClsTask
		and IsActive = 'Y'
		
		select @cnt = @cnt + 1
	--select 1, * from @DC	
		if exists (select 1 from @DC
					where cnt = @cnt - 1 and
					(NC like '%<' + @UserID + '>%'
					or Ncntr like '%<' + @UserID + '>%'
					or NR like '%<' + @UserID + '>%'
					or LtV like '%<' + @UserID + '>%'
					or LTE like '%<' + @UserID + '>%'
					or Corr like '%<' + @UserID + '>%'))
		begin
			select @isOK = 1
		end
		else
		begin
			while @rcnt > 0
			begin				  
				insert into @DC
					(DocID, NC, NCntr, NR, LtV, LTE,Corr, cnt)
				select 
					D.DocID, D.NameCreation, D.NameControl, D.NameResponsible, D.ListToView, D.ListToEdit,D.Correspondent, @cnt
				from Docs D
				inner join @DC C on D.DocIDParent = C.DocID and C.cnt = @cnt - 1
				where D.ClassDoc = @ClsTask
				and D.IsActive = 'Y'
				select @rcnt = @@ROWCOUNT, @cnt = @cnt + 1
	--select 2, * from @DC			
				IF exists (select 1 from @DC
					where cnt = @cnt - 1 and
					(NC like '%<' + @UserID + '>%'
					or Ncntr like '%<' + @UserID + '>%'
					or NR like '%<' + @UserID + '>%'
					or LtV like '%<' + @UserID + '>%'
					or LTE like '%<' + @UserID + '>%'
					or Corr like '%<' + @UserID + '>%'))
				begin
					select @isOK = 1
					goto exit_while
				end
			
			end
	exit_while:

		end
		select @Res = @@error if @Res <> 0 goto Err
/************************************/	
		If @isOK = 0 --проверим по цепочке договор-допник
		begin
			select 
				@ClassDoc = case when ClassDoc like '%/%' then LEFT(ClassDoc, CHARINDEX('/', ClassDoc)) else ClassDoc end
			from dbo.Docs
			where DocID = @DocID
			
			if @ClassDoc = @ClsContr
			begin

				insert into @DC
					(DocID, NC, NCntr, NR, LtV, LTE, LTR, Corr, cnt)
				select 
					DocID, NameCreation, NameAproval, NameResponsible, '', ListToEdit, ListToReconcile, Correspondent, @cnt
				from Docs
				where DocIDParent = @DocID
				and ClassDoc like @ClsContr + '%'
				and IsActive = 'Y'
							
				select @cnt = @cnt + 1
			--select 1, * from @DC	
				if exists (select 1 from @DC
							where cnt = @cnt - 1 and
							(NC like '%<' + @UserID + '>%'
							or Ncntr like '%<' + @UserID + '>%'
							or NR like '%<' + @UserID + '>%'
							or LtV like '%<' + @UserID + '>%'
							or LTE like '%<' + @UserID + '>%'
							or LTR like '%<' + @UserID + '>%'
							or Corr like '%<' + @UserID + '>%'))
				begin
					select @isOK = 1
				end
				else
				begin
					while @rcnt > 0
					begin				  
						insert into @DC
							(DocID, NC, NCntr, NR, LtV, LTE, LTR, Corr, cnt)
						select 
							D.DocID, D.NameCreation, D.NameAproval, D.NameResponsible, '', D.ListToEdit, D.ListToReconcile, D.Correspondent, @cnt
						from Docs D
						inner join @DC C on D.DocIDParent = C.DocID and C.cnt = @cnt - 1
						where  D.ClassDoc like @ClsContr + '%'
						and D.IsActive = 'Y'
						select @rcnt = @@ROWCOUNT, @cnt = @cnt + 1
			--select 2, * from @DC			
						IF exists (select 1 from @DC
							where cnt = @cnt - 1 and
							(NC like '%<' + @UserID + '>%'
							or Ncntr like '%<' + @UserID + '>%'
							or NR like '%<' + @UserID + '>%'
							or LtV like '%<' + @UserID + '>%'
							or LTE like '%<' + @UserID + '>%'
							or LTR like '%<' + @UserID + '>%'
							or Corr like '%<' + @UserID + '>%'))
						begin
							select @isOK = 1
							goto exit_while1
						end
					
					end
			exit_while1:

				end
			end--If @ClassDoc = @ClsContr
		end
		select @Res = @@error if @Res <> 0 goto Err
	
	
	select @isOK as 'access'

OK:
	return @Res
Err:
	return @Res












GO
/****** Object:  StoredProcedure [dbo].[PDX_f_FilesCopy] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_f_FilesCopy]
	
as
declare 
	@Res int, @Cls varchar(128)
	
	select @Res = 0
	select @Cls = dbo.PDX_CLSGrGet('RIK_CategoryName_DOGOVORY_B') + '%'
	
	delete from dbo.f_Files
	delete from dbo.f_Docs
	
	insert into dbo.f_Docs
		(TransferGUID,
		DocID,--Рег. номер
		DateActivation,--Рег. дата
		UserFieldText2,--Вид договора
		ActDoc,--Вид деятельности
		UserFieldText4,--Проект
		Name,--Заголовок
		Description,--Предмет договора
		DocIdIncoming,--№ договора контрагента
		DateCompletion,--Дата прекращения<BR>срока действия
		UserFieldText3,--Сторона 1
		UserFieldText8,--Контрагент 1
		NameAproval,--Подписывающий 1
		PartnerName,--Контрагент 2
		UserFieldText5,--Подписывающий 2
		UserFieldText6,--Дополнительные контрагенты -
		Currency,--Валюта документа
		AmountDoc,--Сумма договора
		UserFieldMoney1,--в т.ч. НДС
		NameCreation,--Отв. за заключение договора
		Department,--Подразделение отв. за исполнение договора
		NameResponsible,--Отв. за исполнение договора
		UserFieldText1,--Наименование листа согласования
		ListToReconcile,--Лист согласования
		Docrank, --Срочность
		DocIDParent,--Осн.договор (для доп. соглаш.)
		DocIDPrevious ,--Для работ по договору
		LocationPath,--Принято в Бухгалтерию
		Correspondent,--Список рассылки
		ListToEdit,--Список имеющих право редактирования д-та
		SecurityLevel,--Уровень доступа
		DateSigned)
	select
		D.TransferGUID,
		D.DocID,--Рег. номер
		D.DateActivation,--Рег. дата
		D.UserFieldText2,--Вид договора
		D.ActDoc,--Вид деятельности
		D.UserFieldText4,--Проект
		D.Name,--Заголовок
		D.Description,--Предмет договора
		D.DocIdIncoming,--№ договора контрагента
		D.DateCompletion,--Дата прекращения<BR>срока действия
		D.UserFieldText3,--Сторона 1
		D.UserFieldText8,--Контрагент 1
		D.NameAproval,--Подписывающий 1
		D.PartnerName,--Контрагент 2
		D.UserFieldText5,--Подписывающий 2
		D.UserFieldText6,--Дополнительные контрагенты -
		D.Currency,--Валюта документа
		D.AmountDoc,--Сумма договора
		D.UserFieldMoney1,--в т.ч. НДС
		D.NameCreation,--Отв. за заключение договора
		D.Department,--Подразделение отв. за исполнение договора
		D.NameResponsible,--Отв. за исполнение договора
		D.UserFieldText1,--Наименование листа согласования
		D.ListToReconcile,--Лист согласования
		D.Rank, --Срочность
		D.DocIDParent,--Осн.договор (для доп. соглаш.)
		D.DocIDPrevious ,--Для работ по договору
		D.LocationPath,--Принято в Бухгалтерию
		D.Correspondent,--Список рассылки
		D.ListToEdit,--Список имеющих право редактирования д-та
		D.SecurityLevel,--Уровень доступа
		D.DateSigned
	from dbo.f_DocsList L
	inner join dbo.Docs D on D.TransferGUID = L.TransferGUID
	and D.ClassDoc like @Cls 
	select @Res = @@error if @Res <> 0 goto Err
	
	insert into dbo.f_Files
		(TransferGUID,
		DocID,
		FileName,
		FilePath,
		Version,
		Comment)
	select 
		D.TransferGUID,
		C.DocID,
		C.FileName,
		'D:\PayDoxData\PayDoxDocuments\' + C.FileName,
		C.Version,
		C.Comment
	from dbo.f_Docs D
	inner join dbo.Comments C on C.DocID = D.DocID
		and C.CommentType = 'FILE'
		and C.Amount = 0
		
	
OK:
	return @Res
Err:
	return @Res







GO
/****** Object:  StoredProcedure [dbo].[pdx_f_FilesCopyBat] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
--select * from dbo.f_DocsList
--select * from dbo.f_Docs
--select * from dbo.f_Files

--exec dbo.PDX_f_FilesCopy

--делаем процедуру dbo.pdx_f_FilesCopyBat
Create proc [dbo].[pdx_f_FilesCopyBat]
as
declare @FP varchar(100)
declare @OutF varchar(100)
set @FP='D:\PayDoxData\PayDoxDocuments\'
Set @OutF='C:\outF\'

Select 'mkdir '+@outf+replace(DocID,'/','_') from dbo.f_Docs

select 'copy ' + @fp+filename +' C:\outf\'+replace(DocID,'/','_')+'\'+

--генерим название файла
--convert(varchar(20),GETDATE(),105)+'-'+
replace(replace(replace(Replace(replace(replace(replace(version,' ','__')+
--добавляем расширение
reverse(left(REVERSE(FileName ),charindex('.',REVERSE(FileName))))
--решаем вопрос с остатками
,'/','_'),'"','_'),'|','_'),'?','_'),'>','_'),'<','_') as exten
 from dbo.f_Files where not filename is null
GO
/****** Object:  StoredProcedure [dbo].[PDX_FieldsOrderGet] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_FieldsOrderGet]
as
	declare @Result int
	set @Result = 0

	declare @List varchar(8000),
		@DocType varchar(4000),
		@DTName varchar(255)

	declare @ResultTable table
		(Result varchar(4000),
		DocType varchar(255),
		OrderIndex int identity)

	declare @ItogTable table
		(Result varchar(4000),
		OrderIndex int identity)

	--проверяем, что в се константы для Категорий известны
	insert into @ItogTable
		(Result)
	SELECT D.[Name]
	from dbo.DocTypes D
	left join dbo.PDXDocTypesConst C on C.DocType = D.[Name]
	where exists (select 1 from dbo.PDXUserSettingDocTypes T where T.DocType =D.[Name])
	and C.DocType is null
	select @Result = @@error if @Result <> 0 goto Err

	if exists (select 1 from @ItogTable)
	begin --ЕСТЬ КАТЕГОРИИ БЕЗ КОНСТАНТ
	--выдаем сообщение с перечнем категорий без констант
		select @List = ''
		select @List = @List + case len(@List) when 0 then '' else ',' end + Result
		from @ItogTable
		order by OrderIndex
		select @Result = @@error if @Result <> 0 goto Err

		select 
			'Для следующих категорий не определены константы: ' + @List
		select @Result = @@error if @Result <> 0 goto Err			
	end
	else
	begin --формируем код
		--сначала для каждой категории формируем последовательность полей
		DECLARE ListOfCategory CURSOR FOR 
		SELECT C.ConstName, D.[name]
		from dbo.DocTypes D
		inner join dbo.PDXDocTypesConst C on C.DocType = D.[Name]
		where exists (select 1 from dbo.PDXUserSettingDocTypes T where T.DocType =D.[Name])
		order by C.ConstName
		select @Result = @@error if @Result <> 0 goto Err
	
		OPEN ListOfCategory
		select @Result = @@error if @Result <> 0 goto Err
		FETCH NEXT FROM ListOfCategory 
		INTO @DocType,@DTName
		select @Result = @@error if @Result <> 0 goto Err
	
		--в цикле "склеиваем" строку последовательности
		WHILE @@FETCH_STATUS = 0
		begin
			select @List = ''
			select @List = @List + case len(@List) when 0 then '' else ', ' end +
				case lower(FieldName)
					when lower('Docrank')
						then 'Rank'
					when lower('DocResult')
						then 'Result'
					when lower('DocHistory')
						then 'History'
					else FieldName
				end 
			from dbo.PDXUserSettingDocTypes
			where DocType = @DTName
				and OrderIndex <> 100
			order by OrderIndex
			select @Result = @@error if @Result <> 0 goto Err
	
			insert into @ResultTable
				(DocType,Result)
			values
				(@DocType,@List)
			select @Result = @@error if @Result <> 0 goto Err
			
			FETCH NEXT FROM ListOfCategory 
			INTO @DocType,@DTName
			select @Result = @@error if @Result <> 0 goto Err
		end
		select @Result = @@error if @Result <> 0 goto Err
	
		CLOSE ListOfCategory
	    DEALLOCATE ListOfCategory

		--а затем объединяем  одинаковые списки, чтобы код не выглядел громоздко
		insert into @ItogTable
			(Result)
		values
			('''' + suser_sname() + ' ' + convert(varchar(100),getdate(),121) + ' auto
Select Case S_ClassDoc' )
		select @Result = @@error if @Result <> 0 goto Err
	
		DECLARE ListOfCategory CURSOR FOR 
		SELECT Result
		from @ResultTable
		group by Result
		order by min (OrderIndex)
		select @Result = @@error if @Result <> 0 goto Err
		OPEN ListOfCategory
		select @Result = @@error if @Result <> 0 goto Err
		FETCH NEXT FROM ListOfCategory 
		INTO @List
		select @Result = @@error if @Result <> 0 goto Err
	
		WHILE @@FETCH_STATUS = 0
		begin
			select @DocType = ''
			select @DocType = @DocType + case len(@DocType) when 0 then '' else ', ' end + DocType
			from @ResultTable
			where Result = @List
			order by OrderIndex
			select @Result = @@error if @Result <> 0 goto Err
			
			insert into @ItogTable
				(Result)
			values
				('Case ' + @DocType + '
  CurrentDocFieldOrder="' + @List + '"')
			select @Result = @@error if @Result <> 0 goto Err
	
			FETCH NEXT FROM ListOfCategory 
			INTO @List
			select @Result = @@error if @Result <> 0 goto Err
		end
		select @Result = @@error if @Result <> 0 goto Err
	
		CLOSE ListOfCategory
	    DEALLOCATE ListOfCategory
	
		insert into @ItogTable
			(Result)
		values
			('End Select')
		select @Result = @@error if @Result <> 0 goto Err
		
		select
			Result 
		from @ItogTable
		order by OrderIndex
		select @Result = @@error if @Result <> 0 goto Err
	end

	return @Result
Err:
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_FindField] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_FindField]
	@DocID varchar(250),
	@ClassDoc varchar(2000),
	@MainActivity varchar(50)= null, --не используетя больше, оставлено для совместимости
	@SQLStatement varchar(8000) = null out
as
	--declare @Result int
	--set @Result = 0

	declare @Field varchar(255),
		@RUSField varchar(255),
		@DirType int,
		@FieldNumber varchar(10),
		@FieldID int,
		@Code varchar(255),
		@ExtValue varchar(4096),
		@OneValue varchar(4096),
		@Pos1 int,
		@Pos2 int,
		@addDirType int,
		@ActDoc varchar(128),
		@Projects varchar(1024),
		@PrjField varchar(128),
		@SQLString nvarchar(500),
		@ParmDefinition nvarchar(500),
		@DT datetime

		--, @i int

	create table #ListTable
		(OneValue varchar(4096),
		ValueID varchar(1024),
		ExtValue varchar(4096))

	create table #Errors
		(Error varchar(2048),
		OrderIndex int identity)

	create table #CursorTable
		(Field varchar(255),
		DirType int, 
		FieldNumber varchar(10),
		RUSField varchar(255),
		Value varchar(4096),
		FieldID int identity,
		ExtValue varchar(1024)/*,
		i int default 0*/)

	If ltrim(rtrim(isnull(@ClassDoc,''))) = '' or ltrim(rtrim(isnull(@DocID,''))) = ''
	begin
	  select @SQLStatement = '<font color=red>ОШИБКА! </font>Сбой операции, перезагрузите СЭД Paydox и попробуйте еще раз.'
	  goto Ok
	end

--	select @Result = @@error if @Result <> 0 goto Err
	if exists (select 1 from dbo.Docs with (nolock) where DocID = @DocID
				/*and lower(isActive) <> 'y'*/)
	begin
		select @SQLStatement = ''
		--select @Result = @@error if @Result <> 0 goto Err
	--ПРОВЕРКА НА СУЩЕСТВОВАНИЕ ЗНАЧЕНИЙ
		--получаем список обязательных для проверки полей 
		--DECLARE ListOfField CURSOR FOR 
		insert into #CursorTable
		(Field, DirType, FieldNumber, RUSField)
		SELECT case lower(FieldName)
				when lower('DocResult')
					then 'Result'
				when lower('Docrank')
					then 'Rank'
				else FieldName
			   end, DirType,
			   cast(case isnull(FieldNumber,'') when '' then 1 else FieldNumber end as varchar(10)),
			   RUSName
		from dbo.PDXUserSettingDocTypes with (nolock)
		where DocType = @ClassDoc
			--and FieldType = 1 --только текстовые поля
			and not DirType is null
		order by OrderIndex
		--select @Result = @@error if @Result <> 0 goto Err
		
		select @PrjField = ''
		select top 1
			@PrjField = Field
		from #CursorTable 
		where DirType = 35
		
		If exists (select 1 from #CursorTable where ltrim(rtrim(isnull(Field,''))) <> '')
		begin
			--получаем значения из полей, которые будем проверять
			select @SQLStatement = 'update C set Value = case C.Field '
			--select @Result = @@error if @Result <> 0 goto Err
			select @SQLStatement = @SQLStatement + ' when ''' + Field + ''' then D.[' +Field+']'
			from #CursorTable with (nolock)
			where ltrim(rtrim(isnull(Field,''))) <> ''
			--select @Result = @@error if @Result <> 0 goto Err
			--select @SQLStatement = @SQLStatement + ' else '''' end, ExtValue = case C.Field when ''ListToReconcile'' then ListReconciled when ''NameAproval'' then NameApproved else '''' end '
			select @SQLStatement = @SQLStatement + ' else '''' end '
			--select @Result = @@error if @Result <> 0 goto Err
			select @SQLStatement = @SQLStatement + ' from #CursorTable C inner join dbo.Docs D on D.DocID = ''' + @DocID + ''''
			--select @Result = @@error if @Result <> 0 goto Err
			--print @SQLStatement
			exec (@SQLStatement)
			--select @Result = @@error if @Result <> 0 goto Err

			If exists (select 1 from #CursorTable where ltrim(rtrim(isnull(Field,''))) in ('ListToReconcile','NameAproval','LocationPath', 'NameControl', 'UserFieldText3') )
			begin
				select @SQLStatement = ''
				select @SQLStatement = @SQLStatement + 'update C set ExtValue = case C.Field when ''ListToReconcile'' then ListReconciled when ''NameAproval'' then NameApproved when ''LocationPath'' then Department when ''NameControl'' then UserFieldText2  when ''UserFieldText3'' then UserFieldText4 else '''' end '
				--select @Result = @@error if @Result <> 0 goto Err
				select @SQLStatement = @SQLStatement + ' from #CursorTable C inner join dbo.Docs D on D.DocID = ''' + @DocID + ''''
				--select @Result = @@error if @Result <> 0 goto Err
				--print @SQLStatement
				exec (@SQLStatement)
				--select @Result = @@error if @Result <> 0 goto Err
			end
		end
/*
		--получение значений в цикле по 5 штук ...так кажется удобнее всего (ограничение обусловлено длиной строки)
		select @i = 0, @SQLStatement = ''
		while exists (select 1 from #CursorTable where i = 0)
		begin
			select @i = @i + 1
			select top 1
				@SQLStatement = @SQLStatement + ' when ''' + Field + ''' then D.[' +Field+']',
				@Field = Field
			from #CursorTable 
			select @Result = @@error if @Result <> 0 goto Err

			update #CursorTable
			set i = 2
			where Field = @Field
			select @Result = @@error if @Result <> 0 goto Err

			If @i = 5
			begin
				select @SQLStatement = 'update C set Value = case C.Field ' + @SQLStatement +
								' else '''' end, ExtValue = case C.Field when ''ListToReconcile'' then ''ListReconciled'' when ''NameAproval'' then ''NameApproved'' else '''' end ' +
								' from #CursorTable C inner join dbo.Docs D on D.DocID = ''' + @DocID + ''' where C.i=2'
				select @Result = @@error if @Result <> 0 goto Err

				--print @SQLStatement
				exec (@SQLStatement)
				select @Result = @@error if @Result <> 0 goto Err

				select @i = 0, @SQLStatement = ''
				select @Result = @@error if @Result <> 0 goto Err

				update #CursorTable
				set i = 1
				where i = 2
				select @Result = @@error if @Result <> 0 goto Err
			end 
		end
*/
		--обработка апострофа
		update #CursorTable
			set Value = replace(replace(Value,'''',''''''),'<(#!)>','(#!)'),
				ExtValue = replace(replace(ExtValue,'''',''''''),'<(#!)>','(#!)')
		--select @Result = @@error if @Result <> 0 goto Err
		
		--в цикле проверяем поля на "заполненность"
		WHILE exists(select 1 from #CursorTable)
		begin
			select top 1 
				@FieldID = FieldID,
				@Field = Field,
				@DirType = DirType,
				@addDirType = case when DirType in (224,227,41,42,48,84) then -2 else -100 end,
				@FieldNumber = FieldNumber,
				@RUSField = RUSField,
				@SQLStatement = ltrim(rtrim(isnull(Value,''))),
				@ExtValue = ltrim(rtrim(isnull(ExtValue,'')))
			from #CursorTable
			--select @Result = @@error if @Result <> 0 goto Err

			delete from #ListTable
			--select @Result = @@error if @Result <> 0 goto Err

			--РАЗБОР многострочного значения по угловым скобкам или получение логина "от пользователя"
			if @DirType in (-2,41,42,48,84)  --Users и Делопроиз-во, отв. по филалу
				or @DirType in (-1,-3,-4,-5) --Activities--Currency--Partners--Departments
				or @DirType in (39)--инвест мероприяти
				or @DirType in (51, 52)--ИСР
				or @DirType in (205,212)--платежи
				or @DirType in (224,227)
			begin
				--для справочников, где разделитель Enter, преобразуем разделитель к угловым скобкам
				If @DirType in (-1,-3,-4,-5,39,51,52) 
				begin
					select @SQLStatement = replace(@SQLStatement, char(13)+char(10),'><')
					--select @Result = @@error if @Result <> 0 goto Err
					select @SQLStatement = case when @SQLStatement like '%><%' then '<' else '' end + @SQLStatement + case when @SQLStatement like '%><%' then '>' else '' end
					--select @Result = @@error if @Result <> 0 goto Err
				End

				--все остальные части "Enter" нас не интересуют		
				select @SQLStatement = replace(replace(@SQLStatement, char(13),''),char(10),'')
				--select @Result = @@error if @Result <> 0 goto Err

				If ltrim(rtrim(@SQLStatement)) like '%<%>%' 
				begin --если есть угловые скобки - разбираем
					while ltrim(rtrim(@SQLStatement)) like '%<%>%'
					begin
						--будем получать 2 значение - одно. которое отображается в ошибке, второе- по кот. ищется в справочнике
						select @Pos1 = charindex('<',@SQLStatement),
								@Pos2 = charindex('>',@SQLStatement,@Pos1+1)
						--select @Result = @@error if @Result <> 0 goto Err

						select @OneValue = substring(@SQLStatement,1,@Pos2)
						--select @Result = @@error if @Result <> 0 goto Err
						insert into #ListTable (OneValue, ValueID) values (ltrim(rtrim(@OneValue)), ltrim(rtrim(dbo.PDX_SubstringReturn(@OneValue,charindex('<',@OneValue),charindex('>',@OneValue,charindex('<',@OneValue)+1)))))
						--select @Result = @@error if @Result <> 0 goto Err
	
						--если значение OneValue целиком стоит в угловых скобках, то от них нужно избавиться
						update #ListTable
							set OneValue = substring(OneValue,2,len(OneValue)-2)
						where OneValue like '<%>'
						--select @Result = @@error if @Result <> 0 goto Err

						select @SQLStatement = substring(@SQLStatement,@Pos2+1, len(@SQLStatement))--replace(@SQLStatement,'<' + @OneValue + '>', '')
						--select @Result = @@error if @Result <> 0 goto Err
					end
				end
				else --если их нет, то будем искать значение целиком
				begin
					insert into #ListTable (OneValue,ValueID) values (ltrim(rtrim(@SQLStatement)),ltrim(rtrim(@SQLStatement)))
					--select @Result = @@error if @Result <> 0 goto Err
				end

				-- это работает только для листа согласования и говорит о том, что "уже согласовавший" на момент проверки может и не быть уже пользователем
				-- для утверждающего - уже утвердивший
				If @ExtValue <> ''
				begin 
					delete from #ListTable
					where @ExtValue like '%<' + ValueID + '>%'
					--select @Result = @@error if @Result <> 0 goto Err
				end
			end 
			else --это однострочное значение - ищем целиком
			begin	
				insert into #ListTable (OneValue, ValueID) values (ltrim(rtrim(@SQLStatement)),ltrim(rtrim(@SQLStatement)))
				--select @Result = @@error if @Result <> 0 goto Err
			end

			--удалем  НЕнужные значения
			delete from #ListTable
			where upper(OneValue) like '%USERS:%'
				or upper(OneValue) like '%DEPARTMENTS:%'
				or upper(OneValue) like '%CONTACTS:%'
				or upper(OneValue) like '%DOC:%'
				or upper(OneValue) like '%COMPANIES:%'
				or upper(ValueID) like '#%#'
			--select @Result = @@error if @Result <> 0 goto Err

			If @DirType <> 84 -- для отв. по филиалу, пустое значение, это тоже возможное значение, поэтому его не исключаеим
			begin
				--удалем  НЕнужные значения
				delete from #ListTable
				where ltrim(rtrim(OneValue)) = ''
				--select @Result = @@error if @Result <> 0 goto Err
			end
/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
--на users м.б. двойная проверка
/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

			if @DirType = -2 or @addDirType = -2 --Users
			begin
				--для ЛС и утверждающего строго необходимо иметь доступ
				/*if @Field in ('ListToReconcile', 'NameAproval') 
				begin*/				
					--проверяем наличие значений в справочниках
					insert into #Errors
						(Error)
					select 	distinct 
						case -2
							when @addDirType
								then @RUSField + ': Указанный пользователь не существует. Обратитесь к администратору СЭД.'
							else @RUSField + ': значение [' + OneValue + '] в справочнике не существует'
						end
					from #ListTable L
					left join dbo.Users U on U.UserID = L.ValueID 
						and U.DateExpirationSecurity >= getdate() 
						and not Permitions like '%*%' 
						and isnull(StatusActive,'') <> ''
					where U.UserID is null
						and L.OneValue <> case @addDirType when -2 then '' else cast(newid() as varchar(40)) end 
					--select @Result = @@error if @Result <> 0 goto Err
				/*end 
				else --для остальных достаточно просто быть в справочнике
				begin
					--проверяем наличие значений в справочниках
					insert into #Errors
						(Error)
					select 	distinct 
						case -2
							when @addDirType
								then @RUSField + ': Указанный пользователь не существует. Обратитесь к администратору СЭД.'
							else @RUSField + ': значение [' + OneValue + '] в справочнике не существует'
						end
					from #ListTable L
					left join dbo.Users U on U.UserID = L.ValueID 
					where U.UserID is null
						and L.OneValue <> case @addDirType when -2 then '' else cast(newid() as varchar(40)) end 
					select @Result = @@error if @Result <> 0 goto Err
				end*/
			end
--все остальное уже можно через else
/*******************************************************/
			if @DirType in (-1,-3,-4,-5) --Activities--Currency--Partners--Departments
			begin
				select @SQLStatement = 'insert into #Errors (Error) ' +
				' select distinct ''' + @RUSField + ': значение ['' + D.OneValue + ''] в справочнике не существует'' from #ListTable D ' + 
				' left join ' + 
					case @DirType	
						when -1
							then 'dbo.Activities'
						when -3
							then 'dbo.CurrencyRates'
						when -4
							then 'dbo.Partners'
						when -5
							then 'dbo.Departments'
					end + ' A with (nolock) on (D.OneValue = A.' + case @DirType 
														when -3 then 'Code' 
														else 'Name' end + 
					' or A.' + case @DirType 
								when -3 then 'Code' 
								else 'Name' end + ' like ''%'' + D.OneValue + ''/%'') ' +
				' where ltrim(rtrim(D.OneValue)) <> '''' and A.' + case @DirType 
																			when -3 then 'Code' 
																			else 'Name' end + 
				' is null'
				--select @Result = @@error if @Result <> 0 goto Err
				--print @SQLStatement
				exec (@SQLStatement)
				--select @Result = @@error if @Result <> 0 goto Err
			end
			else if @DirType in (30,34,35,36,37,38,40,43,44,45,46,49,81,83,86,87,214,215,219,91) --пользовательские справочники
	-- проверка осуществляется, если искомое поле FieldX? где X = @FieldNumber
			begin
				select @SQLStatement = 'insert into #Errors (Error) ' +
				' select distinct ''' + @RUSField + ': значение ['' + D.OneValue + ''] в справочнике не существует'' from #ListTable D ' + 
				' left join dbo.UserDirValues V with (nolock) on V.Field' + @FieldNumber + ' = D.ValueID' + 
				' and V.UDKeyField = ' + cast(@DirType as varchar(10)) +
				' where V.UDKeyField is null' 
				--select @Result = @@error if @Result <> 0 goto Err
				--print @SQLStatement
				exec (@SQLStatement)
				--select @Result = @@error if @Result <> 0 goto Err
			end 
            else if @DirType in (84) --обработка по отв. по филиалу, директору
            begin --по FieldX с учетом Field1
/**************************определяем нужную запись в справочнике*/
--данные либо будут на код целиком, либо на первые 2 символа кода
				select @Code = case when ActDoc like '%<>%' then ltrim(rtrim(replace(ActDoc,'<>',''))) else dbo.PDX_SubstringReturn(ActDoc,charindex('<',ActDoc),charindex('>',ActDoc)) end
				from dbo.Docs where DocID = @DocID
				--select @Result = @@error if @Result <> 0 goto Err

				if isnull(@Code,'') <> '' and not exists (select 1 from dbo.PDXBranchSettings where Fld1 = @Code)
				begin
					select @Code = left(@Code,2)
					--select @Result = @@error if @Result <> 0 goto Err
				end
				--select @Result = @@error if @Result <> 0 goto Err
/**************************/
				select @SQLStatement = 'insert into #Errors (Error) ' +
				' select distinct ''' + @RUSField + ': значение ['' + D.OneValue + ''] в справочнике не существует'' from #ListTable D ' + 
				' left join dbo.PDXBranchSettings V with (nolock) on (V.Fld' + @FieldNumber + ' like ''%<'' + D.ValueID + ''>%'' or ' +
				' (D.ValueID = '''' and char(13)+char(10) + ltrim(rtrim(isnull(V.Fld' + @FieldNumber + ',''''))) + char(13)+char(10) like char(13)+char(10)+char(13)+char(10)+''%'' ) )' +
				' and V.Fld1 = ''' + @Code + '''' + 
				' where V.SetID is null' 
				--select @Result = @@error if @Result <> 0 goto Err
				--print @SQLStatement
				exec (@SQLStatement)
				--select @Result = @@error if @Result <> 0 goto Err
            end
			else if @DirType in (39)--инвест мероприятия(многострочное)
			begin
				select @SQLStatement = 'insert into #Errors (Error) ' +
				' select distinct ''' + @RUSField + ': значение ['' + D.OneValue + ''] в справочнике не существует'' from #ListTable D ' + 
				' left join dbo.UserDir_IM V with (nolock) on V.Code = D.ValueID ' +
				' where V.KeyField is null' 
				--select @Result = @@error if @Result <> 0 goto Err
				--print @SQLStatement
				exec (@SQLStatement)
				--select @Result = @@error if @Result <> 0 goto Err
			end
			else if @DirType = -6  --проверка в документах 
			begin
--существование / дс может быть только к договору
/*Номер договора в СЭД не найден. Проверьте корректность номера (категория указана латинской буквой, указан прямой слеш «/»)*/

				select @SQLStatement = 'insert into #Errors (Error) ' +
				' select distinct case when V.DocID is null then ''' + @RUSField + ': Номер документа ['' + D.' + @Field + ' + ''] в СЭД не найден. Проверьте корректность номера (русские/латинские буквы, прямой слеш «/»)''' +
				' when ''' + @Field + ''' = ''DocIDParent'' and D.ClassDoc like ''Договоры /%'' and not V.ClassDoc like ''Договоры /%'' then ''Доп. соглашение может быть оформлено только к карточке Договора.''' +
				' when ''' + @Field + ''' = ''DocIDParent'' and D.ClassDoc = ''Внутренние / Заказы'' and not V.ClassDoc = ''Внутренние / Заказы'' then ''Внутренний заказ может быть оформлен только к карточке Внутреннего заказа.'' else '''' end' +
				' from dbo.Docs D with (nolock) ' + 
				' left join dbo.Docs V with (nolock) on V.DocID = D.' + @Field + 
				' where ltrim(rtrim(D.' + @Field + ')) <> '''' and D.DocID = ''' + @DocID + '''' 
				--select @Result = @@error if @Result <> 0 goto Err

				--print @SQLStatement
				exec (@SQLStatement)
				--select @Result = @@error if @Result <> 0 goto Err
			end
			else if @DirType in (51, 52)--ИСР
			begin
				select @SQLStatement = 'insert into #Errors (Error) ' +
				' select distinct ''' + @RUSField + ': значение ['' + D.OneValue + ''] в справочнике не существует'' from #ListTable D ' + 
				' left join dbo.UserDir_ISR V with (nolock) on V.Code = D.ValueID ' + 
				' and isnull(V.ParentKeyField,-1) =' + case @DirType when 51 then '-1' else 'isnull(V.ParentKeyField,-1)' end +
				' where V.KeyField is null' 
				--select @Result = @@error if @Result <> 0 goto Err
				--print @SQLStatement
				exec (@SQLStatement)
				--select @Result = @@error if @Result <> 0 goto Err
			end
			else if @DirType in (41)--отв. за делопроиз-во
			begin/*
				select @SQLStatement = 'insert into #Errors (Error) ' +
				' select distinct ''' + @RUSField + ': значение ['' + D.OneValue + ''] в справочнике не существует'' from #ListTable D ' + 
				' left join dbo.Departments V with (nolock) on V.LocationPath like ''%<'' + D.ValueID + ''>%''' + 
				' where V.LocationPath is null' */

				select @ExtValue = ltrim(rtrim(@ExtValue))
				--select @Result = @@error if @Result <> 0 goto Err
				select @ExtValue = @ExtValue + case right(@ExtValue,1) when '/' then '' else '/' end
				--select @Result = @@error if @Result <> 0 goto Err

				select @SQLStatement = 'insert into #Errors (Error) ' +
				' select distinct ''' + @RUSField + ': значение ['' + D.OneValue + ''] в справочнике не существует'' from #ListTable D ' + 
				' left join (select top 1 * from dbo.Departments where ''' + @ExtValue + ''' like Name + ''%'' and ltrim(rtrim(isnull(LocationPath,'''')))<>'''' order by Name desc) as P' +
				' on P.LocationPath like ''%<'' + D.ValueID + ''>%''' + 
				' where P.LocationPath is null' 
				--select @Result = @@error if @Result <> 0 goto Err
				--print @SQLStatement
				exec (@SQLStatement)
				--select @Result = @@error if @Result <> 0 goto Err
			end
			else if @DirType in (42)--регистратор дов-ти
			begin
				select @SQLStatement = 'insert into #Errors (Error) ' +
				' select distinct ''' + @RUSField + ': значение ['' + D.OneValue + ''] в справочнике не существует'' from #ListTable D ' + 
				' left join (select top 1 * from dbo.Departments where Name in (''' + @ExtValue + ''',  ''' + @ExtValue + '/'') order by Name asc) as V ' + 
				' on V.ATT_Register like ''%<'' + D.ValueID + ''>%''' + 
				' where V.ATT_Register is null' 
				--select @Result = @@error if @Result <> 0 goto Err
				--select @Result = @@error if @Result <> 0 goto Err
				--print @SQLStatement
				exec (@SQLStatement)
				--select @Result = @@error if @Result <> 0 goto Err
			end
			else if @DirType in (48)--контроль дов-ти
			begin
				select @SQLStatement = 'insert into #Errors (Error) ' +
				' select distinct ''' + @RUSField + ': значение ['' + D.OneValue + ''] в справочнике не существует'' from #ListTable D ' + 
				' left join (select top 1 * from dbo.Departments where Name in (''' + @ExtValue + ''',  ''' + @ExtValue + '/'') order by Name asc) as V ' + 
				' on V.ATT_Controller like ''%<'' + D.ValueID + ''>%''' + 
				' where V.ATT_Controller is null' 
				--select @Result = @@error if @Result <> 0 goto Err
				--print @SQLStatement
				exec (@SQLStatement)
				--select @Result = @@error if @Result <> 0 goto Err
			end
			else if @DirType in (201,203,204)--платежи/фирмы/счета/цфо
			begin
				select @SQLStatement = 'insert into #Errors (Error) ' +
				' select distinct ''' + @RUSField + ': значение ['' + D.OneValue + ''] в справочнике не существует'' from #ListTable D ' + 
				' left join dbo.' + case  @DirType
										when 201 then 'PDX_pay_Firms'
										when 203 then 'PDX_pay_Accounts'
										when 204 then 'PDX_pay_CFO'								
									end + ' V with (nolock) on V.Name = D.ValueID ' + 
				' where V.SetID is null' 
				--select @Result = @@error if @Result <> 0 goto Err
				--print @SQLStatement
				exec (@SQLStatement)
				--select @Result = @@error if @Result <> 0 goto Err
			end
			else if @DirType in (202)--платежи/направл
			begin
				select @SQLStatement = 'insert into #Errors (Error) ' +
				' select distinct ''' + @RUSField + ': значение ['' + D.OneValue + ''] в справочнике не существует (или не соответствует указанному Проекту)'' from #ListTable D ' + 
				' left join dbo.PDX_pay_Directions V with (nolock) on V.Name = D.ValueID and Project = ''' + @ExtValue + ''' ' + 
				' where V.SetID is null' 
				--select @Result = @@error if @Result <> 0 goto Err
				--print @SQLStatement
				exec (@SQLStatement)
				--select @Result = @@error if @Result <> 0 goto Err
			end
			else if @DirType in (205, 212)--платежи/приз/новые статьи
			begin
			   select 
				@DT = case ClassDoc when dbo.PDX_CLSGet('RIK_CategoryName_KAZ_PLNPAY') then UserFieldDate1 else DateCreation end 
			   from dbo.Docs
			   where DocID = @DocID
			
				select @SQLStatement = 'insert into #Errors (Error) ' +
				' select distinct ''' + @RUSField + ': значение ['' + D.OneValue + ''] в справочнике не существует'' from #ListTable D ' + 
				' left join dbo.' + case  @DirType
										when 205 then 'PDX_pay_PRiZ'
										when 212 then case when year(@DT)<=2015 then 'PDX_pay_Items' else 'PDX_pay_Items2016' end
									end + ' V with (nolock) on ' + case  @DirType
										when 205 then 'V.Code'
										when 212 then 'V.Code'
									end + '= D.ValueID ' + 
				' where V.SetID is null' 
				--select @Result = @@error if @Result <> 0 goto Err
				--print @SQLStatement
				exec (@SQLStatement)
				--select @Result = @@error if @Result <> 0 goto Err
			end
			else if @DirType = 224
			begin
				SET @SQLString =
					 N'SELECT top 1 @ActDoc = ActDoc, @Projects = ' + @PrjField +' from dbo.Docs where DocID = @DocID'
				set @ParmDefinition = N'@ActDoc varchar(128) output, @Projects varchar(1024) output, @DocID varchar(128)'
				EXECUTE sp_executesql @SQLString, @ParmDefinition,
						  @ActDoc = @ActDoc OUTPUT, @Projects = @Projects OUTPUT ,@DocID=@DocID
						  
				select @SQLStatement = 'insert into #Errors (Error) ' +
					' select top 1 ''' + @RUSField + ': Значение может быть только из списка [''+ S.Users + '']'' from #ListTable D ' + 
					' inner join dbo.NameAprovalSettings S on S.ClassDoc = ''' + @ClassDoc + ''' and (S.ActDoc = ''' + @ActDoc + ''' or S.ActDoc='''') and S.Projects = ''' + @Projects + ''' ' +
					' where not S.Users like ''%<'' + D.ValueID + ''>%'' ' + 
					' order by S.ActDoc desc' 
					--select @Result = @@error if @Result <> 0 goto Err
					--print @SQLStatement
					exec (@SQLStatement)
					--select @Result = @@error if @Result <> 0 goto Err
			end
			else if @DirType = 227
			begin
				SET @SQLString =
					 N'SELECT top 1 @ActDoc = ActDoc from dbo.Docs where DocID = @DocID'
				set @ParmDefinition = N'@ActDoc varchar(128) output, @DocID varchar(128)'
				EXECUTE sp_executesql @SQLString, @ParmDefinition,
						  @ActDoc = @ActDoc OUTPUT, @DocID=@DocID
						  						  
				select @SQLStatement = 'insert into #Errors (Error) ' +
					' select top 1 ''' + @RUSField + ': Значение может быть только из списка [''+ S.Users + '']'' from #ListTable D ' + 
					' inner join dbo.NAZOOSettings S on S.ClassDoc = ''' + @ClassDoc + ''' and (S.ActDoc = ''' + @ActDoc + ''' or S.ActDoc='''')  ' +
					' where not S.Users like ''%<'' + D.ValueID + ''>%'' ' + 
					' order by S.ActDoc desc' 
					--select @Result = @@error if @Result <> 0 goto Err
					--print @SQLStatement
					exec (@SQLStatement)
					--select @Result = @@error if @Result <> 0 goto Err
			end
			else if @DirType = 230
			begin
										  						  
				select @SQLStatement = 'insert into #Errors (Error) ' +
				' select distinct ''' + @RUSField + ': значение ['' + D.OneValue + ''] в справочнике не существует '' from #ListTable D ' + 
				' left join dbo.Scenariy V with (nolock) on V.Descr = D.ValueID ' + 
				' where V.ID is null' 
				--select @Result = @@error if @Result <> 0 goto Err
				--print @SQLStatement
				exec (@SQLStatement)
				--select @Result = @@error if @Result <> 0 goto Err
			end
			--select @Result = @@error if @Result <> 0 goto Err
	
			delete from #CursorTable
			where FieldID = @FieldID
			--select @Result = @@error if @Result <> 0 goto Err
		
		end

		--select @Result = @@error if @Result <> 0 goto Err
			
		--формируем итоговое сообщение об ошибке
		select @SQLStatement = ''
		select @SQLStatement = @SQLStatement + 
		case @SQLStatement when '' then '' else '<BR>' end + '<font color=red>ОШИБКА! </font>' + ltrim(rtrim(Error))
		from #Errors
		where ltrim(rtrim(isnull(Error,''))) <> ''
		order by OrderIndex desc
		--select @Result = @@error if @Result <> 0 goto Err
	end
	else
	begin
		select @SQLStatement = ''
	end
	--select @Result = @@error if @Result <> 0 goto Err
Ok:
	drop table #CursorTable 
	--select @Result = @@error if @Result <> 0 goto Err
	drop table #ListTable 
	--select @Result = @@error if @Result <> 0 goto Err
	drop table #Errors
	--select @Result = @@error if @Result <> 0 goto Err

	select case @SQLStatement when '' then '' else '<BR>' end + @SQLStatement
	--select @Result = @@error if @Result <> 0 goto Err

	--return @Result
--Err:
	--drop table #CursorTable 
    --	drop table #ListTable 
	--drop table #Errors

	--return @Result


















GO
/****** Object:  StoredProcedure [dbo].[PDX_FindOneField] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_FindOneField]
	@Value varchar(1024),
	@notEmpty bit,
	@Table varchar(50),
	@FieldName varchar(128),
	@RUSName varchar(255),
	@isMulti bit
as
	declare @Result int,
			@OneValue varchar(1024),
			@Pos1 int,
			@Pos2 int,
			@Separator varchar(1),
			@SQLSt varchar(8000)
			

 	set @Result = 0

set @Separator = '
'
	create table #tbl 
		(OneValue varchar(1024))
	create table #Errors 
		(Error varchar(2048))

	select @Value = ltrim(rtrim(@Value)), @Table = ltrim(rtrim(@Table)),@FieldName=ltrim(rtrim(@FieldName))
	select @Result = @@error if @Result <> 0 goto Err

	If @FieldName = '' or @Table = ''
	begin
		insert into #Errors (Error) values ('Для поля ' + @RUSName + ' не указано имя справочника. Обратитесь к Администратору СЭД.')
		select @Result = @@error if @Result <> 0 goto Err
	end 
	else
	begin
	    If @notEmpty = 1 and @Value = ''
		begin
			insert into #Errors (Error) values ('Поле [' + @RUSName + '] не может быть пустым.')
			select @Result = @@error if @Result <> 0 goto Err
		end
		else
		begin
			if @isMulti = 1
			begin
				while @Value <> ''
				begin
					select @Pos1=1, @Pos2=0, @OneValue = ''
					select @Result = @@error if @Result <> 0 goto Err
					select @Pos2 = charindex(@Separator,@Value)		
					select @Result = @@error if @Result <> 0 goto Err
		
			        if @Pos2<@Pos1 
					begin
						set @Pos2 = len(@Value)
						select @Result = @@error if @Result <> 0 goto Err
					end
					select @OneValue = substring(@Value,@Pos1,@Pos2+1),
							@Value = stuff(@Value,@Pos1,@Pos2,'')
					select @Result = @@error if @Result <> 0 goto Err
		
					If ltrim(rtrim(@OneValue)) = '' and ltrim(rtrim(@Value)) <> ''
					begin	
						select @OneValue = @Value,
							@Value = ''
						select @Result = @@error if @Result <> 0 goto Err
					end
					
					select @OneValue = ltrim(rtrim(replace(replace(replace(@OneValue,@Separator,''),char(13),''),char(10),'')))
					select @Result = @@error if @Result <> 0 goto Err
		
					If @OneValue <> ''
					begin
			 			insert into #tbl (OneValue) values (@OneValue)
						select @Result = @@error if @Result <> 0 goto Err
					end
				end
				
			end
			else
			begin
		 		insert into #tbl (OneValue) values (@Value)
				select @Result = @@error if @Result <> 0 goto Err
			end
			
			select @SQLSt = 'insert into #Errors(Error) select ''' + @RUSName + ': значение ['' + V.OneValue + ''] в справочнике не существует'' from #tbl V left join ' + @Table +' T on V.OneValue=T.' + @FieldName + ' where T.' + @FieldName + ' is null'
			print @SQLSt
			exec (@SQLSt)
		end
	end

	select @SQLSt = ''
	select @SQLSt = @SQLSt + 
	case @SQLSt when '' then '' else '<BR>' end + '<font color=red>ОШИБКА! </font>' + ltrim(rtrim(Error))
	from #Errors
	where ltrim(rtrim(isnull(Error,''))) <> ''
	order by Error
	select @Result = @@error if @Result <> 0 goto Err


	select @SQLSt
	select @Result = @@error if @Result <> 0 goto Err

    drop table #tbl
    drop table #Errors

	return @Result
Err:
    drop table #tbl
    drop table #Errors

	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_FindShCode] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_FindShCode]			
	@Code varchar(128)
as

set @Code = ltrim(ISNULL(@Code,''))
If len(@Code)>0
begin
	;with X as (
	select distinct C.DocIDInt from dbo.PDXSHCode C
	where Code like '%' + @Code + '%'
		and isDel = 0
	)
	
	select
		D.DocID,
		D.GUID,
		D.DocIDadd,
		D.DocIDIncoming,
		D.DocIDParent,
		D.DocIDPrevious,
		D.Author,
		D.Correspondent,
		D.Resolution,
		D.History,
		D.Result,
		D.PercentCompletion,
		D.Department,
		D.Name,
		D.Description,
		D.LocationURL,
		D.LocationPaper,
		D.FileNamePrefix,
		D.FileName,
		D.FileNameNameLastModification,
		D.FileNameDateLastAccessed,
		D.FileNameDateLastModification,
		D.LocationPath,
		D.ExtInt,
		D.PartnerName,
		D.StatusDevelopment,
		D.StatusPayment,
		D.StatusArchiv,
		D.StatusCompletion,
		D.StatusDelivery,
		D.TypeDoc,
		D.ClassDoc,
		D.ActDoc,
		ISNULL(REPLACE((
          SELECT DISTINCT C.Code +';;'
          FROM dbo.PDXSHCode C
          WHERE C.DocIdInt = D.DocIdInt and C.isDel = 0
          FOR XML PATH('')
          ),';;',CHAR(13)+char(10)),'') as InventoryUnit,
		D.PaymentMethod,
		D.AmountDoc,
		D.QuantityDoc,
		D.DateActivation,
		D.SecurityLevel,
		D.DateCreation,
		D.DateCompletion,
		D.DateCompleted,
		D.DateExpiration,
		D.NameCreation,
		D.NameAproval,
		D.NameApproved,
		D.DateApproved,
		D.ListToEdit,
		D.ListToReconcile,
		D.ListReconciled,
		D.NameResponsible,
		D.NameControl,
		D.NameLastModification,
		D.DateLastModification,
		D.UserFieldText1,
		D.UserFieldText2,
		D.UserFieldText3,
		D.UserFieldText4,
		D.UserFieldText5,
		D.UserFieldText6,
		D.UserFieldText7,
		D.UserFieldText8,
		D.UserFieldMoney1,
		D.UserFieldMoney2,
		D.UserFieldDate1,
		D.UserFieldDate2,
		D.UserFieldDate3,
		D.UserFieldDate4,
		D.UserFieldDate5,
		D.UserFieldDate6,
		D.UserFieldDate7,
		D.UserFieldDate8,
		D.IsActive,
		D.DateActive,
		D.BusinessProcessStep, 
        D.ExtPassword,
		D.DateSigned,
		D.Currency,
		D.CurrencyRate,
		D.Rank,
		D.ListToView,
		D.Content,
		D.License,
		D.TransferGUID,
		D.DocIDInt,
		D.DocID_AddNumber
    from X
    inner join dbo.Docs D on X.DocIDInt = D.DocIDInt
    order by d.DateActivation desc, D.DocID
end
else
begin
	select top 0
		DocID,
		GUID,
		DocIDadd,
		DocIDIncoming,
		DocIDParent,
		DocIDPrevious,
		Author,
		Correspondent,
		Resolution,
		History,
		Result,
		PercentCompletion,
		Department,
		Name,
		Description,
		LocationURL,
		LocationPaper,
		FileNamePrefix,
		FileName,
		FileNameNameLastModification,
		FileNameDateLastAccessed,
		FileNameDateLastModification,
		LocationPath,
		ExtInt,
		PartnerName,
		StatusDevelopment,
		StatusPayment,
		StatusArchiv,
		StatusCompletion,
		StatusDelivery,
		TypeDoc,
		ClassDoc,
		ActDoc,
		'' as InventoryUnit,
		PaymentMethod,
		AmountDoc,
		QuantityDoc,
		DateActivation,
		SecurityLevel,
		DateCreation,
		DateCompletion,
		DateCompleted,
		DateExpiration,
		NameCreation,
		NameAproval,
		NameApproved,
		DateApproved,
		ListToEdit,
		ListToReconcile,
		ListReconciled,
		NameResponsible,
		NameControl,
		NameLastModification,
		DateLastModification,
		UserFieldText1,
		UserFieldText2,
		UserFieldText3,
		UserFieldText4,
		UserFieldText5,
		UserFieldText6,
		UserFieldText7,
		UserFieldText8,
		UserFieldMoney1,
		UserFieldMoney2,
		UserFieldDate1,
		UserFieldDate2,
		UserFieldDate3,
		UserFieldDate4,
		UserFieldDate5,
		UserFieldDate6,
		UserFieldDate7,
		UserFieldDate8,
		IsActive,
		DateActive,
		BusinessProcessStep,
		ExtPassword,
		DateSigned,
		Currency,
		CurrencyRate,
		Rank,
		ListToView,
		Content,
		License,
		TransferGUID,
		DocIDInt,
		DocID_AddNumber
	from dbo.Docs
end
GO
/****** Object:  StoredProcedure [dbo].[PDX_FinLink_Check] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO





CREATE proc [dbo].[PDX_FinLink_Check]
	@DocID varchar(128)
as

declare @Result int
select @Result = 0

declare @UFT2 varchar(1024),
		@UFT5 varchar(1024),
		@Currency varchar(12),
		@ExtDocID varchar(128),
		@UFT2_1 varchar(1024),
		@UFT5_1 varchar(1024),
		@UFD datetime,
		@Currency_1 varchar(12),
		@ClassDoc varchar(128),
		@Cnt int,	
		@Ex3 char(1)

if isnull(@DocID,'') = ''
begin
	select '<font color=red>Ошибка!</font> Не указан исходный документ. Для устранения ошибки обратитесь к администратору СЭД.' as Err
	goto OK
end
select @Result = @@error if @Result <> 0 goto Err

select @UFT2 = UserFieldText2,
		@UFT5 = UserFieldText5,
		@Currency = Currency,
		@ClassDoc = ClassDoc
from dbo.Docs
where DocID = @DocID
select @Result = @@error if @Result <> 0 goto Err

If @ClassDoc <> dbo.PDX_CLSGet('RIK_CategoryName_FIN_ORDPAY')
begin
	select '<font color=red>Ошибка!</font> Ошибка в определении категории документа. Обратитесь к администратору СЭД.' as Err
	goto OK
end
select @Result = @@error if @Result <> 0 goto Err

select 
	@Ex3 = e3
from dbo.PDX_pay_PRiZ
where code = dbo.PDX_SubstringReturn(@UFT5, CHARINDEX('<',@UFT5), charindex('>',@UFT5) )
select @Result = @@error if @Result <> 0 goto Err

if ISNULL(@Ex3,'') <> '1' --проверка нужна , если призак <> 1
begin

	select @Cnt = 0 
	select @Result = @@error if @Result <> 0 goto Err
	select @Cnt = count(*) from dbo.Comments
	where DocID = @DocID
	and CommentType = 'LINK'
	and RIK_CommentType in (dbo.PDX_CLSGet('RIK_CategoryName_FIN_PLNPAY'),
							dbo.PDX_CLSGet('RIK_CategoryName_FIN_CORPAY'))
	select @Result = @@error if @Result <> 0 goto Err
							
	If @Cnt = 0 
	begin
		select '<font color=red>Ошибка!</font> В данном документе должна быть обязательная ссылка на Плановую или Корректирующую заявку.' as Err
		goto OK
	end
	else if @Cnt > 1
	begin
		select '<font color=red>Ошибка!</font> В данном документе может быть только одна обязательная ссылка на Плановую или Корректирующую заявку.' as Err
		goto OK
	end
	select @Result = @@error if @Result <> 0 goto Err

	select @ExtDocID = Subject
	from dbo.Comments
	where DocID = @DocID
	and CommentType = 'LINK'
	and RIK_CommentType in (dbo.PDX_CLSGet('RIK_CategoryName_FIN_PLNPAY'),
							dbo.PDX_CLSGet('RIK_CategoryName_FIN_CORPAY'))
	select @Result = @@error if @Result <> 0 goto Err


	select @UFT2_1 = case ClassDoc when dbo.PDX_CLSGet('RIK_CategoryName_FIN_CORPAY') then UserFieldText3 else UserFieldText2 end,
			@UFT5_1 = case ClassDoc when dbo.PDX_CLSGet('RIK_CategoryName_FIN_CORPAY') then UserFieldText7 else UserFieldText5 end,
			@UFD = case ClassDoc when dbo.PDX_CLSGet('RIK_CategoryName_FIN_CORPAY') then UserFieldDate3 else UserFieldDate1 end,
			@Currency_1 = Currency
	from dbo.Docs
	where DocID = @ExtDocID
	select @Result = @@error if @Result <> 0 goto Err

	If @UFT2 <> @UFT2_1 or @UFT5 <> @UFT5_1 or @Currency <> @Currency_1
	begin
		select '<font color=red>Ошибка!</font> ЦФО, статья расходов и валюта в ЗнО(текущем док-те) и в обязательной ссылке (на ПЗ/КЗ) должны совпадать.' as Err
		goto OK
	end
	select @Result = @@error if @Result <> 0 goto Err
	
	If not (MONTH(@UFD) = MONTH(getdate()) and YEAR(@UFD) = YEAR(getdate()))
	begin
		select '<font color=red>Ошибка!</font> Дата корректирующей или плановой заявки должна относиться к текущему месяцу.' as Err
		goto OK
	end
	select @Result = @@error if @Result <> 0 goto Err
	
end
	
select '' as Err
select @Result = @@error if @Result <> 0 goto Err

OK:
	return @Result
Err:
	
	return @Result






GO
/****** Object:  StoredProcedure [dbo].[PDX_FullUserNameGet] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
create proc [dbo].[PDX_FullUserNameGet]
	@UserNameIN AS varchar(250),
	@UserNameOUT as varchar(250) out,
	@Type bit = 0
AS

	declare @Result int
	set @Result = 0

	declare @UserID varchar(16)

	if @UserNameIN like '%<%>%' 
	begin
		select @UserID = dbo.PDX_SubstringReturn (@UserNameIN, charindex('<',@UserNameIN),charindex('>',@UserNameIN))
		select @Result = @@error if @Result <> 0 goto Err
	end
	else
	begin
		select @UserID = @UserNameIN
		select @Result = @@error if @Result <> 0 goto Err
	end

	select @UserNameOUT = Name
	from dbo.Users with (nolock)
	where UserID = @UserID
	select @Result = @@error if @Result <> 0 goto Err

	select @UserNameOUT = 
		case when isnull(@UserNameOUT,'') = ''  and @UserNameIN like '%<%>%' 
			then replace(dbo.PDX_SubstringReturn (' ' + @UserNameIN, 1, charindex('<',' ' + @UserNameIN)),'"','')
			else isnull(@UserNameOUT,'')
		end
	select @Result = @@error if @Result <> 0 goto Err

	if @Type = 0
	begin
		select @UserNameOUT as 'UserNameOUT'
	end

	return @Result
Err:

	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_GenerateNewNumber] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_GenerateNewNumber]
	@ClassDoc varchar(1000), --именно название одной категории
	@Year int,	
	@Day int,
	@Month int,
	@ParentDocID varchar(50) = null
as
	declare @Result int
	declare @StrNumber varchar(100),
		@OrderNumber int,
		@ListOfDocClass varchar(4000)
	set @Result = 0

	--табдица для получения последнего "занятого" номера
	create table #OrderNumber
		(OrderNumber int)
--определим константы для категорий документов, чтобы при необх. название править в одном месте
	declare 
		@d_DOVERENNOST varchar(100),
		@d_RASP_PRIKAZ varchar(100),
		@d_RASP_PR_IO  varchar(100),
		@d_PASPORJAZ   varchar(100),
		@d_DOG_AREND   varchar(100),
		@d_DOG_RPP	   varchar(100),	
		@d_DOG_PROCH   varchar(100),
		@d_DOG_POST	   varchar(100),
		@d_DOG_SMR	   varchar(100)	,
		@d_DOPSOGLAS   varchar(100)	

	select
		@d_DOVERENNOST = 'Доверенности',
		@d_RASP_PRIKAZ = 'Распорядительные док-ты / Приказы',
		@d_RASP_PR_IO = 'Распорядительные док-ты / Приказы об ИО',
		@d_PASPORJAZ = 'Распорядительные док-ты / Распоряжения',
		@d_DOG_AREND = 'Договоры / (А) Договоры аренды',
		@d_DOG_RPP = 'Договоры / (Е) Договоры на РПП',	
		@d_DOG_PROCH = 'Договоры / (М) Прочие договоры',
		@d_DOG_POST = 'Договоры / (Р) Договоры поставки',
		@d_DOG_SMR = 'Договоры / (С) Договоры на СМР',
		@d_DOPSOGLAS = 'Доп.соглашения'
	
--***Доверенности
	if @ClassDoc = @d_DOVERENNOST
	begin
		--На сохранение
		if not @Year is null
		begin
			--список категорий, по которым ведется счетчик
			select @ListOfDocClass = '''' + @ClassDoc + ''''
			select @Result = @@error if @Result <> 0 goto Err		

			--получить последний использованный номер
			insert into #OrderNumber
				(OrderNumber)
			exec dbo.PDX_GetLastIndex
				@ClassDoc = @ListOfDocClass,
				@Year = @Year,
				@FieldName = 'DocID',
				@FieldDate = 'DateCreation',
				@ParentDocID = null
			select @Result = @@error if @Result <> 0 goto Err

			--получили след. номер
			select top 1 @OrderNumber = isnull(OrderNumber,0) + 1 from #OrderNumber
			select @Result = @@error if @Result <> 0 goto Err		

			--структура номера NNN/ddmmyy
			--дополнили в начале 0-ми	
			select @StrNumber = isnull(replicate('0',3-len(@OrderNumber)),'') + cast(@OrderNumber as varchar(100))
			select @Result = @@error if @Result <> 0 goto Err

			--приписали к нему дату
			select @StrNumber = @StrNumber + '/' + 
								replicate('0',2-len(@Day)) + cast(@Day as varchar(2)) +
								replicate('0',2-len(@Month)) + cast(@Month as varchar(2)) +
								right(@Year,2)
			select @Result = @@error if @Result <> 0 goto Err
		end
		else
		begin --Создание нового
			--вернули результат
			select @StrNumber = 'Будет сформирован автоматически!'
			select @Result = @@error if @Result <> 0 goto Err
		end
	end
--****Договоры / (А) Договоры аренды
--****Договоры / (Е) Договоры на РПП
--****Договоры / (М) Прочие договоры
--****Договоры / (Р) Договоры поставки
--****Договоры / (С) Договоры на СМР
	if @ClassDoc in (@d_DOG_AREND,@d_DOG_RPP,@d_DOG_PROCH,@d_DOG_POST,@d_DOG_SMR)
	begin
		--создание
		--список категорий, по которым ведется счетчик
		select @ListOfDocClass = '''' + @ClassDoc + ''''
		select @Result = @@error if @Result <> 0 goto Err		

		--получить последний использованный номер
		insert into #OrderNumber
			(OrderNumber)
		exec dbo.PDX_GetLastIndex
			@ClassDoc = @ListOfDocClass,
			@Year = @Year,
			@FieldName = 'DocID',
			@FieldDate = 'DateActivation',
			@ParentDocID = null
		select @Result = @@error if @Result <> 0 goto Err		
		
		--получили след. номер
		select top 1 @OrderNumber = isnull(OrderNumber,0) + 1 from #OrderNumber
		select @Result = @@error if @Result <> 0 goto Err
		--БукваNNN/ГГ
		--дополнили в начале 0-ми	
		select @StrNumber = isnull(replicate('0',3-len(@OrderNumber)),'') + cast(@OrderNumber as varchar(100))
		select @Result = @@error if @Result <> 0 goto Err
		--поставим букву и год (букву берем из @ClassDOc)
		select @StrNumber = substring(@ClassDoc,charindex('(',@ClassDoc) + 1, 1) + @StrNumber + '/' + right(cast(isnull(@Year,Year(getdate())) as varchar(4)),2)
		select @Result = @@error if @Result <> 0 goto Err
	end

--***Распорядительные док-ты / Приказы
--***Распорядительные док-ты / Приказы об ИО
--***Распорядительные док-ты / Распоряжения
	if @ClassDoc in (@d_RASP_PRIKAZ,@d_RASP_PR_IO,@d_PASPORJAZ)
	begin
		--список категорий, по которым ведется счетчик
		select @ListOfDocClass = '''' + @d_RASP_PRIKAZ + ''',''' + @d_RASP_PR_IO + ''',''' + @d_PASPORJAZ + ''''
		select @Result = @@error if @Result <> 0 goto Err		

		if @Year is null --СОЗДАНИЕ
		begin
			--получить последний использованный номер
			insert into #OrderNumber
				(OrderNumber)
			exec dbo.PDX_GetLastIndex
				@ClassDoc = @ListOfDocClass,
				@Year = @Year,
				@FieldName = 'DocIDAdd',
				@FieldDate = 'DateCreation',
				@ParentDocID = null
			select @Result = @@error if @Result <> 0 goto Err		
		end
		else --РЕГИСТРАЦИЯ
		begin
			--получить последний использованный номер
			insert into #OrderNumber
				(OrderNumber)
			exec dbo.PDX_GetLastIndex
				@ClassDoc = @ListOfDocClass,
				@Year = @Year,
				@FieldName = 'DocID',
				@FieldDate = 'DateCreation',
				@ParentDocID = null
			select @Result = @@error if @Result <> 0 goto Err		
		end

		--получили след. номер
		select top 1 @OrderNumber = isnull(OrderNumber,0) + 1 from #OrderNumber
		select @Result = @@error if @Result <> 0 goto Err
		
		--Проект-NNNРП/06
		--NNNРП/06
		--дополнили в начале 0-ми	
		select @StrNumber = isnull(replicate('0',3-len(@OrderNumber)),'') + cast(@OrderNumber as varchar(100))
		select @Result = @@error if @Result <> 0 goto Err
		
		--добавляе  префикс, суффикс и год
		select @StrNumber = case when @Year is null
								then 'Проект-'
							else '' end + @StrNumber + 
							case @ClassDoc
								when @d_PASPORJAZ
									then 'РП'
								when @d_RASP_PRIKAZ
									then 'ПР'
								when @d_RASP_PR_IO
									then 'ИО'
							end + '/' + right(cast(isnull(@Year,Year(getdate())) as varchar(4)),2) + '-РИК'
		select @Result = @@error if @Result <> 0 goto Err
	end

--***Доп.Соглашения
	if @ClassDoc = @d_DOPSOGLAS
	begin
		--список категорий, по которым ведется счетчик
		select @ListOfDocClass = '''' + @ClassDoc + ''''
		select @Result = @@error if @Result <> 0 goto Err	
	
		--получить последний использованный номер
		insert into #OrderNumber
			(OrderNumber)
		exec dbo.PDX_GetLastIndex
			@ClassDoc = @ListOfDocClass,
			@Year = @Year,
			@FieldName = 'DocID',
			@FieldDate = null,
			@ParentDocID = @ParentDocID
		select @Result = @@error if @Result <> 0 goto Err	

		--получили след. номер
		select top 1 @OrderNumber = isnull(OrderNumber,0) + 1 from #OrderNumber
		select @Result = @@error if @Result <> 0 goto Err
		
		--.NN
		--дополнили в начале 0-ми	
		select @StrNumber = isnull(replicate('0',2-len(@OrderNumber)),'') + cast(@OrderNumber as varchar(100))
		select @Result = @@error if @Result <> 0 goto Err
		
		--добавляем родит. номер
		select @StrNumber = @ParentDocID + '.' + @StrNumber
		select @Result = @@error if @Result <> 0 goto Err
	end

	drop table #OrderNumber
	select @Result = @@error if @Result <> 0 goto Err

	--возвращаем результат
	select @StrNumber as DocID
	select @Result = @@error if @Result <> 0 goto Err	

	return @Result
Err:
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_GetLastIndex] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_GetLastIndex]
	@ClassDoc varchar(2000),
	@Year int,
	@FieldName varchar(25),
	@FieldDate varchar(25),
	@ParentDocID varchar(50) = null
as
	declare @Result int
	declare 
		@SQLString varchar(4000)
	set @Result = 0

	if isnull(len(@ClassDoc),0) = 0
	begin
		raiserror('Не указаны категории документов',16,1)
		select @Result = @@error goto Err
	end

	--проверить, что указанные поля даты и номера существуют
	if (select count(*) from sysobjects o
		inner join syscolumns c on c.id = o.id
			and c.Name in (@FieldName,@FieldDate)
		where o.Name = 'Docs') <> case when @ParentDocID is null then 2 else 1 end
	begin
		raiserror('Неправильно указано название поля Дата или Номер',16,1)
		select @Result = @@error goto Err
	end
	select @Result = @@error if @Result <> 0 goto Err

	--НОМЕР САМОСТОЯТЕЛЬНОГО ДОКУМЕНТА
	if @ParentDocID is null
	begin
	    --получаем последний номер из БД
		--ищем первую "цифровую" часть номера (слева направо)
		select @SQLString = 
		'select isnull((
		select 
			max(cast(
				substring(FIELD,
						  PATINDEX(''%[0-9]%'',FIELD),
						  PATINDEX(''%[^0-9]%'',substring(FIELD,PATINDEX(''%[0-9]%'',FIELD),len(FIELD)) + ''/'') - 1
						  ) 
				as int))
		from dbo.Docs D
		where D.ClassDoc in (' + @ClassDoc + ')
			and Year(FDATE) = ' + convert(varchar(100),isnull(@Year,Year(getdate()))) +
		' ),0)'
		--если год указан, то значит ищем среди сохраненных за указанный год
		--если год не указан, то ищем среди сохраненных за текущий год
		select @Result = @@error if @Result <> 0 goto Err
	end
	else
	begin--НОМЕР ПОДЧИНЕННОГО ДОКУМЕНТА  (пока прецендент только один -это доп. соглашения)
	--структура номера = номер_родит_докум.NN
	--при поиске от этого и отталкиваемся
		select @SQLString = 
		'select isnull((
		select 
			max(cast(
				replace(FIELD,''' + @ParentDocID + '.'','''')
				as int))
		from dbo.Docs D
		where D.ClassDoc in (' + @ClassDoc + ')
			and FIELD like ''' + @ParentDocID + '.%''' +
		' ),0)'
		select @Result = @@error if @Result <> 0 goto Err
	end

	select @SQLString = replace(replace(@SQLString,'FIELD','D.' + @FieldName),'FDATE','D.' + isnull(@FieldDate,''))
	select @Result = @@error if @Result <> 0 goto Err

	print @SQLString
	exec (@SQLString)
	select @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_GetResponsibleList] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
create proc [dbo].[PDX_GetResponsibleList]
	@UserList varchar(4000)
as
	declare @Result int
	set @Result = 0

	declare @Field varchar(255),
		@SQLStatement varchar(8000)

	create table #ListTable
		(Value varchar(4000),
		OneValue varchar(255),
		ValueID varchar(255))

--	select @Result = @@error if @Result <> 0 goto Err
	--РАЗБОР многострочного значения - разделитель ;
	delete #ListTable
	select @Result = @@error if @Result <> 0 goto Err
	if ltrim(rtrim(@UserList)) <> ''
	begin
		--разбираем значение на составляющие по разделителю - ;
		select @SQLStatement = 'insert into #ListTable (OneValue) values(''' + replace(@UserList,';',''') insert into #ListTable (OneValue) values(''') + ''')'
		select @Result = @@error if @Result <> 0 goto Err
		print @SQLStatement
		exec (@SQLStatement)
		select @Result = @@error if @Result <> 0 goto Err		
	end

	select @UserList = ''
	select 
		@UserList = @UserList + 
		case 
			when not @UserList like '%' + dbo.REC_DocProcessResponsibleByUserGet(ltrim(rtrim(OneValue))) + '%'
				then
					case isnull(len(@UserList),0)
						when 0 
							then '' 
						else char(13) + char(10) 
					end + 
					dbo.REC_DocProcessResponsibleByUserGet(ltrim(rtrim(OneValue)))
			else ''
		end
	from #ListTable
	select @Result = @@error if @Result <> 0 goto Err

	select ltrim(rtrim(@UserList)) as UserList
	select @Result = @@error if @Result <> 0 goto Err

    drop table #ListTable	
	select @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:
	drop table #ListTable
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_GetShCodeByDocID] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[PDX_GetShCodeByDocID]			
	@DocID varchar(128),
	@UserID varchar(24)
as
	declare @DocIDInt int, @isAdmin bit
	declare @ADoc table (ActDoc varchar(128))

	set @isAdmin = 0
	select @DocIDInt = DocIDInt
	from dbo.Docs 
	where DocID = @DocID


	select
		@isAdmin = case when StatusActive IN ('1','-') and WriteSecurityLevel = 10 and DateExpirationSecurity>=cast(GETDATE() AS DATE)
						then 1
					else 0 
					end
	from dbo.Users
	where UserID = @UserID
	
	insert into @ADoc (ActDoc)
	select A.Name
	from [dbo].[PDXBranchSettings] S
	inner join [dbo].Activities A on A.Name like '%<' + S.Fld1 + '>%'
	where S.Fld8 like '%<' + @UserID + '>%'

	select ROW_NUMBER() OVER(order by C.ActDoc, C.PartnerName) AS OI, C.KeyField,
		C.ActDoc, C.PartnerName, C.Code, C.Place, convert(varchar(100),C.DLM,104) + ' ' + convert(varchar(5),C.DLM,108) +  ' / ' + C.NLM as ILM,
		cast(case when not A.ActDoc is null OR @isAdmin = 1 then 1 else 0 end as bit) as isCanEdit,
		@UserID as UserID,
		right('000' + dbo.PDX_SubstringReturn(C.ActDoc, CHARINDEX('<',C.ActDoc), charindex('>',C.ActDoc)),3) + '\d\d\d\d\d\d\d\d\d\d$' as Dig
	from dbo.PDXShCode C
	left join @ADoc A on A.ActDoc = C.ActDoc
	where C.DocIDInt = @DocIDInt
		and C.isDel = 0
	order by C.OI

GO
/****** Object:  StoredProcedure [dbo].[PDX_IMList] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_IMList]
	@scavalue varchar(1024),
	@bExpAll bit
	
as
	declare 
		@Res int,
		@i int	
	
	declare @tbl table (Category varchar(1024), Cat varchar(1024))

	select @Res = 0, @i=0

	if @bExpAll = 1
	begin
		select Code, Descr, GrName + '/' + ActDoc + '/' as Category 
		from dbo.UserDir_IM 
		order by 3,1
		select @Res = @@error if @Res <> 0 goto Err
	end
	else
	begin --список всех "групп"? за исключением той, что будет "листовой"
		insert into @tbl (Category)
		select distinct GrName + '/' + ActDoc + '/'
	   	from dbo.UserDir_IM
		where GrName + '/' + ActDoc + '/' <> @scavalue
		select @Res = @@error if @Res <> 0 goto Err

		update @tbl set 
			category =  case when @scavalue = '' or (@scavalue <> '' and not category like @scavalue + '%')
							 then replace(category,stuff(category,1,charindex('/',category,1),''),'')
							 else category
						end
		select @Res = @@error if @Res <> 0 goto Err
						
		select distinct '' as Code,'' as Descr,Category
		from @tbl
		union 
		select Code, Descr, GrName + '/' + ActDoc + '/' as Category 
		from dbo.UserDir_IM 
		where GrName + '/' + ActDoc + '/' = @scavalue
		order by 3,1
		select @Res = @@error if @Res <> 0 goto Err
	end 
	select @Res = @@error if @Res <> 0 goto Err

OK:

	return @Res
Err:
	return @Res
GO
/****** Object:  StoredProcedure [dbo].[PDX_ImportObjectsFromMaster] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_ImportObjectsFromMaster]
	@dbname varchar(128)
as

declare @dbsysname varchar(128) = null
declare @sql nvarchar(1024)
declare @sql_res int = -1

select @dbsysname=name from sys.databases where name=@dbname

declare @currentdb nvarchar(128) = DB_NAME()

if @dbsysname is null or @currentdb = @dbsysname
begin
	RAISERROR('PDX_ImportObjectsFromMaster. Invalid source database name',16,1)
	return -1
end

set @sql = REPLACE('insert into dbo.UserDir_ISR(KeyField,Code,Descr,ParentKeyField,Project,NC,DC,NLM,DLM,FD) select KeyField,Code,Descr,ParentKeyField,Project,NC,DC,NLM,DLM,FD from [#DBNAME#].[dbo].[UserDir_ISR]','#DBNAME#', @dbsysname)
--select @sql
delete from UserDir_ISR

set IDENTITY_INSERT dbo.UserDir_ISR ON

execute @sql_res = sp_executesql @sql

set IDENTITY_INSERT dbo.UserDir_ISR OFF

if @sql_res != 0
begin
	raiserror('PDX_ImportObjectsFromMaster. Import failed.',16,1)
	return -2
end
return 0



GO
/****** Object:  StoredProcedure [dbo].[PDX_ImportSimpleDictionaryFromMaster] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_ImportSimpleDictionaryFromMaster]
	@dbname varchar(128)
	,@udname varchar(128)
as

declare @dbsysname varchar(128) = null
declare @sql nvarchar(1024)
declare @sql_res int = -1
declare @udkey int = null

select @dbsysname=name from sys.databases where name=@dbname

declare @currentdb nvarchar(128) = DB_NAME()

if @dbsysname is null or @currentdb = @dbsysname
begin
	RAISERROR('PDX_ImportSimpleDictionaryFromMaster. Invalid source database name',16,1)
	return -1
end

select @udkey= KeyField from UserDirectories where Name=@udname

if @udkey is null 
begin
	RAISERROR('PDX_ImportSimpleDictionaryFromMaster. Invalid dictionary name',16,1)
	return -1
end

set @sql = REPLACE('insert into UserDirValues(UDKeyField,Field1,Field2,Field3,Field4,Field5,Field6,GUID,GUIDUD,NameLastModification,DateLastModification) select UDKeyField,Field1,Field2,Field3,Field4,Field5,Field6,GUID,GUIDUD,NameLastModification,DateLastModification from [#DBNAME#].[dbo].UserDirValues where UDKeyField=@udid','#DBNAME#', @dbsysname)
--select @sql,@udkey
delete from UserDirValues where UDKeyField=@udkey

execute @sql_res = sp_executesql @sql, N'@udid int' ,@udid=@udkey

if @sql_res != 0
begin
	raiserror('PDX_ImportSimpleDictionaryFromMaster. Import error',16,1)
	return -2
end
return 0



GO
/****** Object:  StoredProcedure [dbo].[PDX_InvestKomitet_Email] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_InvestKomitet_Email]
	@DocID varchar(250)
as

	declare @Result int
	set @Result = 0

	declare @TableList table
		(UserName varchar(1024))

	declare @TableTmp table
		(UserList varchar(4000),
		UID int identity)
	
	declare
		@OneValue varchar(1024),	
		@UserList varchar(4000),
		@Ind int,
		@UID int

	--Инвестиционный комитет
	insert into @TableTmp (UserList)
	select Correspondent
	from dbo.Docs  with (nolock) 
	where DocID = @DocID
	select @Result = @@error if @Result <> 0 goto Err
	--приглашенные на вопросы
	insert into @TableTmp (UserList)
	select Correspondent
	from dbo.Docs  with (nolock)
	where DocIDParent = @DocID
		and ClassDoc = 'Инвестиционный комитет / Вопрос'
	select @Result = @@error if @Result <> 0 goto Err
	--докладчики по вопросам
	insert into @TableTmp (UserList)
	select Author
	from dbo.Docs  with (nolock)
	where DocIDParent = @DocID
		and ClassDoc = 'Инвестиционный комитет / Вопрос'
	select @Result = @@error if @Result <> 0 goto Err

	while exists (select 1 from @TableTmp)
	begin
		select top 1
			@UserList = ltrim(rtrim(isnull(UserList,''))),
			@UID = UID
		from @TableTmp
		select @Result = @@error if @Result <> 0 goto Err

		while len(@UserList) <> 0
		begin
			select @Ind = 0,@OneValue = ''
			select @Result = @@error if @Result <> 0 goto Err
			select @Ind = charindex(';',@UserList,1)
			select @Result = @@error if @Result <> 0 goto Err
			if @Ind = 0 select @Ind = len(@UserList)
			select @Result = @@error if @Result <> 0 goto Err
		
			select @OneValue = substring(@UserList,1,@Ind)
			select @Result = @@error if @Result <> 0 goto Err
			select @UserList = replace(@UserList,@OneValue,'')
			select @Result = @@error if @Result <> 0 goto Err

			if not exists (select 1 from @TableList where UserName = replace(@OneValue,';',''))
			begin
				insert into @TableList (UserName)
    			values (replace(@OneValue,';',''))
				select @Result = @@error if @Result <> 0 goto Err
			end
			select @Result = @@error if @Result <> 0 goto Err
		end		
		
		delete @TableTmp
		where UID = @UID
		select @Result = @@error if @Result <> 0 goto Err
	end
  	select @Result = @@error if @Result <> 0 goto Err


	select distinct
		U.UserID,
		U.Name,
		U.email + case when isnull(R.email,'')<>'' and right(rtrim(U.email),1) <> ';' then '; ' else '' end + isnull(R.email,'') as email
	from @TableList T
	inner join dbo.Users U with (nolock) on T.UserName like '%<' + U.UserID + '>%'
	left join dbo.Users R with (nolock) on R.UserID = U.DeputyID and 
		convert(datetime,convert(varchar(100),getdate(),104),104) between U.DeputyDateFrom and U.DeputyDateTo
  	select @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:
	
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_InvestKomitet_UsersList] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_InvestKomitet_UsersList]
	@DocID varchar(250),
	@ClassDoc varchar(255)
as

	declare @Result int
	set @Result = 0

	declare @TableList table
		(DocID varchar(255),
         UserName varchar(1024),
		 DT datetime,
 		 Type int)

	declare @TableTmp table
		(DocID varchar(255),
         UserList varchar(4000),
		 DT datetime)
	
	declare
		@TmpDocID varchar(250),
		@OneValue varchar(1024),	
		@UserList varchar(4000),
		@Ind int,
		@DT datetime

--1 - отв. исп/NameResponcible
--2 - докладчик/Author
--3 - приглашенные/Correspondent

	--отв. испольнитель = отв. за подготовку материалов
	insert into @TableList
		(DocID,UserName,Type,DT)
    select D.DocID, replace(D.NameResponsible,';',''),1,UserFieldDate2
	from dbo.Docs D with (nolock)
	where D.DocIDParent = @DocID	
		and isnull(ltrim(rtrim(replace(replace(D.NameResponsible,char(10),''),char(13),''))),'') <> ''
		and D.ClassDoc = @ClassDoc
		and lower(D.isActive) = 'y'
		and D.StatusCompletion <> '1'
	select @Result = @@error if @Result <> 0 goto Err

	--докладчик
	insert into @TableList
		(DocID,UserName,Type,DT)
    select D.DocID, replace(D.Author,';',''),2,UserFieldDate2
	from dbo.Docs D with (nolock)
	where D.DocIDParent = @DocID	
		and isnull(ltrim(rtrim(replace(replace(D.Author,char(10),''),char(13),''))),'') <> ''
		and D.ClassDoc = @ClassDoc
		and lower(D.isActive) = 'y'
	select @Result = @@error if @Result <> 0 goto Err

	--список приглашенных
 	insert into @TableTmp
		(DocID,UserList,DT)
    select D.DocID, replace(replace(D.Correspondent,char(10),''),char(13),''),UserFieldDate2
	from dbo.Docs D with (nolock)
	where D.DocIDParent = @DocID	
		and isnull(ltrim(rtrim(replace(replace(D.Correspondent,char(10),''),char(13),''))),'') <> ''
		and D.ClassDoc = @ClassDoc
		and lower(D.isActive) = 'y'
	select @Result = @@error if @Result <> 0 goto Err

 	while exists (select 1 from @TableTmp)
	begin
		select top 1 
			@UserList = UserList,
			@TmpDocID = DocID,
			@DT = DT
 		from @TableTmp
		select @Result = @@error if @Result <> 0 goto Err

		delete @TableTmp
		where DocID = @TmpDocID 
			and UserList = @UserList
		select @Result = @@error if @Result <> 0 goto Err

		while len(@UserList) <> 0
		begin
			select @Ind = 0,@OneValue = ''
			select @Result = @@error if @Result <> 0 goto Err
			select @Ind = charindex(';',@UserList,1)
			select @Result = @@error if @Result <> 0 goto Err
			if @Ind = 0 select @Ind = len(@UserList)
			select @Result = @@error if @Result <> 0 goto Err
		
			select @OneValue = substring(@UserList,1,@Ind)
			select @Result = @@error if @Result <> 0 goto Err
			select @UserList = replace(@UserList,@OneValue,'')
			select @Result = @@error if @Result <> 0 goto Err

			insert into @TableList
				(DocID,UserName,Type,DT)
    		values
				(@TmpDocID, replace(@OneValue,';',''),0,@DT)
			select @Result = @@error if @Result <> 0 goto Err
		end		
	end
    
	select 
		DocID,
		UserName,
		Type,
		convert(varchar(100),DT,104) as [DT],
		convert(varchar(5),DT,114) as [DT1] 
	from @TableList
	order by DocID,Type,UserName
  	select @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:
	
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_InvestKomitetMaterials] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_InvestKomitetMaterials]
	@DocID varchar(128),
	@VOP_Class varchar(255),
	@POV_Class varchar(255),
	@PRO_Class varchar(255),
	@RES_Class varchar(255)
as

  declare @Result int
  select @Result = 0

	declare @ClassDoc varchar(255),
		@DocIDParent varchar(255),
		@DocIDPrevious varchar(255)
		--@Description varchar(1024)
	declare @DocList table
	(DocID varchar(255), DocIDParent varchar(255),
	ClassDoc varchar(255),
	Description ntext)

	declare @Res table
		(Type varchar(255), 
		DocID varchar(255), 
		Version varchar(255), 
		FileName varchar(255), 
		Description ntext, 
		ClassDoc varchar(255), 
		OrderIndex int,
		FileNameOriginal varchar(255))

	select
		@ClassDoc = ClassDoc,
		@DocIDParent = DocIDParent,
		@DocIDPrevious = DocIDPrevious
		--@Description = Description
	from dbo.Docs with (nolock)
	where DocID = @DocID 
	select @Result = @@error if @Result <> 0 goto Err
		
	if @ClassDoc = @PRO_Class 
	begin
		insert into @DocList
			(DocID, Description, DocIDParent, ClassDoc)
		select
			P.DocID, P.Description, P.DocID, P.ClassDoc
		from Docs P with (nolock)
		where P.ClassDoc = @VOP_Class
			and P.DocIDParent = @DocIDParent
			and upper(isnull(P.isActive,'')) = 'Y'
			and isnull(P.StatusCompletion,'') <> '0'
		select @Result = @@error if @Result <> 0 goto Err

		insert into @DocList
			(DocID, Description, DocIDParent, ClassDoc)
		select
			P.DocID, /*P.Description,*/P.Content, P.DocIDPrevious, P.ClassDoc
		from Docs P with (nolock)
		where P.ClassDoc = @RES_Class
			and P.DocIDParent = @DocID
			and upper(isnull(P.isActive,'')) = 'Y'
			and isnull(P.StatusCompletion,'') <> '0'
		select @Result = @@error if @Result <> 0 goto Err
	end
	else if @ClassDoc = @RES_Class
	begin
		insert into @DocList
			(DocID, Description, DocIDParent, ClassDoc)
		select
			@DocIDPrevious, Description, @DocIDPrevious, ClassDoc
		from dbo.Docs with (nolock)
		where DocID = @DocIDPrevious
		select @Result = @@error if @Result <> 0 goto Err

		insert into @DocList
			(DocID, Description, DocIDParent, ClassDoc)
		--values (@DocID, @Description, @DocIDPrevious, @ClassDoc)
		select
			DocID, Content, DocIDPrevious, ClassDoc
		from dbo.Docs with (nolock)
		where DocID = @DocID
		select @Result = @@error if @Result <> 0 goto Err
		
		select @Result = @@error if @Result <> 0 goto Err
	end


	insert into @Res (Type, DocID, Version, FileName, Description, ClassDoc, OrderIndex, FileNameOriginal)
	select
		1 as Type, C.DocID, C.Version + ' (от ' + convert(varchar(100), C.DateCreation, 104) + ' ' + convert(varchar(100), C.DateCreation, 114) + ')', FileName, '' as 'Description',ClassDoc, 1 as orderIndex, ISNULL(C.FileNameOriginal,C.FileName)
	from dbo.Comments C with (nolock)
		inner join @DocList D on D.DocID = C.DocID
	where C.CommentType = 'FILE'
		and isnull(C.FileName,'') <> ''
		and C.Amount = 0
	select @Result = @@error if @Result <> 0 goto Err

	insert into @Res (Type, DocID, Version, FileName, /*Description,*/ ClassDoc, OrderIndex, FileNameOriginal)
	select distinct
		0, R.DocID, '', '', /*C.Description,'',*/ R.ClassDoc, 1, ''
	from @Res R
	--inner join @DocList C on C.DocID = R.DocID
	--group by R.DocID, /*C.Description,*/ R.ClassDoc
	select @Result = @@error if @Result <> 0 goto Err

	update R 
		set Description = C.Description	 
	from @Res R 
	inner join @DocList C on C.DocID = R.DocID
	where R.Type = 0
	select @Result = @@error if @Result <> 0 goto Err
	

	insert into @Res (Type, DocID, Version, FileName, Description, ClassDoc, OrderIndex, FileNameOriginal)
	select 
		-1, ClassDoc, '' , '' , '' , ClassDoc, 0, ''
	from @Res
	group by ClassDoc
	select @Result = @@error if @Result <> 0 goto Err

	select
	  Type, DocID, Version, FileName, ClassDoc, OrderIndex, FileNameOriginal, Description
	from @Res
	order by 5,6,2,1,3
	select @Result = @@error if @Result <> 0 goto Err

	--select @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:
	
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_InvestKomitetProCreate] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_InvestKomitetProCreate]
	@DocID varchar(128),
	@NewDocID varchar(128),
	@NameCreation varchar(255),
	@Predsedatel varchar(255),
	@Secretar varchar(255),
	@IKContent varchar(512),
	@Add1     varchar(255),
	@Add2     varchar(255),
	@ClassDocPr varchar(255),
	@ClassDocPv varchar(255),
	@ClassDocR varchar(255),
	@ClassDocV varchar(255)
	
as
declare 
	@Res int,
	@FileNamePrefix varchar(255),
	@FileName1 varchar(255),
	@FileNameNameLastModification varchar(1024),
	@FileNameDateLastAccessed datetime,
	@FileNameDateLastModification datetime,
	@Date datetime

declare @TmpID table
	(DID varchar(255),
	Ind int identity)	
	
select @Res = 0
	select @FileNamePrefix = cast(replace(cast(NEWID() as varchar(40)),'-','') as varchar(24))
	select @Res = @@error if @Res <> 0 goto Err

	select @FileName1 = ''
	select @Res = @@error if @Res <> 0 goto Err

	select @FileNameNameLastModification = ''
	select @Res = @@error if @Res <> 0 goto Err

	select @FileNameDateLastAccessed = null
	select @Res = @@error if @Res <> 0 goto Err

	select @FileNameDateLastAccessed = null
	select @Res = @@error if @Res <> 0 goto Err

	/*select @InventoryUnit = ''
	select @Res = @@error if @Res <> 0 goto Err

	select @BusinessProcessStep = ''
	select @Res = @@error if @Res <> 0 goto Err

	select @CurrencyRate = null
	select @Res = @@error if @Res <> 0 goto Err

	*/select @Date = '1900-02-01 00:00:00.000'
	select @Res = @@error if @Res <> 0 goto Err

	if exists (select 1 from dbo.Docs where DocID = @DocID and ClassDoc = @ClassDocPv)--существует повестка
	begin
		if not exists (select 1 from dbo.Docs where DocIDParent = @DocID
						and ClassDoc = @ClassDocPr)
		begin
			if not exists (select 1 from dbo.Docs where DocID = @NewDocID)
			begin --протокол
				insert into dbo.Docs
					(DocID,
					GUID,
					DocIDadd,
					DocIDIncoming,
					DocIDParent,
					DocIDPrevious,
					Author,
					Correspondent,
					Resolution,
					History,
					Result,
					PercentCompletion,
					Department,
					Name,
					Description,
					LocationURL,
					LocationPaper,
					FileNamePrefix,
					FileName,
					FileNameNameLastModification,
					FileNameDateLastAccessed,
					FileNameDateLastModification,
					LocationPath,
					ExtInt,
					PartnerName,
					StatusDevelopment,
					StatusPayment,
					StatusArchiv,
					StatusCompletion,
					StatusDelivery,
					TypeDoc,
					ClassDoc,
					ActDoc,
					InventoryUnit,
					PaymentMethod,
					AmountDoc,
					QuantityDoc,
					DateActivation,
					SecurityLevel,
					DateCreation,
					DateCompletion,
					DateCompleted,
					DateExpiration,
					NameCreation,
					NameAproval,
					NameApproved,
					DateApproved,
					ListToEdit,
					ListToReconcile,
					ListReconciled,
					NameResponsible,
					NameControl,
					NameLastModification,
					DateLastModification,
					UserFieldText1,
					UserFieldText2,
					UserFieldText3,
					UserFieldText4,
					UserFieldText5,
					UserFieldText6,
					UserFieldText7,
					UserFieldText8,
					UserFieldMoney1,
					UserFieldMoney2,
					UserFieldDate1,
					UserFieldDate2,
					UserFieldDate3,
					UserFieldDate4,
					UserFieldDate5,
					UserFieldDate6,
					UserFieldDate7,
					UserFieldDate8,
					IsActive,
					DateActive,
					BusinessProcessStep,
					ExtPassword,
					DateSigned,
					Currency,
					CurrencyRate,
					Rank,
					ListToView,
					Content)
				select
					@NewDocID,--DocID,
					NewID(),--GUID,
					'',--DocIDAdd,--DocIDadd,
					'',--DocIDIncoming,--DocIDIncoming,
					@DocID,--DocIDParent,
					'',--DocIDPrevious,--DocIDPrevious,
					Author,--Author,
					Correspondent,--!!!!Correspondent,
					null,--Resolution,--Resolution,
					'',--,--History,--History,
					'',--Result,--Result,
					null,--PercentCompletion,--PercentCompletion,
					Department,--Department,
					'',--Name,--Name,
					Description,--!!!!!!!!!!!111Description,
					null,--LocationURL,--LocationURL,
					null,--LocationPaper,--LocationPaper,
					@FileNamePrefix,--FileNamePrefix,
					@FileName1,--FileName,
					@FileNameNameLastModification,-- FileNameNameLastModification,
					@FileNameDateLastAccessed, --FileNameDateLastAccessed,
					@FileNameDateLastModification, --FileNameDateLastModification,
					null,--LocationPath, --LocationPath,
					'',--ExtInt,-- ExtInt,
					'',--PartnerName,-- PartnerName,
					'1',--@StatusDevelopment, -- StatusDevelopment,
					'',--@StatusPayment,-- StatusPayment,
					'',--@StatusArchiv,-- StatusArchiv,
					'',--@StatusCompletion,-- StatusCompletion,
					null,--@StatusDelivery,-- StatusDelivery,
					'',--TypeDoc,-- TypeDoc,
					@ClassDocPr,--@ClassDoc,-- ClassDoc,
					'',--ActDoc,-- ActDoc,
					'',--InventoryUnit,-- InventoryUnit,
					'',--PaymentMethod,-- PaymentMethod,
					0,--AmountDoc,-- AmountDoc,
					QuantityDoc,--QuantityDoc,-- QuantityDoc,
					@Date,--DateActivation,--DateActivation,
					'4',--@SecurityLevel,-- SecurityLevel,
					getdate(),--@DateCreation,-- DateCreation,
					DateCompletion,-- DateCompletion,
					null,--@DateCompleted,-- DateCompleted,
					@Date,--DateExpiration, --DateExpiration,
					@NameCreation, --NameCreation,
					@Add2,--@NameAproval, --NameAproval,
					'',--@NameApproved, --NameApproved
					null,--@DateApproved, --DateApproved
					'',--ListToEdit, -- ListToEdit
					@Secretar + char(13) + char(10) + @Add1 + char(13) + char(10) + @Predsedatel + char(13) + char(10) + replace(@IKContent,char(13) + char(10),' '),--@ListToReconcile, --ListToReconcile
					'',--@ListReconciled, --ListReconciled
					'',--NameResponsible, -- NameResponsible
					@Secretar, -- NameControl
					@NameCreation, --NameLastModification,
					getdate(),--DateLastModification,
					'',--@UserFieldText1, --UserFieldText1
					'',--@UserFieldText2, -- UserFieldText2
					'',--@UserFieldText3,  --UserFieldText3
					'',--@UserFieldText4, --UserFieldText4
					'',--@UserFieldText5, -- UserFieldText5
					'',--@UserFieldText6, -- UserFieldText6
					'',--@UserFieldText7, -- UserFieldText7
					'',--@UserFieldText8, -- UserFieldText8
					0,--@UserFieldMoney1, --UserFieldMoney1
					0,--@UserFieldMoney2,--UserFieldMoney2
					@Date,--@UserFieldDate1, --UserFieldDate1
					@Date,--@UserFieldDate2, --UserFieldDate2
					@Date,--@UserFieldDate3,--UserFieldDate3
					@Date,--@UserFieldDate4, --UserFieldDate4
					@Date,--@UserFieldDate5, --UserFieldDate5
					@Date,--@UserFieldDate6, --UserFieldDate6
					@Date,--@UserFieldDate7, --UserFieldDate7
					@Date,--@UserFieldDate8, --UserFieldDate8
					'Y',--@IsActive, -- IsActive
					null,--@DateActive, --DateActive
					'',--BusinessProcessStep, --BusinessProcessStep
					'',--@ExtPassword, -- ExtPassword
					null,--@DateSigned, --DateSigned
					'',--Currency, --Currency
					null,--CurrencyRate, --CurrencyRate
					'',--Rank, --Rank
					'',--ListToView, --ListToView
					''--Content -- Content
				from dbo.Docs 
				where DocID = @DocID
				select @Res = @@error if @Res <> 0 goto Err
			
				--решения
				insert into @TmpID
					(DID)
				select
					DocID
				from dbo.Docs 
				where DocIDParent = @DocID
					and ClassDoc = @ClassDocV
				order by QuantityDoc
				select @Res = @@error if @Res <> 0 goto Err
	
				insert into dbo.Docs
					(DocID,
					GUID,
					DocIDadd,
					DocIDIncoming,
					DocIDParent,
					DocIDPrevious,
					Author,
					Correspondent,
					Resolution,
					History,
					Result,
					PercentCompletion,
					Department,
					Name,
					Description,
					LocationURL,
					LocationPaper,
					FileNamePrefix,
					FileName,
					FileNameNameLastModification,
					FileNameDateLastAccessed,
					FileNameDateLastModification,
					LocationPath,
					ExtInt,
					PartnerName,
					StatusDevelopment,
					StatusPayment,
					StatusArchiv,
					StatusCompletion,
					StatusDelivery,
					TypeDoc,
					ClassDoc,
					ActDoc,
					InventoryUnit,
					PaymentMethod,
					AmountDoc,
					QuantityDoc,
					DateActivation,
					SecurityLevel,
					DateCreation,
					DateCompletion,
					DateCompleted,
					DateExpiration,
					NameCreation,
					NameAproval,
					NameApproved,
					DateApproved,
					ListToEdit,
					ListToReconcile,
					ListReconciled,
					NameResponsible,
					NameControl,
					NameLastModification,
					DateLastModification,
					UserFieldText1,
					UserFieldText2,
					UserFieldText3,
					UserFieldText4,
					UserFieldText5,
					UserFieldText6,
					UserFieldText7,
					UserFieldText8,
					UserFieldMoney1,
					UserFieldMoney2,
					UserFieldDate1,
					UserFieldDate2,
					UserFieldDate3,
					UserFieldDate4,
					UserFieldDate5,
					UserFieldDate6,
					UserFieldDate7,
					UserFieldDate8,
					IsActive,
					DateActive,
					BusinessProcessStep,
					ExtPassword,
					DateSigned,
					Currency,
					CurrencyRate,
					Rank,
					ListToView,
					Content)
				select
					@NewDocID + '-' + replicate('0',2-len(cast(Ind as varchar(100)))) + cast(Ind as varchar(100)),--DocID,
					NewID(),--GUID,
					'',--DocIDAdd,--DocIDadd,
					'',--DocIDIncoming,--DocIDIncoming,
					@NewDocID,--DocIDParent,
					DocID,--DocIDPrevious,--DocIDPrevious,
					Author,--!!!!!!!Author,
					Correspondent,--!!!!Correspondent,
					'',--Resolution,--Resolution,
					History,--History,
					null,--Result,--Result,
					null,--PercentCompletion,--PercentCompletion,
					'',--Department,
					'',--Name,
					Description,--!!!!!!!!!!!111Description,
					null,--,--LocationURL,
					null,--LocationPaper,--LocationPaper,
					@FileNamePrefix,--FileNamePrefix,
					@FileName1,--FileName,
					@FileNameNameLastModification,-- FileNameNameLastModification,
					@FileNameDateLastAccessed, --FileNameDateLastAccessed,
					@FileNameDateLastModification, --FileNameDateLastModification,
					null, --LocationPath,
					'',-- ExtInt,
					'',-- PartnerName,
					'1',--@StatusDevelopment, -- StatusDevelopment,
					'',--@StatusPayment,-- StatusPayment,
					'',--@StatusArchiv,-- StatusArchiv,
					'',--@StatusCompletion,-- StatusCompletion,
					null,--@StatusDelivery,-- StatusDelivery,
					TypeDoc,-- TypeDoc,
					@ClassDocR,--@ClassDoc,-- ClassDoc,
					'',-- ActDoc,
					'',--InventoryUnit,-- InventoryUnit,
					'',--PaymentMethod,-- PaymentMethod,
					0,--AmountDoc,-- AmountDoc,
					QuantityDoc,-- QuantityDoc,
					@Date,--DateActivation,--DateActivation,
					'4',--@SecurityLevel,-- SecurityLevel,
					getdate(),--@DateCreation,-- DateCreation,
					@Date,--DateCompletion,-- DateCompletion,
					null,--@DateCompleted,-- DateCompleted,
					@Date,--DateExpiration, --DateExpiration,
					@NameCreation, --NameCreation,
					'',--@NameAproval, --NameAproval,
					null,--@NameApproved, --NameApproved
					null,--@DateApproved, --DateApproved
					replace(ListToView,'>-;','>;') + 
					case charindex(@Secretar,ListToView) when 0 then char(13) + char(10) + @Secretar else '' end +
  					case when charindex(@Add1,ListToView)=0 or charindex(@Add2,ListToView)=0 then char(13) + char(10) + '===Добавлены==================================================' else '' end+
  					case charindex(@Add1,ListToView) when 0 then char(13) + char(10) + @Add1 else '' end+
  					case charindex(@Add2,ListToView) when 0 then char(13) + char(10) + @Add2 else '' end, -- ListToEdit
					'',--@ListToReconcile, --ListToReconcile
					'',--@ListReconciled, --ListReconciled
					'',--NameResponsible, -- NameResponsible
					@Secretar,--NameControl, -- NameControl
					@NameCreation, --NameLastModification,
					getdate(),--DateLastModification,
					'',--@UserFieldText1, --UserFieldText1
					UserFieldText2, -- UserFieldText2
					'',--@UserFieldText3,  --UserFieldText3
					'',--@UserFieldText4, --UserFieldText4
					'',--@UserFieldText5, -- UserFieldText5
					'',--@UserFieldText6, -- UserFieldText6
					UserFieldText7, -- UserFieldText7
					'',--@UserFieldText8, -- UserFieldText8
					0,--@UserFieldMoney1, --UserFieldMoney1
					0,--@UserFieldMoney2,--UserFieldMoney2
					@Date,--@UserFieldDate1, --UserFieldDate1
					@Date,--@UserFieldDate2, --UserFieldDate2
					UserFieldDate3,--UserFieldDate3
					@Date,--@UserFieldDate4, --UserFieldDate4
					@Date,--@UserFieldDate5, --UserFieldDate5
					@Date,--@UserFieldDate6, --UserFieldDate6
					@Date,--@UserFieldDate7, --UserFieldDate7
					@Date,--@UserFieldDate8, --UserFieldDate8
					'Y',--@IsActive, -- IsActive
					null,--@DateActive, --DateActive
					'',--BusinessProcessStep, --BusinessProcessStep
					'',--@ExtPassword, -- ExtPassword
					null,--@DateSigned, --DateSigned
					Currency, --Currency
					null,--CurrencyRate, --CurrencyRate
					'',--Rank, --Rank
					'',--ListToView, --ListToView
					Content -- Content
				from dbo.Docs D
				inner join @TmpID T on T.DID = D.DocID
				where DocIDParent = @DocID
					and ClassDoc = @ClassDocV
				select @Res = @@error if @Res <> 0 goto Err
				
				select '' as res, '' as DocID
				select @Res = @@error if @Res <> 0 goto Err
			end
			else 
			begin
				select 
					'Документ с таким номером уже существует' as res,
					DocID
				from dbo.Docs where DocID = @NewDocID
				select @Res = @@error if @Res <> 0 goto Err
			end
		end
		else
		begin	
			select 
				'Протокол к этой повестке уже существует' as res,
				DocID
			from dbo.Docs where DocIDParent = @DocID
						and ClassDoc = @ClassDocPr
			select @Res = @@error if @Res <> 0 goto Err
		end
	end
	else
	begin	
		select 'Указанный документ не существует' as res
		select @Res = @@error if @Res <> 0 goto Err		
	end
	

	return @Res
Err:
	
	return @Res
GO
/****** Object:  StoredProcedure [dbo].[PDX_InvestKomitetVypiska] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_InvestKomitetVypiska]
	@DocIDParent varchar(255),
	@DocID varchar(255),
	@ClassDoc varchar(255),
	@SDMembers varchar(4000)=null,
	@SDPredsedatel varchar(500)=null,
	@SDSecretar varchar(500)=null
as
	declare @Result int
	set @Result = 0
	
	declare 
		@UserList varchar(2048),
		@Ind int,
		@OneValue varchar(255),
		@UserRes varchar(4000),
		@UserNameOUT varchar(255),
		@Type int

	declare @TblRes table
    --create table @TblRes
		(DocID varchar(255),
		UserFieldText1 varchar(1024),
		Author varchar(255),
		Correspondent varchar(4000), --приглашенные
		ListToView varchar(1024), --члены СД ИСД
		UserFieldText5 varchar(4000), --рассылка
		NameControl varchar(255),
		Type int default 0,
		Name varchar(1024),
		Ind int,
		NameLastModification varchar(512),
		DateLastModification datetime,
		DateCreation datetime,
		UserFieldText2 ntext)

	declare @TableTmp table
		(UserList varchar(2048),
		Type int)
	
	--получаем карточки решений
	insert into @TblRes
		(DocID, UserFieldText1, UserFieldText2, Author, Correspondent, ListToView, UserFieldText5, Name, NameControl, Ind,
		NameLastModification, DateLastModification, DateCreation)
	select 
		DocID,
		replace(isnull(UserFieldText1,''),char(13) + char(10),'<br>') as 'Обсуждали',
		/*isnull(UserFieldText2,'') + isnull(UserFieldText3,'')*/isnull(Content,'') as 'Решили',
		Author,
		replace(Correspondent,'===Добавлены==================================================',''), --приглашенные
		replace(ListToEdit,'===Добавлены==================================================',''),
		replace(ListToView,'===Добавлены==================================================',''), --рассылка будет
		Description,
		NameControl,
		cast(QuantityDoc as int),
		NameLastModification,
		DateLastModification,
		DateCreation
	from dbo.Docs with (nolock)
	where DocIDParent = @DocIDParent 
		and ClassDoc = @ClassDoc
		and (DocID = @DocID or @DocID = '')
	order by DocID
	select @Result = @@error if @Result <> 0 goto Err

	--!!!!НЕ работает для документов созданных до 11,07,2007
	if exists (select 1 from @TblRes where convert(datetime,convert(varchar(100),DateCreation,104),104) < '2007-07-01')
	begin 
		delete from @TblRes
		select @Result = @@error if @Result <> 0 goto Err
		goto Res
	end
	select @Result = @@error if @Result <> 0 goto Err

--формируем списки пользователей,котрые е=нужно вывести на документе
	--члены сд исд (из протокола)
	insert into @TableTmp (UserList,Type)
	select
		case isnull(charindex('===Добавлены==================================================',Correspondent),0)
			when 0 
				then Correspondent
			else left(Correspondent,charindex('===Добавлены==================================================',Correspondent)-1)
		end,5
	from dbo.Docs
	where DocID = @DocIDParent
	select @Result = @@error if @Result <> 0 goto Err

	--секретарь (из протокола)
	insert into @TableTmp (UserList,Type)
	select NameControl,1
	from dbo.Docs P
	where DocID = @DocIDParent
	select @Result = @@error if @Result <> 0 goto Err

	--УДАЛИТЬ ИЗ ЧЛЕНОВ ИК секретаря
	update @TableTmp
		set UserList = replace(UserList,(select replace(UserList,';','') from @TableTmp where Type = 1),'')
	where Type = 5
	select @Result = @@error if @Result <> 0 goto Err

	--председатель
	insert into @TableTmp (UserList,Type)
	select --берем первое значение из списк членов комитета
		dbo.PDX_SubstringReturn(D.Correspondent,1,charindex('>',D.Correspondent)+1),6--D.NameAproval,6
	from dbo.Docs D
	where D.DocID = @DocIDParent
	select @Result = @@error if @Result <> 0 goto Err

	--ген. директор РИК(из протокола)
	insert into @TableTmp (UserList,Type)
	select
		D.Author,7
	from dbo.Docs D
	where D.DocID = @DocIDParent
	select @Result = @@error if @Result <> 0 goto Err

	If isnull(@DocID,'') <> ''
	begin
		--список рассылка
		insert into @TableTmp (UserList,Type)
		select distinct UserFieldText5,4
		from @TblRes
		where not UserFieldText5 is null
		select @Result = @@error if @Result <> 0 goto Err
	end
	Else
	begin	
		--приглашенные
		insert into @TableTmp (UserList,Type)
		select distinct Correspondent,3
		from @TblRes
		where not Correspondent is null
		select @Result = @@error if @Result <> 0 goto Err
	
		--докладчики
		insert into @TableTmp (UserList,Type)
		select distinct Author,2
		from @TblRes
		where not Author is null
		select @Result = @@error if @Result <> 0 goto Err
	end

--разбор списков пользователей (по-фамильно)
	insert into @TblRes
		(UserFieldText5, Type)
	select distinct '',Type
	from @TableTmp
	where Type <> 0
	select @Result = @@error if @Result <> 0 goto Err

	while exists (select 1 from @TableTmp)
	begin
		select top 1 
			@UserList = UserList,
			@Type = Type
 		from @TableTmp
		select @Result = @@error if @Result <> 0 goto Err

		delete @TableTmp
		where UserList = @UserList and @Type = Type
		select @Result = @@error if @Result <> 0 goto Err

		while len(@UserList) <> 0
		begin
			select @Ind = 0,@OneValue = ''
			select @Result = @@error if @Result <> 0 goto Err
			select @Ind = charindex(';',@UserList,1)
			select @Result = @@error if @Result <> 0 goto Err
			if @Ind = 0 select @Ind = len(@UserList)
			select @Result = @@error if @Result <> 0 goto Err
		
			select @OneValue = substring(@UserList,1,@Ind)
			select @Result = @@error if @Result <> 0 goto Err
			select @UserList = replace(@UserList,@OneValue,'')
			select @Result = @@error if @Result <> 0 goto Err

			select @UserNameOUT = ''
			exec dbo.PDX_FullUserNameGet 
				@UserNameIN = @OneValue,
		    	@UserNameOUT = @UserNameOUT out,
				@Type = 1
			if @Result <> 0 goto Err

			update @TblRes
				set UserFieldText5 = UserFieldText5 + ' ' + @UserNameOUT + '<br>'
			where Type = @Type
			and not UserFieldText5 like '%' + @UserNameOUT + '%'
			select @Result = @@error if @Result <> 0 goto Err
		end		
	end

	--информация о дате последнего изменения и пользователе
	insert into @TblRes
		(UserFieldText5, Type, DateLastModification)
	select 
		'Изменено: ' + T.NameLastModification + ' ' + convert(varchar(100),T.DateLastModification,104) + ' ' + convert(varchar(100),T.DateLastModification,114), -100, 
		DateLastModification
	from (
		select top 1 * from @TblRes T where Type = 0
		order by DateLastModification desc) as T
	select @Result = @@error if @Result <> 0 goto Err

	--уточнем инфу по последнему изменению
	update T
	set UserFieldText5 =  
						case when T.DateLastModification < P.DateCreation
								then 'Изменено: ' + P.UserName + ' <' + P.UserID + '> ' + convert(varchar(100),P.DateCreation,104) + ' ' + convert(varchar(100),P.DateCreation,114)
							else T.UserFieldText5
						end
	from @TblRes T
	inner join ( 
		select top 1 *
		from dbo.Comments  with (nolock) 
		where (DocID in (select distinct DocID from @TblRes)
				or DocID = case isnull(@DocID,'') when '' then @DocIDParent else '' end)
			and CommentType in ('CHECKINOUT','FILE')
		order by DateCreation desc
		) as P on 1 = 1
	where T.Type = -100
	select @Result = @@error if @Result <> 0 goto Err

Res:
	select * from @TblRes
	order by Type desc, Ind
	select @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_InvestKomitetVypiskaEmail] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_InvestKomitetVypiskaEmail]
	@DocIDParent varchar(255),
	@DocID varchar(255),
	@ClassDoc varchar(255),
	@SDMembers varchar(2000),
	@SDPredsedatel varchar(500),
	@SDSecretar varchar(500),
	@Emails varchar(512) = ''
as
declare @Result int
	set @Result = 0
	
	declare 
		@UserList varchar(2048),
		@OneValue varchar(1024),
		@email  varchar(1024),
		@Users varchar(1024)

	declare @TblRes table
		(DocID varchar(255),
		UserList varchar(2048),
		Email varchar(4000),
		FileName varchar(255),
		FileDescr varchar(255),
		FileType varchar(255),
		FileExists int default 0,
		Type int,
		isPRCL int)

	declare @TableTmp table
		(UserList varchar(2048),
		DocID  varchar(255),
		isPRCL int,
		DateCreation datetime)
	
	if isnull(@DocIDParent,'') = '' goto Res
	select @Result = @@error if @Result <> 0 goto Err

--списки пользователей
--сд исд + рассылка + приглашенные + автор
	insert into @TableTmp (UserList,DocID,isPRCL,DateCreation)
	select distinct 
		case DocID 
			when @DocIDParent
				then @SDPredsedatel + @SDMembers + @SDSecretar 
			else ''
		end + isnull(ListToView,'') + isnull(Correspondent,'') +
		isnull(Author,''), DocID,
		case DocID
			when @DocIDParent
				then 1
			else 0
		end, DateCreation
	from dbo.Docs with (nolock)
	where (DocIDParent = @DocIDParent or DocID = @DocIDParent)
		--and ClassDoc = @ClassDoc
		and (DocID = @DocID or @DocID = '')
	order by DocID
	select @Result = @@error if @Result <> 0 goto Err

	--!!!!НЕ работает для документов созданных до 11,07,2007
	if exists (select 1 from @TableTmp where convert(datetime,convert(varchar(100),DateCreation,104),104) < '2007-07-12')
	begin 
		goto Res
	end
	select @Result = @@error if @Result <> 0 goto Err

    --файлы
	insert into @TblRes
		(DocID, Type, FileName, FileDescr,FileType, isPRCL)
	select
		DocID, 1, FileName, DocID + '_' + Version, substring(FileName,charindex('.',FileName), len(FileName)),
		case DocID
			when @DocIDParent
				then 1
			else 0
		end
	from dbo.Comments C with (nolock)
	where CommentType = 'FILE'
		and Amount = 0
		and isnull(FileName,'')<>''
		and DocID in (select DocID from @TableTmp)
	select @Result = @@error if @Result <> 0 goto Err
  
	if exists (select 1 from @TableTmp where DocID = @DocIDParent)
	begin
		insert into @TblRes
			(DocID, Type, FileName, FileDescr,FileType, isPRCL, FileExists)
		select 
			@DocIDParent, R.Type, R.FileName, R.FileDescr, R.FileType, 1, 1
		from @TblRes R 
		where R.Type = 1
			and DocID <> @DocIDParent
		select @Result = @@error if @Result <> 0 goto Err
	end
	select @Result = @@error if @Result <> 0 goto Err

	if isnull(@Emails,'') <> '' --если есть конкретные email - ы отправляем на них
	begin
		--разбор списков пользователей
		insert into @TblRes
			(DocID, Type, email,isPRCL,UserList)
		select distinct DocID, 0, @Emails, isPRCL, @Emails
		from @TableTmp
		select @Result = @@error if @Result <> 0 goto Err
	end 
	else --if isnull(@emails,'') <> ''
	begin
		--списки пользователей
		--разбор списков пользователей
		insert into @TblRes
			(DocID, Type, email,isPRCL,UserList)
		select distinct DocID, 0, '', isPRCL, ''
		from @TableTmp
		select @Result = @@error if @Result <> 0 goto Err

		while exists (select 1 from @TableTmp)
		begin
			select top 1 
				@UserList = UserList,
				@DocID = DocID,
 				@email = '', @Users = ''
	 		from @TableTmp
			select @Result = @@error if @Result <> 0 goto Err
	
			delete @TableTmp
			where UserList = @UserList
				and DocID = @DocID
			select @Result = @@error if @Result <> 0 goto Err

			while charindex('<',@UserList)> 0 and  charindex('>',@UserList)> 0 
				and charindex('>',@UserList) > charindex('<',@UserList)
			begin
				select @OneValue = '', @email = '', @Users = ''
				select @OneValue = dbo.PDX_SubstringReturn (@UserList,charindex('<',@UserList),charindex('>',@UserList))
	  		    select @Result = @@error if @Result <> 0 goto Err
	
				select @UserList = replace(@UserList,'<' + @OneValue + '>','')
				select @Result = @@error if @Result <> 0 goto Err
				
				select @email = email, @Users = case len(Name)
													when len(replace(name,' ','')) + 2 --т.е. имя состоит из 3-х слов
														then substring(name,1,charindex(' ',name) -1) + ' ' + substring(Name,charindex(' ', name)+1,1) + '. ' + substring(reverse(name),charindex(' ',reverse(name))-1,1) + '.'
													else name
												end + '<' + UserID + '>; '
				from dbo.Users with (nolock) 
				where UserID = @OneValue
				select @Result = @@error if @Result <> 0 goto Err
	
				--ищем замов
				select @email = @email + ';' + z.email, 
					@Users = @Users + 
							case len(z.Name)
								when len(replace(z.name,' ','')) + 2 --т.е. имя состоит из 3-х слов
									then substring(z.name,1,charindex(' ',z.name) -1) + ' ' + substring(z.Name,charindex(' ', z.name)+1,1) + '. ' + substring(reverse(z.name),charindex(' ',reverse(z.name))-1,1) + '.'
								else z.name
							end + 
							'<' + z.UserID + '>; '
				from dbo.Users U with (nolock) 
				inner join dbo.Users Z with (nolock) on Z.UserID = U.DeputyID
				where U.UserID = @OneValue
					and getdate() between U.DeputyDateFrom and U.DeputyDateTo
				select @Result = @@error if @Result <> 0 goto Err
	
				update @TblRes
					set Email = email + ';' + @email
				where DocID= @DocID
				and not Email like '%' + @Email + '%'
				select @Result = @@error if @Result <> 0 goto Err		

				update @TblRes --отдельно так как по пайдокс email-s могут совпадать (начальник / руководитель)
					set UserList = UserList + @Users
				where DocID= @DocID
				and not UserList like '%' + @Users + '%'
				select @Result = @@error if @Result <> 0 goto Err		
			end		
		end
	end --if isnull(@emails,'') <> ''
Res:
	select DocID,isnull(Email,'') as Email,	FileName,FileDescr,	FileType,FileExists,
		Type,isPRCL,isnull(UserList,'') as UserList
	from @TblRes
	order by isPRCL, DocID, Type 
	select @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_ISR_Change] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE proc [dbo].[PDX_ISR_Change]
	@Project varchar(1024),
	@Code varchar(64),
	@Descr varchar(512),
	@FD tinyint = 0,
	@KeyField int,
	@ParentKeyField int,
	@Actual varchar(3) = null,
	@NC varchar(128),
	@Act int, --1--ceate, 2-update,3 delete
	@Chk bit = 0
	
as
	declare  @Res int

	declare @ErrList varchar(1024), @blnInAct bit
	--declare @blnAct_tbl table (KeyField int, PKF int)

	select @Res = 0,@ErrList = ''
	
	set @Actual = ISNULL(@Actual,'')
	select
		@Project = ltrim(rtrim(isnull(@Project,''))),
		@Descr = ltrim(rtrim(isnull(@Descr,''))),
		@NC  = ltrim(rtrim(isnull(@NC,''))),
		@FD  = isnull(@FD,0)
	select @Res = @@error if @Res <> 0 goto Err
	
	set @blnInAct = case @Actual when 'ДА' then 0 else 1 end
	
    if @ParentKeyField = 0
    begin
		set @ParentKeyField = null
	end
	else
	begin
		set @Project = ''
    end
    if @KeyField = 0
    begin
		set @KeyField = null
    end
    
/************************************
ПРОВЕРКИ ВВЕДЕННЫХ ЗНАЧЕНИЙ
*************************************/
if @Act in (1,2)
begin

	If @Descr = ''
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Укажите наименование'
		goto NXT
	end

	If @Project <> ''
	begin
		If not exists (select 1 from dbo.UserDirValues where UDKeyField = 35 and Field1 = @Project)
		begin
			select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
				'Указанный Проект не существует'
			select @Res = @@error if @Res <> 0 goto Err		
		end
	end

	If exists (select 1 from dbo.UserDir_ISR where Code = @Code and KeyField <> isnull(@KeyField,-1))
	begin
			select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
				'Указанный Код ИСР уже существует'
			select @Res = @@error if @Res <> 0 goto Err	
	end
end

If @Act = 3
begin
  if exists (select 1 from dbo.UserDir_ISR where ParentKeyField = @KeyField)
  begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Нельзя удалить данный узел, у него есть подчиненные'
		select @Res = @@error if @Res <> 0 goto Err	
  end  
end

/************************************/

NXT:

If @Chk = 0
begin --если это создание , то нужно генерить ошибкуесли она есть
	If @ErrList <> '' 
	begin
		RAISERROR (@ErrList, 16,1)
		goto Err
	end
end
else --если это проверка просто выводим сообщение, даже если оно пустое
begin
	select @ErrList as ErrList 
	select @Res = @@error if @Res <> 0 goto Err
end

IF @ErrList = '' and @Chk = 0
BEGIN
	if @Act = 2
	begin
		update dbo.UserDir_ISR
			set 
				Code = @Code,
				Project = @Project,
				Descr = @Descr,
				FD = @FD,
				ParentKeyField = @ParentKeyField,
				inActive = @blnInAct,
				NLM = @NC,
				DLM = getdate()
		where KeyField = @KeyField
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 1
	begin
		insert into dbo.UserDir_ISR
			(Code, Project, Descr, FD, ParentKeyField, inActive, NC, DC, NLM, DLM)
		values 
			(@Code, @Project, @Descr, @FD, @ParentKeyField, @blnInAct, @NC, getdate(), @NC, getdate())
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 3
	begin
		delete from dbo.UserDir_ISR where KeyField = @KeyField
		select @Res = @@error if @Res <> 0 goto Err
	end
END
	select @Res = @@error if @Res <> 0 goto Err

OK:

	return @Res
Err:
	return @Res



GO
/****** Object:  StoredProcedure [dbo].[PDX_ISR_Synchronize] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE [dbo].[PDX_ISR_Synchronize] 
	@RequestId uniqueidentifier,  -- идентификатор сессии
	@DeleteNotFound bit = 0, -- если 1, то удаляем все ИСР по данному проекту, которых нет в таблице WBS_SyncRequestItems для данной сессии. Этот режим по сути означает полную перезаливку содержания ИСР по проекту
	@Chk bit = 0,  -- режим проверки (1) либо изменения (0)
	@NC varchar(128)  -- логин или имя автора изменений. возможно, правильнее 
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

declare  @Res int
declare @ErrList varchar(1024)

declare @ProjectName varchar(1024)
declare @OldName varchar(512)

declare @ErrCounterAdd int
declare @ErrCounterEdit int
declare @ErrCounterDelete int

select @Res = 0
select @ErrList = ''
select @ProjectName = ''
select @ErrCounterAdd = 0
select @ErrCounterEdit = 0
select @ErrCounterDelete = 0

-- блок проверок исходных данных
begin 
	--если не нашли такую сессию, то возвращаем ошибку
	If not exists (select 1 from dbo.WBS_SyncRequests where RequestId = @RequestId) 
	begin
		select @Res = -1
		Select @ErrList = 'Не найдена сессия с идентификатором ' + convert(varchar(512), @RequestId)
		RAISERROR (@ErrList, 16,1)
		goto Err
	end

	--если пустое название проекта, то возвращаем ошибку
	select @ProjectName = ProjectName from dbo.WBS_SyncRequests where RequestId = @RequestId
	if isnull(@ProjectName, '') = ''
	begin
		select @Res = -1
		Select @ErrList = 'Указано пустое название проекта для сессии с идентификатором ' + convert(varchar(512), @RequestId)
		RAISERROR (@ErrList, 16,1)
		goto Err
	end
end
-- конец блока проверок

declare @CurrentID uniqueidentifier
declare @ParentID uniqueidentifier
declare @Code varchar(64)
declare @ParentCode varchar(64)
declare @ShortName varchar(512)
declare @FD tinyint
declare @KeyField int
declare @ParentKeyField int
declare @Actual varchar(3)
declare @Act int

select @Actual = 'ДА'
select @FD = 0

-- добавляем проект, если его еще нет
	select @Code = ProjectCode from dbo.WBS_SyncRequests where RequestId = @RequestId

	If not exists (select * from UserDir_ISR where Code = isnull(@Code, 0)) 
	begin
		select @Act = 1
        exec @Res = [dbo].[PDX_ISR_Change] @ProjectName, @Code, @ProjectName, @FD, 0, NULL, @Actual, @NC, @Act, @Chk

		insert into UserDirValues( UDKeyField, Field1, Field2, Field3, Field4, Field5, Field6, NameLastModification, DateLastModification)
		values                   (35, @ProjectName, @Code, '', '', 1, '', @NC, GETDATE())  

		/*
		-- всегда добавляем в новый проект один элемент - "общая часть" с кодом _10. добавляем в исходную таблицу, чтобы механизм сам добавил этот элемент в справочник ИСР
		--select @ParentKeyField = KeyField from dbo.UserDir_ISR where Code = @Code
		select @Code = @Code + '_10'
		select @ShortName = 'Общая часть'
		if not exists (select * from UserDir_ISR where Code = isnull(@Code, 0))
		begin
		if not exists (select * from WBS_SyncRequestItems where RequestId = @RequestId and FullCode = @Code)
			begin 
		--exec @Res = [dbo].[PDX_ISR_Change] @ProjectName, @Code, @ShortName, @FD, @KeyField, @ParentKeyField, @Actual, @NC, @Act, @Chk
				insert into WBS_SyncRequestItems (RequestId, Id, ParentId, Level, ShortCode, FullCode, ShortName, FullName, 
				Comment, Status, ErrorMessage, Created)
				values (@RequestId, NEWID(), '00000000-0000-0000-0000-000000000000', 1, '10', @Code, @ShortName, @ShortName, 
				'В справочник ИСР обавлен обьект "Общая часть с кодом _10"', 1, null, GETDATE())
			end
		end
		*/
	end

-- проходим каждую запись требуемой сессии несколько раз. первый проход - добавление записей, второй - редактирование, третий - удаление.
-- результаты добавления и редактирования пишем в таблицу WBS_SyncRequestItems по каждой строке отдельно, в таблицу WBS_SyncRequests пишем общий результат - были ли ошибки при редактировании и добавлении.
-- если возникли ошибки при удалении ИСР, то заносим по каждой строке ИСР новую запись в таблицу WBS_SyncRequestItems и пишем результат туда. в таблицу WBS_SyncRequests пишем общий результат


 -- первый проход - редактируем существующие записи
 -- если новое название объекта совпадает с существующим, то ничего не меняем и так и пишем в лог
select @Act = 2
--объявляем курсор для выборки тех записей, которые нужно изменить
 DECLARE my_curEdit CURSOR FOR 
	select distinct I.FullCode, I.ShortName, ISR.KeyField, I.ParentId, I.Id, ISR.Descr
	from dbo.WBS_SyncRequestItems as I
	inner join UserDir_ISR as ISR on I.FullCode = ISR.Code
	where I.RequestId = @RequestId

   --открываем курсор
   OPEN my_curEdit

   --считываем данные первой строки в наши переменные
   FETCH NEXT FROM my_curEdit INTO @Code, @ShortName, @KeyField, @ParentID, @CurrentID, @OldName
   --если данные в курсоре есть, то заходим в цикл
   --и крутимся там до тех пор, пока не закончатся строки в курсоре
   WHILE @@FETCH_STATUS = 0
   BEGIN
      begin
        --на каждую итерацию цикла запускаем нашу основную процедуру с нужными параметрами   
		if len(@Code) > 6
		begin
			select @ParentCode = Fullcode from WBS_SyncRequestItems where ID = @ParentID 
		end
		else
		begin
			select @ParentCode = left(@Code,3)
		end
		select @ParentKeyField = KeyField from dbo.UserDir_ISR where Code = @ParentCode

		if @Chk = 0
		if exists(select * from UserDir_ISR where Code = @Code and Descr = @ShortName and inActive = 0)
		begin
			update WBS_SyncRequestItems set ErrorMessage = '', Comment = 'Новое название совпадает со старым. Запись оставлена без изменений в справочнике ИСР', Status = 1 where ID = @CurrentID
		end
		else
		begin
	        exec @Res = [dbo].[PDX_ISR_Change] @ProjectName, @Code, @ShortName, @FD, @KeyField, @ParentKeyField, @Actual, @NC, @Act, @Chk
			if @Res = 0
			begin
				if @ShortName = @OldName
				begin
					update WBS_SyncRequestItems set ErrorMessage = '', Comment = 'Запись помечена активной в справочнике ИСР.', Status = 1 where ID = @CurrentID
				end
				else
				begin
					update WBS_SyncRequestItems set ErrorMessage = '', Comment = 'Запись изменена в справочнике ИСР. Старое название - ' + @OldName, Status = 1 where ID = @CurrentID
				end
			end
			else
			begin
				update WBS_SyncRequestItems set Comment = '', ErrorMessage = 'Ошибка при редактировании записи в справочнике ИСР: ' + convert(varchar, @Res), Status = -1 where ID = @CurrentID
				select @ErrCounterEdit = @ErrCounterEdit + 1
			end
		end
	end	 
        --считываем следующую строку курсора
        FETCH NEXT FROM my_curEdit INTO @Code, @ShortName, @KeyField, @ParentID, @CurrentID, @OldName
   END

   
   --закрываем курсор
   CLOSE my_curEdit
   DEALLOCATE my_curEdit

-- второй проход - добавляем новые записи
select @Act = 1
--объявляем курсор для выборки тех записей, которых нет в таблице ИСР
 DECLARE my_curAdd CURSOR FOR 
	select distinct I.FullCode, I.ShortName, ISR.KeyField, I.ParentId, I.Id
	from dbo.WBS_SyncRequestItems as I
	left join UserDir_ISR as ISR on I.FullCode = ISR.Code
	where I.FullCode <> isnull(ISR.Code, 0)
	and I.RequestId = @RequestId ORDER BY I.FullCode ASC

   --открываем курсор
   OPEN my_curAdd

   --считываем данные первой строки в наши переменные
   FETCH NEXT FROM my_curAdd INTO @Code, @ShortName, @KeyField, @ParentID, @CurrentID
   --если данные в курсоре есть, то заходим в цикл
   --и крутимся там до тех пор, пока не закончатся строки в курсоре
   WHILE @@FETCH_STATUS = 0
   BEGIN

   begin
        --на каждую итерацию цикла запускаем нашу основную процедуру с нужными параметрами   
		if len(@Code) > 6
		begin
			select @ParentCode = Fullcode from WBS_SyncRequestItems where ID = @ParentID 
		end
		else
		begin
			select @ParentCode = left(@Code,3)
		end
		select @ParentKeyField = KeyField from dbo.UserDir_ISR where Code = @ParentCode

        exec @Res = [dbo].[PDX_ISR_Change] @ProjectName, @Code, @ShortName, @FD, @KeyField, @ParentKeyField, @Actual, @NC, @Act, @Chk
		if @Chk = 0
		begin
			if @Res = 0
			begin
				update WBS_SyncRequestItems set ErrorMessage = '', Comment = 'Запись добавлена в справочник ИСР', Status = 1 where ID = @CurrentID
			end
			else
			begin
				update WBS_SyncRequestItems set Comment = '', ErrorMessage = 'Ошибка при добавлении записи в справочник ИСР: ' + convert(varchar, @Res), Status = -1 where ID = @CurrentID
				select @ErrCounterAdd = @ErrCounterAdd + 1
			end
		end
	end	 
        --считываем следующую строку курсора
        FETCH NEXT FROM my_curAdd INTO @Code, @ShortName, @KeyField, @ParentID, @CurrentID
   END

   
   --закрываем курсор
   CLOSE my_curAdd
   DEALLOCATE my_curAdd


   -- третий проход - редактируем существующие записи. Пока реализован только вариант "Удаляем все по данному проекту, чего нет в табличке WBS_SyncRequestItems для текущей сессии. 
   -- для того, чтобы удалять поштучно на основе того, что прописано в исходном екселе, надо добавить в табличку WBS_SyncRequestItems поле "что сделать", туда помещать отметку о необходимости удаления, и тогда просто нужно будет открыть курсор с выборкой по данной сессии и присутсивю пометки на удаление, пройтись по нему и поштучно удалить
select @Act = 3
--объявляем курсор для выборки тех записей, которые нужно удалить. не нравится то, что здесь мы выбираем по коду проекта, но других вариантов не видно 
 DECLARE my_curDelete CURSOR FOR 
	select distinct  ISR.Code, ISR.Descr, ISR.KeyField, I.ParentId, I.Id
	from (select * from dbo.WBS_SyncRequestItems where RequestId = @RequestId) as I
	right join UserDir_ISR as ISR on I.FullCode = ISR.Code
	where Left(ISR.Code, 3) = (select ProjectCode from WBS_SyncRequests where RequestId = @RequestId)
	and len(ISR.Code) <> 3 
	and I.FullCode is null ORDER BY ISR.Code DESC


   --открываем курсор
   OPEN my_curDelete

   --считываем данные первой строки в наши переменные
   FETCH NEXT FROM my_curDelete INTO @Code, @ShortName, @KeyField, @ParentID, @CurrentID
   --если данные в курсоре есть, то заходим в цикл
   --и крутимся там до тех пор, пока не закончатся строки в курсоре
   WHILE @@FETCH_STATUS = 0
   BEGIN
		if @Chk = 0
		begin
			if exists (select * from UserDir_ISR where Code = @Code and inActive = 0) 
			begin
				update UserDir_ISR set inActive = 1 where Code = @Code 
	--		update WBS_SyncRequestItems set Comment = 'Запись удалена в справочнике ИСР', Status = 1 where ID = @CurrentID
				insert into WBS_SyncRequestItems (RequestId, Id, ParentId, Level, ShortCode, FullCode, ShortName, FullName, 
				Comment, Status, ErrorMessage, Created)
				values (@RequestId, NEWID(), null, 0, right(@Code, 2), @Code, @ShortName, @ShortName, 
				'В справочнике ИСР помечена неактивной запись с кодом ' + convert(varchar(20), @Code) + 'значение поля KeyField = ' + convert(varchar(20), @KeyField),
				1, null, GETDATE())
			end
		end
        --считываем следующую строку курсора
        FETCH NEXT FROM my_curDelete INTO @Code, @ShortName, @KeyField, @ParentID, @CurrentID
	END
   
	--закрываем курсор
	CLOSE my_curDelete
	DEALLOCATE my_curDelete
-- если при проходе нашли элементы, которые нельзя было удалить (из-за наличия подчиненных), то нужно повторить проход после удаления подчиненных


	select @Res = @ErrCounterAdd + @ErrCounterEdit + @ErrCounterDelete
	if @Res = 0 
	begin
		update WBS_SyncRequests set Status = 1, ErrorMessage = '' where RequestId = @RequestId
	end
	else
	begin
		update WBS_SyncRequests set Status = -1, ErrorMessage = 'При добавлении записей в справочник ИСР возникло ' + CONVERT(varchar(10), @ErrCounterAdd) + ' ошибок, при редактировании ' + CONVERT(varchar(10), @ErrCounterEdit) + ', при удалении ' + CONVERT(varchar(10), @ErrCounterDelete) where RequestId = @RequestId
	end

OK:

	select @Res = @ErrCounterAdd + @ErrCounterEdit + @ErrCounterDelete
	return @Res
Err:
	return @Res


END
GO
/****** Object:  StoredProcedure [dbo].[PDX_JOB_ForAccess] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE proc [dbo].[PDX_JOB_ForAccess]
as


--заявка от 04.12.2015 + 07.12.2015 
if exists (select 1 from dbo.Users where UserID = 'TonkihAA'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	--исполнение 06.12.2015 21:05 + 07.12.2015 22:20
	--корректировка по заявке от 29.07.2016
	update D 
		set Correspondent = Correspondent + ' "А. А. Тонких" <TonkihAA>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0
	where D.ClassDoc in ('Платежи(Н) / Заявка на оплату','Платежи(Н) / Платежи в бюджет')
		and D.Correspondent not like '%<TonkihAA>%'
		and DateCreation >= '2015-01-01' 
		and IsActive = 'Y'
	/*
	--отменео 21.05.2018
	update D 
		set Correspondent = Correspondent + ' "А. А. Тонких" <TonkihAA>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0
	where D.ClassDoc = 'Платежи(Н) / Плановая заявка'
		and D.Correspondent not like '%<TonkihAA>%'
		and DateCreation >= '2016-01-01' 
		and IsActive = 'Y'
		*/
end

--заявка от 08.12.2015 
if exists (select 1 from dbo.Users where UserID = 'BakhteevaMN'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
	/*	--отменено , заявка 7 октября 2016 г., 11:49:30  (Fri, 7 Oct 2016 08:49:30 +0000)
	--исполнение 08.12.2015 21:25
	update D 
		set Correspondent = Correspondent + ' "М. Н. Бахтеева" <BakhteevaMN>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 in ('Охта - Парк')
		and D.Correspondent not like '%<BakhteevaMN>%'
		and DateCreation >= '2015-01-01' 
		and IsActive = 'Y'
	*/
	
	--7 октября 2016 г., 11:49:30  (Fri, 7 Oct 2016 08:49:30 +0000)
	update D 
		set Correspondent = Correspondent + ' "М. Н. Бахтеева" <BakhteevaMN>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText8 = 'Рент'
		and D.UserFieldText1 not like '%Заявка на оплату труда (для счета типа Б)%'
		and D.UserFieldText1 not like '%(БЛС) Заявка на оплату (для счета типа Б) (ЗП)%'
		and D.Correspondent not like '%<BakhteevaMN>%'
		and DateCreation >= '2015-01-01' 
		and IsActive = 'Y'
		
	
	--24/03/2019
	update D 
		set Correspondent = Correspondent + ' "М. Н. Бахтеева" <BakhteevaMN>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0
	where D.ClassDoc in ('Платежи(Н) / Заявка на оплату',
						'Платежи(Н) / Платежи в бюджет')
		and D.UserFieldText8 = 'Компания Колос'
		and D.UserFieldText2 in ('Компания Колос',
									'Образ Жизни')
		and D.UserFieldText1 not like '%Заявка на оплату труда (для счета типа Б)%'
		and D.UserFieldText1 not like '%(БЛС) Заявка на оплату (для счета типа Б) (ЗП)%'
		and D.Correspondent not like '%<BakhteevaMN>%'
		and DateCreation >= '2017-01-01' 
		and IsActive = 'Y'
		
	
	
	--30,05,2020
	update D 
		set Correspondent = Correspondent + ' "М. Н. Бахтеева" <BakhteevaMN>;'
	from dbo.Docs D
	where D.ClassDoc in ('Договоры / (C) СМР')
	and D.UserFieldText1 in ('(БЛС) Договор на выполнение ПИР, СМР (Образ жизни. Лесная деревня)')
	and D.Correspondent not like '%<BakhteevaMN>%'
	and IsActive = 'Y'
	and D.DateCreation >='2020-05-28'
	
end

/*
--отключено 21.05.2018
--"А. В. Гончаревич" <GoncharevichAV>;
--заявка от 05.05.20156
if exists (select 1 from dbo.Users where UserID = 'GoncharevichAV'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	--исполнение 06.05.2016 9:25
	update D 
		set Correspondent = Correspondent + ' "А. В. Гончаревич" <GoncharevichAV>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 in ('Охта - Парк')
		and D.Correspondent not like '%<GoncharevichAV>%'
		and IsActive = 'Y'
	
		
end
*/

--"Е. А. Ватрушкина" <VatrushkinaEA>;
--заявка от 11 мая 2016 г., 16:10:03  (Wed, 11 May 2016 13:10:03 +0000)
if exists (select 1 from dbo.Users where UserID = 'VatrushkinaEA'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	--исполнение 11.05.2016 23:00
	update D 
		set Correspondent = Correspondent + ' "Е. А. Ватрушкина" <VatrushkinaEA>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 in ('Охта - Парк')
		and D.Correspondent not like '%<VatrushkinaEA>%'
		and D.DateCreation >= '2015-01-01' 
		and D.IsActive = 'Y'
	
		
end

/*
--отключено 21.05.2018
--"И. А. Деменская" <DemenskayaIA>;
--заявка от 21 июля 2016 г., 17:32:35  (Thu, 21 Jul 2016 14:32:35 +0000)
if exists (select 1 from dbo.Users where UserID = 'DemenskayaIA'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	--исполнение 24.07.2016 19:00
	update D 
		set Correspondent = Correspondent + ' "И. А. Деменская" <DemenskayaIA>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 in ('Охта-Рест'/*,'Сервис-Эксплуатация'*/) --изменение от 29.11.2017
		and D.Correspondent not like '%<DemenskayaIA>%'
		and D.IsActive = 'Y'
	
		
end
*/

--заявка от 05.09.2016
if exists (select 1 from dbo.Users where UserID = 'ChernenkoKK'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	--исполнение05.09.2016 22:45
	--изменено 06.12.2022 СпиридоноваЕИ, добавила ограничение по ЛС на оплату труда
	update D 
		set Correspondent = Correspondent + ' "К. К. Амерева" <ChernenkoKK>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 <> 'Охта Чисто'
		and D.UserFieldText1 not like '%Заявка на оплату труда (для счета типа Б)%'
		and D.UserFieldText1 not like '%(БЛС) Заявка на оплату (для счета типа Б) (ЗП)%' 
		and D.Correspondent not like '%<ChernenkoKK>%'
		and DateCreation >= '2021-12-26' 
		and IsActive = 'Y'
	
		
end

/*
--заявка от 08/11/2016
if exists (select 1 from dbo.Users where UserID = 'khrustalevaVA'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin		
--заявка от 27.10.2016
	--исполнение 28.10.2016 12:05
	update D 
		set Correspondent = Correspondent + ' "В. А. Мингазова" <khrustalevaVA>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.Correspondent not like '%<khrustalevaVA>%'
		and DateCreation >= '2015-01-01' 
		and IsActive = 'Y'
	
		
end
*/

/*
--заявка от 08/11/2016
if exists (select 1 from dbo.Users where UserID = 'RyvkinaSI'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
	
--заявка от 27.10.2016	
	--исполнение 28.10.2016 12:05
	update D 
		set Correspondent = Correspondent + ' "С. И. Рывкина" <RyvkinaSI>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.Correspondent not like '%<RyvkinaSI>%'
		and DateCreation >= '2015-01-01' 
		and IsActive = 'Y'
	
		
end
*/

/* --отключено 15.07.2017
--"Н. Н. Радченко" <RadchenkoNN>;
--заявка от 17 марта 2017 г., 15:14:06  (Fri, 17 Mar 2017 12:14:06 +0000)
if exists (select 1 from dbo.Users where UserID = 'RadchenkoNN'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	--исполнение 19 марта 2017 г.,
	update D 
		set Correspondent = Correspondent + ' "Н. Н. Радченко" <RadchenkoNN>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 in ('Компания Колос')
		and D.Correspondent not like '%<RadchenkoNN>%'
		and D.IsActive = 'Y'
		and D.DateCreation >= '2016-01-01' 
	
		
end
*/

/*
--отключено 21.05.2018
--"А. И. Ларионов" <LarionovAI>;
--21 апреля 2017 г., 17:00:16  (Fri, 21 Apr 2017 14:00:16 +0000)
if exists (select 1 from dbo.Users where UserID = 'LarionovAI'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	--исполнение 23 04 2017 г.,
	update D 
		set Correspondent = Correspondent + ' "А. И. Ларионов" <LarionovAI>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 in ('Лыжный Клуб')
		and D.Correspondent not like '%<LarionovAI>%'
		and D.IsActive = 'Y'
		and D.DateCreation >= '2017-01-01' 
	
		
end
*/


--"С. Н. Решетников" <ReshetnikovSN>;
--заявка от 15.05.2017
if exists (select 1 from dbo.Users where UserID = 'ReshetnikovSN'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	--исполнение 16.05.2017 21:00
	update D 
		set Correspondent = Correspondent + ' "С. Н. Решетников" <ReshetnikovSN>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0
	where D.ClassDoc = 'Платежи(Н) / Платежи в бюджет'
		and D.UserFieldText2 in ('РИД', 'Компания Колос')
		and D.Correspondent not like '%<ReshetnikovSN>%'
		and DateCreation >= '2015-01-01' 
		and IsActive = 'Y'
		
	--заявка от 14.12.2017	
	--исполнение 14.12.2017 22:40
	update D 
		set Correspondent = Correspondent + ' "С. Н. Решетников" <ReshetnikovSN>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0
	where D.ClassDoc = 'Платежи(Н) / Платежи в бюджет'
		and D.UserFieldText2 in ('Образ Жизни')
		and D.Correspondent not like '%<ReshetnikovSN>%'
		and DateCreation >= '2017-12-14' 
		and IsActive = 'Y'
				
	--25 августа 2017 г., 16:58:13  (Fri, 25 Aug 2017 13:58:13 +0000)
	--исполнение 30.08.2017 0:30
	update D 
		set Correspondent = Correspondent + ' "С. Н. Решетников" <ReshetnikovSN>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 = 'Компания Колос'
		and D.Correspondent not like '%<ReshetnikovSN>%'
		and D.UserFieldText1 in (
						'Заявка на оплату (для счет типа Б) (Образ жизни)',
						'Заявка на оплату (для счет типа Б) (ТРЗ)')
		and IsActive = 'Y'
		and D.DateCreation >='2017-08-25'
	
	
	--25 августа 2017 г., 16:58:13  (Fri, 25 Aug 2017 13:58:13 +0000)
	--исполнение 30.08.2017 0:30
	update D 
		set Correspondent = Correspondent + ' "С. Н. Решетников" <ReshetnikovSN>;'
	from dbo.Docs D
	where D.ClassDoc in ('Договоры / (C) СМР',
						'Договоры / (E) По проектированию',
						'Договоры / (X) Прочие(заказчик)',
						'Договоры / (F) Фин. обеспечение')
	and D.ActDoc = 'КК <42>'
	and D.UserFieldText4 = 'Жилой комплекс «Образ Жизни»'
	and D.UserFieldText1 in ('(БЛС) Договор на выполнение ПИР, СМР (Образ жизни)',
							'(БЛС) Договор на фин.обеспечение (Образ жизни)',
							'(БЛС) Договор на оказание услуг (Образ жизни)')
	and D.Correspondent not like '%<ReshetnikovSN>%'
	and IsActive = 'Y'
	and D.DateCreation >='2017-08-25'
	
		
	update D 
		set Correspondent = Correspondent +  ' "С. Н. Решетников" <ReshetnikovSN>;'
	from dbo.Docs D
	where D.ClassDoc =  'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 in ('Образ Жизни')
		and D.UserFieldText1 = 'Размещение депозитов (для счета типа Б) (Образ жизни)'
		and D.Correspondent not like '%<ReshetnikovSN>%'
		and DateCreation >= '2018-02-12' 
		and IsActive = 'Y'
		
end



--"М. Ю. Хуснуллина" <HusnulinaMY>;
--заявка от 29.06.2017
if exists (select 1 from dbo.Users where UserID = 'HusnulinaMY'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	--исполнение 30.06.2017 1:10
	update D 
		set Correspondent = Correspondent + ' "М. Ю. Хуснуллина" <HusnulinaMY>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
	 --Компания Колос отключено 15.07.2017
		and D.UserFieldText2 in ( /*'Компания Колос',*/'Баня-Лэнд') --ЦФО
		and D.UserFieldText8 in (/* 'Компания Колос',*/'Баня-Лэнд')  --БЕ
		and D.Correspondent not like '%<HusnulinaMY>%'
		and IsActive = 'Y'
		and D.DateCreation >='2017-01-01'

end



--"Н. П. Савельева" <SavelevaNP>;
if exists (select 1 from dbo.Users where UserID = 'SavelevaNP'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	update D 
		set Correspondent = Correspondent + ' "Н. П. Савельева" <SavelevaNP>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText8 = 'Компания Колос'
		and D.UserFieldText2 = 'Компания Колос'
		and D.Correspondent not like '%<SavelevaNP>%'
		and IsActive = 'Y'
		and D.DateCreation >='2015-01-01'
	
		
end



--"Ю. А. Любимцева" <LubimtsevaYA>;
if exists (select 1 from dbo.Users where UserID = 'LubimtsevaYA'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	--25 августа 2017 г., 16:58:13  (Fri, 25 Aug 2017 13:58:13 +0000)
	--исполнение 30.08.2017 0:30
	update D 
		set Correspondent = Correspondent + ' "Ю. А. Любимцева" <LubimtsevaYA>;'
	from dbo.Docs D
	where D.ClassDoc in ('Договоры / (C) СМР',
						'Договоры / (E) По проектированию',
						'Договоры / (X) Прочие(заказчик)',
						'Договоры / (F) Фин. обеспечение')
	and D.ActDoc = 'КК <42>'
	and D.UserFieldText4 = 'Жилой комплекс «Образ Жизни»'
	and D.UserFieldText1 in ('(БЛС) Договор на выполнение ПИР, СМР (Образ жизни)',
							'(БЛС) Договор на фин.обеспечение (Образ жизни)',
							'(БЛС) Договор на оказание услуг (Образ жизни)')
	and D.Correspondent not like '%<LubimtsevaYA>%'
	and IsActive = 'Y'
	and D.DateCreation >='2017-08-25'
	
		
	--25 августа 2017 г., 16:58:13  (Fri, 25 Aug 2017 13:58:13 +0000)
	--исполнение 30.08.2017 0:30
	update D 
		set Correspondent = Correspondent + ' "Ю. А. Любимцева" <LubimtsevaYA>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 = 'Компания Колос'
		and D.Correspondent not like '%<LubimtsevaYA>%'
		and D.UserFieldText1 in (
						'Заявка на оплату (для счет типа Б) (Образ жизни)',
						'Заявка на оплату (для счет типа Б) (ТРЗ)')
		and IsActive = 'Y'
		and D.DateCreation >='2017-08-25'
	
		
	--заявка от 14.12.2017	
	--исполнение 14.12.2017 22:40
	update D 
		set Correspondent = Correspondent + ' "Ю. А. Любимцева" <LubimtsevaYA>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0
	where D.ClassDoc = 'Платежи(Н) / Платежи в бюджет'
		and D.UserFieldText2 in ('Образ Жизни')
		and D.Correspondent not like '%<LubimtsevaYA>%'
		and DateCreation >= '2017-12-14' 
		and IsActive = 'Y'
		
		
	update D 
		set Correspondent = Correspondent + ' "Ю. А. Любимцева" <LubimtsevaYA>;'
	from dbo.Docs D
	where D.ClassDoc =  'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 in ('Образ Жизни')
		and D.UserFieldText1 = 'Размещение депозитов (для счета типа Б) (Образ жизни)'
		and D.Correspondent not like '%<LubimtsevaYA>%'
		and DateCreation >= '2018-02-12' 
		and IsActive = 'Y'
		
end


--"В. С. Писоцкий" <PisotskiyVS>;
if exists (select 1 from dbo.Users where UserID = 'PisotskiyVS'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	--25 августа 2017 г., 16:58:13  (Fri, 25 Aug 2017 13:58:13 +0000)
	--исполнение 30.08.2017 0:30
	update D 
		set Correspondent = Correspondent + ' "В. С. Писоцкий" <PisotskiyVS>;'
	from dbo.Docs D
	where D.ClassDoc in ('Договоры / (C) СМР',
						'Договоры / (E) По проектированию')
	and D.ActDoc = 'КК <42>'
	and D.UserFieldText4 = 'Жилой комплекс «Образ Жизни»'
	and D.UserFieldText1 in ('(БЛС) Договор на выполнение ПИР, СМР (Образ жизни)',
							'(БЛС) Договор на фин.обеспечение (Образ жизни)',
							'(БЛС) Договор на оказание услуг (Образ жизни)')
	and D.Correspondent not like '%<PisotskiyVS>%'
	and IsActive = 'Y'
	and D.DateCreation >='2017-08-25'
	
		
end

--"Главный бухгалтер - АО." <GlBuh_AO>;
if exists (select 1 from dbo.Users where UserID = 'GlBuh_AO'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	--25 августа 2017 г., 16:58:13  (Fri, 25 Aug 2017 13:58:13 +0000)
	--исполнение 30.08.2017 0:30
	update D 
		set Correspondent = Correspondent + ' "Главный бухгалтер - АО." <GlBuh_AO>;'
	from dbo.Docs D
	where D.ClassDoc in ('Договоры / (C) СМР',
						'Договоры / (E) По проектированию',
						'Договоры / (X) Прочие(заказчик)',
						'Договоры / (F) Фин. обеспечение')
	and D.ActDoc = 'КК <42>'
	and D.UserFieldText4 = 'Жилой комплекс «Образ Жизни»'
	and D.UserFieldText1 in ('(БЛС) Договор на выполнение ПИР, СМР (Образ жизни)',
							'(БЛС) Договор на фин.обеспечение (Образ жизни)',
							'(БЛС) Договор на оказание услуг (Образ жизни)')
	and D.Correspondent not like '%<GlBuh_AO>%'
	and IsActive = 'Y'
	and D.DateCreation >='2017-08-25'
	
		
	--25 августа 2017 г., 16:58:13  (Fri, 25 Aug 2017 13:58:13 +0000)
	--исполнение 30.08.2017 0:30
	--отмена 04.10.2017
	/*
	update D 
		set Correspondent = Correspondent + ' "Главный бухгалтер - АО." <GlBuh_AO>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 = 'Компания Колос'
		and D.Correspondent not like '%<GlBuh_AO>%'
		and D.UserFieldText1 = 'Заявка на оплату (для счет типа Б) (Образ жизни)'
		and IsActive = 'Y'
		and D.DateCreation >='2017-08-25'
	*/
end


--"Г. А. Куликов" <KulikovGA>;
--отмена 07.05.2018
/*
if exists (select 1 from dbo.Users where UserID = 'KulikovGA'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		

	update D 
		set Correspondent = Correspondent + ' "Г. А. Куликов" <KulikovGA>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 = 'Компания Колос'
		and D.Correspondent not like '%<KulikovGA>%'
		and D.UserFieldText1 in (
						'Заявка на оплату (для счет типа Б) (Образ жизни)',
						'Заявка на оплату (для счет типа Б) (ТРЗ)')
		and IsActive = 'Y'
		and D.DateCreation >='2017-08-25'
	
end
*/

/*
--отключено 21.05.2018
--"Н. В. Карпова" <KarpovaNV>;
if exists (select 1 from dbo.Users where UserID = 'KarpovaNV'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		

	update D 
		set Correspondent = Correspondent + ' "Н. В. Карпова" <KarpovaNV>;'
	from dbo.Docs D
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 = 'Компания Колос'
		and D.UserFieldText8 = 'Лидс'
		and D.Correspondent not like '%<KarpovaNV>%'
		and IsActive = 'Y'
		and D.DateCreation >='2017-01-01'
	
end
*/


--"Я. Н. Павлова" <PavlovaYN>;
if exists (select 1 from dbo.Users where UserID = 'PavlovaYN'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		

	update D 
		set Correspondent = Correspondent + ' "Я. Н. Павлова" <PavlovaYN>;'
	from dbo.Docs D
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 = 'Компания Колос'
		and D.UserFieldText8 = 'Лидс'
		and D.Correspondent not like '%<PavlovaYN>%'
		and IsActive = 'Y'
		and D.DateCreation >='2017-12-13'
	
end

/*
--заявка 2018-01-15 
--"М. В. Коноплев" <KonoplevMV>; 
if exists (select 1 from dbo.Users where UserID = 'KonoplevMV'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
/*
	update D 
		set Correspondent = Correspondent + ' "М. В. Коноплев" <KonoplevMV>;'
	from dbo.Docs D
	where D.ClassDoc in ('Платежи(Н) / Заявка на оплату','Платежи(Н) / Платежи в бюджет')
		and D.UserFieldText2 = 'Лыжный Клуб'
		and D.Correspondent not like '%<KonoplevMV>%'
		and DateCreation >= '2017-09-01' 
		and IsActive = 'Y'
		*/
	/*
	--отменено 21.05.2018
	update D 
		set Correspondent = Correspondent + ' "М. В. Коноплев" <KonoplevMV>;'
	from dbo.Docs D
	where D.ClassDoc = 'Платежи(Н) / Плановая заявка'
		and D.UserFieldText2 = 'Лыжный Клуб'
		and D.Correspondent not like '%<KonoplevMV>%'
		and DateCreation >= '2017-09-01' 
		and IsActive = 'Y'
	*/
	update D
		set Correspondent = Correspondent + ' "М. В. Коноплев" <KonoplevMV>;'
	from dbo.Docs D
	where D.ClassDoc = 'Платежи(Н) / Корректирующая заявка'
		and 'Лыжный Клуб' in (D.UserFieldText2, D.UserFieldText3)
		and D.Correspondent not like '%<KonoplevMV>%'
		and D.IsActive = 'Y'
		and D.DateCreation >= '2017-09-01' 
		
end
*/
--"Е. Н. Демидова" <DemidovaEN>;
if exists (select 1 from dbo.Users where UserID = 'DemidovaEN'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	
	update D 
		set Correspondent = Correspondent + ' "Е. Н. Демидова" <DemidovaEN>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0 --Б 
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 in ('Компания Колос','Образ Жизни')
		and D.Correspondent not like '%<DemidovaEN>%'
		and IsActive = 'Y'
		and D.DateCreation >='2015-01-01'
	
	
	update D 
		set Correspondent = Correspondent + ' "Е. Н. Демидова" <DemidovaEN>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0 --Б
	where D.ClassDoc = 'Платежи(Н) / Платежи в бюджет'
		and D.UserFieldText2 = 'Компания Колос'
		and D.Correspondent not like '%<DemidovaEN>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'
		
		
	--30,05,2020
	update D 
		set Correspondent = Correspondent + ' "Е. Н. Демидова" <DemidovaEN>;'
	from dbo.Docs D
	where D.ClassDoc in ('Договоры / (C) СМР')
	and D.UserFieldText1 in ('(БЛС) Договор на выполнение ПИР, СМР (Образ жизни. Лесная деревня)')
	and D.Correspondent not like '%<DemidovaEN>%'
	and IsActive = 'Y'
	and D.DateCreation >='2020-05-28'
	
end


/*
--отмена от 13.03.2018 выполнено 14.03.2018
--"Главный бухгалтер - Службы Инструкторов." <GlBuhSI>;
--04.03.2018
if exists (select 1 from dbo.Users where UserID = 'GlBuhSI'
			and StatusActive in ('1','-')
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	update D 
		set Correspondent = Correspondent + ' "Главный бухгалтер - Службы Инструкторов." <GlBuhSI>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0 --Б
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 = 'Лыжный Клуб'
		and D.UserFieldText8 in ('Слугина Ирина Викторовна')
		and D.Correspondent not like '%<GlBuhSI>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'
	
end
*/
/*
--отмена от 13.03.2018 выполнено 14.03.2018
--"Финансовый менеджер Службы Инструкторов." <FinMnrgSI>;
--04.03.2018
if exists (select 1 from dbo.Users where UserID = 'FinMnrgSI'
			and StatusActive in ('1','-')
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	update D 
		set Correspondent = Correspondent + ' "Финансовый менеджер Службы Инструкторов." <FinMnrgSI>;'
	from dbo.Docs D
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 = 'Лыжный Клуб'
		and D.UserFieldText8 in ('Слугина Ирина Викторовна')
		and D.Correspondent not like '%<FinMnrgSI>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'
	
	
	update D 
		set Correspondent = Correspondent + ' "Финансовый менеджер Службы Инструкторов." <FinMnrgSI>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0 --Б
	where D.ClassDoc = 'Платежи(Н) / Платежи в бюджет'
		and D.UserFieldText2 = 'Лыжный Клуб'
		and D.UserFieldText8 in ('Слугина Ирина Викторовна')
		and D.Correspondent not like '%<FinMnrgSI>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'
		
end
*/
/*
--отмена от 13.03.2018 выполнено 14.03.2018
--"Главный бухгалтер Лыжный клуб." <GlBuhLK>;
--04.03.2018
if exists (select 1 from dbo.Users where UserID = 'GlBuhLK'
			and StatusActive in ('1','-')
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	update D 
		set Correspondent = Correspondent + ' "Главный бухгалтер Лыжный клуб." <GlBuhLK>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0 --Б
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 = 'Лыжный Клуб'
		and D.UserFieldText8 in ('Лыжный Клуб')
		and D.Correspondent not like '%<GlBuhLK>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'
	
end
*/
/*
--отмена от 13.03.2018 выполнено 14.03.2018
--"Главный бухгалтер - СервисЭксплуатация." <GlBuh_SE>;
--04.03.2018
if exists (select 1 from dbo.Users where UserID = 'GlBuh_SE'
			and StatusActive in ('1','-')
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	update D 
		set Correspondent = Correspondent + ' "Главный бухгалтер - СервисЭксплуатация." <GlBuh_SE>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0 --Б
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 = 'Сервис-Эксплуатация'
		and D.Correspondent not like '%<GlBuh_SE>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'
	
end
*/
/*
--отмена от 13.03.2018 выполнено 14.03.2018
--"Финансовый менеджер ЛК." <FinMnrgLK>;
--04.03.2018
if exists (select 1 from dbo.Users where UserID = 'FinMnrgLK'
			and StatusActive in ('1','-')
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	update D 
		set Correspondent = Correspondent + ' "Финансовый менеджер ЛК." <FinMnrgLK>;'
	from dbo.Docs D
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 = 'Лыжный Клуб'
		and D.UserFieldText8 in ('Лыжный Клуб')
		and D.Correspondent not like '%<FinMnrgLK>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'
	
	
	update D 
		set Correspondent = Correspondent + ' "Финансовый менеджер ЛК." <FinMnrgLK>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0 --Б
	where D.ClassDoc = 'Платежи(Н) / Платежи в бюджет'
		and D.UserFieldText2 = 'Лыжный Клуб'
		and D.UserFieldText8 in ('Лыжный Клуб')
		and D.Correspondent not like '%<FinMnrgLK>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'
		
end
*/

/*
--отмена от 13.03.2018 выполнено 14.03.2018
--"Финансовый менеджер Сервис-Эксплуатация." <FinMnrgSE>;
--04.03.2018
if exists (select 1 from dbo.Users where UserID = 'FinMnrgSE'
			and StatusActive in ('1','-')
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	update D 
		set Correspondent = Correspondent + ' "Финансовый менеджер Сервис-Эксплуатация." <FinMnrgSE>;'
	from dbo.Docs D
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 = 'Сервис-Эксплуатация'
		and D.Correspondent not like '%<FinMnrgSE>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'
	
	update D 
		set Correspondent = Correspondent + ' "Финансовый менеджер Сервис-Эксплуатация." <FinMnrgSE>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0 --Б
	where D.ClassDoc = 'Платежи(Н) / Платежи в бюджет'
		and D.UserFieldText2 = 'Сервис-Эксплуатация'
		and D.Correspondent not like '%<FinMnrgSE>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'
	
	
end
*/

/*
--отмена от 13.03.2018 выполнено 14.03.2018
--"Главный бухгалтер - АрендаСпорт." <GlBuh_AS>;
--04.03.2018
if exists (select 1 from dbo.Users where UserID = 'GlBuh_AS'
			and StatusActive in ('1','-')
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	update D 
		set Correspondent = Correspondent + ' "Главный бухгалтер - АрендаСпорт." <GlBuh_AS>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0 --Б
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 = 'АрендаСпорт'
		and D.Correspondent not like '%<GlBuh_AS>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'
	
end
*/

/*
--отмена от 13.03.2018 выполнено 14.03.2018
--"Финансовый менеджер АрендаСпорт." <FinMnrgAS>;
--04.03.2018
if exists (select 1 from dbo.Users where UserID = 'FinMnrgAS'
			and StatusActive in ('1','-')
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	update D 
		set Correspondent = Correspondent + ' "Финансовый менеджер АрендаСпорт." <FinMnrgAS>;'
	from dbo.Docs D
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 = 'АрендаСпорт'
		and D.Correspondent not like '%<FinMnrgAS>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'
	
	update D 
		set Correspondent = Correspondent + ' "Финансовый менеджер АрендаСпорт." <FinMnrgAS>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0 --Б
	where D.ClassDoc = 'Платежи(Н) / Платежи в бюджет'
		and D.UserFieldText2 = 'АрендаСпорт'
		and D.Correspondent not like '%<FinMnrgAS>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'
	
	
end
*/

/*
--отмена от 13.03.2018 выполнено 14.03.2018
--"Финансовый менеджер БаняЛэнд." <FinMnrgBL>;
--04.03.2018
if exists (select 1 from dbo.Users where UserID = 'FinMnrgBL'
			and StatusActive in ('1','-')
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	update D 
		set Correspondent = Correspondent + ' "Финансовый менеджер БаняЛэнд." <FinMnrgBL>;'
	from dbo.Docs D
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 = 'Баня-Лэнд'
		and D.Correspondent not like '%<FinMnrgBL>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'
	
	update D 
		set Correspondent = Correspondent + ' "Финансовый менеджер БаняЛэнд." <FinMnrgBL>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0 --Б
	where D.ClassDoc = 'Платежи(Н) / Платежи в бюджет'
		and D.UserFieldText2 = 'Баня-Лэнд'
		and D.Correspondent not like '%<FinMnrgBL>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'
	
end
*/

--"И. В. Милованова" <MilovanovaIV>;
--04.03.2018
if exists (select 1 from dbo.Users where UserID = 'MilovanovaIV'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
	
	/*
--отмена от 13.03.2018 выполнено 14.03.2018	
	update D 
		set Correspondent = Correspondent + ' "И. В. Милованова" <MilovanovaIV>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0 --Б
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 = 'Баня-Лэнд'
		and D.Correspondent not like '%<MilovanovaIV>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'
	*/
	
	--заявка от 13.03.2018 выполнено 14.03.2018	
	update D 
		set Correspondent = Correspondent + ' "И. В. Милованова" <MilovanovaIV>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0 --Б
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 = 'Лыжный Клуб'
		and D.UserFieldText8 in ('Слугина Ирина Викторовна')
		and D.Correspondent not like '%<MilovanovaIV>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'
		
		
	update D 
		set Correspondent = Correspondent + ' "И. В. Милованова" <MilovanovaIV>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0 --Б
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 in ('Сервис-Эксплуатация ' /*, 'ЗимаЛето'*/) --изменено 21.05.2018
		and D.Correspondent not like '%<MilovanovaIV>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'
		
			
	update D 
		set Correspondent = Correspondent + ' "И. В. Милованова" <MilovanovaIV>;'
	from dbo.Docs D
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 in ('Баня-Лэнд')
		and D.Correspondent not like '%<MilovanovaIV>%'
		and IsActive = 'Y'
		and D.DateCreation >='2019-01-01'
end

/*
--отмена от 13.03.2018 выполнено 14.03.2018
--"Главный бухгалтер - ЗимаЛето." <GlBuh_ZL>;
--04.03.2018
if exists (select 1 from dbo.Users where UserID = 'GlBuh_ZL'
			and StatusActive in ('1','-')
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	update D 
		set Correspondent = Correspondent + ' "Главный бухгалтер - ЗимаЛето." <GlBuh_ZL>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0 --Б
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 = 'ЗимаЛето'
		and D.Correspondent not like '%<GlBuh_ZL>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'
	
end
*/
/*
--отмена от 13.03.2018 выполнено 14.03.2018
--"Финансовый менеджер ЗимаЛето." <FinMnrgZL>;
--04.03.2018
if exists (select 1 from dbo.Users where UserID = 'FinMnrgZL'
			and StatusActive in ('1','-')
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	update D 
		set Correspondent = Correspondent + ' "Финансовый менеджер ЗимаЛето." <FinMnrgZL>;'
	from dbo.Docs D
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 = 'ЗимаЛето'
		and D.Correspondent not like '%<FinMnrgZL>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'
	
	update D 
		set Correspondent = Correspondent + ' "Финансовый менеджер ЗимаЛето." <FinMnrgZL>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0 --Б
	where D.ClassDoc = 'Платежи(Н) / Платежи в бюджет'
		and D.UserFieldText2 = 'ЗимаЛето'
		and D.Correspondent not like '%<FinMnrgZL>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'
end
*/
/*
--отмена от 13.03.2018 выполнено 14.03.2018
--"Главный бухгалтер - Колос." <GlBuh_KK>;
--04.03.2018
if exists (select 1 from dbo.Users where UserID = 'GlBuh_KK'
			and StatusActive in ('1','-')
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	update D 
		set Correspondent = Correspondent + ' "Главный бухгалтер - Колос." <GlBuh_KK>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0 --Б
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 = 'Компания Колос'
		and D.Correspondent not like '%<GlBuh_KK>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'
	
end
*/
/*
--отмена от 13.03.2018 выполнено 14.03.2018
--"Финансовый менеджер Компания Колос." <FinMnrgKK>;
--04.03.2018
if exists (select 1 from dbo.Users where UserID = 'FinMnrgKK'
			and StatusActive in ('1','-')
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	update D 
		set Correspondent = Correspondent + ' "Финансовый менеджер Компания Колос." <FinMnrgKK>;'
	from dbo.Docs D
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 = 'Компания Колос'
		and D.Correspondent not like '%<FinMnrgKK>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'
	
	update D 
		set Correspondent = Correspondent + ' "Финансовый менеджер Компания Колос." <FinMnrgKK>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0 --Б
	where D.ClassDoc = 'Платежи(Н) / Платежи в бюджет'
		and D.UserFieldText2 = 'Компания Колос'
		and D.Correspondent not like '%<FinMnrgKK>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'
end
*/

/*
--отключено 21.05.2018
--"К. М. Слугина" <SluginaKM>;
--04.03.2018
if exists (select 1 from dbo.Users where UserID = 'SluginaKM'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	update D 
		set Correspondent = Correspondent + ' "К. М. Слугина" <SluginaKM>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 1 --C
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 = 'Лыжный Клуб'
		and D.UserFieldText8 in ('Слугина Ирина Викторовна')
		and D.UserFieldText1 in ('(БЛС) Заявка на оплату (для счета типа С) (ЗП) (СИ)')
		and D.Correspondent not like '%<SluginaKM>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'
		
		
	update D 
		set Correspondent = Correspondent + ' "К. М. Слугина" <SluginaKM>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 1 --C
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 = 'Лыжный Клуб'
		and D.UserFieldText8 in ('Лыжный Клуб')
		and D.UserFieldText1 in ('(БЛС) Заявка на оплату (для счета типа С) (ЗП) (ЛК)')
		and D.Correspondent not like '%<SluginaKM>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'
		
	
	update D 
		set Correspondent = Correspondent + ' "К. М. Слугина" <SluginaKM>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 1 --C
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 = 'Сервис-Эксплуатация'
		and D.UserFieldText1 in ('(БЛС) Заявка на оплату (для счета типа С) (ЗП) (СЭ)')
		and D.Correspondent not like '%<SluginaKM>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'
	
	update D 
		set Correspondent = Correspondent + ' "К. М. Слугина" <SluginaKM>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 1 --C
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 = 'АрендаСпорт'
		and D.UserFieldText1 in ('(БЛС) Заявка на оплату (для счета типа С) (ЗП) (АрендаСпорт)')
		and D.Correspondent not like '%<SluginaKM>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'
		
	update D 
		set Correspondent = Correspondent + ' "К. М. Слугина" <SluginaKM>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 1 --C
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 = 'ЗимаЛето'
		and D.UserFieldText1 in ('(БЛС) Заявка на оплату (для счета типа С) (ЗП) (ЗимаЛето)')
		and D.Correspondent not like '%<SluginaKM>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'
		
		
	update D 
		set Correspondent = Correspondent + ' "К. М. Слугина" <SluginaKM>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 1 --C
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 = 'Компания Колос'
		and D.UserFieldText1 in ('(БЛС) Заявка на оплату (для счета типа С) (ЗП) (Колос, РИД, РССО, Рент, Лидс)')
		and D.Correspondent not like '%<SluginaKM>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'
		
	update D 
		set Correspondent = Correspondent + ' "К. М. Слугина" <SluginaKM>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 1 --C
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 = 'Баня-Лэнд'
		and D.UserFieldText1 in ('(БЛС) Заявка на оплату (для счета типа С) (ЗП) (БаняЛэнд)')
		and D.Correspondent not like '%<SluginaKM>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'
end
*/

--"А. В. Селиванова" <SelivanovaAV>;
--13.03.2018
if exists (select 1 from dbo.Users where UserID = 'SelivanovaAV'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
	
	
	update D 
		set Correspondent = Correspondent + ' "А. В. Селиванова" <SelivanovaAV>;'
	from dbo.Docs D
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 = 'Лыжный Клуб'
		and D.UserFieldText8 in ('Слугина Ирина Викторовна'/*,'Лыжный Клуб'*/)
		and D.Correspondent not like '%<SelivanovaAV>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'
		
		
	
	update D 
		set Correspondent = Correspondent + ' "А. В. Селиванова" <SelivanovaAV>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0 --Б
	where D.ClassDoc = 'Платежи(Н) / Платежи в бюджет'
		and D.UserFieldText2 = 'Лыжный Клуб'
		and D.UserFieldText8 in ('Слугина Ирина Викторовна'/*,'Лыжный Клуб'*/)
		and D.Correspondent not like '%<SelivanovaAV>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'
		
	
		
	update D 
		set Correspondent = Correspondent + ' "А. В. Селиванова" <SelivanovaAV>;'
	from dbo.Docs D
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 = 'Инструкторская служба'
		and D.UserFieldText8 ='Слугина Ирина Викторовна'
		and D.Correspondent not like '%<SelivanovaAV>%'
		and IsActive = 'Y'
		and D.DateCreation >='2019-01-01'
		
		
	
	update D 
		set Correspondent = Correspondent + ' "А. В. Селиванова" <SelivanovaAV>;'
	from dbo.Docs D
	where D.ClassDoc = 'Платежи(Н) / Платежи в бюджет'
		and D.UserFieldText2 = 'Инструкторская служба'
		and D.UserFieldText8 ='Слугина Ирина Викторовна'
		and D.Correspondent not like '%<SelivanovaAV>%'
		and IsActive = 'Y'
		and D.DateCreation >='2019-01-01'
		
end


--"Ю. В. Буянова" <BuyanovaYV>;
--13.03.2018
if exists (select 1 from dbo.Users where UserID = 'BuyanovaYV'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
	
	
	update D 
		set Correspondent = Correspondent + ' "Ю. В. Буянова" <BuyanovaYV>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0 --Б
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 = 'Лыжный Клуб'
		and D.UserFieldText8 = 'Лыжный Клуб'
		and D.Correspondent not like '%<BuyanovaYV>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'
	
end


/*
--отключено 21.05.2018
--"А. А. Реморенко" <RemorenkoAA>;
--13.03.2018
if exists (select 1 from dbo.Users where UserID = 'RemorenkoAA'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
	
	update D 
		set Correspondent = Correspondent + ' "А. А. Реморенко" <RemorenkoAA>;'
	from dbo.Docs D
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 in ('Сервис-Эксплуатация','Компания Колос')
		and D.Correspondent not like '%<RemorenkoAA>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'
	
	update D 
		set Correspondent = Correspondent + ' "А. А. Реморенко" <RemorenkoAA>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0 --Б
	where D.ClassDoc = 'Платежи(Н) / Платежи в бюджет'
		and D.UserFieldText2 = 'Сервис-Эксплуатация'
		and D.Correspondent not like '%<RemorenkoAA>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'
end
*/

--"О. Б. Боярская" <BoyarskayaOB>;
--13.03.2018
if exists (select 1 from dbo.Users where UserID = 'BoyarskayaOB'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
	
	
	update D 
		set Correspondent = Correspondent + ' "О. Б. Боярская" <BoyarskayaOB>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0 --Б
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 = 'АрендаСпорт'
		and D.Correspondent not like '%<BoyarskayaOB>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'
	
end


/*
--отключено 21.05.2018
--"Н. П. Малишевская" <MalishevskayaNP>;
--13.03.2018
if exists (select 1 from dbo.Users where UserID = 'MalishevskayaNP'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	update D 
		set Correspondent = Correspondent + ' "Н. П. Малишевская" <MalishevskayaNP>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0 --Б
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 = 'Баня-Лэнд'
		and D.Correspondent not like '%<MalishevskayaNP>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'
	
end
*/


--"Е. А. Ватрушкина" <VatrushkinaEA>;
--13.03.2018
if exists (select 1 from dbo.Users where UserID = 'VatrushkinaEA'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	update D 
		set Correspondent = Correspondent + ' "Е. А. Ватрушкина" <VatrushkinaEA>;'
	from dbo.Docs D
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 = 'Баня-Лэнд'
		and D.Correspondent not like '%<VatrushkinaEA>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'
	
	update D 
		set Correspondent = Correspondent + ' "Е. А. Ватрушкина" <VatrushkinaEA>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0 --Б
	where D.ClassDoc = 'Платежи(Н) / Платежи в бюджет'
		and D.UserFieldText2 = 'Баня-Лэнд'
		and D.Correspondent not like '%<VatrushkinaEA>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'
		
		
	update D 
		set Correspondent = Correspondent + ' "Е. А. Ватрушкина" <VatrushkinaEA>;'
	from dbo.Docs D
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 = 'ЗимаЛето'
		and D.Correspondent not like '%<VatrushkinaEA>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'
	
	update D 
		set Correspondent = Correspondent + ' "Е. А. Ватрушкина" <VatrushkinaEA>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0 --Б
	where D.ClassDoc = 'Платежи(Н) / Платежи в бюджет'
		and D.UserFieldText2 = 'ЗимаЛето'
		and D.Correspondent not like '%<VatrushkinaEA>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'
end

--"Л. В. Савицкая" <SavitskayaLV>;
--13.03.2018
if exists (select 1 from dbo.Users where UserID = 'SavitskayaLV'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	update D 
		set Correspondent = Correspondent + ' "Л. В. Савицкая" <SavitskayaLV>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0 --Б
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 in ('Компания Колос',
								'РИД',
								'АрендаСпорт',
								'ЗимаЛето',
								'Сервис-Эксплуатация',
								'Баня-Лэнд',
								'Лыжный Клуб',
								'Начисто')
		and D.Correspondent not like '%<SavitskayaLV>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'--'2015-11-01'
	
	update D 
		set Correspondent = Correspondent + ' "Л. В. Савицкая" <SavitskayaLV>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0 --Б
	where D.ClassDoc = 'Платежи(Н) / Платежи в бюджет'
		and D.UserFieldText2 in ('Компания Колос',
								'РИД',
								'АрендаСпорт',
								'ЗимаЛето',
								'Сервис-Эксплуатация',
								'Баня-Лэнд',
								'Лыжный Клуб',
								'Начисто')
		and D.Correspondent not like '%<SavitskayaLV>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01' --'2015-11-01'
		
	
	update D 
		set Correspondent = Correspondent + ' "Л. В. Савицкая" <SavitskayaLV>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0 --Б
	where D.ClassDoc = 'Платежи(Н) / Плановая заявка'
		and D.UserFieldText2 in ('РИД',
								'АрендаСпорт',
								'ЗимаЛето',
								'Сервис-Эксплуатация',
								'Баня-Лэнд',
								'Лыжный Клуб',
								'Начисто')
		and D.Correspondent not like '%<SavitskayaLV>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'--'2015-11-01'
		
		
	
	update D 
		set Correspondent = Correspondent + ' "Л. В. Савицкая" <SavitskayaLV>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0 --Б
	where D.ClassDoc = 'Платежи(Н) / Корректирующая заявка'
		and D.UserFieldText2 in ('РИД',
								'АрендаСпорт',
								'ЗимаЛето',
								'Сервис-Эксплуатация',
								'Баня-Лэнд',
								'Лыжный Клуб',
								'Начисто')
		and D.Correspondent not like '%<SavitskayaLV>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'--'2015-11-01'
		
end

--"И. О. Кузнецова" <KuznetsovaIO>;
--13.03.2018
if exists (select 1 from dbo.Users where UserID = 'KuznetsovaIO'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	update D 
		set Correspondent = Correspondent + ' "И. О. Кузнецова" <KuznetsovaIO>;'
	from dbo.Docs D
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 = 'Компания Колос'
		and D.Correspondent not like '%<KuznetsovaIO>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'
	
end


--"С. Г. Погодина" <PogodinaSG>;
--23.04.2018
--откл 23,12,2019
/*if exists (select 1 from dbo.Users where UserID = 'PogodinaSG'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	update D 
		set Correspondent = Correspondent + ' "С. Г. Погодина" <PogodinaSG>;'
	from dbo.Docs D
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 in (
								'Компания Колос',
								'ЗимаЛето',
								'Баня-Лэнд',
								'АрендаСпорт',
								'Лыжный клуб',
								'Сервис-Эксплуатация',
								'ПитерЭвент',
								'ОхтаРест',
								'Начисто')
		and D.UserFieldText6 = 'Касса ОП'
		and D.Correspondent not like '%<PogodinaSG>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'
	
	--17/03/2019
	update D 
		set Correspondent = Correspondent + ' "С. Г. Погодина" <PogodinaSG>;'
	from dbo.Docs D
	where D.ClassDoc in ('Платежи(Н) / Заявка на оплату',
						'Платежи(Н) / Платежи в бюджет',
						'Платежи(Н) / Плановый бюджет',
						'Платежи(Н) / Плановая заявка',
						'Платежи(Н) / Корректирующая заявка')
		and D.UserFieldText8 = 'Формула (ИНН 7802550107)'
		and D.Correspondent not like '%<PogodinaSG>%'
		and IsActive = 'Y'
		and D.DateCreation >='2019-03-14' 
	
end*/

--А. В. Сивова <SivovaAV>;
--18.12.2019
if exists (select 1 from dbo.Users where UserID = 'SivovaAV'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
			
	--18/12/2019
	update D 
		set Correspondent = Correspondent + ' "А. В." Сивова <SivovaAV>;'
	from dbo.Docs D
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 in (
								'Компания Колос',
								'ЗимаЛето',
								'Баня-Лэнд',
								'АрендаСпорт',
								'Лыжный клуб',
								'Сервис-Эксплуатация',
								'ПитерЭвент',
								'ОхтаРест',
								'Начисто')
		and D.UserFieldText6 = 'Касса ОП'
		and D.Correspondent not like '%<SivovaAV>%'
		and IsActive = 'Y'
		and D.DateCreation >='2019-12-19'
	
	--17/03/2019
	update D 
		set Correspondent = Correspondent + ' "А. В." Сивова <SivovaAV>;'
	from dbo.Docs D
	where D.ClassDoc in ('Платежи(Н) / Заявка на оплату',
						'Платежи(Н) / Платежи в бюджет',
						'Платежи(Н) / Плановый бюджет',
						'Платежи(Н) / Плановая заявка',
						'Платежи(Н) / Корректирующая заявка')
		and D.UserFieldText8 = 'Формула (ИНН 7802550107)'
		and D.Correspondent not like '%<SivovaAV>%'
		and IsActive = 'Y'
		and D.DateCreation >='2019-12-19' 
		
	
end

--"Р. W. Бухгалтер" <Rzp_WA>;
--04.06.2018
if exists (select 1 from dbo.Users where UserID = 'Rzp_WA'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
	
	
	update D 
		set Correspondent = Correspondent + ' "Р. W. Бухгалтер" <Rzp_WA>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0 --Б
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 = 'ЗимаЛето'
		and D.UserFieldText8 = 'ЗеленыйДень'
		and D.Correspondent not like '%<Rzp_WA>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-05-01'
	
end

--"Н. Ю. Зотова" <ZotovaNY>;
--заявка  25 июня 2018 г., 18:22:27  (Mon, 25 Jun 2018 15:22:27 +0000)
if exists (select 1 from dbo.Users where UserID = 'ZotovaNY'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	--исполнение 26.06.2018 23:15
	update D 
		set Correspondent = Correspondent + ' "Н. Ю. Зотова" <ZotovaNY>;'
	from dbo.Docs D
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 in ('Компания Колос')
		and D.Correspondent not like '%<ZotovaNY>%'
		and D.IsActive = 'Y'
		and D.DateCreation >= '2018-05-01' 
	
		
end

--"О. Н. Данилова" <DanilovaON>;
--заявка  25 июня 2018 г., 18:22:27  (Mon, 25 Jun 2018 15:22:27 +0000)
if exists (select 1 from dbo.Users where UserID = 'DanilovaON'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	--исполнение 26.06.2018 23:15
	update D 
		set Correspondent = Correspondent + ' "О. Н. Данилова" <DanilovaON>;'
	from dbo.Docs D
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 in ('Компания Колос')
		and D.Correspondent not like '%<DanilovaON>%'
		and D.IsActive = 'Y'
		and D.DateCreation >= '2018-05-01' 
	
		
end



--заявка 2018-07-02
--"Д. И. Герасенков" <GerasenkovDI>;
if exists (select 1 from dbo.Users where UserID = 'GerasenkovDI'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin

	update D 
		set Correspondent = Correspondent + ' "Д. И. Герасенков" <GerasenkovDI>;'
	from dbo.Docs D
	where D.ClassDoc in ('Платежи(Н) / Заявка на оплату','Платежи(Н) / Платежи в бюджет')
		and D.UserFieldText2 = 'Лыжный Клуб'
		and D.Correspondent not like '%<GerasenkovDI>%'
		and DateCreation >= '2017-09-01' 
		and IsActive = 'Y'
		
	update D
		set Correspondent = Correspondent + ' "Д. И. Герасенков" <GerasenkovDI>;'
	from dbo.Docs D
	where D.ClassDoc = 'Платежи(Н) / Корректирующая заявка'
		and 'Лыжный Клуб' in (D.UserFieldText2, D.UserFieldText3)
		and D.Correspondent not like '%<GerasenkovDI>%'
		and D.IsActive = 'Y'
		and D.DateCreation >= '2017-09-01' 
		
end



--"Д. Д. Молодых" <MolodykhDD>;
if exists (select 1 from dbo.Users where UserID = 'MolodykhDD'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
			
	update D 
		set Correspondent = Correspondent + ' "Д. Д. Молодых" <MolodykhDD>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0 --Б 
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 in ('Компания Колос',
								'Образ Жизни')
		and D.Correspondent not like '%<MolodykhDD>%'
		and IsActive = 'Y'
		and D.DateCreation >='2015-01-01'
	
	
end




--"WA. Главный бухгалтер2." <WAGlBuh2>;
--заявка от 12.11.2018
if exists (select 1 from dbo.Users where UserID = 'WAGlBuh2'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin

/*	--30.05.209	
	--исполнение 21.11.2018 23:00
	update D 
		set Correspondent = Correspondent + ' "WA. Главный бухгалтер2." <WAGlBuh2>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0--Б 
	where D.ClassDoc = 'Платежи(Н) / Платежи в бюджет'
		and D.UserFieldText2 in ('АрендаСпорт','Баня-Лэнд'/*,'ЗимаЛето'*/)
		and D.Correspondent not like '%<WAGlBuh2>%'
		and DateCreation >= '2018-08-01' 
		and IsActive = 'Y'
	*/	
				
	
	--исполнение 21.11.2018 23:00
	update D 
		set Correspondent = Correspondent + ' "WA. Главный бухгалтер2." <WAGlBuh2>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0--Б 
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 = 'Компания Колос'
		and D.Correspondent not like '%<WAGlBuh2>%'
		and D.UserFieldText1 = 'Платежи в бюджет (для счета типа Б) (ИПБ)'
		and IsActive = 'Y'
		and D.DateCreation >='2018-08-01' 
end



--"Е. Н. Мороз" <MorozEN>;
if exists (select 1 from dbo.Users where UserID = 'MorozEN'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
						
	
	update D 
		set Correspondent = Correspondent + ' "Е. Н. Мороз" <MorozEN>;'
	from dbo.Docs D
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 = 'Компания Колос'
		and D.Correspondent not like '%<MorozEN>%'
		and D.UserFieldText6 in ('ББР', 'ББР Инвест')
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01' 
end



--"Н. В. Акимова" <AkimovaNV>;
if exists (select 1 from dbo.Users where UserID = 'AkimovaNV'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	update D 
		set Correspondent = Correspondent + ' "Н. В. Акимова" <AkimovaNV>;'
	from dbo.Docs D
	where D.ClassDoc = 'Платежи(Н) / Корректирующая заявка'
		and (D.UserFieldText2= 'ЗимаЛето' or D.UserFieldText3 = 'ЗимаЛето')
		and D.UserFieldText8 ='ЗимаЛето'
		and D.Correspondent not like '%<AkimovaNV>%'
		and DateCreation >= '2018-01-01' 
		and IsActive = 'Y'
		
				
	update D 
		set Correspondent = Correspondent + ' "Н. В. Акимова" <AkimovaNV>;'
	from dbo.Docs D
	where D.ClassDoc in ('Платежи(Н) / Заявка на оплату',
						'Платежи(Н) / Плановый бюджет',
						'Платежи(Н) / Платежи в бюджет',
						 'Платежи(Н) / Плановая заявка')
		and D.UserFieldText2 ='ЗимаЛето'
		and D.UserFieldText8 ='ЗимаЛето'
		and D.Correspondent not like '%<AkimovaNV>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01' 
end



--"И. С. Якимова" <YakimovaIS>;
if exists (select 1 from dbo.Users where UserID = 'YakimovaIS'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
			
				
	update D 
		set Correspondent = Correspondent + ' "И. С. Якимова" <YakimovaIS>;'
	from dbo.Docs D
	where D.ClassDoc  = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 in ('АрендаСпорт',
								'Сервис-Эксплуатация')
		and D.UserFieldText8 in ('АрендаСпорт',
							'СЕРВИС-ЭКСПЛУАТАЦИЯ',
							'Фэмили-клаб')
		and D.Correspondent not like '%<YakimovaIS>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01' 
				
	update D 
		set Correspondent = Correspondent + ' "И. С. Якимова" <YakimovaIS>;'
	from dbo.Docs D
	where D.ClassDoc  = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 in ('ЗимаЛето','Детский клуб')
		and D.UserFieldText8 in ('ЗимаЛето','Зеленый день')
		and D.Correspondent not like '%<YakimovaIS>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01' 
		
	
end


/*
--"Е. С. Волчкова" <VolchkovaES>;
if exists (select 1 from dbo.Users where UserID = 'VolchkovaES'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
			
				
	update D 
		set Correspondent = Correspondent + ' "Е. С. Волчкова" <VolchkovaES>;'
	from dbo.Docs D
	where D.ClassDoc  = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 in ('Компания Колос')
		and D.UserFieldText8 in ('Компания Колос',
								'РегионСпецСтрой',
								'Лидс',
								'Басова Юлия Юрьевна')
		and D.Correspondent not like '%<VolchkovaES>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01' 
end
*/


--"И. С. Андреевич" <AndreevichIS>;
if exists (select 1 from dbo.Users where UserID = 'AndreevichIS'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
			
	--04/11/2019
	update D 
		set Correspondent = Correspondent + ' "И. С. Андреевич" <AndreevichIS>;'
	from dbo.Docs D
	where D.ClassDoc in ('Платежи(Н) / Заявка на оплату')
		and D.UserFieldText8 in ('ЗимаЛето',
								'Зеленый день')
		and D.UserFieldText2 in ('ЗимаЛето',
								'Детский клуб')
		and D.Correspondent not like '%<AndreevichIS>%'
		and DateCreation >= '2019-01-01' 
		and IsActive = 'Y'
		/*	
	--05.02.2020
	update D 
		set Correspondent = Correspondent + ' "И. С. Андреевич" <AndreevichIS>;'
	from dbo.Docs D
	where D.ClassDoc in ('Платежи(Н) / Заявка на оплату',
						'Платежи(Н) / Платежи в бюджет',
						'Платежи(Н) / Плановая заявка')
		and D.UserFieldText2 in ('Компания Колос')
		and D.UserFieldText8 in ('РегионСпецСтрой',
								'Лидс',
								'Басова Юлия Юрьевна')
		and D.Correspondent not like '%<AndreevichIS>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01' 
		*/
		
		--05.02.2020
		/*
	update D 
		set Correspondent = Correspondent + ' "И. С. Андреевич" <AndreevichIS>;'
	from dbo.Docs D
	where D.ClassDoc in ('Платежи(Н) / Плановый бюджет')
		and D.UserFieldText2 in ('Компания Колос')
		and D.UserFieldText8 in ('Лидс')
		and D.Correspondent not like '%<AndreevichIS>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01' 
		*/
		/*
	update D
		set Correspondent = Correspondent + ' "И. С. Андреевич" <AndreevichIS>;'
	from dbo.Docs D
	where D.ClassDoc = 'Платежи(Н) / Корректирующая заявка'
		and 'Компания Колос' in (D.UserFieldText2, D.UserFieldText3)
		and D.UserFieldText8 in ('РегионСпецСтрой',
								'Лидс',
								'Басова Юлия Юрьевна')
		and D.Correspondent not like '%<AndreevichIS>%'
		and D.IsActive = 'Y'
		and D.DateCreation >= '2018-01-01' 
		*/
end



--"А. С. Березнева" <BereznevaAS>;
--13.03.2018
if exists (select 1 from dbo.Users where UserID = 'BereznevaAS'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
	
		
	update D 
		set Correspondent = Correspondent + ' "А. С. Березнева" <BereznevaAS>;'
	from dbo.Docs D
	where D.ClassDoc in ('Платежи(Н) / Заявка на оплату',
						'Платежи(Н) / Платежи в бюджет',
						'Платежи(Н) / Плановый бюджет',
						'Платежи(Н) / Плановая заявка')
		and D.UserFieldText2 in ('ЗимаЛето')
		and D.UserFieldText8 in ('ЗимаЛето',
								'Зеленый деньа')
		and D.Correspondent not like '%<BereznevaAS>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01' 
	
		
		
	update D
		set Correspondent = Correspondent + ' "А. С. Березнева" <BereznevaAS>;'
	from dbo.Docs D
	where D.ClassDoc = 'Платежи(Н) / Корректирующая заявка'
		and 'ЗимаЛето' in (D.UserFieldText2, D.UserFieldText3)
		and D.UserFieldText8 in ('ЗимаЛето',
								'Зеленый деньа')
		and D.Correspondent not like '%<BereznevaAS>%'
		and D.IsActive = 'Y'
		and D.DateCreation >= '2018-01-01' 
	
	update D 
		set Correspondent = Correspondent + ' "А. С. Березнева" <BereznevaAS>;'
	from dbo.Docs D
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 = 'АрендаСпорт'
		and D.Correspondent not like '%<BereznevaAS>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'
	
	update D 
		set Correspondent = Correspondent + ' "А. С. Березнева" <BereznevaAS>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0 --Б
	where D.ClassDoc = 'Платежи(Н) / Платежи в бюджет'
		and D.UserFieldText2 = 'АрендаСпорт'
		and D.Correspondent not like '%<BereznevaAS>%'
		and IsActive = 'Y'
		and D.DateCreation >='2018-01-01'
end


--"И. В. Кукарина" <KukarinaIV>;
--17.03.2019
if exists (select 1 from dbo.Users where UserID = 'PogodinaSG'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
	
		
	update D 
		set Correspondent = Correspondent + ' "И. В. Кукарина" <KukarinaIV>;'
	from dbo.Docs D
	where D.ClassDoc in ('Платежи(Н) / Заявка на оплату',
						'Платежи(Н) / Платежи в бюджет',
						'Платежи(Н) / Плановый бюджет',
						'Платежи(Н) / Плановая заявка',
						'Платежи(Н) / Корректирующая заявка')
		and D.UserFieldText8 = 'Формула (ИНН 7802550107)'
		and D.Correspondent not like '%<KukarinaIV>%'
		and IsActive = 'Y'
		and D.DateCreation >='2019-03-14' 
	
		
end



if exists (select 1 from dbo.Users where UserID = 'RyachkinaAI'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
			
	
	--28/03/2019
	update D 
		set Correspondent = Correspondent + ' "А. И. Рячкина" <RyachkinaAI>;'
	from dbo.Docs D
	where D.ClassDoc in ('Платежи(Н) / Заявка на оплату',
						'Платежи(Н) / Платежи в бюджет')
		and D.UserFieldText8 in ('Зеленый день',
								'ЗимаЛето')
		and D.UserFieldText2 in ('ЗимаЛето',
								'Детский клуб')
		and D.Correspondent not like '%<RyachkinaAI>%'
		and DateCreation >= '2019-03-18' 
		and IsActive = 'Y'
		
	--2021/05/26	
	update D 
		set Correspondent = Correspondent + ' "А. И. Рячкина" <RyachkinaAI>;'
	from dbo.Docs D
	where D.ClassDoc in (--'Платежи(Н) / Заявка на оплату',
						--'Платежи(Н) / Платежи в бюджет',
						'Платежи(Н) / Плановый бюджет',
						'Платежи(Н) / Плановая заявка')--,
						--'Платежи(Н) / Корректирующая заявка')
		and D.UserFieldText8 in ('Компания Колос')
		and D.UserFieldText2 in ('Компания Колос',
								'Образ Жизни')
		and D.Correspondent not like '%<RyachkinaAI>%'
		and DateCreation >= '2016-01-11' 
		and IsActive = 'Y'
		
end


--"Е. Н. Иванов" <IvanovEN>;
if exists (select 1 from dbo.Users where UserID = 'IvanovEN'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
	--15/04/2019
	update D 
		set Correspondent = Correspondent + ' "Е. Н. Иванов" <IvanovEN>;'
	from dbo.Docs D
	where D.ClassDoc in ('Платежи(Н) / Заявка на оплату')
		and D.UserFieldText8 in ('АрендаСпорт',
								'Басова Юлия Юрьевна',
								'Слугина Ирина Викторовна',
								'Фэмили-клаб')
		and D.UserFieldText2 in ('АрендаСпорт')
		and D.Correspondent not like '%<IvanovEN>%'
		and DateCreation >= '2018-01-01' 
		and IsActive = 'Y'
		
	update D 
		set Correspondent = Correspondent + ' "Е. Н. Иванов" <IvanovEN>;'
	from dbo.Docs D
	where D.ClassDoc in ('Платежи(Н) / Заявка на оплату')
		and D.UserFieldText8 in ('Лыжный Клуб')
		and D.UserFieldText2 in ('Лыжный Клуб')
		and D.Correspondent not like '%<IvanovEN>%'
		and DateCreation >= '2018-01-01' 
		and IsActive = 'Y'

	--01.04.2022 СпиридоноваЕИ
	update D 
		set Correspondent = Correspondent + ' "Е. Н. Иванов" <IvanovEN>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0 --Б
	where D.ClassDoc in ('Платежи(Н) / Заявка на оплату')
		and D.UserFieldText8 in ('Элефант Системс')
		and D.UserFieldText2 in ('Элефант')
		and D.Correspondent not like '%<IvanovEN>%'
		and DateCreation >= '2021-07-01' 
		and IsActive = 'Y'
end


--"М. Н. Чигинева" <ChiginevaMN>;
if exists (select 1 from dbo.Users where UserID = 'ChiginevaMN'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
	--15/04/2019
	update D 
		set Correspondent = Correspondent + ' "М. Н. Чигинева" <ChiginevaMN>;'
	from dbo.Docs D
	where D.ClassDoc in ('Платежи(Н) / Заявка на оплату')
		and D.UserFieldText8 in ('АрендаСпорт',
								'Басова Юлия Юрьевна',
								'Слугина Ирина Викторовна',
								'Фэмили-клаб')
		and D.UserFieldText2 in ('АрендаСпорт')
		and D.Correspondent not like '%<ChiginevaMN>%'
		and DateCreation >= '2018-01-01' 
		and IsActive = 'Y'
		
	--16/04/2019
	update D 
		set Correspondent = Correspondent + ' "М. Н. Чигинева" <ChiginevaMN>;'
	from dbo.Docs D
	where D.ClassDoc in ('Платежи(Н) / Заявка на оплату')
		and D.UserFieldText8 in ('Лыжный Клуб')
		and D.UserFieldText2 in ('Лыжный Клуб')
		and D.Correspondent not like '%<ChiginevaMN>%'
		and DateCreation >= '2017-01-01' 
		and IsActive = 'Y'
		
		
	update D 
		set Correspondent = Correspondent + ' "М. Н. Чигинева" <ChiginevaMN>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0 --Б
	where D.ClassDoc in ('Платежи(Н) / Заявка на оплату')
		and D.UserFieldText8 in ('Басова Юлия Юрьевна')
		and D.UserFieldText2 in ('Отдел по организации мероприятий')
		and D.Correspondent not like '%<ChiginevaMN>%'
		and DateCreation >= '2017-01-01' 
		and IsActive = 'Y'
			


end


--заявка от 29.05.2019
if exists (select 1 from dbo.Users where UserID = 'OsipenkoNE'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin

	--30.05.2019	
	update D 
		set Correspondent = Correspondent + ' "Н. Е. Осипенко" <OsipenkoNE>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0
	where D.ClassDoc in ('Платежи(Н) / Заявка на оплату')
		and D.UserFieldText8 = 'Компания Колос'
		and D.UserFieldText2 in ('Компания Колос',
									'Образ Жизни')
		and D.Correspondent not like '%<OsipenkoNE>%'
		and DateCreation >= '2015-01-01' 
		and IsActive = 'Y'
		
	--10.11.2019	
	update D 
		set Correspondent = Correspondent + ' "Н. Е. Осипенко" <OsipenkoNE>;'
	from dbo.Docs D
	where D.ClassDoc in ('Платежи(Н) / Заявка на оплату')
		and D.UserFieldText2 in ('Охта - Парк')
		and D.Correspondent not like '%<OsipenkoNE>%'
		and DateCreation >= '2010-01-01' 
		and IsActive = 'Y'
		
end


--заявка от 29.05.2019
if exists (select 1 from dbo.Users where UserID = 'OliferovichIE'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin

	--30.05.2019
	--изменено 06.12.2022 СпиридоноваЕИ добавила ограничение по ЛС на оплату труда
	update D 
		set Correspondent = Correspondent + ' "И. Е. Олиферович" <OliferovichIE>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0
	where D.ClassDoc in ('Платежи(Н) / Заявка на оплату')
		and D.UserFieldText8 = 'Компания Колос'
		and D.UserFieldText2 in ('Компания Колос',
									'Образ Жизни')
		and D.UserFieldText1 not like '%Заявка на оплату труда (для счета типа Б)%'
		and D.UserFieldText1 not like '%(БЛС) Заявка на оплату (для счета типа Б) (ЗП)%'
		and D.Correspondent not like '%<OliferovichIE>%'
		and DateCreation >= '2015-01-01' 
		and IsActive = 'Y'
		
			
	--30,05,2020
	update D 
		set Correspondent = Correspondent + ' "И. Е. Олиферович" <OliferovichIE>;'
	from dbo.Docs D
	where D.ClassDoc in ('Договоры / (C) СМР')
	and D.UserFieldText1 in ('(БЛС) Договор на выполнение ПИР, СМР (Образ жизни. Лесная деревня)')
	and D.Correspondent not like '%<OliferovichIE>%'
	and IsActive = 'Y'
	and D.DateCreation >='2020-05-28'
	
end



--заявка от 29.05.2019
if exists (select 1 from dbo.Users where UserID = 'GorchakovaI'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin

	--30.05.2019	
	update D 
		set Correspondent = Correspondent + ' "И. Б. Горчакова" <GorchakovaIB>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0
	where D.ClassDoc in ('Платежи(Н) / Заявка на оплату')
		and D.UserFieldText8 = 'Компания Колос'
		and D.UserFieldText2 in ('Компания Колос',
									'Образ Жизни')
		and D.Correspondent not like '%<GorchakovaI>%'
		and DateCreation >= '2015-01-01' 
		and IsActive = 'Y'
end


--заявка от 04.06.2019
if exists (select 1 from dbo.Users where UserID = 'ProlyginaND'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin

/*--09.02.2020
	--30.05.2019	
	update D 
		set Correspondent = Correspondent + ' "Н. Д. Пролыгина" <ProlyginaND>;'
	from dbo.Docs D
	where D.ClassDoc in ('Платежи(Н) / Заявка на оплату')
		and D.UserFieldText8 in ('АрендаСпорт',
								'Фэмили-клаб',
								'Сервис-Эксплуатация')
		and D.UserFieldText2 in ('АрендаСпорт',
								'Сервис-Эксплуатация')
		and D.Correspondent not like '%<ProlyginaND>%'
		and DateCreation >= '2019-01-01' 
		and IsActive = 'Y'
*/		
	update D 
		set Correspondent = Correspondent + ' "Н. Д. Пролыгина" <ProlyginaND>;'
	from dbo.Docs D
	where D.ClassDoc in ('Платежи(Н) / Заявка на оплату',
						'Платежи(Н) / Платежи в бюджет',
						'Платежи(Н) / Плановый бюджет',
						'Платежи(Н) / Плановая заявка')
		and D.UserFieldText8 in ('Басова Юлия Юрьевна')
		and D.UserFieldText2 in ('Отдел по организации мероприятий')
		and D.Correspondent not like '%<ProlyginaND>%'
		and DateCreation >= '2019-01-01' 
		and IsActive = 'Y'
		
	update D 
		set Correspondent = Correspondent + ' "Н. Д. Пролыгина" <ProlyginaND>;'
	from dbo.Docs D
	where D.ClassDoc in ('Платежи(Н) / Корректирующая заявка')
		and D.UserFieldText8 in ('Басова Юлия Юрьевна')
		and D.UserFieldText3 in ('Отдел по организации мероприятий')
		and D.Correspondent not like '%<ProlyginaND>%'
		and DateCreation >= '2019-01-01' 
		and IsActive = 'Y'
		
		
		/****************************/
	/*	
	update D 
		set Correspondent = Correspondent + ' "Н. Д. Пролыгина" <ProlyginaND>;'
	from dbo.Docs D
	where D.ClassDoc in ('Платежи(Н) / Заявка на оплату')
		and D.UserFieldText8 in ('ЗимаЛето',
								'Зеленый день')
		and D.UserFieldText2 in ('ЗимаЛето',
								'Детский клуб')
		and D.Correspondent not like '%<ProlyginaND>%'
		and DateCreation >= '2019-01-01' 
		and IsActive = 'Y'
		*/		
	update D 
		set Correspondent = Correspondent + ' "Н. Д. Пролыгина" <ProlyginaND>;'
	from dbo.Docs D
	where D.ClassDoc in ('Платежи(Н) / Заявка на оплату',
						'Платежи(Н) / Платежи в бюджет',
						'Платежи(Н) / Плановая заявка')
		and D.UserFieldText2 in ('Компания Колос')
		and D.UserFieldText8 in ('РегионСпецСтрой',
								'Лидс',
								'Басова Юлия Юрьевна')
		and D.Correspondent not like '%<ProlyginaND>%'
		and IsActive = 'Y'
		and D.DateCreation >='2019-01-01' 
				
		
	update D 
		set Correspondent = Correspondent + ' "Н. Д. Пролыгина" <ProlyginaND>;'
	from dbo.Docs D
	where D.ClassDoc in ('Платежи(Н) / Плановый бюджет')
		and D.UserFieldText2 in ('Компания Колос')
		and D.UserFieldText8 in ('Лидс')
		and D.Correspondent not like '%<ProlyginaND>%'
		and IsActive = 'Y'
		and D.DateCreation >='2019-01-01' 
		
		
	update D
		set Correspondent = Correspondent + ' "Н. Д. Пролыгина" <ProlyginaND>;'
	from dbo.Docs D
	where D.ClassDoc = 'Платежи(Н) / Корректирующая заявка'
		and 'Компания Колос' in (D.UserFieldText2, D.UserFieldText3)
		and D.UserFieldText8 in ('РегионСпецСтрой',
								'Лидс',
								'Басова Юлия Юрьевна')
		and D.Correspondent not like '%<ProlyginaND>%'
		and D.IsActive = 'Y'
		and D.DateCreation >= '2018-01-01' 
		
end



--заявка от 04.08.2019
if exists (select 1 from dbo.Users where UserID = 'VolkovaLV'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin

	--30.05.2019	
	update D 
		set Correspondent = Correspondent + ' "Л. В. Волкова" <VolkovaLV>;'
	from dbo.Docs D
	where D.ClassDoc in ('Платежи(Н) / Заявка на оплату')
		and D.UserFieldText8 in ('ЗимаЛето',
									'Зеленый день')
		and D.UserFieldText2 in ('ЗимаЛето',
								'Детский клуб')
		and D.Correspondent not like '%<VolkovaLV>%'
		and DateCreation >= '2018-01-01' 
		and IsActive = 'Y'
end



--"А. Н. Лузина" <LuzinaAN>;
if exists (select 1 from dbo.Users where UserID = 'LuzinaAN'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	update D 
		set Correspondent = Correspondent + ' "А. Н. Лузина" <LuzinaAN>;'
	from dbo.Docs D
	where D.ClassDoc in ('Договоры / (H) Прочие(исполнитель)')
	and D.ActDoc = 'Образ жизни<25>'
	and D.UserFieldText4 = 'Жилой комплекс «Образ Жизни». Горная деревня'
	and D.UserFieldText7 = '<351> Жилой комплекс «Образ Жизни». Горная деревня'
	and D.Correspondent not like '%<LuzinaAN>%'
	and IsActive = 'Y'
	and D.DateCreation >='2018-12-31'
	
			
	update D 
		set Correspondent = Correspondent + ' "А. Н. Лузина" <LuzinaAN>;'
	from dbo.Docs D
	where D.ClassDoc in ('Договоры / (H) Прочие(исполнитель)')
	and D.ActDoc = 'Образ жизни<25>'
	and D.UserFieldText4 = 'Лесная деревня'
	and D.UserFieldText7 = '<358> Лесная деревня'
	and D.Correspondent not like '%<LuzinaAN>%'
	and IsActive = 'Y'
	and D.DateCreation >='2019-08-09'
	

end


--"О. Е. Колованова" <BormotovaOE>;
if exists (select 1 from dbo.Users where UserID = 'BormotovaOE'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	update D 
		set Correspondent = Correspondent + ' "О. Е. Колованова" <BormotovaOE>;'
	from dbo.Docs D
	where D.ClassDoc in ('Договоры / (H) Прочие(исполнитель)')
	and D.ActDoc = 'Образ жизни<25>'
	and D.UserFieldText4 = 'Жилой комплекс «Образ Жизни». Горная деревня'
	and D.UserFieldText7 = '<351> Жилой комплекс «Образ Жизни». Горная деревня'
	and D.Correspondent not like '%<BormotovaOE>%'
	and IsActive = 'Y'
	and D.DateCreation >='2018-12-01'
	
		
end



--"К. В. Пучнина" <PuchninaKV>;
if exists (select 1 from dbo.Users where UserID = 'PuchninaKV'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
	--22/10/2019
	update D 
		set Correspondent = Correspondent + ' "К. В. Пучнина" <PuchninaKV>;'
	from dbo.Docs D
	where D.ClassDoc in ('Платежи(Н) / Заявка на оплату')
		and D.UserFieldText8 in ('Лыжный Клуб')
		and D.UserFieldText2 in ('Лыжный Клуб')
		and D.Correspondent not like '%<PuchninaKV>%'
		and DateCreation >= '2017-10-21' 
		and IsActive = 'Y'
		
		
	update D 
		set Correspondent = Correspondent + ' "К. В. Пучнина" <PuchninaKV>;'
	from dbo.Docs D
	where D.ClassDoc = 'Платежи(Н) / Платежи в бюджет'
		and D.UserFieldText2 = 'Лыжный Клуб'
		and D.UserFieldText8 in ('Лыжный Клуб')
		and D.Correspondent not like '%<PuchninaKV>%'
		and IsActive = 'Y'
		and D.DateCreation >='2019-12-18'
		
	
	update D 
		set Correspondent = Correspondent + ' "К. В. Пучнина" <PuchninaKV>;'
	from dbo.Docs D
	where D.ClassDoc in ('Платежи(Н) / Заявка на оплату',
						'Платежи(Н) / Платежи в бюджет',
						'Платежи(Н) / Плановый бюджет',
						'Платежи(Н) / Плановая заявка',
						'Платежи(Н) / Корректирующая заявка')
		and D.UserFieldText8 in ('Слугина Ирина Викторовна')
		and D.Correspondent not like '%<PuchninaKV>%'
		and DateCreation >= '2018-01-01' 
		and IsActive = 'Y'
	
	update D 
		set Correspondent = Correspondent + ' "К. В. Пучнина" <PuchninaKV>;'
	from dbo.Docs D
	where D.ClassDoc in ('Платежи(Н) / Заявка на оплату')
		and D.UserFieldText8 in ('Зеленый день')
		and D.UserFieldText2 in ('Детский клуб')
		and D.Correspondent not like '%<PuchninaKV>%'
		and DateCreation >= '2018-01-01' 
		and IsActive = 'Y'
			
			

end



--"А. А. Фонарева" <FonarevaAA>;
if exists (select 1 from dbo.Users where UserID = 'FonarevaAA'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
	--27/10/2019
	update D 
		set Correspondent = Correspondent + ' "А. А. Фонарева" <FonarevaAA>;'
	from dbo.Docs D
	where D.ClassDoc in ('Платежи(Н) / Заявка на оплату')
		and D.UserFieldText8 in ('Зеленый день')
		and D.UserFieldText2 in ('Детский клуб')
		and D.Correspondent not like '%<FonarevaAA>%'
		and DateCreation >= '2018-11-08' 
		and IsActive = 'Y'
end



--заявка от 30.10.2019
/*if exists (select 1 from dbo.Users where UserID = 'SovetovaAD'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin*/

	--31.10.2019	
/*	update D 
		set Correspondent = Correspondent + ' "А. Д. Советова" <SovetovaAD>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0
	where D.ClassDoc in ('Платежи(Н) / Заявка на оплату')
		and D.UserFieldText8 = 'Компания Колос'
		and D.UserFieldText2 in ('Компания Колос')
		and D.Correspondent not like '%<SovetovaAD>%'
		and DateCreation >= '2016-01-01' 
		and IsActive = 'Y'
		
		
	update D 
		set Correspondent = Correspondent + ' "А. Д. Советова" <SovetovaAD>;'
	from dbo.Docs D
	where D.ClassDoc in ('Платежи(Н) / Заявка на оплату')
		and D.UserFieldText8 = 'Компания Колос'
		and D.UserFieldText2 in ('Образ Жизни')
		and D.Correspondent not like '%<SovetovaAD>%'
		and DateCreation >= '2016-01-01' 
		and IsActive = 'Y'*/
/*		
	update D 
		set Correspondent = Correspondent + ' "А. Д. Советова" <SovetovaAD>;'
	from dbo.Docs D
	where D.ClassDoc in ('Платежи(Н) / Заявка на оплату')
		and D.UserFieldText2 in ('Компания Колос',
									'Образ Жизни')
		and D.Correspondent not like '%<SovetovaAD>%'
		and DateCreation >= '2015-01-01' 
		and IsActive = 'Y'
*/		
/*end*/




if exists (select 1 from dbo.Users where UserID = 'SadakovaIA'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	update D 
		set Correspondent = Correspondent + ' "И. А. Садакова" <SadakovaIA>;'
	from dbo.Docs D
	where D.ClassDoc in ('Платежи(Н) / Заявка на оплату',
						'Платежи(Н) / Платежи в бюджет',
						'Платежи(Н) / Плановый бюджет',
						'Платежи(Н) / Плановая заявка')
		and D.UserFieldText2 in ('АрендаСпорт','Сервис-Эксплуатация')
		and D.Correspondent not like '%<SadakovaIA>%'
		and DateCreation >= '2016-01-01' 
		and IsActive = 'Y'
		
	update D 
		set Correspondent = Correspondent + ' "И. А. Садакова" <SadakovaIA>;'
	from dbo.Docs D
	where D.ClassDoc in ('Платежи(Н) / Корректирующая заявка')
		and D.UserFieldText3 in ('АрендаСпорт','Сервис-Эксплуатация')
		and D.Correspondent not like '%<SadakovaIA>%'
		and DateCreation >= '2016-01-01' 
		and IsActive = 'Y'
		
		
	update D 
		set Correspondent = Correspondent + ' "И. А. Садакова" <SadakovaIA>;'
	from dbo.Docs D
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 in ( 'Сервис-Эксплуатация',
									'АрендаСпорт',
									'Элефант')
		and D.UserFieldText6 = 'Касса ОП'
		and D.Correspondent not like '%<SadakovaIA>%'
		and IsActive = 'Y'	
		and D.DateCreation >= '2016-01-01'
		
end



if exists (select 1 from dbo.Users where UserID = 'KaznForm'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	update D 
		set Correspondent = Correspondent + ' "Казначей-ОП." <KaznForm>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0 --Б
	where D.ClassDoc in ('Платежи(Н) / Заявка на оплату',
						'Платежи(Н) / Платежи в бюджет')
		and D.UserFieldText2 in ('Компания Колос')
		and D.Correspondent not like '%<KaznForm>%'
		and DateCreation >= '2020-01-01' 
		and IsActive = 'Y'
		
end



--"Т. В. Запорожская" <ZaporozhskayaTV>;
if exists (select 1 from dbo.Users where UserID = 'ZaporozhskayaTV'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	update D 
		set Correspondent = Correspondent + ' "Т. В. Запорожская" <ZaporozhskayaTV>;'
	from dbo.Docs D
	where D.ClassDoc in ('Платежи(Н) / Заявка на оплату')
		and D.UserFieldText2 in ('Лыжный Клуб')
		and D.Correspondent not like '%<ZaporozhskayaTV>%'
		and DateCreation >= '2019-01-01' 
		and IsActive = 'Y'
		
end




--"Д. А. Служаев" <SluzhaevDA>;
if exists (select 1 from dbo.Users where UserID = 'SluzhaevDA'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	--30,05,2020
	update D 
		set Correspondent = Correspondent + ' "Д. А. Служаев" <SluzhaevDA>;'
	from dbo.Docs D
	where D.ClassDoc in ('Договоры / (C) СМР')
	and D.UserFieldText1 in ('(БЛС) Договор на выполнение ПИР, СМР (Образ жизни. Лесная деревня)')
	and D.Correspondent not like '%<SluzhaevDA>%'
	and IsActive = 'Y'
	and D.DateCreation >='2020-05-28'
	
end


--"Казначей Инвест." <KaznInvest>;
if exists (select 1 from dbo.Users where UserID = 'KaznInvest'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	--30,05,2020
	update D 
		set Correspondent = Correspondent + ' "Казначей Инвест." <KaznInvest>;'
	from dbo.Docs D
	where D.ClassDoc in ('Договоры / (C) СМР')
	and D.UserFieldText1 in ('(БЛС) Договор на выполнение ПИР, СМР (Образ жизни. Лесная деревня)')
	and D.Correspondent not like '%<KaznInvest>%'
	and IsActive = 'Y'
	and D.DateCreation >='2020-05-28'
	
end

--"Ю. В. Полякова"" <PolyakovaYV>;
if exists (select 1 from dbo.Users where UserID = 'PolyakovaYV'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	--30,05,2020
	update D 
		set Correspondent = Correspondent + ' "Ю. В. Полякова"" <PolyakovaYV>;'
	from dbo.Docs D
	where D.ClassDoc in ('Договоры / (C) СМР')
	and D.UserFieldText1 in ('(БЛС) Договор на выполнение ПИР, СМР (Образ жизни. Лесная деревня)')
	and D.Correspondent not like '%<PolyakovaYV>%'
	and IsActive = 'Y'
	and D.DateCreation >='2020-05-28'
	
end


--"Г. В. Екимашева" <EkimashevaGV>;
if exists (select 1 from dbo.Users where UserID = 'EkimashevaGV'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	--исполнение 26.07.2020
	update D 
		set Correspondent = Correspondent + ' "Г. В. Екимашева" <EkimashevaGV>;'
	from dbo.Docs D
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 = 'Лыжный Клуб'
		and D.PartnerName = 'ISR Academy d.o.o.'
		and D.Correspondent not like '%<EkimashevaGV>%'
		and D.DateCreation >= '2018-06-01' 
		and D.IsActive = 'Y'
	
		
		
	update D 
		set Correspondent = Correspondent + ' "Г. В. Екимашева" <EkimashevaGV>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0 --Б
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText8 in ('Слугина Ирина Викторовна',
								'АрендаСпорт',
								'Фэмили-клаб',
								'Басова Юлия Юрьевна ',
								'Лыжный клуб')
		and D.Correspondent not like '%<EkimashevaGV>%'
		and D.DateCreation >= '2018-01-01' 
		and D.IsActive = 'Y'
		
		
end


--"М. В. Грабежева" <GrabezhevaMV>;
if exists (select 1 from dbo.Users where UserID = 'GrabezhevaMV'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	update D 
		set Correspondent = Correspondent + ' "М. В. Грабежева" <GrabezhevaMV>;'
	from dbo.Docs D
	where D.ClassDoc like 'Договоры / %'
	and D.Correspondent not like '%<GrabezhevaMV>%'
	and IsActive = 'Y'
	and D.DateCreation >='2009-01-01'
	
end


--"Н. С. Просвирнина" <ProsvirninaNS>;
if exists (select 1 from dbo.Users where UserID = 'ProsvirninaNS'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	update D 
		set Correspondent = Correspondent + ' "Н. С. Просвирнина" <ProsvirninaNS>;'
	from dbo.Docs D
	where D.ClassDoc like 'Договоры /%'
	and D.PartnerName in ('АрендаСпорт ООО','Фэмили-клаб ООО')
	and D.Correspondent not like '%<ProsvirninaNS>%'
	and IsActive = 'Y'
	and D.DateCreation >='2016-01-01'
	
	

end

--"Е. Е. Меркулова" <MerkulovaEE>;
if exists (select 1 from dbo.Users where UserID = 'MerkulovaEE'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
		
	update D 
		set Correspondent = Correspondent + ' "Е. Е. Меркулова" <MerkulovaEE>;'
	from dbo.Docs D	
	where D.ClassDoc in ('Платежи(Н) / Заявка на оплату',
						'Платежи(Н) / Плановая заявка'/*,
						'Платежи(Н) / Корректирующая заявка'*/)
		and (D.UserFieldText8 = 'Лыжный Клуб'
			or D.UserFieldText2 = 'Лыжный Клуб')
		and D.Correspondent not like '%<MerkulovaEE>%'
		and DateCreation >= '2020-11-06' 
		and IsActive = 'Y'
	
	
	update D 
		set Correspondent = Correspondent + ' "Е. Е. Меркулова" <MerkulovaEE>;'
	from dbo.Docs D
	inner join dbo.PDX_pay_Accounts A on D.UserFieldText6 = A.Name
		and A.Class = 0--Б
	where D.ClassDoc = 'Платежи(Н) / Заявка на оплату'
		and D.UserFieldText2 = 'Инструкторская служба'
		and D.Correspondent not like '%<MerkulovaEE>%'
		and IsActive = 'Y'	
		and D.DateCreation >= '2020-11-01'
end



--"Е. А. Алексеева" <AlekseevaEA>;
if exists (select 1 from dbo.Users where UserID = 'AlekseevaEA'
			and StatusActive = '1'
			and DateExpirationSecurity >= GETDATE()
			and not Permitions like '%*%')
begin
--2021-02-27		
	update D 
		set Correspondent = Correspondent + ' "Е. А. Алексеева" <AlekseevaEA>;'
	from dbo.Docs D	
	where D.ClassDoc in ('Платежи(Н) / Заявка на оплату')
		and D.UserFieldText2 in ('Сервис-Эксплуатация',
								'Баня-Лэнд',
								'Охта Чисто')
		and D.UserFieldText6 = 'ББР'
		and D.Correspondent not like '%<AlekseevaEA>%'
		and DateCreation >= '2020-01-01' 
		and IsActive = 'Y'
	
	

end









GO
/****** Object:  StoredProcedure [dbo].[PDX_JOB_PAYORDn_Shrink] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_JOB_PAYORDn_Shrink]
	@date datetime  
as
declare @T table(DocID varchar(32)
		,strID varchar(32) 
		,DateActivation datetime
		,DateSigned datetime
		,UserFieldText7 varchar(1024)
		,Currency varchar(8)
		,UserFieldText8 varchar(1024)
		,NameAproval varchar(1024)
		,UserFieldText2 varchar(1024)
		,PartnerName varchar(1024)
		,UserFieldText4 varchar(1024)
		,UserFieldText5 varchar(1024)
		,UFT5 varchar(1024)
		,Name varchar(1024)
		,AmountDoc money
		,DocIDParent varchar(32)
		,DocIDPrevious varchar(32)
		,UserFieldText6 varchar(1024)
		,Description varchar(1024)
		,NameCreation varchar(1024)
		,UserFieldText1 varchar(1024)
		,ListToReconcile varchar(1024)
		,Correspondent varchar(1024)
		,ListToEdit varchar(1024)
		,[Status] varchar(32)
		,UFM2	money
)

declare @from datetime,@to datetime

select @from=DATEADD(YEAR,-1,@date), @to = @date

begin tran SHRINK_PAYORDn

begin try
	insert into @T 
	exec dbo.PDX_REP_PAYORDn_Find
		@DID=null
		,@DAf=@from
		,@DAt=@to
		,@DSf='1900-01-01'
		,@DSt='2100-01-01'
		,@UFT7=null
		,@Currency=null
		,@UFT8=null
		,@UFT2=null
		,@PN=null
		,@UFT4=null
		,@UFT5=null
		,@Name=null
		,@DIDPar=null
		,@DIDPrev=null
		,@UFT6=null
		,@NCr=null
		,@State=5
		,@UFM2=2
		,@Access=1

	insert into dbo.Log
		(DocID
		,DocName
		,[DateTime]
		,UserID
		,UserName
		,IPAddress
		,[Action])
	select distinct
		c.DocID
		,LEFT(c.FileName,127)+'%'
		,GETDATE()
		,'Admin'
		,'System Administrator'
		,''
		,'Файл к удалению'
	from Comments c
		inner join @T t on t.strID = c.DocID
	where (not c.FileName is null) and (LTRIM(RTRIM(c.FileName)) != '')

	insert into dbo.Log
		(DocID
		,DocName
		,[DateTime]
		,UserID
		,UserName
		,IPAddress
		,[Action])
	select distinct
		d.DocID
		,LEFT(d.Name,127)
		,GETDATE()
		,'Admin'
		,'System Administrator'
		,''
		,'Карточка удалена'
	from Docs d
		inner join @T t on t.strID = d.DocID


	delete pdd
	from PDXDocDetails pdd
		inner join @T t on t.strID = pdd.DocID

	delete c
	from Comments c
		inner join @T t on t.strID = c.DocID

	delete d from Docs d
		inner join @T t on t.strID = d.DocID
		
	commit tran SHRINK_PAYORDn
end try
begin catch
	rollback tran SHRINK_PAYORDn
end catch


GO
/****** Object:  StoredProcedure [dbo].[PDX_KAZ_DetailCopy] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_KAZ_DetailCopy]
	@DocID varchar(128),
	@NewDocID varchar(128),
	@UName varchar(96)
AS

	declare  @Res int, @ClassDoc varchar(128), @nClassDoc varchar(128)
	
	select 
		@ClassDoc = ClassDoc
	from dbo.Docs
	where DocID = @DocID
	select @Res = @@error if @Res <> 0 goto Err
	select 
		@nClassDoc = ClassDoc
	from dbo.Docs
	where DocID = @NewDocID
	select @Res = @@error if @Res <> 0 goto Err

	if @ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_ORDPAY')
		and @nClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_ORDPAY')
	begin
		insert into dbo.PDXDocDetails
			(SetID, DocID, ClassDoc, Am1, Am2, Am3, Am4, Am5, Tx1, Tx2, Tx3, Tx4, Tx5, TxL1, TxL2, Dt1, Dt2, Dt3, Dt4, Dt5, Bl1, Bl2, Bl3, Bl4, Bl5, DC, NC, DLM, NLM)
		select
			NEWID(), @NewDocID, ClassDoc, Am1, Am2, Am3, Am4, Am5, Tx1, Tx2, Tx3, Tx4, Tx5, TxL1, TxL2, Dt1, Dt2, Dt3, Dt4, Dt5, Bl1, Bl2, Bl3, Bl4, Bl5, GETDATE(), @UName, GETDATE(), @UName
		from dbo.PDXDocDetails
		where DocID = @DocID
		select @Res = @@error if @Res <> 0 goto Err
	end


OK:
	return @Res
Err:
	return @Res


GO
/****** Object:  StoredProcedure [dbo].[PDX_KAZ_ExtCheck] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_KAZ_ExtCheck]
	@DocID varchar(128),
	@Mess varchar(1024) = null out
	
as
declare 
	--@Res int,
	@ClassDoc varchar(128),
	@UFT5 varchar(1024), @UFT7 varchar(1024),@UFT6 varchar(1024),
	@UFT5_1 varchar(50), @UFT7_1 varchar(50),  @AmountDoc money, @UFD1 datetime, @UFD3 datetime, @year int,
	
	@Description [varchar](264),
	@Status [varchar](512) ,
	@KPP [varchar](128) ,
	@KBK [varchar](128) ,
	@OKTMO [varchar](128),
	@TaxPeriod [varchar](264),
	@Year2 [varchar](4) ,
	@Month [varchar](2),
	@DocIDInt int,
	@RCH varchar(1024),
	@Purpose varchar(255),
	@VAT varchar(255),
	@Amount money,
	@flg bit,
	@DocIDParent varchar(128),
	@RUSField varchar(128)
	
	--select @Res = 0
	select @Mess = ''

	declare @Tbl table (Val varchar(64), Pos int, Flag bit)

	select
		@ClassDoc = ClassDoc,
		@UFT5 = UserFieldText5,
		@UFT7 = case 
					when ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_CORPAY')
						then UserFieldText7
					else ''
				end,
		@AmountDoc = AmountDoc,
		@UFD1 = UserFieldDate1,
		@UFD3 = UserFieldDate3,
		@year = year(case ClassDoc
						when  dbo.PDX_CLSGet('RIK_CategoryName_KAZ_PLNPAY')  then UserFieldDate1
						else DateCreation
					end),
		@DocIDInt = DocIDInt,
		@RCH = case 
					when ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_BUDG') 	
						then UserFieldText7
					else ''
				end,
		@UFT6 = UserFieldText6,
		@DocIDParent = DocIDParent
	from dbo.Docs 
	where DocID = ltrim(rtrim(isnull(@DocID,'')))
	--select @Res = @@error if @Res <> 0 goto Err

	select 
		@UFT5_1 = dbo.PDX_SubstringReturn(@UFT5, CHARINDEX('<', @UFT5), charindex('>', @UFT5)),
		@UFT7_1 = dbo.PDX_SubstringReturn(@UFT7, CHARINDEX('<', @UFT7), charindex('>', @UFT7))
	--select @Res = @@error if @Res <> 0 goto Err
	set @RCH = LTRIM(rtrim(isnull(@RCH,'')))

	If @ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_ORDPAY') 	 
	begin
		if not exists(select top 1 1 from dbo.PDXDocDetails where DocID = @DocID)
		begin
			select @Mess = @Mess + 
				'<br><font color=red>ОШИБКА! </font> В Заявке на оплату должна быть указана хотя бы одна сумма (детальная строка).' 	
		end
		else
		begin
			if exists (select top 1 1 from dbo.PDXDocDetails where DocID = @DocID and ltrim(ISNULL(Tx2,'')) = '')
			begin
				select @Mess = @Mess + 
					'<br><font color=red>ОШИБКА! </font> В детальных строках Заявок на оплату обязательно должен быть указан параметр [НДС].' 	
			end
		end
		
		
		set @flg = 0
		select
			@flg = case Field3 when 'NO' then 0 else 1 end
		from dbo.UserDirValues
		where UDKeyField = 68
		and Field1 = '{AC5E2C19-E63C-4FDD-ADE4-173035E7D220}'
		
		if @flg = 1
		begin
			if isnull(YEAR(@UFD1),1900) = 1900
			begin
				set @RUSField = ''
				select @RUSField = RUSName
				from dbo.PDXUserSettingDocTypes
				where DocType = @ClassDoc
				and FieldName = 'UserFieldDate1'
				 
				select @Mess = @Mess + 
				'<br><font color=red>ОШИБКА! </font> Поле [' + @RUSField + '] не может быть пустым.' 	
			end
			
			if isnull((select Class from dbo.PDX_pay_Accounts where Name = @UFT6),0) <> 1
			begin
				if ltrim(isnull(@DocIDParent,'')) = ''
				begin
					set @RUSField = ''
					select @RUSField = RUSName
					from dbo.PDXUserSettingDocTypes
					where DocType = @ClassDoc
					and FieldName = 'DocIDParent'
					 
					select @Mess = @Mess + 
					'<br><font color=red>ОШИБКА! </font> Поле [' + @RUSField + '] не может быть пустым.' 	
				end
			end
		end
			
		
	End

	If @ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_PLNPAY') 
	begin
		if @AmountDoc = 0
		begin
			select @Mess = @Mess + 
				'<br><font color=red><b>Ошибка!</b></font> Плановая сумма не может быть нулевой.' 	
		end
		
		if not DATEDIFF(MONTH, GETDATE(), @UFD1) >=1
		begin
			select @Mess = @Mess + 
				'<br><font color=red><b>Ошибка!</b></font> Только Плановая Заявка на будущие периоды может быть активирована.' 	
		end
		
	End


	If @ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_CORPAY') 
	begin
		
		if not DATEDIFF(MONTH, GETDATE(), @UFD3) = 0
		begin
			select @Mess = @Mess + 
				'<br><font color=red><b>Ошибка!</b></font> Только Коррект. Заявка за текущий период может быть активирована.' 	
		end
		
	End
	
	if @year <= 2015
	begin
		if exists (select 1 from dbo.PDX_pay_Items where ParentID in (
		(select SetID from dbo.PDX_pay_Items where Code = @UFT5_1)))
		begin
			select @Mess = @Mess + 
					'<br><font color=red>ОШИБКА! </font> Статья расходов [' + @UFT5 + '] не может быть указана в карточке документа (у нее есть "дочерние" элементы). Уточните статью расходов.</font>' 
			--select @Res = @@error if @Res <> 0 goto Err
		end

		if @UFT7_1 <> '' and exists (select 1 from dbo.PDX_pay_Items where ParentID in (
		(select SetID from dbo.PDX_pay_Items where Code = @UFT7_1)))
		begin
			select @Mess = @Mess + 
					'<br><font color=red>ОШИБКА! </font> Статья расходов [' + @UFT7 + '] не может быть указана в карточке документа (у нее есть "дочерние" элементы). Уточните статью расходов.</font>' 
			--select @Res = @@error if @Res <> 0 goto Err
		end
	end
	else
	begin
		if exists (select 1 from dbo.PDX_pay_Items2016 where ParentID in (
		(select SetID from dbo.PDX_pay_Items2016 where Code = @UFT5_1)))
		begin
			select @Mess = @Mess + 
					'<br><font color=red>ОШИБКА! </font> Статья расходов [' + @UFT5 + '] не может быть указана в карточке документа (у нее есть "дочерние" элементы). Уточните статью расходов.</font>' 
			--select @Res = @@error if @Res <> 0 goto Err
		end

		if @UFT7_1 <> '' and exists (select 1 from dbo.PDX_pay_Items2016 where ParentID in (
		(select SetID from dbo.PDX_pay_Items2016 where Code = @UFT7_1)))
		begin
			select @Mess = @Mess + 
					'<br><font color=red>ОШИБКА! </font> Статья расходов [' + @UFT7 + '] не может быть указана в карточке документа (у нее есть "дочерние" элементы). Уточните статью расходов.</font>' 
			--select @Res = @@error if @Res <> 0 goto Err
		end
		
		--115.1 – 115.6, 108.2, 108.3, 116
		If @ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_ORDPAY')  and (@UFT5_1 like '108.[2-3]' or @UFT5_1 like '115.[1-6]' or @UFT5_1 = '116')
		begin
			select @Mess = @Mess + 
					'<br><font color=red>ОШИБКА! </font> Статья расходов [' + @UFT5 + '] не может быть указана в карточке категории ' + dbo.PDX_CLSGet('RIK_CategoryName_KAZ_ORDPAY') + ', выберите категорию ' + dbo.PDX_CLSGet('RIK_CategoryName_KAZ_BUDG') + '</font>' 
		end
	end
	
	
	if @ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_BUDG') 	
	begin
		select 
			@Description = '',
			@Status = '',
			@KPP = '',
			@KBK = '',
			@OKTMO = '',
			@TaxPeriod = '',
			@Year2 = '',
			@Month = '',
			@Purpose = '',
			@VAT = '',
			@AmountDoc = 0
			
		select
			@Description = Description,
			@Status = Status,
			@KPP = KPP,
			@KBK = KBK,
			@OKTMO = OKTMO,
			@TaxPeriod = TaxPeriod,
			@Year2 = Year,
			@Month = Month,
			@Purpose = Purpose,
			@VAT = VAT,
			@Amount = Amount
		from dbo.[DocsPayBudget] 
		where DocIDInt = @DocIDInt
		
		If @Description = ''
		begin
			select @Mess = @Mess + 
				'<br><font color=red>ОШИБКА! </font> Поле [Основание платежа] не может быть пустым</font>'
		end	
		if not exists (select top 1 1 from dbo.[PayRationale] where @Description = Name + '<' + Code + '>')
		begin
			select @Mess = @Mess + 
				'<br><font color=red>ОШИБКА! </font> Поле [Основание платежа]: значение [' + @Description + '] в справочнике не существует</font>'
		end
		
		If @Status = ''
		begin
			select @Mess = @Mess + 
				'<br><font color=red>ОШИБКА! </font> Поле [Статус составителя] не может быть пустым</font>'
		end
		if not exists (select top 1 1 from dbo.[PayBudgStatus] where Name + '<' + Code + '>' = @Status)
		begin
			select @Mess = @Mess + 
				'<br><font color=red>ОШИБКА! </font> Поле [Статус составителя]: значение [' + @Status + '] в справочнике не существует</font>'
		end
		
		
		If @KPP = ''
		begin
			select @Mess = @Mess + 
				'<br><font color=red>ОШИБКА! </font> Поле [КПП] не может быть пустым</font>'
		end
		If @KBK = ''
		begin
			select @Mess = @Mess + 
				'<br><font color=red>ОШИБКА! </font> Поле [КБК] не может быть пустым</font>'
		end
		else if len(@KBK) <> 20
		begin
			select @Mess = @Mess + 
				'<br><font color=red>ОШИБКА! </font> Некорректно заполнено поле [КБК] (должно быть 20 символов)</font>'
		end
		If @OKTMO = ''
		begin
			select @Mess = @Mess + 
				'<br><font color=red>ОШИБКА! </font> Поле [ОКТМО] не может быть пустым</font>'
		end
		else if len(@OKTMO) <> 8
		begin
			select @Mess = @Mess + 
				'<br><font color=red>ОШИБКА! </font> Некорректно заполнено поле [ОКТМО] (должно быть 8 символов)</font>'
		end
		
		If @TaxPeriod = ''
		begin
			select @Mess = @Mess + 
				'<br><font color=red>ОШИБКА! </font> Поле [Налоговый период] не может быть пустым</font>'
		end
		if not exists (select top 1 1 from dbo.[PayTaxes] where Name + '<' + Code + '>' = @TaxPeriod)
		begin
			select @Mess = @Mess + 
				'<br><font color=red>ОШИБКА! </font> Поле [Налоговый период]: значение [' + @TaxPeriod + '] в справочнике не существует</font>'
		end
		
		
		/*If @Year2 = ''
		begin
			select @Mess = @Mess + 
				'<br><font color=red>ОШИБКА! </font> Поле [Год периода] не может быть пустым</font>'
		end
		else */
		If  @Year2 <> '' 
		begin
			if isnumeric(@Year2) = 0
			begin
				select @Mess = @Mess + 
					'<br><font color=red>ОШИБКА! </font> Некорректно заполнено поле [Год периода]</font>'
			end
			else if not cast(@Year2 as int) between 2000 and 2050
			begin
				select @Mess = @Mess + 
					'<br><font color=red>ОШИБКА! </font> Некорректно заполнено поле [Год периода] (допустимое значение от 2000 г. до 2050 г.)</font>'
			end
		end
		
		/*
		If  @Month = ''
		begin
			select @Mess = @Mess + 
				'<br><font color=red>ОШИБКА! </font> Поле [Месяц] не может быть пустым</font>'
		end
		*/
		
		If @Purpose = ''
		begin
			select @Mess = @Mess +  + case len(@Mess) when 0 then '' else '<br>' end +
				'<font color=red>ОШИБКА! </font>Поле [Назначение платежного поручения] не может быть пустым'
		end

		If @VAT = ''
		begin
			select @Mess = @Mess +  + case len(@Mess) when 0 then '' else '<br>' end +
				'<font color=red>ОШИБКА! </font>Поле [НДС] не может быть пустым'
		end
		
		If @Amount = 0
		begin
			select @Mess = @Mess +  + case len(@Mess) when 0 then '' else '<br>' end +
				'<font color=red>ОШИБКА! </font>Укажите сумму платежа'
		end
	End
	
	
	select @Mess = @Mess + case len(@Mess) when 0 then '' else '<br>' end
    --select @Res = @@error if @Res <> 0 goto Err

OK:

	select @Mess as 'res'
	--return @Res
--Err:
	--select @Mess  as 'res'
	--return @Res

















GO
/****** Object:  StoredProcedure [dbo].[PDX_KAZActive_Activate] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*drop proc [dbo].[PDX_KAZActive_Activate]
go*/
create proc [dbo].[PDX_KAZActive_Activate]
	@ActionLogID int,
	@VisaCnt int,
	@UserID varchar(16),
	@RoleID varchar(16)
as
declare @tbl table (DocID varchar(128), DocIDInt int, LTR varchar(4096), NA varchar(96))

	declare @UName varchar(96), @UName2 varchar(96), @UNameR varchar(128), @UNameR2 varchar(128), @DocDate datetime, @DocDate2 datetime
	set @VisaCnt = isnull(@VisaCnt,0)
	
	set @DocDate = GETDATE()
	if @VisaCnt < 0 
	begin
		set @DocDate2 = DATEADD(hour,-1*@VisaCnt,@DocDate)
	end
	else if @VisaCnt > 0 
	begin
		set @DocDate2 = DATEADD(day,@VisaCnt,@DocDate)
	end
	else --=0
	begin
		set @DocDate2 = DATEADD(day,1,@DocDate)
	end
	
	set @UName = dbo.User_PaydoxLogin(@UserID) 
	set @UName2 = rtrim(replace(LEFT(@UName,CHARINDEX('<', @UName)-1),'"',''))
	
	set @UNameR = ''
	if ISNULL(@RoleID,'')<>''
	begin
		set @UNameR = dbo.User_PaydoxLogin(@RoleID) 
		if ISNULL(@UNameR,'') <> '' 
		begin
			set @UNameR2 = rtrim(LEFT(@UNameR,CHARINDEX('<', @UNameR)-1))
			set @UName = @UNameR2 + ' / ' + @UName
			set @UNameR = ' / ' + @UNameR		
		end		
	end

	update L
		set ErrTxt = '<font color=red>ОШИБКА! </font> Документ уже был активирован ранее.',
		Err = 1
	from [dbo].[PDX_KAZActive_LogDocs] L 
	inner join dbo.Docs D on D.DocIDInt = L.DocIDInt
		and D.IsActive = 'Y'
	where L.ActionLogID = @ActionLogID 
	and L.Err = 0
	

	insert into @tbl (DocID, DocIDInt, LTR, NA)
	select L.DocID, L.DocIDInt,
	D.ListToReconcile, D.NameAproval
	from [dbo].[PDX_KAZActive_LogDocs] L 
	inner join dbo.Docs D on D.DocIDInt = L.DocIDInt
		and D.IsActive <> 'Y'
	where L.ActionLogID = @ActionLogID 
	and L.Err = 0


	update @tbl
	set LTR = case when not LTR like '%<%>%' then ''
					else dbo.PDX_SubstringReturn(' ' + LTR,CHARINDEX('<',' ' + LTR)-1, LEN(LTR)+1)
			end
	update @tbl
	set LTR = case when not LTR like '%<%>%' then ''
					else LEFT(LTR + CHAR(13), CHARINDEX(char(13),LTR + char(13))-1)
			end

	update D
		set IsActive = 'Y',
		DateActive = @DocDate,
		StatusDevelopment = '1'
	from @tbl L
	inner join dbo.Docs D on D.DocIDInt = L.DocIDInt

--коммент об активации
	insert into dbo.Comments
	(	UserID,
		UserName,
		ContactUserName,
		ContactUserID,
		PartnerName,
		DocID,
		DateCreation,
		DateEvent,
		DateEventEnd,
		Address,
		Subject,
		Comment,
		CommentType,
		SpecialInfo,
		FileName,
		--KeyField,
		PartnerID,
		Version,
		GUID,
		GUIDPartner,
		GUIDUser,
		GUIDDoc,
		Amount,
		FileNameOriginal,
		RIK_CommentType)
	select
		@UserID,
		@UName2,
		null,--ContactUserName,
		null,--ContactUserID,
		'',--PartnerName,
		DocID,
		@DocDate,--DateCreation,
		null,--DateEvent,
		null,--DateEventEnd,
		'',--Address,
		NULL,-- Subject,
		'Документ активен' + @UNameR,--Comment,
		'system',--CommentType,
		'',--SpecialInfo,
		null,--FileName,
		--KeyField,
		null,--PartnerID,
		'',--Version,
		newid(),--GUID,
		null,--GUIDPartner,
		null,--GUIDUser,
		null,--GUIDDoc,
		0,--Amount,
		null,--FileNameOriginal,
		null--RIK_CommentType
	from @tbl
				
	--счетчики
	insert into dbo.Comments
	(	UserID,
		UserName,
		ContactUserName,
		ContactUserID,
		PartnerName,
		DocID,
		DateCreation,
		DateEvent,
		DateEventEnd,
		Address,
		Subject,
		Comment,
		CommentType,
		SpecialInfo,
		FileName,
		--KeyField,
		PartnerID,
		Version,
		GUID,
		GUIDPartner,
		GUIDUser,
		GUIDDoc,
		Amount,
		FileNameOriginal,
		RIK_CommentType)
	select
		U.UserID,
		dbo.PDX_FIObyFullNameGet(U.Name),
		null,--ContactUserName,
		null,--ContactUserID,
		'',--PartnerName,
		DocID,
		@DocDate,--DateCreation,
		@DocDate,--DateEvent,
		@DocDate2,--DateEventEnd,
		null,--Address,
		'',-- Subject,
		'Согласование...',--Comment,
		'VISA',--CommentType,
		'VISAWAITING',--SpecialInfo,
		null,--FileName,
		--KeyField,
		null,--PartnerID,
		'',--Version,
		newid(),--GUID,
		null,--GUIDPartner,
		null,--GUIDUser,
		null,--GUIDDoc,
		0,--Amount,
		null,--FileNameOriginal,
		null--RIK_CommentType
	from @tbl T
	inner join dbo.Users U on T.LTR like '%<' + U.UserID + '>%'
				
	select '<'+U.UserID+'>' as UserID, T.DocID, 1 as Tp
	from @tbl T
	inner join dbo.Users U on T.LTR like '%<' + U.UserID + '>%'
	union
	select '<'+U.UserID+'>' as UserID, T.DocID, 2 as Tp
	from @tbl T
	inner join dbo.Users U on T.NA like '%<' + U.UserID + '>%'
	where not T.LTR like '%<%>%'
	order by 2,3,1
	
GO
/****** Object:  StoredProcedure [dbo].[PDX_KAZActive_Check] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*drop proc [dbo].[PDX_KAZActive_Check] 
go*/

CREATE proc [dbo].[PDX_KAZActive_Check] 
	@ActionLogID int
as
set nocount on

declare @DocID varchar(128), @ClassDoc varchar(128), @Mess varchar(8000), @Mess2 varchar(8000), @DocIDInt int
create table #tbl (DocID varchar(128), ClassDoc varchar(128), DocIDInt int)

insert into #tbl(DocID, ClassDoc, DocIDInt)
select L.DocID, A.ClassDoc, L.DocIDInt
from [dbo].[PDX_KAZActive_LogDocs] L
inner join [dbo].[PDX_KAZActive_Log] A on A.ActionLogID = L.ActionLogID
where L.ActionLogID = @ActionLogID


while exists (select 1 from #tbl)
begin
	select top 1
		@DocID = DocID,
		@DocIDInt = DocIDInt,
		@ClassDoc = ClassDoc,
		@Mess2 = ''	
	from #tbl
	
	set @Mess2 = ''
	set @Mess = ''
	exec dbo.PDX_CheckField_VM @DocID =@DocID, @ClassDoc = @ClassDoc, @Type = 1, @SQLStatement = @Mess out
	if 	@Mess <> '' select @Mess2 = @Mess2 + case @Mess2 when '' then '' else '<br>' end + @Mess


	set @Mess = ''	
    exec dbo.PDX_FindField @DocID = @DocID, @ClassDoc = @ClassDoc, @SQLStatement = @Mess out
	if 	@Mess <> '' select @Mess2 = @Mess2 + case @Mess2 when '' then '' else '<br>' end + @Mess
	
	set @Mess = ''	
    exec dbo.PDX_KAZ_ExtCheck @DocID = @DocID, @Mess = @Mess out	
    if 	@Mess <> '' select @Mess2 = @Mess2 + case @Mess2 when '' then '' else '<br>' end + @Mess
    
	set @Mess = ''	
    exec [dbo].[PDX_KazLink_Check]@DocID = @DocID, @Mess = @Mess out	
    if 	@Mess <> '' select @Mess2 = @Mess2 + case @Mess2 when '' then '' else '<br>' end + @Mess

	
	if @Mess2 <> ''
	begin
	
		Update [dbo].[PDX_KAZActive_LogDocs]
			set ErrTxt = isnull(ErrTxt,'') + case isnull(ErrTxt,'') when '' then '' else '<br>' end  + @Mess2,
			Err = 1
		where ActionLogID = @ActionLogID
			and DocIDInt = @DocIDInt
	end
						
	delete from #tbl where DocIDInt = @DocIDInt
	
end




drop table #tbl
	
GO
/****** Object:  StoredProcedure [dbo].[PDX_KAZActive_Fill] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*
drop proc [dbo].[PDX_KAZActive_Fill] 
go*/
CREATE proc [dbo].[PDX_KAZActive_Fill] 
	@ActionLogID int,
	@DocIDInt int
as

set nocount on
	
	insert into [dbo].[PDX_KAZActive_LogDocs]
		([ActionLogID],[DocID],[DocIDInt],[PartnerName],[BE],[CFO],[ITM],[Currency],[AmountDoc], Users)
	select
		@ActionLogID, DocID, DocIDInt, PartnerName, UserFieldText8, UserFieldText2,UserFieldText5, Currency, AmountDoc,
		LEFT(ListToReconcile + CHAR(13), CHARINDEX(char(13),ListToReconcile + CHAR(13))) 
	from dbo.Docs
	where DocIDInt = @DocIDInt
	

GO
/****** Object:  StoredProcedure [dbo].[PDX_KAZActive_PNCheck] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*drop proc [dbo].[PDX_KAZActive_PNCheck] 
go*/
CREATE proc [dbo].[PDX_KAZActive_PNCheck] 
	@ActionLogID int,
	@PartnerName varchar(1024),
	@Err varchar(4096),
	@Warn varchar(4096)
as

set nocount on
	
	set @Err = ISNULL(@Err,'')
	set @Warn = ISNULL(@Warn,'')
	
	if @Err <> '' or @Warn <> ''
	begin
		update [dbo].[PDX_KAZActive_LogDocs]
			set ErrTxt =  isnull(ErrTxt,'') + case isnull(ErrTxt,'') when '' then '' else '<br>' end  + @Err,
			WarnTxt = @Warn,
			[Err] = case @Err when '' then 0 else 1 end
		where ActionLogID = @ActionLogID
			and PartnerName = @PartnerName
	end

GO
/****** Object:  StoredProcedure [dbo].[PDX_KAZActive_Start] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_KAZActive_Start] 
	@DF datetime,
	@DT datetime,
	@BE varchar(1024) ,
	@CFO varchar(1024) ,
	@PN varchar(1024) ,
	@ITM varchar(1024) ,
	@Category varchar(128),
	@UserID varchar(16),
	@CurrUserID varchar(16)
as

set nocount on


	declare  @ActionLogID int, @Err varchar(1024)
	set @Err = ''
	
	if not exists (select 1 from dbo.DocTypes where name = @Category)
		or not exists (select 1 from dbo.Users where UserID = @UserID)
	begin
			set @Err = 'Некорректные параметры!'
	end
	else
	begin
		
			insert into [PDX_KAZActive_Log]
				([ClassDoc],[ActionUserID],[ActionDate],[DF],[DT],[BE],[CFO],[PN],[ITM],[UserID])
			values (@Category, @CurrUserID, GETDATE(), @DF, @DT, @BE, @CFO,@PN,@ITM, @UserID)
			set @ActionLogID = @@IDENTITY
		
	end
	select @ActionLogID as ActionLogID, @Err as Err
	

GO
/****** Object:  StoredProcedure [dbo].[PDX_KAZAprove] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO




CREATE proc [dbo].[PDX_KAZAprove]
	@DocsList varchar(4096),
	@TransactionID uniqueidentifier
as

create table #dcs (DocIDInt int, DocID varchar(128), isOK bit default 0, UserID varchar(20), UserName varchar(128),
					Correspondent varchar(4000))
declare @ClassDoc varchar(128), @OperationDate datetime,
@FirstDate datetime,
@LastDate datetime,
@DocCount int = 0

insert into #dcs
	(DocIDInt)
select Value
from dbo.inline_split_with_param(@DocsList,',')
where Value <> ''

select @DocCount = COUNT(*) from #dcs

insert into dbo.KAZAproveLog (TransactionID,DateCreation,Descr)
values (@TransactionID, GETDATE(), 'Docs to approve : ' + CAST(@DocCount as varchar(100)))

set @ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_ORDPAY')

set @OperationDate = GETDATE()

update T
	set isOK = 1,
	DocID = D.DocID,
	UserID = dbo.PDX_SubstringReturn(NameAproval, CHARINDEX('<',NameAproval), CHARINDEX('>',NameAproval)),
	Correspondent = cast(D.Correspondent as varchar(4000))
from #dcs T
inner join dbo.Docs D on D.DocIDInt = T.DocIDInt
where ClassDoc = @ClassDoc
	and IsActive = 'Y'
	and not isnull(StatusDevelopment,'') in ('4', '0')
	and not isnull(StatusCompletion,'') = '0'
	
	and dbo.PDX_CompareReconcilationList(ListToReconcile, ListReconciled) = 1

delete from #dcs where DocID is null

update T
	set UserName = [dbo].[PDX_FIObyFullNameGet](Name)
from #dcs T
inner join dbo.Users U on U.UserID = T.UserID

set @DocCount = 0
update D
set 
	NameApproved = D.NameAproval,
	DateApproved = GETDATE(),
	StatusDevelopment = '4'
from dbo.Docs D
inner join #dcs T on T.DocIDInt = D.DocIDInt

insert into dbo.Comments
(	UserID,
	UserName,
	ContactUserName,
	ContactUserID,
	PartnerName,
	DocID,
	DateCreation,
	DateEvent,
	DateEventEnd,
	Address,
	Subject,
	Comment,
	CommentType,
	SpecialInfo,
	FileName,
	--KeyField,
	PartnerID,
	Version,
	GUID,
	GUIDPartner,
	GUIDUser,
	GUIDDoc,
	Amount,
	FileNameOriginal,
	RIK_CommentType)
select
	UserID,
	UserName,
	null,--ContactUserName,
	null,--ContactUserID,
	null,--PartnerName,
	DocID,
	@OperationDate,--DateCreation,
	null,--DateEvent,
	null,--DateEventEnd,
	'',--Address,
	NULL,-- Subject,Завершено - Н. А. Цалай - 26.02.2019 14:37 
	'Завершено(авт.) - ' + UserName + ' - ' + CONVERT(varchar(100), @OperationDate, 104) + SPACE(1) + CONVERT(varchar(5), @OperationDate, 114),--Comment,
	'APROVAL',--CommentType,
	'',--SpecialInfo,
	null,--FileName,
	--KeyField,
	null,--PartnerID,
	null,--Version,
	newid(),--GUID,
	null,--GUIDPartner,
	null,--GUIDUser,
	null,--GUIDDoc,
	null,--Amount,
	null,--FileNameOriginal,
	null--RIK_CommentType
from #dcs

select
	DocIDInt, DocID, Correspondent
from #dcs
set @DocCount = @@ROWCOUNT

insert into dbo.KAZAproveLog (TransactionID,DateCreation,Descr)
values (@TransactionID, GETDATE(), 'Approved docs : ' + CAST(@DocCount as varchar(100)))

drop table #dcs


GO
/****** Object:  StoredProcedure [dbo].[PDX_KAZAproveLogSave] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[PDX_KAZAproveLogSave]
@TransactionID uniqueidentifier,
@Descr varchar(1024)
as

if @TransactionID is null set @TransactionID = NEWID()

insert into dbo.KAZAproveLog (TransactionID,DateCreation,Descr)
values (@TransactionID, GETDATE(), @Descr)

select @TransactionID as TransactionID

GO
/****** Object:  StoredProcedure [dbo].[PDX_KAZForAprove] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO




CREATE proc [dbo].[PDX_KAZForAprove]
@TransactionID uniqueidentifier	
as

declare @ClassDoc varchar(128),
@FirstDate datetime,
@LastDate datetime,
@UserID varchar(20),
@DocCount int

/*
declare @Users table(UserID varchar(20))

insert into @Users (UserID) values ('Platezhi')
insert into @Users (UserID) values ('VolkovaLV')
insert into @Users (UserID) values ('PiskarevaUI')

insert into @Users (UserID) values ('ZagorskayaNP')
insert into @Users (UserID) values ('KazakovaOE')
insert into @Users (UserID) values ('BelenkoOV')
insert into @Users (UserID) values ('ShipovDO')
insert into @Users (UserID) values ('SaygushinskayaAN')
insert into @Users (UserID) values ('NersesyanLV')
insert into @Users (UserID) values ('KryzhanovskayaNS')
insert into @Users (UserID) values ('MartynovMV')
insert into @Users (UserID) values ('KamornikovaIV')
insert into @Users (UserID) values ('ZubarevSA')
insert into @Users (UserID) values ('LojkinaSV')
insert into @Users (UserID) values ('LazarovSS')
insert into @Users (UserID) values ('ErshovDS')
insert into @Users (UserID) values ('ZhumirVV')
insert into @Users (UserID) values ('VasyutichAS')
insert into @Users (UserID) values ('RakovaNP')
insert into @Users (UserID) values ('DikanSV')
insert into @Users (UserID) values ('GoncharovaEA')
insert into @Users (UserID) values ('KolpakidiEI')
insert into @Users (UserID) values ('SuvorinAS')
insert into @Users (UserID) values ('ProkinaEN')
insert into @Users (UserID) values ('PopovDA')
insert into @Users (UserID) values ('ZyryanovVA')
insert into @Users (UserID) values ('SoloninkoGA')
insert into @Users (UserID) values ('PopovDA2')
insert into @Users (UserID) values ('GrintsevichAV')
insert into @Users (UserID) values ('ArkadovaOA')
insert into @Users (UserID) values ('SkvortsovDL')
insert into @Users (UserID) values ('AndrianovDA')
insert into @Users (UserID) values ('BarylnikKG')
insert into @Users (UserID) values ('AnisimovaMV')
insert into @Users (UserID) values ('KorotchenkoNP')
insert into @Users (UserID) values ('MakarychevaTV')
insert into @Users (UserID) values ('MaksimenkoNM')
insert into @Users (UserID) values ('KlimovaEO')
insert into @Users (UserID) values ('GavrilyukOI ')
insert into @Users (UserID) values ('FilonovDA')
insert into @Users (UserID) values ('BadratdinovTM')
insert into @Users (UserID) values ('SemenovKS')
*/

set @ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_ORDPAY')
--первое число текущего месяца
set @FirstDate = CONVERT(date, CAST(year(getdate()) as varchar(4)) + '-' + CAST(month(getdate()) as varchar(2)) + '-01')
set @LastDate = DATEADD(MONTH,1,@FirstDate)
--сдвигаем начало на 10 дней раньше
set @FirstDate = DATEADD(DAY,-10,@FirstDate)

select 
	D.DocID, D.DocIDInt, D.DocIDParent,
	--P.DocID, P.IsActive, P.StatusDevelopment, P.StatusCompletion,
	dbo.PDX_fn_pay_CFOGET(D.UserFieldText2) as UserFieldText2, 
	dbo.PDX_SubstringReturn(D.UserFieldText5, charindex('<',D.UserFieldText5), charindex('>',D.UserFieldText5)) as UserFieldText5,
	D.AmountDoc,
	D.Currency, 
	isnull(isnull(D.DateActive, D.DateActivation), D.DateCreation) as DateActive, 
	D.UserFieldDate3,
	case when isnull(D.StatusDevelopment,'') in ('0','4') or isnull(D.StatusCompletion,'') in ('0','1') then 0 else 1 end as State,
	dbo.PDX_fn_pay_ItemexGET(
		dbo.PDX_fn_pay_ItemIDGET(D.UserFieldText5, year(D.DateCreation)),
		@ClassDoc, year(D.DateCreation)) as Ex
from dbo.Docs D
left join dbo.Docs P on P.DocID = D.DocIDParent
where D.ClassDoc = @ClassDoc
	and D.IsActive = 'Y'
	and not isnull(D.StatusDevelopment,'') in ('4', '0')
	and not isnull(D.StatusCompletion,'') = '0'
	and D.DateActivation >= @FirstDate
	and D.DateActivation < @LastDate
	
	and dbo.PDX_CompareReconcilationList(D.ListToReconcile, D.ListReconciled) = 1

	and (
			P.DocID = '' 
		or 
			P.DocID is null
		or
			(P.IsActive ='Y' and P.StatusDevelopment = '4' and not isnull(P.StatusCompletion,'') = '0' )
		)
	--для всех пользователей
	--and dbo.PDX_SubstringReturn(D.NameCreation,CHARINDEX('<',D.NameCreation), CHARINDEX('>',D.NameCreation)) in (Select UserID from @Users)
set @DocCount = @@ROWCOUNT

insert into dbo.KAZAproveLog (TransactionID,DateCreation,Descr)
values (@TransactionID, GETDATE(), 'Selected docs :' + CAST(@DocCount as varchar(100)))




GO
/****** Object:  StoredProcedure [dbo].[PDX_KAZForSend_Get] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_KAZForSend_Get]
	@LTR varchar(1024) = '',
	@ClassDoc varchar(256),
	@DocID varchar(128) = ''

as
	declare  @Res int
	--If @ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_ORDPAY')
	--begin
	
		if @DocID <> ''
		begin
			If @ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_ORDPAY')
			begin
				select
					@LTR = UserFieldText1
				from dbo.Docs
				where DocID = @DocID
			END
		end
		
		select
			0 as OI ,0 as notForSL4, 0 as onlyDefault, '"' + dbo.PDX_FIObyFullNameGet(U.Name) + '" <' + U.UserID + '>;' as 'Position'
		from dbo.UserDirValues D
		inner join dbo.Users U on D.Field6 like '%<' + U.UserID + '>%'
			and U.DateExpirationSecurity > CONVERT(datetime, convert(varchar(100), getdate(), 104), 104)
			and U.StatusActive = '1'
			and not U.Permitions like '%*%'
		where D.UDKeyField = 219
			and D.Field1 = @LTR
	
	--end
			
GO
/****** Object:  StoredProcedure [dbo].[PDX_KazLink_Check] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[PDX_KazLink_Check]
	@DocID varchar(128),
	@Mess varchar(1024) = null out	
as


declare @UFT2 varchar(1024),
		@UFT5 varchar(1024),
		@Currency varchar(12),
		@ExtDocID varchar(128),
		@UFT2_1 varchar(1024),
		@UFT5_1 varchar(1024),
		@UFD datetime,
		@Currency_1 varchar(12),
		@ClassDoc varchar(128),
		@Cnt int,	
		@Ex3 char(1),
		@Year int

if isnull(@DocID,'') = ''
begin
	select @Mess = '<font color=red>Ошибка!</font> Не указан исходный документ. Для устранения ошибки обратитесь к администратору СЭД.' 
	goto OK
end

select @UFT2 = UserFieldText2,
		@UFT5 = UserFieldText5,
		@Currency = Currency,
		@ClassDoc = ClassDoc,
		@Year = YEAR(DateCreation)
from dbo.Docs
where DocID = @DocID

If @ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_ORDPAY')
	--or @ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_BUDG')
begin
	
	if @Year <= 2015
	begin
		select 
			@Ex3 = e3
		from dbo.PDX_pay_Items
		where code = dbo.PDX_SubstringReturn(@UFT5, CHARINDEX('<',@UFT5), charindex('>',@UFT5) )
	end
	else
	begin
		select 
			@Ex3 = e3
		from dbo.PDX_pay_Items2016
		where code = dbo.PDX_SubstringReturn(@UFT5, CHARINDEX('<',@UFT5), charindex('>',@UFT5) )
	end
	
	if ISNULL(@Ex3,'') <> '1' --проверка нужна , если призак <> 1
	begin

		select @Cnt = 0 
		select @Cnt = count(*) from dbo.Comments
		where DocID = @DocID
		and CommentType = 'LINK'
		and RIK_CommentType in (dbo.PDX_CLSGet('RIK_CategoryName_KAZ_PLNPAY'),
								dbo.PDX_CLSGet('RIK_CategoryName_KAZ_CORPAY'))
								
		If @Cnt = 0 
		begin
			select @Mess = '<font color=red>Ошибка!</font> В данном документе должна быть обязательная ссылка на Плановую или Корректирующую заявку.' 
			goto OK
		end
		else if @Cnt > 1
		begin
			select @Mess = '<font color=red>Ошибка!</font> В данном документе может быть только одна обязательная ссылка на Плановую или Корректирующую заявку.'
			goto OK
		end

		select @ExtDocID = Subject
		from dbo.Comments
		where DocID = @DocID
		and CommentType = 'LINK'
		and RIK_CommentType in (dbo.PDX_CLSGet('RIK_CategoryName_KAZ_PLNPAY'),
								dbo.PDX_CLSGet('RIK_CategoryName_KAZ_CORPAY'))


		select @UFT2_1 = case ClassDoc when dbo.PDX_CLSGet('RIK_CategoryName_KAZ_CORPAY') then UserFieldText3 else UserFieldText2 end,
				@UFT5_1 = case ClassDoc when dbo.PDX_CLSGet('RIK_CategoryName_KAZ_CORPAY') then UserFieldText7 else UserFieldText5 end,
				@UFD = case ClassDoc when dbo.PDX_CLSGet('RIK_CategoryName_KAZ_CORPAY') then UserFieldDate3 else UserFieldDate1 end,
				@Currency_1 = Currency
		from dbo.Docs
		where DocID = @ExtDocID


		select @UFT5 = case when @UFT5 like '%<%>%' then dbo.PDX_SubstringReturn(@UFT5, charindex('<',@UFT5), charindex('>', @UFT5)) else @UFT5 end
		select @UFT5_1 = case when @UFT5_1 like '%<%>%' then dbo.PDX_SubstringReturn(@UFT5_1, charindex('<',@UFT5_1), charindex('>', @UFT5_1)) else @UFT5_1 end


		If @UFT2 <> @UFT2_1 or @UFT5 <> @UFT5_1 or @Currency <> @Currency_1
		begin
			select @Mess = '<font color=red>Ошибка!</font> ЦФО, статья расходов и валюта в ЗнО(текущем док-те) и в обязательной ссылке (на ПЗ/КЗ) должны совпадать.' 
			goto OK
		end
		
		If not (MONTH(@UFD) = MONTH(getdate()) and YEAR(@UFD) = YEAR(getdate()))
		begin
			select @Mess = '<font color=red>Ошибка!</font> Дата корректирующей или плановой заявки должна относиться к текущему месяцу.'
			goto OK
		end 
		
	end
end
	

OK:
	

select @Mess as Err











GO
/****** Object:  StoredProcedure [dbo].[PDX_KazLink2_Check] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE proc [dbo].[PDX_KazLink2_Check]
	@DocID varchar(128),
	@Mess varchar(1024) = null out	
as


declare @UFT2 varchar(1024),
		@UFT5 varchar(1024),
		@Currency varchar(12),
		@ExtDocID varchar(128),
		@UFT2_1 varchar(1024),
		@UFT5_1 varchar(1024),
		@UFD datetime,
		@Currency_1 varchar(12),
		@ClassDoc varchar(128),
		@Cnt int,	
		@Ex3 char(1),
		@Ex1 char(1),
		@Year int,
		@Cls_Pln varchar(128),
		@Cls_Cor varchar(128),
		@Cls_PTbl varchar(128),
		@RIK_CommentType varchar(128),
		@DateActivation datetime,
		@UFT7 varchar(4),
		@LinkDocIDInt int

if isnull(@DocID,'') = ''
begin
	select @Mess = '<font color=red>Ошибка!</font> Не указан исходный документ. Для устранения ошибки обратитесь к администратору СЭД.' 
	goto OK
end

set @Cls_Pln = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_PLNPAY')
set @Cls_Cor = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_CORPAY')
set @Cls_PTbl = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_PLNTBL')
								
select @UFT2 = UserFieldText2,
		@UFT5 = UserFieldText5,
		@Currency = Currency,
		@ClassDoc = ClassDoc,
		@Year = YEAR(DateCreation),
		@DateActivation = DateActivation
from dbo.Docs
where DocID = @DocID

If @ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_ORDPAY')
	--or @ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_BUDG')
begin
	
	if @Year <= 2015
	begin
		select 
			@Ex3 = e3,
			@Ex1 = e1
		from dbo.PDX_pay_Items
		where code = dbo.PDX_SubstringReturn(@UFT5, CHARINDEX('<',@UFT5), charindex('>',@UFT5) )
	end
	else
	begin
		select 
			@Ex3 = e3,
			@Ex1 = e1
		from dbo.PDX_pay_Items2016
		where code = dbo.PDX_SubstringReturn(@UFT5, CHARINDEX('<',@UFT5), charindex('>',@UFT5) )
	end
	
	if ISNULL(@Ex3,'') <> '1' --проверка нужна , если призак <> 1
	begin

		select @Cnt = 0 
		select @Cnt = count(*) from dbo.Comments
		where DocID = @DocID
		and CommentType = 'LINK'
		and RIK_CommentType in (@Cls_Pln,
								@Cls_Cor,
								@Cls_PTbl)
								
		If @Cnt = 0 
		begin
			select @Mess = '<font color=red>Ошибка!</font> В данном документе должна быть обязательная ссылка на Плановую, Корректирующую заявку или Плановый бюджет.' 
			goto OK
		end
		else if @Cnt > 1
		begin
			select @Mess = '<font color=red>Ошибка!</font> В данном документе может быть только одна обязательная ссылка на Плановую или Корректирующую заявку.'
			goto OK
		end

		select 
			@ExtDocID = Subject,
			@RIK_CommentType = RIK_CommentType
		from dbo.Comments
		where DocID = @DocID
		and CommentType = 'LINK'
		and RIK_CommentType in (@Cls_Pln,
								@Cls_Cor,
								@Cls_PTbl)


		select @UFT2_1 = case ClassDoc when @Cls_Cor then UserFieldText3 else UserFieldText2 end,
				@UFT5_1 = case ClassDoc when @Cls_Cor then UserFieldText7 else UserFieldText5 end,
				@UFD = case ClassDoc when @Cls_Cor then UserFieldDate3 else UserFieldDate1 end,
				@Currency_1 = Currency,
				@UFT7 = case ClassDoc when @Cls_PTbl then UserFieldText7 else '' end,
				@LinkDocIDInt = DocIDInt
		from dbo.Docs
		where DocID = @ExtDocID


		select @UFT5 = case when @UFT5 like '%<%>%' then dbo.PDX_SubstringReturn(@UFT5, charindex('<',@UFT5), charindex('>', @UFT5)) else @UFT5 end
		select @UFT5_1 = case when @UFT5_1 like '%<%>%' then dbo.PDX_SubstringReturn(@UFT5_1, charindex('<',@UFT5_1), charindex('>', @UFT5_1)) else @UFT5_1 end
								
		If @RIK_CommentType = @Cls_Cor
		begin	
	
			if  (
				(@Ex1 = '0'
				and year(@DateActivation) = YEAR(@UFD) and YEAR(@DateActivation)=YEAR(getdate())
				and MONTH(@DateActivation) = MONTH(@UFD) and MONTH(@DateActivation)=MONTH(getdate())
				)
				or
				(@Ex1 = '2'
				and year(@DateActivation) = YEAR(@UFD) and YEAR(@DateActivation)=YEAR(getdate())
				)
				or
				(@Ex1 = '1')
				)
				and @UFT5 = @UFT5_1 and @Currency = @Currency_1
				and @UFT2 = @UFT2_1
			begin
				print 'OK'
			end
			else
			begin
				if @Ex1 = '0' set @Mess = '<font color=red>Ошибка!</font> ЦФО, статья расходов и валюта в ЗнО(текущем док-те) и в обязательной ссылке КЗ должны совпадать. Рег. даты обоих документов должны быть из текущего месяца.' 
				else if @Ex1 = '2' set @Mess = '<font color=red>Ошибка!</font> ЦФО, статья расходов и валюта в ЗнО(текущем док-те) и в обязательной ссылке КЗ должны совпадать. Рег. даты обоих документов должны быть из текущего года.' 
				else if @Ex1 = '1' set @Mess = '<font color=red>Ошибка!</font> ЦФО, статья расходов и валюта в ЗнО(текущем док-те) и в обязательной ссылке КЗ должны совпадать.' 
				goto OK
			end
		end
		
		If @RIK_CommentType = @Cls_Pln
		begin			
			if  (
				(@Ex1 = '0'
				and year(@DateActivation) = YEAR(@UFD) and YEAR(@DateActivation)=YEAR(getdate())
				and MONTH(@DateActivation) = MONTH(@UFD) and MONTH(@DateActivation)=MONTH(getdate())
				)
				or
				(@Ex1 = '2'
				and year(@DateActivation) = YEAR(@UFD) and YEAR(@DateActivation)=YEAR(getdate())
				)
				or
				(@Ex1 = '1')
				)
				and @UFT5 = @UFT5_1 and @Currency = @Currency_1
				and @UFT2 = @UFT2_1
			begin
				print 'OK'
			end
			else
			begin
				if @Ex1 = '0' set @Mess = '<font color=red>Ошибка!</font> ЦФО, статья расходов и валюта в ЗнО(текущем док-те) и в обязательной ссылке ПЗ должны совпадать. Рег. даты ЗнО и Плановая дата оплаты ПЗ должны быть из текущего месяца.' 
				else if @Ex1 = '2' set @Mess = '<font color=red>Ошибка!</font> ЦФО, статья расходов и валюта в ЗнО(текущем док-те) и в обязательной ссылке ПЗ должны совпадать. Рег. даты ЗнО и Плановая дата оплаты ПЗ должны быть из текущего года.' 
				else if @Ex1 = '1' set @Mess = '<font color=red>Ошибка!</font> ЦФО, статья расходов и валюта в ЗнО(текущем док-те) и в обязательной ссылке ПЗ должны совпадать.' 
				goto OK
			end
		end

		If @RIK_CommentType = @Cls_PTbl
		begin			
			if  (
				(@Ex1 = '0'
				and @UFT7 = cast(YEAR(GETDATE()) as varchar(4))
				and YEAR(@DateActivation)=YEAR(getdate())
				and MONTH(@DateActivation)=MONTH(getdate())
				)
				or
				(@Ex1 = '2'
				and @UFT7 = cast(YEAR(GETDATE()) as varchar(4))
				)
				or
				(@Ex1 = '1')
				)
				and @Currency = @Currency_1
				and @UFT2 = @UFT2_1
				
				and exists (select top 1 1 from dbo.DocsPLNTBL P
							where P.DocIDInt = @LinkDocIDInt
							and P.Item like '%<' + @UFT5 + '>%'
							and (
								(@Ex1 = '1'
								and isnull(case MONTH(getdate())
										when 1 then P.Jan
										when 2 then P.Feb
										when 3 then P.Mar
										when 4 then P.Apr
										when 5 then P.May
										when 6 then P.Jun
										when 7 then P.Jul
										when 8 then P.Aug
										when 9 then P.Sep
										when 10 then P.Oct
										when 11 then P.Nov
										when 12 then P.Dec
									end,0) > 0
								)
								or
								(@Ex1 <> '1')
								)
							)
				
			begin
				print 'OK'
			end
			else
			begin
				if @Ex1 = '0' set @Mess = '<font color=red>Ошибка!</font> ЦФО, статья расходов и валюта в ЗнО(текущем док-те) и в обязательной ссылке ПБ должны совпадать. Рег. дата ЗнО должна быть из текущего месяца и соотвествовать году плана в картчоке ПБ.' 
				else if @Ex1 = '2' set @Mess = '<font color=red>Ошибка!</font> ЦФО, статья расходов и валюта в ЗнО(текущем док-те) и в обязательной ссылке ПБ должны совпадать. Год плана ПБ должен быть равен текущему году.' 
				else if @Ex1 = '1' set @Mess = '<font color=red>Ошибка!</font> ЦФО, статья расходов и валюта в ЗнО(текущем док-те) и в обязательной ссылке ПБ должны совпадать.' 
				goto OK
			end
		end

		
	end
end
	

OK:

set @Mess = ISNULL(@Mess,'')	

select @Mess as Err












GO
/****** Object:  StoredProcedure [dbo].[PDX_kazORD_Aprove] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_kazORD_Aprove]
	@UserID varchar(128),
	--@Date datetime,
	@DocID varchar(128),
	@RoleID varchar(128)
	
as
	declare 
	@Date datetime, @UserName varchar(128)

	set @Date = GETDATE()
	select 
		@UserName = Name
	from dbo.Users
	where UserID = @UserID
	
	set @RoleID = ltrim(ISNULL(@RoleID,''))
	If @RoleID <> ''
	begin
		set @RoleID = ' / ' + dbo.User_PaydoxLogin(@RoleID)
	end
	
	update D
		set StatusDevelopment='4',
		DateApproved = @Date,
		NameApproved=D.NameAproval,
		ListToReconcile = ListToReconcile + 
						  case dbo.PDX_CompareReconcilationList(ListToReconcile, ListReconciled) 
							when 1 then '' 
							else '(#$)'
						  end
	from dbo.Docs D 
	where D.DocID = @DocID
	
	delete C from dbo.Comments C
	where C.DocID = @DocID
	and C.CommentType = 'VISA'
	and C.SpecialInfo = 'VISAWAITING'
	
	insert into Comments	
			(UserID,
			UserName,
			ContactUserName,
			ContactUserID,
			PartnerName,
			DocID,
			DateCreation,
			DateEvent,
			DateEventEnd,
			Address,
			Subject,
			Comment,
			CommentType,
			SpecialInfo,
			FileName,
			--KeyField,
			PartnerID,
			Version,
			GUID,
			GUIDPartner,
			GUIDUser,
			GUIDDoc,
			Amount,
			FileNameOriginal,
			RIK_CommentType)
		values(
			@UserID, -- UserID,
			@UserName,--UserName,
			null,--ContactUserName,
			null,--ContactUserID,
			null,--PartnerName,
			@DocID,--DocID,
			getdate(),--DateCreation,
			null,--DateEvent,
			null,--DateEventEnd,
			null,--Address,
			null,--Subject,
			'Завершено Автоматически на дату ' + CONVERT(varchar(100), @Date, 104) + @RoleID,--Comment,
			'APROVAL',--CommentType,
			'',-- SpecialInfo,
			null,--FileName,
			--KeyField,
			null,--PartnerID,
			null,--Version,
			newid(),--GUID,
			null,--GUIDPartner,
			null,--GUIDUser,
			null,--GUIDDoc,
			null,--Amount,
			null,--FileNameOriginal,
			null--RIK_CommentType
			)
		
	select '' as res	

GO
/****** Object:  StoredProcedure [dbo].[PDX_KAZORDn_Find] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*drop proc [dbo].[PDX_KAZORDn_Find] 
go*/
CREATE proc [dbo].[PDX_KAZORDn_Find] 
	@DF datetime,
	@DT datetime,
	@BE varchar(1024),
	@CFO varchar(1024),
	@ITM varchar(1024),
	@PN varchar(1024),
	@UserID varchar(16)
as

set nocount on

--set @UserID = 'OsipovAG'
	declare @ClassName varchar(128)
	
	select @ClassName = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_ORDPAY')
	
	set @BE = ISNULL(@BE,'')
	set @CFO = ISNULL(@CFO,'')
	set @ITM = ISNULL(@ITM,'')
	set @PN = ISNULL(@PN,'')
	
	select
		@CFO = case when @CFO like '%<%>%'
					then '<' + dbo.PDX_SubstringReturn(@CFO,CHARINDEX('<', @CFO), CHARINDEX('>', @CFO)) + '>'
					else @CFO
				end
	
	;with KAZ as (
	select
		D.UserFieldDate3, --Рег. дата
		D.DocID, --Рег. номер
		D.UserFieldDate1, --Плановая дата оплаты
		D.UserFieldText7, --Наличный расчет
		D.Currency, --Валюта
		D.UserFieldText8, --Бизнес единица
		D.NameAproval, --Фин. Менеджер
		D.UserFieldText2, --ЦФО
		D.PartnerName, --Отправитель\Получатель
		D.UserFieldText4, --Объект
		D.UserFieldText5, --Статья расходов
		D.Name, --Назначение
		D.AmountDoc, --Сумма
		D.DocIDParent, --Оплата по договору №
		D.DocIDPrevious, --№ договора с Заказчиком
		D.UserFieldText6, --Счет
		D.Description, --Основание
		D.UserFieldMoney1, --Возникновение обязательств
		D.NameCreation, --Заявитель
		D.UserFieldText1, --Наименование листа согласования
		D.ListToReconcile, --Лист согласования
		D.Correspondent, --Список рассылки
		D.ListToEdit, --Список имеющих право редактирования д-та
		D.DocIDInt,
		D.UserFieldText3, 
		
		D.IsActive,
		D.ClassDoc,
		D.StatusCompletion,
		D.StatusDevelopment,
		D.StatusPayment,
		D.StatusArchiv,
		D.StatusDelivery,
		--D.ListToReconcile,
		D.ListReconciled,
		D.NameApproved,
		D.ListToView,
		--D.NameAproval,
		--D.Correspondent,
		D.NameResponsible,
		D.NameControl,
		D.LocationPath,
		D.DateCompleted,
		D.DateCompletion,		
		D.DateSigned,
		D.Resolution,
		D.DateApproved,
		D.TypeDoc,
		D.DateCreation
	from dbo.Docs D
	where D.ClassDoc = @ClassName
		and D.IsActive = 'N'
		and isnull(D.StatusCompletion,'') <> '0'
		and D.DateCreation between @DF and @DT
		and D.UserFieldText2 like '%' + @CFO + '%'
		and (D.UserFieldText8 = @BE or @BE = '')
		and D.UserFieldText5 like '%' + @ITM + '%'
		and D.PartnerName like '%' + @PN + '%'
		and D.NameCreation like '%<' + @UserID + '>%'
		)
		
	select
		1 as OI,
		D.UserFieldDate3, --Рег. дата
		D.Currency, --Валюта
		D.DocID, --Рег. номер
		D.UserFieldDate1, --Плановая дата оплаты
		D.UserFieldText7, --Наличный расчет
		D.UserFieldText8, --Бизнес единица
		D.NameAproval, --Фин. Менеджер
		D.UserFieldText2, --ЦФО
		D.PartnerName, --Отправитель\Получатель
		D.UserFieldText4, --Объект
		D.UserFieldText5, --Статья расходов
		D.Name, --Назначение
		D.AmountDoc, --Сумма
		D.DocIDParent, --Оплата по договору №
		D.DocIDPrevious, --№ договора с Заказчиком
		D.UserFieldText6, --Счет
		D.Description, --Основание
		D.UserFieldMoney1, --Возникновение обязательств
		D.NameCreation, --Заявитель
		D.UserFieldText1, --Наименование листа согласования
		D.ListToReconcile, --Лист согласования
		D.Correspondent, --Список рассылки
		D.ListToEdit, --Список имеющих право редактирования д-та
		D.DocIDInt,
		D.UserFieldText3, 
		
		D.IsActive,
		D.ClassDoc,
		D.StatusCompletion,
		D.StatusDevelopment,
		D.StatusPayment,
		D.StatusArchiv,
		D.StatusDelivery,
		--D.ListToReconcile,
		D.ListReconciled,
		D.NameApproved,
		D.ListToView,
		--D.NameAproval,
		--D.Correspondent,
		D.NameResponsible,
		D.NameControl,
		D.LocationPath,
		D.DateCompleted,
		D.DateCompletion,		
		D.DateSigned,
		D.Resolution,
		D.DateApproved,
		D.TypeDoc,
		D.DateCreation
	from KAZ D	
	
	order by d.PartnerName, d.UserFieldText5, d.UserFieldText8, d.UserFieldText2
	




GO
/****** Object:  StoredProcedure [dbo].[PDX_KAZORDn_Save] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*drop proc [dbo].[PDX_KAZORDn_Save] 
go*/
CREATE proc [dbo].[PDX_KAZORDn_Save] 
	@DocIDInt int,
	@Name varchar(128),
	@Obj varchar(1024),
	@ITM varchar(1024),
	@Curr varchar(32),
	@Am varchar(64),
	@UserID varchar(20)
as

declare @Amount money, @Err varchar(4000), @NCr varchar(96),
@ClassDoc varchar(128), @isActive char(1), @DocID varchar(128)
set @Err = ''

set @NCr = [dbo].[User_PaydoxLogin](@UserID)
set @Am = replace(REPLACE(@Am,' ',''),',','.')

If @Am is null
begin
	set @Amount = null
end
else
begin
	if ISNUMERIC(@Am) = 1
	begin
		set @Amount = CAST(@Am as money)
	end
	else
	begin
		set @Err = case @Err when '' then '' else '<br>' end + 'Указана некорректая сумма'
		goto NXT
	end
end

select 
	@ClassDoc = ClassDoc,
	@isActive = IsActive,
	@DocID = DocID
from dbo.Docs where DocIDInt = @DocIDInt

if dbo.PDX_CLSConstGet(@ClassDoc) <> 'RIK_CategoryName_KAZ_ORDPAY'
begin
	set @Err = case @Err when '' then '' else '<br>' end + 'Документ неправильной категории'
	goto NXT
end

if @isActive = 'Y'
begin
	set @Err = case @Err when '' then '' else '<br>' end + 'Документ нельзя корректировать, т.к. он активен'
	goto NXT
end

update dbo.Docs
	set 
		Currency = @Curr,
		UserFieldText4 = @Obj,
		UserFieldText5=@ITM,
		AmountDoc = case when @Amount IS null then AmountDoc else @Amount end,
		Name = @Name,
		NameLastModification = @NCr,
		DateLastModification = GETDATE()
where DocIDInt = @DocIDInt

if not @Amount is null
begin
	update dbo.PDXDocDetails
		set Am1 = @Amount,
		DLM = GETDATE(),
		NLM = @NCr
	where DocID = @DocID
	 
end

NXT:
select @Err as Err, @DocID as DocID
GO
/****** Object:  StoredProcedure [dbo].[PDX_KAZPLNn_Find] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*drop proc [dbo].[PDX_KAZPLNn_Find] 
go*/
CREATE proc [dbo].[PDX_KAZPLNn_Find] 
	@DF datetime,
	@DT datetime,
	@BE varchar(1024),
	@CFO varchar(1024),
	@ITM varchar(1024),
	@PN varchar(1024),
	@UserID varchar(16)
as

set nocount on

--set @UserID = 'OsipovAG'
	declare @ClassName varchar(128)
	
	select @ClassName = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_PLNPAY')
	
	set @BE = ISNULL(@BE,'')
	set @CFO = ISNULL(@CFO,'')
	set @ITM = ISNULL(@ITM,'')
	set @PN = ISNULL(@PN,'')
	
	select
		@CFO = case when @CFO like '%<%>%'
					then '<' + dbo.PDX_SubstringReturn(@CFO,CHARINDEX('<', @CFO), CHARINDEX('>', @CFO)) + '>'
					else @CFO
				end
	
	;with KAZ as (
	select
		D.UserFieldDate3, --Рег. дата
		D.DocID, --Рег. номер
		D.UserFieldDate1, --Плановая дата оплаты
		D.UserFieldText7, --Наличный расчет
		D.Currency, --Валюта
		D.UserFieldText8, --Бизнес единица
		D.NameAproval, --Фин. Менеджер
		D.UserFieldText2, --ЦФО
		D.PartnerName, --Отправитель\Получатель
		D.UserFieldText4, --Объект
		D.UserFieldText5, --Статья расходов
		D.Name, --Назначение
		D.AmountDoc, --Сумма
		D.DocIDParent, --Оплата по договору №
		D.DocIDPrevious, --№ договора с Заказчиком
		D.UserFieldText6, --Счет
		D.Description, --Основание
		D.UserFieldMoney1, --Возникновение обязательств
		D.NameCreation, --Заявитель
		D.UserFieldText1, --Наименование листа согласования
		D.ListToReconcile, --Лист согласования
		D.Correspondent, --Список рассылки
		D.ListToEdit, --Список имеющих право редактирования д-та
		P.FinStatus,
		D.DocIDInt,
		
		D.IsActive,
		D.ClassDoc,
		D.StatusCompletion,
		D.StatusDevelopment,
		D.StatusPayment,
		D.StatusArchiv,
		D.StatusDelivery,
		--D.ListToReconcile,
		D.ListReconciled,
		D.NameApproved,
		D.ListToView,
		--D.NameAproval,
		--D.Correspondent,
		D.NameResponsible,
		D.NameControl,
		D.LocationPath,
		D.DateCompleted,
		D.DateCompletion,		
		D.DateSigned,
		D.Resolution,
		D.DateApproved,
		D.TypeDoc
	from dbo.Docs D
	left join [dbo].[PayStatusDetails] P on P.DocIDInt = D.DocIDInt
	where D.ClassDoc = @ClassName
		and D.IsActive = 'N'
		and isnull(D.StatusCompletion,'') <> '0'
		and D.UserFieldDate1 between @DF and @DT
		and D.UserFieldText2 like '%' + @CFO + '%'
		and (D.UserFieldText8 = @BE or @BE = '')
		and D.UserFieldText5 like '%' + @ITM + '%'
		and D.PartnerName like '%' + @PN + '%'
		and D.NameCreation like '%<' + @UserID + '>%'
		)
		
	select
		1 as OI,
		D.UserFieldDate3, --Рег. дата
		D.Currency, --Валюта
		D.DocID, --Рег. номер
		D.UserFieldDate1, --Плановая дата оплаты
		D.UserFieldText7, --Наличный расчет
		D.UserFieldText8, --Бизнес единица
		D.NameAproval, --Фин. Менеджер
		D.UserFieldText2, --ЦФО
		D.PartnerName, --Отправитель\Получатель
		D.UserFieldText4, --Объект
		D.UserFieldText5, --Статья расходов
		D.Name, --Назначение
		D.AmountDoc, --Сумма
		D.DocIDParent, --Оплата по договору №
		D.DocIDPrevious, --№ договора с Заказчиком
		D.UserFieldText6, --Счет
		D.Description, --Основание
		D.UserFieldMoney1, --Возникновение обязательств
		D.NameCreation, --Заявитель
		D.UserFieldText1, --Наименование листа согласования
		D.ListToReconcile, --Лист согласования
		D.Correspondent, --Список рассылки
		D.ListToEdit, --Список имеющих право редактирования д-та
		D.FinStatus,
		D.DocIDInt,
		
		D.IsActive,
		D.ClassDoc,
		D.StatusCompletion,
		D.StatusDevelopment,
		D.StatusPayment,
		D.StatusArchiv,
		D.StatusDelivery,
		--D.ListToReconcile,
		D.ListReconciled,
		D.NameApproved,
		D.ListToView,
		--D.NameAproval,
		--D.Correspondent,
		D.NameResponsible,
		D.NameControl,
		D.LocationPath,
		D.DateCompleted,
		D.DateCompletion,		
		D.DateSigned,
		D.Resolution,
		D.DateApproved,
		D.TypeDoc
	from KAZ D	
	
	order by d.PartnerName, d.UserFieldText5, d.UserFieldText8, d.UserFieldText2
	/*union
	
	select
		2 as OI,
		null,--D.UserFieldDate3, --Рег. дата
		D.Currency, --Валюта
		null,--D.DocID, --Рег. номер
		null,--D.UserFieldDate1, --Плановая дата оплаты
		null,--D.UserFieldText7, --Наличный расчет
		null,--D.UserFieldText8, --Бизнес единица
		null,--D.NameAproval, --Фин. Менеджер
		null,--D.UserFieldText2, --ЦФО
		null,--D.PartnerName, --Отправитель\Получатель
		null,--D.UserFieldText4, --Объект
		null,--D.UserFieldText5, --Статья расходов
		null,--D.Name, --Назначение
		sum(D.AmountDoc) as AmountDoc, --Сумма
		null,--D.DocIDParent, --Оплата по договору №
		null,--D.DocIDPrevious, --№ договора с Заказчиком
		null,--D.UserFieldText6, --Счет
		null,--D.Description, --Основание
		null,--D.UserFieldMoney1, --Возникновение обязательств
		null,--D.NameCreation, --Заявитель
		null,--D.UserFieldText1, --Наименование листа согласования
		null,--D.ListToReconcile, --Лист согласования
		null,--D.Correspondent, --Список рассылки
		null,--D.ListToEdit, --Список имеющих право редактирования д-та
		null,--D.FinStatus,
		null,--D.DocIDInt,
		
		null,--D.IsActive,
		null,--D.ClassDoc,
		null,--D.StatusCompletion,
		null,--D.StatusDevelopment,
		null,--D.StatusPayment,
		null,--D.StatusArchiv,
		null,--D.StatusDelivery,
		--null,--D.ListToReconcile,
		null,--D.ListReconciled,
		null,--D.NameApproved,
		null,--D.ListToView,
		--null,--D.NameAproval,
		--null,--D.Correspondent,
		null,--D.NameResponsible,
		null,--D.NameControl,
		null,--D.LocationPath,
		null,--D.DateCompleted,
		null,--D.DateCompletion,		
		null,--D.DateSigned,
		null,--D.Resolution,
		null,--D.DateApproved,
		null--D.TypeDoc
	from KAZ D
	group by D.Currency
	
	order by 1,2,3*/





GO
/****** Object:  StoredProcedure [dbo].[PDX_KAZPLNn_Save] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*drop proc [dbo].[PDX_KAZPLNn_Save] 
go*/
CREATE proc [dbo].[PDX_KAZPLNn_Save] 
	@DocIDInt int,
	@Name varchar(128),
	@Obj varchar(1024),
	@ITM varchar(1024),
	@Curr varchar(32),
	@Am varchar(64),
	@UserID varchar(20)
as

declare @Amount money, @Err varchar(4000), @NCr varchar(96),
@ClassDoc varchar(128), @isActive char(1), @DocID varchar(128)
set @Err = ''

set @NCr = [dbo].[User_PaydoxLogin](@UserID)
set @Am = replace(REPLACE(@Am,' ',''),',','.')

if ISNUMERIC(@Am) = 1
begin
	set @Amount = CAST(@Am as money)
end
else
begin
	set @Err = case @Err when '' then '' else '<br>' end + 'Указана некорректая сумма'
	goto NXT
end

select 
	@ClassDoc = ClassDoc,
	@isActive = IsActive,
	@DocID = DocID
from dbo.Docs where DocIDInt = @DocIDInt

if dbo.PDX_CLSConstGet(@ClassDoc) <> 'RIK_CategoryName_KAZ_PLNPAY'
begin
	set @Err = case @Err when '' then '' else '<br>' end + 'Документ неправильной категории'
	goto NXT
end

if @isActive = 'Y'
begin
	set @Err = case @Err when '' then '' else '<br>' end + 'Документ нельзя корректировать, т.к. он активен'
	goto NXT
end

update dbo.Docs
	set 
		Currency = @Curr,
		UserFieldText4 = @Obj,
		UserFieldText5=@ITM,
		AmountDoc = @Amount,
		Name = @Name,
		NameLastModification = @NCr,
		DateLastModification = GETDATE()
where DocIDInt = @DocIDInt

NXT:
select @Err as Err, @DocID as DocID
GO
/****** Object:  StoredProcedure [dbo].[PDX_kazPLNPAY_Aprove] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[PDX_kazPLNPAY_Aprove]
	@UserID varchar(128),
	@NameAproval varchar(128),
	@Date datetime,
	@Flg bit = 0
	
as
	declare 
	@Res int,
	@StopRefuseFlag bit,
	@ClassDoc varchar(128)

	create table #Apptmp (DocID varchar(128), Name varchar(256),
		UFT8 varchar(1024), UFT2 varchar(1024), AmountDoc money, Currency varchar(64))

	select @NameAproval = dbo.PDX_SubstringReturn(@NameAproval, CHARINDEX('<',@NameAproval), charindex('>',@NameAproval))
	select @Res = @@error if @Res <> 0 goto Err
	
	select @StopRefuseFlag = StopRefuseFlag,
		@ClassDoc = DocType
	from dbo.PDXDocTypesConst
	where ConstName = 'RIK_CategoryName_KAZ_PLNPAY'
	select @Res = @@error if @Res <> 0 goto Err

	insert into #Apptmp
		(DocID, Name, UFT2, UFT8, AmountDoc, Currency)
	SELECT 
		D.DocID, 
		D.Name,  D.Userfieldtext2, D.Userfieldtext8, D.AmountDoc, D.Currency
	FROM dbo.Docs AS D 
	WHERE D.ClassDoc = @ClassDoc
		AND CHARINDEX('<' + @NameAproval + '>', D.NameAproval) > 0 
		AND UPPER(ISNULL(D.IsActive, '')) = 'Y'
		AND NOT (ISNULL(D.StatusCompletion, '') IN ('1', '0')) 
		AND isnull(D.StatusDevelopment,'') <> '0'
		AND ltrim(rtrim(isnull(D.NameApproved,''))) = ''
		AND dbo.PDX_CompareReconcilationList(D.ListToReconcile, D.ListReconciled) = 1
		and dbo.PDX_fn_stopReconcilation (D.ListToReconcile, D.ListReconciled, @StopRefuseFlag) = 0
		and MONTH(D.UserFieldDate1) = MONTH(@Date)
		and year(D.UserFieldDate1) = year(@Date)
	select @Res = @@error if @Res <> 0 goto Err


	If @Flg = 1
	begin
		update D
		set StatusDevelopment='4',
			DateApproved = @Date,
			NameApproved=D.NameAproval,
			DateLastModification = GETDATE(),
			NameLastModification = @UserID
		from #Apptmp A
		inner join dbo.Docs D on D.DocID = A.DocID
		select @Res = @@error if @Res <> 0 goto Err
		
		insert into Comments	
			(UserID,
			UserName,
			ContactUserName,
			ContactUserID,
			PartnerName,
			DocID,
			DateCreation,
			DateEvent,
			DateEventEnd,
			Address,
			Subject,
			Comment,
			CommentType,
			SpecialInfo,
			FileName,
			--KeyField,
			PartnerID,
			Version,
			GUID,
			GUIDPartner,
			GUIDUser,
			GUIDDoc,
			Amount,
			FileNameOriginal,
			RIK_CommentType)
		select
			dbo.PDX_SubstringReturn(@UserID, charindex('<',@UserID), charindex('>', @UserID)), -- UserID,
			ltrim(rtrim(replace(replace(@UserID,dbo.PDX_SubstringReturn(@UserID, charindex('<',@UserID), charindex('>', @UserID)),''),'"',''))),--UserName,
			null,--ContactUserName,
			null,--ContactUserID,
			null,--PartnerName,
			DocID,--DocID,
			getdate(),--DateCreation,
			null,--DateEvent,
			null,--DateEventEnd,
			null,--Address,
			null,--Subject,
			'Завершено Автоматически на дату ' + CONVERT(varchar(100), @Date, 104),--Comment,
			'APROVAL',--CommentType,
			'',-- SpecialInfo,
			null,--FileName,
			--KeyField,
			null,--PartnerID,
			null,--Version,
			newid(),--GUID,
			null,--GUIDPartner,
			null,--GUIDUser,
			null,--GUIDDoc,
			null,--Amount,
			null,--FileNameOriginal,
			null--RIK_CommentType
		FROM #Apptmp
		select @Res = @@error if @Res <> 0 goto Err
	end
	
	select * from #Apptmp order by DocID
	select @Res = @@error if @Res <> 0 goto Err
		
	drop table #Apptmp
OK:

	return @Res
Err:
	return @Res


GO
/****** Object:  StoredProcedure [dbo].[PDX_KAZPLNTBL_ExtCheck] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
Create proc [dbo].[PDX_KAZPLNTBL_ExtCheck]
	@DocID varchar(128),
	@Mess varchar(1024) = null out
	
as
declare 
	@ClassDoc varchar(128),@DocIDInt int, @UFT7 varchar(1024), @Year int,@fld_UFT7 varchar(128),@TBLCat varchar(128), @Curr_Year int
	
	--select @Res = 0
	select @Mess = ''

	set @TBLCat = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_PLNTBL') 

	select
		@ClassDoc = ClassDoc,
		@DocIDInt = DocIDInt,
		@UFT7 = UserFieldText7,
		@Curr_Year=YEAR(GETDATE())
	from dbo.Docs 
	where DocID = ltrim(rtrim(isnull(@DocID,'')))
	

	If @ClassDoc = @TBLCat	 
	begin
	
		select @fld_UFT7 = RUSName
		from dbo.PDXUserSettingDocTypes
		where DocType = @TBLCat
			and FieldName = 'UserFieldText7'
		
		if not @UFT7 like '[0-9][0-9][0-9][0-9]'
		begin
			select @Mess = @Mess + 
				'<br><font color=red>ОШИБКА! </font> Некорректное значение в поле [' + @fld_UFT7 + ']' 	
		end
		else
		begin
			set @Year = CAST(@UFT7 as int)
			if @Year < @Curr_Year
			begin
			select @Mess = @Mess + 
				'<br><font color=red>ОШИБКА! </font> Укажите значение в поле [' + @fld_UFT7 + '] не меньше текущего года.' 	
			end
			if @Year > @Curr_Year + 5
			begin
			select @Mess = @Mess + 
				'<br><font color=red>ОШИБКА! </font> Укажите значение в поле [' + @fld_UFT7 + '] не больше, чем ' + CAST(@Curr_Year+5 as varchar(10)) + ' год.' 	
			end
		end
		
	
	
		if not exists(select top 1 1 from dbo.DocsPLNTBL where DocIDInt = @DocIDInt)
		begin
			select @Mess = @Mess + 
				'<br><font color=red>ОШИБКА! </font> В Заявке  должна быть указана хотя бы одна сумма (детальная строка).' 	
		end		
	End

	
	select @Mess = @Mess + case len(@Mess) when 0 then '' else '<br>' end

OK:

	select @Mess as 'res'



GO
/****** Object:  StoredProcedure [dbo].[PDX_ListToReconcile] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_ListToReconcile]
	@Field varchar(250),
	@Cls varchar(250),
	@ADoc varchar(250)
as
declare 
	@Result int
	
	declare @tbl table (Field1 varchar(1024), Field2 varchar(1024), OI int identity)
	
	insert into @tbl (Field1,Field2)
	select 
		case @Field
			when 'DOCLISTTORECONCILE'
				then Field2
			else Field1
		end,		
		case @Field
			when 'DOCLISTTORECONCILE'
				then Field1
			else Field2
		end		
	from dbo.UserDirValues 
	where UDKeyField = 34 
		and (Field3 like '%' + @Cls + '%' or isnull(Field3,'') = '') 
		and ((Field4 like '%' + @ADoc + '%' and @ADoc <> '') or isnull(Field4,'') = '') 
	order by case when isnull(Field3,'') = '' or isnull(Field2,'') like '%(#%)%' then 0 else 1 end,
	 Field1
	
	insert into @tbl(Field1, Field2) values ('','')
	
	if @Field = 'DOCLISTTORECONCILE'
	begin
		select Field1 as Field2, Field2 as Field1 from @tbl order by OI
	end
	else
	begin
		select Field1, Field2 from @tbl order by OI
	end
	
	return @Result
Err:
	
	return @Result

GO
/****** Object:  StoredProcedure [dbo].[PDX_ListToView] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
--формирование бумажного листа ознакомления
create proc [dbo].[PDX_ListToView]
	@DocID varchar(250)
as
declare 
	@Result int,
	@Pos1 int,
	@Curr varchar(1024),
	@ListToView varchar(4096),
	@ListToView1 varchar(4096)

	create table #tbl 
		(UserID varchar(128),
		UserName varchar(255),
		Flag int,
		DateCreation datetime)

	select @ListToView = ListToView,
			@ListToView1 = ListToView
	from dbo.Docs 
	where DocID = @DocID
	select @Result = @@error if @Result <> 0 goto Err


	
	while @ListToView1 like '%>%'
	begin 
		select @Pos1 = charindex('>',@ListToView1)
		select @Result = @@error if @Result <> 0 goto Err

		select @Curr = left(@ListToView1,@Pos1),
			@ListToView1 = right(@ListToView1,len(@ListToView1)-@Pos1)
		select @Result = @@error if @Result <> 0 goto Err

		insert into #tbl (UserName,UserID)
		values (ltrim(rtrim(replace(replace(replace(replace(replace(@Curr,char(13),''),char(10),''),'===Добавлены==================================================',''),';',''),'-',''))),
			dbo.PDX_SubstringReturn(@Curr,charindex('<',@Curr), charindex('>',@Curr)))		
		select @Result = @@error if @Result <> 0 goto Err
	end
	update #tbl
		set FLAG = case when @ListToView like '%<' + UserID + '>-%' then 1 else 0 end
	select @Result = @@error if @Result <> 0 goto Err


	select 
		isnull('"' + U.Name + '" <' + U.UserID + '>;',T.UserName+ ';') as UserName,
		isnull(C.Comment,'') as Comment,
		C.DateCreation,
		case C.UserID when 'Admin' then 2 else T.FLAG end as FLAG
	from #tbl T
	left join dbo.Users U on U.UserID = T.UserID
	left join dbo.Comments C on (T.UserID = C.UserID or (C.UserID = 'Admin' and C.Comment like '%<' + T.UserID + '>%'))
		and C.CommentType = 'VIEWED'
		and DocID = @DocID
	order by T.UserID,C.DateCreation
	select @Result = @@error if @Result <> 0 goto Err

	drop table #tbl
	return @Result
Err:
	
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_NameAprovalSet_Change] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE proc [dbo].[PDX_NameAprovalSet_Change]
	@ClassDoc varchar(128),
	@ActDoc varchar(64),
	@Projects varchar(1024),
	@Users varchar(1024),
	@ID uniqueidentifier,
	@NC varchar(128),
	@Act int, --1--ceate, 2-update,3 delete
	@Chk bit = 0
	
as
	declare  @Res int

	declare @ErrList varchar(1024), @ClsGr varchar(128)

	select @Res = 0,@ErrList = ''
	


	select
		@ClassDoc = ltrim(rtrim(isnull(@ClassDoc,''))),
		@ActDoc = ltrim(rtrim(isnull(@ActDoc,''))),
		@Users = ltrim(rtrim(isnull(@Users,''))),
		@NC  = ltrim(rtrim(isnull(@NC,'')))
	select @Res = @@error if @Res <> 0 goto Err

    set @ClsGr = dbo.PDX_CLSGrByNameGet(@ClassDoc)

/************************************
ПРОВЕРКИ ВВЕДЕННЫХ ЗНАЧЕНИЙ
*************************************/
If @ClassDoc = ''
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Укажите категорию'
	goto NXT
end

if @ClsGr <> dbo.PDX_CLSGrGet('RIK_CategoryName_ISHO_VNESH')
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Данные настройки допустимы только для Корреспонденции'
	goto NXT
end
/*
If @ActDoc = ''
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Укажите вид деятельности'
	goto NXT
end*/

If @Projects = ''
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Укажите проект'
	goto NXT
end

If @Users = ''
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Укажите пользователей'
	goto NXT
end

if exists(select 1 from dbo.NameAprovalSettings where ClassDoc = @ClassDoc	
	and ActDoc = @ActDoc and Projects = @Projects
	and ID <> isnull(@ID,'00000000-0000-0000-0000-000000000000'))
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Настройка для указанных Категории, Вида деят-ти  и Проекта уже существует'
	goto NXT
end	

/************************************/

NXT:

If @Chk = 0
begin --если это создание , то нужно генерить ошибкуесли она есть
	If @ErrList <> '' 
	begin
		RAISERROR (@ErrList, 16,1)
		goto Err
	end
end
else --если это проверка просто выводим сообщение, даже если оно пустое
begin
	select @ErrList as ErrList 
	select @Res = @@error if @Res <> 0 goto Err
end

IF @ErrList = '' and @Chk = 0
BEGIN
	if @Act = 2
	begin
		update dbo.NameAprovalSettings
			set 
				ClassDoc = @ClassDoc,
				ActDoc = @ActDoc,
				Projects = @Projects,
				Users = @Users,
				NLM = @NC,
				DLM = getdate()
		where ID = @ID
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 1
	begin
		insert into dbo.NameAprovalSettings
			(ClassDoc, ActDoc, Projects, Users, NLM, DLM)
		values 
			(@ClassDoc, @ActDoc, @Projects, @Users, @NC, getdate())
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 3
	begin
		delete from dbo.NameAprovalSettings where ID = @ID
		select @Res = @@error if @Res <> 0 goto Err
	end
END
	select @Res = @@error if @Res <> 0 goto Err

OK:

	return @Res
Err:
	return @Res




GO
/****** Object:  StoredProcedure [dbo].[PDX_NAZOO_Get] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[PDX_NAZOO_Get]
	@ClassDoc varchar(255),
	@ActDoc varchar(255)

as
	declare @strres varchar(4000),
		@Result int

	select @Result = 0

	--create table #tmp(UName varchar(255))
	select @strres = ''

	select @strres = Users 
	from dbo.NAZOOSettings 
	where (ActDoc = @ActDoc or ActDoc = '')
	and ClassDoc = @ClassDoc
	select @Result = @@error if @Result <> 0 goto Err

    select 
		dbo.User_PaydoxLoginByParam(U.UserID, U.Name) as Fld
    from dbo.Users U
    where @strres like '%<' + U.UserID + '>%'
    and U.StatusActive = '1'
    and U.DateExpirationSecurity >= GETDATE()
    and not U.Permitions like '%*%'

	/*select Uname as Fld from #tmp
	select @Result = @@error if @Result <> 0 goto Err*/

	return @Result
Err:
	--drop table #tmp

	return @Result



GO
/****** Object:  StoredProcedure [dbo].[PDX_NAZOOSet_Change] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[PDX_NAZOOSet_Change]
	@ClassDoc varchar(128),
	@ActDoc varchar(64),
	@Users varchar(1024),
	@ID uniqueidentifier,
	@NC varchar(128),
	@Act int, --1--ceate, 2-update,3 delete
	@Chk bit = 0
	
as
	declare  @Res int

	declare @ErrList varchar(1024), @ClsGr varchar(128)

	select @Res = 0,@ErrList = ''
	


	select
		@ClassDoc = ltrim(rtrim(isnull(@ClassDoc,''))),
		@ActDoc = ltrim(rtrim(isnull(@ActDoc,''))),
		@Users = ltrim(rtrim(isnull(@Users,''))),
		@NC  = ltrim(rtrim(isnull(@NC,'')))
	select @Res = @@error if @Res <> 0 goto Err

    set @ClsGr = dbo.PDX_CLSGrByNameGet(@ClassDoc)

/************************************
ПРОВЕРКИ ВВЕДЕННЫХ ЗНАЧЕНИЙ
*************************************/
If @ClassDoc = ''
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Укажите категорию'
	goto NXT
end

if @ClsGr <> dbo.PDX_CLSGrGet('RIK_CategoryName_OTHERS_ZOO')
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Данные настройки допустимы только для Заявок на открытое опубликование'
	goto NXT
end
/*
If @ActDoc = ''
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Укажите вид деятельности'
	goto NXT
end*/

If @Users = ''
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Укажите пользователей'
	goto NXT
end

if exists(select 1 from dbo.NAZOOSettings where ClassDoc = @ClassDoc	
	and ActDoc = @ActDoc 
	and ID <> isnull(@ID,'00000000-0000-0000-0000-000000000000'))
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Настройка для указанных Категории и Вида деят-ти  уже существует'
	goto NXT
end	

/************************************/

NXT:

If @Chk = 0
begin --если это создание , то нужно генерить ошибкуесли она есть
	If @ErrList <> '' 
	begin
		RAISERROR (@ErrList, 16,1)
		goto Err
	end
end
else --если это проверка просто выводим сообщение, даже если оно пустое
begin
	select @ErrList as ErrList 
	select @Res = @@error if @Res <> 0 goto Err
end

IF @ErrList = '' and @Chk = 0
BEGIN
	if @Act = 2
	begin
		update dbo.NAZOOSettings
			set 
				ClassDoc = @ClassDoc,
				ActDoc = @ActDoc,
				Users = @Users,
				NLM = @NC,
				DLM = getdate()
		where ID = @ID
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 1
	begin
		insert into dbo.NAZOOSettings
			(ClassDoc, ActDoc, Users, NLM, DLM)
		values 
			(@ClassDoc, @ActDoc, @Users, @NC, getdate())
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 3
	begin
		delete from dbo.NAZOOSettings where ID = @ID
		select @Res = @@error if @Res <> 0 goto Err
	end
END
	select @Res = @@error if @Res <> 0 goto Err

OK:

	return @Res
Err:
	return @Res





GO
/****** Object:  StoredProcedure [dbo].[PDX_NC_BasicParamGet] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_NC_BasicParamGet]
	@Activity varchar(255),
	@Department varchar(255),
	@ClassDoc varchar(255),
	@NFormat varchar(100),

	@VDCode varchar(50) out, --код из вида деят-ти КОД_ВД
	@OUCode varchar(50) out, --код организационной единицы КОД_ОЕ
	@DCCode varchar(50) out,  --делопроизводственный код КОД_Д
	@KPCode varchar(50) out,  --код подразделения КОД_П
	@ORDCode varchar(50) out,  --код ОРД
	@FKCode varchar(50) out --полный код подразделения
	
as

	declare @Result int
	select @Result = 0
	
	declare @strPart varchar(100)

	select @Activity = isnull(@Activity,'')
	select @Result = @@error if @Result <> 0 goto Err
	select @Department = isnull(@Department,'')
	select @Result = @@error if @Result <> 0 goto Err

	select @VDCode = '',
			@OUCode  = '',
			@DCCode = '',
			@KPCode = '',
			@ORDCode = '',
			@FKCode = ''
	select @Result = @@error if @Result <> 0 goto Err

	if @Activity <> '' 
	begin 
		--КОД_ВД берем из самого вида деят-ти
		set @VDCode = isnull(dbo.PDX_SubstringReturn(@Activity, charindex('<',@Activity), charindex('>',@Activity)),'')
		select @Result = @@error if @Result <> 0 goto Err
	end
	
	if @Department <> ''
	begin
		--КОД_Д берем из справочника подразделений
		select top 1 
			@DCCode = isnull(DocFlowCode,''),--DCCode,
			@KPCode = isnull(DepartmentCode,''),--PCode
			@FKCode = isnull(FullCode,'')
		from dbo.Departments 
		where Name = @Department or Name = @Department + '/'
		select @Result = @@error if @Result <> 0 goto Err
	end

	--КОД_ОЕ вычисляем на основе двух предыдущих кодов
	if @VDCode = ''
	begin
		set @OUCode = @DCCode
		select @Result = @@error if @Result <> 0 goto Err
	end
	else
	begin
		set @OUCode = @VDCode
		select @Result = @@error if @Result <> 0 goto Err
	end

	--префикс ОРД ищем в справочнике "Филиалы"
	If @NFormat like '%{ORD}%' 
	begin
		--определяем значение по которому в справочнике нужно вытащить префикс
		If @VDCode = '' --здесь подразумеваем, что вид деят-ти с пустым кодом
		begin --считаем что в таком случае в справочнике запись имеет ид (РИК) = названию ВД (РИК <>)
			set @strPart = ltrim(rtrim(replace(replace(@Activity,'<',''),'>','')))
		end
		--else if not exists (select 1 from dbo.UserDirValues with (nolock) where UDKeyField = 48 and Field1 = @VDCode)
		else if not exists (select 1 from dbo.PDXBranchSettings with (nolock) where Fld1 = @VDCode)
		begin --если не нашли данные по полному коду ВД, то ищем по первым двум буквам
			set @strPart = left(@VDCode,2)
		end
		else
		begin --по коду ВД в чистом виде
			set @strPart = @VDCode
		end
		select @Result = @@error if @Result <> 0 goto Err	

		--получаем префикс ОРД
		select 
			@ORDCode = isnull(Fld4,'')
		from dbo.PDXBranchSettings with (nolock)
		where Fld1 = @strPart
		select @Result = @@error if @Result <> 0 goto Err

/*		select 
			@ORDCode = Field6
		from dbo.UserDirValues with (nolock)
		where UDKeyField = 48 
			and Field1 = @strPart
		select @Result = @@error if @Result <> 0 goto Err
*/
	end

	--адаптация для БоГЭС
	select @VDCode = dbo.PDX_NC_Exceptions (@ClassDoc, @VDCode)
	select @Result = @@error if @Result <> 0 goto Err

	select @VDCode = isnull(@VDCode,''),
		@OUCode  = isnull(@OUCode,''),
		@DCCode = isnull(@DCCode,''),
		@KPCode = isnull(@KPCode,''),
		@ORDCode = isnull(@ORDCode,'')
	select @Result = @@error if @Result <> 0 goto Err

print '@VDCode: ' + @VDCode
print '@KPCode: ' + @KPCode
print '@DCCode: ' + @DCCode
print '@OUCode: ' + @OUCode
print '@ORDCode: ' + @ORDCode
print '@FKCode: ' + @FKCode


	return @Result
Err:
	
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_NC_CounterCalculate] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_NC_CounterCalculate]
	@ClassDoc varchar(255), --категория документа
	@strPart varchar(100), -- символы счетчика {Nx}
	@NFormat varchar(100), --формат номера
	@DocID varchar(128), --"почти" готовый номер документа
	@SetID uniqueidentifier, --ид категории в метаданных
	@ID_Type bit = 1, --признак, определяющий по какому из полей (DocID или DocIDAdd) будем рассчитывать номер
	@MaxCounter int out --счетчик
	
as

	declare @Result int
	select @Result = 0

	declare @tmp table (DocID varchar(128), Part varchar(128), CPart int)
	declare @ClassList table (ClassName varchar(255))
	declare @LPos int, @RPos int
	
	--определяем по родителю или категории определять будем счетчик
	if not @NFormat like '%{PAR}%' 
	begin
		--получаем список категорий , у которых общий счетчик
		insert into @ClassList
			(ClassName)
		select 
			T.DocType
		from dbo.PDXDocTypesCounter C
		inner join dbo.PDXDocTypesConst T on T.SetID = C.WithDocTypeID
		where C.DocTypeID = @SetID
		select @Result = @@error if @Result <> 0 goto Err
		--если в этом списке нет иходной категории - добавляем
		if not exists (select 1 from @ClassList where ClassName = @ClassDoc)
		begin
			insert into @ClassList (ClassName) values (@ClassDoc)
			select @Result = @@error if @Result <> 0 goto Err
		end
	end

	--счетчик делит номер на 2 части 
	--количество символов до счетчика
	set @LPos = charindex(@strPart,@DocID)-1 --символов до счетчика
	set @RPos = len(@DocID) - @LPos - len(@strPart) --символов после счетчика
print '@LPos: ' + cast(@LPos as varchar(100))
print '@RPos: ' + cast(@RPos as varchar(100))
--print '***' + @DocID
--print '***' + replace(@DocID,@strPart,'%')
--print '***' + cast(@SetID as varchar(40))
	if not @NFormat like '%{PAR}%' --по категории
	begin
        If @ID_Type = 1 
		begin 
			insert into @tmp (DocID, Part)
			select D.DocID, substring(D.DocID,@LPos +1, len(D.DocID)-@RPos-@LPos)
			from dbo.Docs D
			where D.ClassDoc in (select ClassName from @ClassList)
				and D.DocID like replace(@DocID,@strPart,'%')
				and dbo.PDX_IsTextAsInteger(substring(D.DocID,@LPos +1, len(D.DocID)-@RPos-@LPos)) = 1
			union
			select D.DocID, substring(D.DocID,@LPos +1, len(D.DocID)-@RPos-@LPos)
			from dbo.Docs_Move D
			where D.ClassDoc in (select ClassName from @ClassList)
				and D.DocID like replace(@DocID,@strPart,'%')
				and dbo.PDX_IsTextAsInteger(substring(D.DocID,@LPos +1, len(D.DocID)-@RPos-@LPos)) = 1
			select @Result = @@error if @Result <> 0 goto Err
		end
		else
		begin
			insert into @tmp (DocID, Part)
			select D.DocIDAdd, substring(D.DocIDAdd,@LPos +1, len(D.DocIDAdd)-@RPos-@LPos)
			from dbo.Docs D
			where D.ClassDoc in (select ClassName from @ClassList)
				and D.DocIDAdd like replace(@DocID,@strPart,'%')
				and dbo.PDX_IsTextAsInteger(substring(D.DocIDAdd,@LPos +1, len(D.DocIDAdd)-@RPos-@LPos)) = 1
			union
			select D.DocIDAdd, substring(D.DocIDAdd,@LPos +1, len(D.DocIDAdd)-@RPos-@LPos)
			from dbo.Docs_Move D
			where D.ClassDoc in (select ClassName from @ClassList)
				and D.DocIDAdd like replace(@DocID,@strPart,'%')
				and dbo.PDX_IsTextAsInteger(substring(D.DocIDAdd,@LPos +1, len(D.DocIDAdd)-@RPos-@LPos)) = 1

			select @Result = @@error if @Result <> 0 goto Err
		End
	end
	else --по родителю
	begin
		If @ID_Type = 1 
		begin 
			insert into @tmp (DocID, Part)
			select D.DocID, substring(D.DocID,@LPos +1, len(D.DocID)-@RPos-@LPos)
			from dbo.Docs D
			where D.DocID like replace(@DocID,@strPart,'%')
				and dbo.PDX_IsTextAsInteger(substring(D.DocID,@LPos +1, len(D.DocID)-@RPos-@LPos)) = 1
			union
			select D.DocID, substring(D.DocID,@LPos +1, len(D.DocID)-@RPos-@LPos)
			from dbo.Docs_Move D
			where D.DocID like replace(@DocID,@strPart,'%')
				and dbo.PDX_IsTextAsInteger(substring(D.DocID,@LPos +1, len(D.DocID)-@RPos-@LPos)) = 1
			select @Result = @@error if @Result <> 0 goto Err
		end
		Else
		begin
			insert into @tmp (DocID, Part)
			select D.DocIDAdd, substring(D.DocIDAdd,@LPos +1, len(D.DocIDAdd)-@RPos-@LPos)
			from dbo.Docs D
			where D.DocIDAdd like replace(@DocID,@strPart,'%')
				and dbo.PDX_IsTextAsInteger(substring(D.DocIDAdd,@LPos +1, len(D.DocIDAdd)-@RPos-@LPos)) = 1
			union
			select D.DocIDAdd, substring(D.DocIDAdd,@LPos +1, len(D.DocIDAdd)-@RPos-@LPos)
			from dbo.Docs_Move D
			where D.DocIDAdd like replace(@DocID,@strPart,'%')
				and dbo.PDX_IsTextAsInteger(substring(D.DocIDAdd,@LPos +1, len(D.DocIDAdd)-@RPos-@LPos)) = 1
			select @Result = @@error if @Result <> 0 goto Err
		End
	end

	update @tmp
		set CPart = cast(Part as int)
	select @Result = @@error if @Result <> 0 goto Err

	select @MaxCounter = max(CPart)
	from @tmp
	select @Result = @@error if @Result <> 0 goto Err
	
	select @MaxCounter = isnull(@MaxCounter,0) + 1
	select @Result = @@error if @Result <> 0 goto Err


OK:
	return @Result
Err:
	return @Result

GO
/****** Object:  StoredProcedure [dbo].[PDX_NC_NumberCalculate] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[PDX_NC_NumberCalculate]
	@Activity varchar(255), --вид деят-ти
	@Department varchar(255), --подразделение 
	--!!!!подразделение М.Б. задано с ключевым словом "<BYUSER:>" - это значит, что подразделение определяется через переданного в этой переменной пользователя
	@ParentDocID varchar(128), --номер родит. 
	@ClassDoc varchar(255),--категория
	@DocDate datetime,--дата
	@OrderIndex varchar(100), --пользовательский счетчик/код  (задается через интерфейс) - может быть дополнен 0 до определенного кол-ва знаков
	@isReg bit,	--признак расчета рег. номера

	@OldDocID varchar(128),--старый номер документа (тот, который хотим изменить/проверить: при регистрации это введенный регистратором номер, иначе введенный пользователем номер)
	@RealDocID varchar(128) = null,--тот номер под которым в данный момент находится документ в системе
	@StatusActive char(1),--статус активный
	@PreviousDocID varchar(128) = null, --для проверки предыдущей версии (новый номер д.б. = Prev + 1)? для этого значение должно быть указано в формате "<CHK:>номер док-та"
	@Error varchar(4000) = null out , --сообщение об ошибке
	@DocID varchar(128) = null out, --рассчитанный номер документа
	--параметры для формирования сообщений об ошибке
	@s_Activity varchar(128) = null,
	@s_Department varchar(128) = null,
	@s_OrderIndex varchar(128) = null,
	@s_PreviousDocID varchar(128) = null,
	@s_ParentDocID varchar(128) = null,
	@s_DocDate varchar(128) = null
as

	declare @Result int
	select @Result = 0

	declare @VDCode varchar(50), --код из вида деят-ти КОД_ВД
			@OUCode varchar(50), --код организационной единицы КОД_ОЕ
			@DCCode varchar(50),  --делопроизводственный код
			@ORDCode varchar(50), --код ОРД
			@KPCode varchar(50), --под подразделения
			@FKCode varchar(50),
			@LETTER varchar(10), --буквенно-цифровой код категории
			@NFormat varchar(128), --формат регистрационного номера
			@SetID uniqueidentifier, --ид категории в мета данных
			@SPos int, 
			@EPos int,
			@strPart varchar(100), --"кусок" формата номера
			@MaxCounter int, --новый счетчик для номера
			@DocIDAdd varchar(128), --вспомогательная переменная, номер без счетчика, не содержащий дополнительных кодов (без круглых скобок)
			@checkDocID varchar(128), --вспомогательная переменная используется при работе с @DocIDAdd
			@IntVal varchar(100), @IntVal1 varchar(100), 
			@DocIDArc varchar(128), --вспомогательная переменная, номер без счетчика и с заменой {LET} на G, не содержащий дополнительных кодов (без круглых скобок)
			@DocIDArc1 varchar(128),--вспомогательная переменная, номер без счетчика и с заменой {LET} на G, содержащий дополнительные коды (с круглыми скобками)
			@ID_Type bit -- 1 = DocID, 0 = DocIDAdd
				
	set @Error = ''
	set @DocID = ''
	set @SetID = null

	select	
		@Activity = ltrim(rtrim(isnull(@Activity,''))),
		@Department = ltrim(rtrim(isnull(@Department,''))),
		@ParentDocID = ltrim(rtrim(isnull(@ParentDocID,''))),
		@ClassDoc = ltrim(rtrim(isnull(@ClassDoc,''))),
		@DocDate = isnull(@DocDate,getdate()),
		@OldDocID = ltrim(rtrim(isnull(@OldDocID,''))),
		@RealDocID = ltrim(rtrim(isnull(@RealDocID,''))),
		@isReg = isnull(@isReg,0),
		
		@s_Activity = case len(ltrim(rtrim(@s_Activity))) when 0 then null else @s_Activity end,
		@s_Department = case len(ltrim(rtrim(@s_Department))) when 0 then null else @s_Department end,
		@s_OrderIndex = case len(ltrim(rtrim(@s_OrderIndex))) when 0 then null else @s_OrderIndex end,
		@s_PreviousDocID = case len(ltrim(rtrim(@s_PreviousDocID))) when 0 then null else @s_PreviousDocID end,
		@s_ParentDocID = case len(ltrim(rtrim(@s_ParentDocID))) when 0 then null else @s_ParentDocID end
	select @Result = @@error if @Result <> 0 goto Err

	If @ClassDoc = '' --не передано значение категории
	begin 
		set @Error = '<font color=red>ОШИБКА! </font> НЕ УКАЗАНА КАТЕГОРИЯ'
		set @Result = 1 
		goto Err
	end

	--так как при регистрации документа иходных данных на клиенте нет, то получаем их на сервере
	--но все-таки при условии, что их не передали снаружи (из-за поразделения, так как есть случаи, когда оно рассчитывается по к-л пользователю)
	If @isReg = 1 and @RealDocID <> ''
		and (@Department = '' or @Activity = '' or @ParentDocID = '')
	begin
		select
			@Activity = isnull(ActDoc,''),
			@Department = case when @Department like '%<BYUSER:>%' then @Department else isnull(Department,'') end,
			@ParentDocID = isnull(DocIDParent,'')
		from dbo.Docs 
		where DocID = @RealDocID
		select @Result = @@error if @Result <> 0 goto Err
	end

print '@Department1: ' + @Department
	--доопределяем подразделение
	If @Department like '%<BYUSER:>%'
	begin
		set @Department = replace(@Department, '<BYUSER:>', '')
		select @Result = @@error if @Result <> 0 goto Err
		
		If ltrim(rtrim(@Department)) <> '' and ltrim(rtrim(@Department)) like '%<%>%'
		begin
			select
				@Department = Department
			from dbo.Users
			where UserID = dbo.PDX_SubstringReturn(@Department, charindex('<', @Department), charindex('>', @Department))
			select @Result = @@error if @Result <> 0 goto Err
		end
		else
		begin
			set @Department = ''
			select @Result = @@error if @Result <> 0 goto Err
		end
	end
print '@Department2: ' + @Department

	--получаем параметры категории
	select 
		@LETTER = ltrim(rtrim(isnull(Letter,''))),
		@NFormat = case 
 					 when @isReg = 1 --для рег. номера
						then ltrim(rtrim(isnull(RegFormat,'')))
					 when @ParentDocID <> '' and ltrim(rtrim(isnull(ChildFormat,''))) <> ''
						then ltrim(rtrim(isnull(ChildFormat,''))) --для подчиненного документа (ДС)
					 else ltrim(rtrim(isnull(NumberFormat,''))) --для остальных
				   end,
		@ID_Type = case 
 					 when @isReg = 1 --для рег. номера
						then 1 --регистрационные номера - это всегда DocID
					 else --если не рег. номер, то DocIDAdd будет только если категория предусматривает рег. номер
						case ltrim(rtrim(isnull(RegFormat,'')))
							when '' --у категории нет рег. номера
								then 1 --значит есть только DocID
							else 0 --DocIDAdd, т.е. когда-ниб документ зарегистрируют по DocID, а этот номер проектный
						end							
				   end,
		@SetID = SetID
	from dbo.PDXDocTypesConst
	where DocType = @ClassDoc
	select @Result = @@error if @Result <> 0 goto Err
	
	If @SetID is null --не нашлась категория в meta данных
	begin 
		set @Error = '<font color=red>ОШИБКА! </font> НЕ УДАЛОСЬ ОПРЕДЕЛИТЬ КАТЕГОРИЮ'
		set @Result = 1 
		goto Err
	end

	If isnull(@NFormat,'') = '' --не определен формат номера
	begin 
		set @Error = '<font color=red>ОШИБКА! </font> Для категории [' + @ClassDoc + '] не задан формат номера. Обратитесь к администратору СЭД.'
		set @Result = 1 
		goto Err
	end

	--обрабатываем возможные нестыковки
	--обяз. д.б. указан OrderIdex, если в формете есть {OI}
	If @NFormat like '%{OI%}%' and isnull(@OrderIndex,'') = ''
	begin 
		set @Error = case len(@Error) when 0 then '' else '<br>' end + '<font color=red>ОШИБКА! </font> Поле [' + isnull(@s_OrderIndex,'Порядковый номер') + '] не может быть пустым.'
		select @Result = @@error if @Result <> 0 goto Err
	end
	--обяз. д.б. указан Вид деят-ти, если в формете есть {KVD} или {ORD}
	If (@NFormat like '%{KVD}%' or @NFormat like '%{ORD}%') and @Activity = ''
	begin 
		set @Error = case len(@Error) when 0 then '' else '<br>' end + '<font color=red>ОШИБКА! </font> Поле [' + isnull(@s_Activity,'Вид деят-ти') + '] не может быть пустым.'
		select @Result = @@error if @Result <> 0 goto Err
	end
	--обяз. д.б. указан Вид деят-ти и подразделение, если в формете есть {KOE}
	If @NFormat like '%{KOE}%' and (@Activity = '' or @Department = '')
	begin 
		set @Error = case len(@Error) when 0 then '' else '<br>' end + '<font color=red>ОШИБКА! </font> Поля [' + isnull(@s_Activity,'Вид деят-ти') + '] и/или [' + isnull(@s_Department,'Подразделение') + '] не могут быть пустыми.'
		select @Result = @@error if @Result <> 0 goto Err
	end
	--обяз. д.б. указано подразделение, если в формете есть {KD} или {KP} или {FK}
	If (@NFormat like '%{KD}%' or @NFormat like '%{KP}%' or @NFormat like '%{FK}%') and @Department = ''
	begin 
		set @Error = case len(@Error) when 0 then '' else '<br>' end + '<font color=red>ОШИБКА! </font> Поле [' + isnull(@s_Department,'Подразделение') + '] не может быть пустым.'
		select @Result = @@error if @Result <> 0 goto Err
	end
	--обяз. д.б. указан родит. объект, если в формете есть {PAR}
	If @NFormat like '%{PAR}%' and @ParentDocID = ''
	begin 
		set @Error = case len(@Error) when 0 then '' else '<br>' end + '<font color=red>ОШИБКА! </font> Поле [' + isnull(@s_ParentDocID,'Родитетельский документ') + '] не может быть пустым.'
		select @Result = @@error if @Result <> 0 goto Err
	end
	--обяз. д.б. указана дата, если в формете есть {GG}, {GM}
	If (@NFormat like '%{GG}%' or @NFormat like '%{GM}%') and (year(@DocDate) = 1900 or @DocDate is null)
	begin 
		set @Error = case len(@Error) when 0 then '' else '<br>' end + '<font color=red>ОШИБКА! </font> Поле [' + isnull(@s_DocDate,'Дата') + '] не может быть пустым.'
		select @Result = @@error if @Result <> 0 goto Err
	end
	If @Error <> '' --есть ошибки
	begin 
		set @Result = 1 
		goto Err
	end

/************************************************************************************************
получение кодов и префиксов
***********************************************************************************************/
	--если необходимы коды будем их рассчитывать
	If @NFormat like '%{KVD}%' or @NFormat like '%{KOE}%' or @NFormat like '%{KD}%' or @NFormat like '%{ORD}%' or @NFormat like '%{KP}%' or @NFormat like '%{FK}%'
	begin
		--получаем коды
		exec @Result = dbo.PDX_NC_BasicParamGet
			@Activity = @Activity,
			@Department = @Department,
			@ClassDoc = @ClassDoc,
			@NFormat = @NFormat,
			@VDCode = @VDCode out, 
			@OUCode = @OUCode out,
			@DCCode = @DCCode out,
			@KPCode = @KPCode out ,
			@ORDCode = @ORDCode out,
			@FKCode = @FKCode out
		if @Result <> 0 goto Err

		--возможно некорректно были выбраны данные и коды неопределились
		If (@NFormat like '%{KD}%' and @DCCode = '') or (@NFormat like '%{KOE}%' and @OUCode = '') or
			(@NFormat like '%{KP}%' and @KPCode = '') or (@NFormat like '%{FK}%' and @FKCode = '')
		begin 
			set @Error = '<font color=red>ОШИБКА! </font> Для значения указанного в поле [' + isnull(@s_Department,'Подразделение') + '] не определен код.Обратитесь к администратору СЭД.'
			set @Result = 1 
			goto Err
		end
		--префикс орд не может быть пустым
		if @NFormat like '%{ORD}%' and @ORDCode = ''
		begin 
			set @Error = '<font color=red>ОШИБКА! </font> Не определен префикс ОРД. Обратитесь к администратору СЭД.'
			set @Result = 1 
			goto Err
		end
	end
/************************************************************************************************/


/************************************************************************************************
собираем номер, заменяя коды на реальные значения
*************************************************************************************************/
print '@NFormat: ' + @NFormat
	set @DocID = @NFormat
	----***обрабатываем {ORD}, {KVD}, {KOE}, {KD}, {PAR}, {KP}, {GG},{GM}, {DT}, {FK}
	set @DocID = replace(@DocID,'{ORD}',isnull(@ORDCode,''))
	set @DocID = replace(@DocID,'{KVD}',isnull(@VDCode,''))
	set @DocID = replace(@DocID,'{KOE}',isnull(@OUCode,''))
	set @DocID = replace(@DocID,'{KD}',isnull(@DCCode,''))
	set @DocID = replace(@DocID,'{PAR}',isnull(@ParentDocID,''))
	set @DocID = replace(@DocID,'{KP}',isnull(@KPCode,''))
	set @DocID = replace(@DocID,'{FK}',isnull(@FKCode,''))
	set @DocID = replace(@DocID,'{GG}',right(cast(year(@DocDate) as varchar(4)),2))
	set @DocID = replace(@DocID,'{GM}',cast(year(@DocDate) as varchar(4)) + case when month(@DocDate) <=9 then '0' else '' end + CAST(month(@DocDate) as varchar(2)))
	set @DocID = replace(@DocID,'{DT}',cast(year(@DocDate) as varchar(4)) + cast(month(@DocDate) as varchar(2)) + cast(day(@DocDate) as varchar(2)))

print '@DocID(до OI): ' + @DocID	
	----***обрабатываем пользовательский счетчик {OI}
	if @DocID like '%{OI%}%'
	begin
		set @strPart = ''
		set @strPart = dbo.PDX_SubstringReturn(@DocID, charindex('{OI', @DocID), charindex('}', @DocID, charindex('{OI', @DocID)+1))
		select @Result = @@error if @Result <> 0 goto Err
		set @strPart = '{' + @strPart + '}'
print '		@strPart: ' + @strPart

		set @SPos = case dbo.PDX_IsTextAsInteger(replace(replace(replace(@strPart,'{',''),'}',''),'OI',''))	
					when 1
						then cast(replace(replace(replace(@strPart,'{',''),'}',''),'OI','') as int)
					else 1
				end
		select @Result = @@error if @Result <> 0 goto Err
print '		@SPos: ' + cast(@SPos as varchar(100))		
		set @DocID = replace(@DocID,@strPart,isnull(replicate('0', @SPos-len(cast(@OrderIndex as varchar(100)))),'') + cast(@OrderIndex as varchar(100)))
		select @Result = @@error if @Result <> 0 goto Err
	end

print '@DocID(после OI): ' + @DocID	

	--***обрабатываем разделители
	select @DocID = replace(@DocID,'{-}','-')
	select @DocID = replace(@DocID,'{/}','/')
	select @DocID = replace(@DocID,'{.}','.')

	-- это 2 варианта (с дополнением и без) архивного (G) номера для данного шаблона, понадобиться при проверках номера на соотв-е шаблону
	set @DocIDArc = replace(@DocID,'{LET}', 'G')
	set @DocIDArc1 = @DocIDArc

	--***обрабатываем символы {LET}
	set @DocID = replace(@DocID,'{LET}',isnull(@LETTER,''))

	--сохраняем "нормальное" (неархивное) значение с круглыми скобками, оно понадобиться для сравнения формата
	set @DocIDAdd = @DocID 

	--***обрабатываем "круглые скобки" - это необязательная , но допустимая часть номера
	--в круглых скобках может быть дополнение к номеру, которое м.б. пропущено при проверке, но в расчетах не участвует
print '@DocID(до круглые скобки): ' + @DocID	
	while @DocID like '%(%)%' or @DocIDArc like '%(%)%' 
	begin
		set @DocID = replace(@DocID,'(' + dbo.PDX_SubstringReturn(@DocID, charindex('(',@DocID), charindex(')',@DocID)) + ')','')
		select @Result = @@error if @Result <> 0 goto Err
		set @DocIDArc = replace(@DocIDArc,'(' + dbo.PDX_SubstringReturn(@DocIDArc, charindex('(',@DocIDArc), charindex(')',@DocIDArc)) + ')','')
		select @Result = @@error if @Result <> 0 goto Err
	end
print '@DocID(после круглые скобки): ' + @DocID	

	if @DocID like '[-,/]%' --номер не может начинаться с разделителя
	begin
		set @DocID = right(@DocID, len(@DocID)-1)
	end

/************************************************************************************************/
	
	--на этом этапе должен остаться только счетчик
	set @strPart = ''
	set @strPart = dbo.PDX_SubstringReturn(@DocID, charindex('{',@DocID), charindex('}',@DocID))
	select @Result = @@error if @Result <> 0 goto Err
	set @strPart = '{' + @strPart + '}'
print '		@strPart: ' + @strPart

	--проверяем, что отобрался счетчик (или пустота), если не он, то это ошибка
	if not (@strPart like '{N%}' or @strPart = '{}')
	begin --обнаружены не предусмотренные алгоритмом КОДЫ
		set @Error = '<font color=red>ОШИБКА! </font> Ошибка структуры номера(1). Для исправления обратитесь к администратору СЭД.'
		set @Result = 1 
		goto Err
	end

/************************************************************************************************
1.данный кусок кода отвечает за необходимость пересчета номера, если он не соответсвует реквизитам
	при условии, что документ неактивен
2.этот же кусок кода проверит удовлетворяет ли шаблону рег. номер 
(если возвращенный DocID будет равен переданному, то все ОК)
*************************************************************************************************/
	if @OldDocID <> ''  --эти проверки актуальны, если изначально был указан старый ид документа
	begin 
		--номер совпадает - все ОК
		if not @strPart like '%{N%}%' and @OldDocID = @DocID --это тот случай, когда счетчика нет (полное совпадение)
		begin			
			set @DocID = @OldDocID 
			if @isReg = 1 --проверка существования номера только при регистрации документа, так как при обчычном сохранении она и так работает на уровне клиента
			begin
				if @RealDocID <> @OldDocID and @RealDocID <> '' and exists(select 1 from dbo.Docs where DocID = @OldDocID union select 1 from dbo.Docs_Move where DocID = @OldDocID)
				begin		
					set @Error = '<font color=red>ОШИБКА! </font> Указанныей рег.номер уже существует(1). Попробуйте еще раз.'
					set @Result = 1 
					goto Err
				end
			end
			goto OK
		end
		else if @strPart like '%{N%}%' and @OldDocID like replace(@DocID,@strPart,'%') --это когда счетчик есть (совпадение по like)
			and dbo.PDX_IsTextAsInteger(substring(@OldDocID,charindex(@strPart,@DocID), len(@OldDocID)-len(@DocID) + len(@strPart))) = 1
		begin
			set @DocID = @OldDocID 
			if @isReg = 1 --проверка существования номера только при регистрации документа, так как при обчычном сохранении она и так работает на уровне клиента
			begin
				if @RealDocID <> @OldDocID and @RealDocID <> '' and exists(select 1 from dbo.Docs where DocID = @OldDocID union select 1 from dbo.Docs_Move where DocID = @OldDocID)
				begin		
					set @Error = '<font color=red>ОШИБКА! </font> Указанныей рег.номер уже существует(2). Попробуйте еще раз.'
					set @Result = 1 
					goto Err
				end
			end
			goto OK			
		end
		else if @DocIDAdd like '%(N)%' --это когда есть допустимое отклонение (напр, номер дан задним числом)
		begin --допустимые символы отклонения (-)(/)(N) -- два разделителя и счетчик
print '@OldDocID: ' + @OldDocID 
print '@DocIDAdd: ' + @DocIDAdd
print '@checkDocID: ' + isnull(@checkDocID,'')

			--проверка номера с "необязательной частью" 
			select @Error = dbo.PDX_NC_DifferenceExists (@OldDocID,@DocIDAdd,@StatusActive)
			select @Result = @@error if @Result <> 0 goto Err
			if @Error = '' 
			begin				
				select @DocID = @OldDocID
				if @isReg = 1 --проверка существования номера только при регистрации документа, так как при обчычном сохранении она и так работает на уровне клиента
				begin
					if @RealDocID <> @OldDocID and @RealDocID <> '' and exists(select 1 from dbo.Docs where DocID = @OldDocID union select 1 from dbo.Docs_Move where DocID = @OldDocID)
					begin		
						set @Error = '<font color=red>ОШИБКА! </font> Указанныей рег.номер уже существует(3). Попробуйте еще раз.'
						set @Result = 1 
						goto Err
					end
				end
				goto OK
			end
			else
			begin
				goto Err
			end
		end
		else --номер не совпадает (ошибка или пересчет)
		begin
			--в даном месте может быть исключение - это архивные документ, которые загружены с символом G
			--номер совпадает - все ОК
			if not @strPart like '%{N%}%' and @RealDocID <> '' and @OldDocID = @DocIDArc --это тот случай, когда счетчика нет (полное совпадение)
			begin			
				set @DocID = @OldDocID 
				if @isReg = 1 --проверка существования номера только при регистрации документа, так как при обчычном сохранении она и так работает на уровне клиента
				begin
					if @RealDocID <> @OldDocID and exists(select 1 from dbo.Docs where DocID = @OldDocID union select 1 from dbo.Docs_Move where DocID = @OldDocID)
					begin		
						set @Error = '<font color=red>ОШИБКА! </font> Указанныей рег.номер уже существует(4). Попробуйте еще раз.'
						set @Result = 1 
						goto Err
					end
				end
				goto OK
			end
			else if @strPart like '%{N%}%' and @OldDocID like replace(@DocIDArc,@strPart,'%') --это когда счетчик есть (совпадение по like)
				and dbo.PDX_IsTextAsInteger(substring(@OldDocID,charindex(@strPart,@DocIDArc), len(@OldDocID)-len(@DocIDArc) + len(@strPart))) = 1
			begin
				set @DocID = @OldDocID 
				if @isReg = 1 --проверка существования номера только при регистрации документа, так как при обчычном сохранении она и так работает на уровне клиента
				begin
					if @RealDocID <> @OldDocID and @RealDocID <> '' and exists(select 1 from dbo.Docs where DocID = @OldDocID union select 1 from dbo.Docs_Move where DocID = @OldDocID)
					begin		
						set @Error = '<font color=red>ОШИБКА! </font> Указанныей рег.номер уже существует(5). Попробуйте еще раз.'
						set @Result = 1 
						goto Err
					end
				end
				goto OK			
			end
			else if @DocIDArc1 like '%(N)%' --это когда есть допустимое отклонение (напр, номер дан задним числом)
			begin --допустимые символы отклонения (-)(/)(N) -- два разделителя и счетчик
				--проверка номера с "необязательной частью" 
				select @Error = dbo.PDX_NC_DifferenceExists (@OldDocID,@DocIDArc1,@StatusActive)
				select @Result = @@error if @Result <> 0 goto Err
		
				if @Error = '' 
				begin
					select @DocID = @OldDocID
					if @isReg = 1 --проверка существования номера только при регистрации документа, так как при обчычном сохранении она и так работает на уровне клиента
					begin
						if @RealDocID <> @OldDocID and @RealDocID <> '' and exists(select 1 from dbo.Docs where DocID = @OldDocID union select 1 from dbo.Docs_Move where DocID = @OldDocID)
						begin		
							set @Error = '<font color=red>ОШИБКА! </font> Указанныей рег.номер уже существует(6). Попробуйте еще раз.'
							set @Result = 1 
							goto Err
						end
					end
					goto OK
				end
				else 
				begin 
					goto Err
				end
			end
 
			if upper(@StatusActive) = 'Y' --если документ активен - ошибка, если неактивен дальше по коду его перерассчитаем
			begin
				set @Error = '<font color=red>ОШИБКА! </font> Рег. номер документа не соответствует реквизитам карточки(2). За информацией обратитесь к администратору СЭД.'
				set @Result = 1 
				goto Err
			end
		end
	end 
/************************************************************************************************/


/************************************************************************************************
получаем новое значение для счетчика
************************************************************************************************/
print '@DocID(до N): ' + @DocID	
	--смотрим есть ли счетчик и сколько в нем фиксированных знаков
	if @strPart like '{N%}'
	begin 	
	 --вычисляем фиксированной кол-во знаков
		set @SPos = case dbo.PDX_IsTextAsInteger(replace(replace(replace(@strPart,'{',''),'}',''),'N',''))	
					when 1
						then cast(replace(replace(replace(@strPart,'{',''),'}',''),'N','') as int)
					else 1
				end
		select @Result = @@error if @Result <> 0 goto Err
print '		@SPos: ' + cast(@SPos as varchar(100))
		--получение счетчика
		exec @Result = dbo.PDX_NC_CounterCalculate
			@ClassDoc = @ClassDoc,
			@strPart = @strPart,
			@NFormat = @NFormat,
			@DocID = @DocID,
			@SetID = @SetID,
			@ID_Type = @ID_Type,
			@MaxCounter = @MaxCounter out
		if @Result <> 0 goto Err

--проверка по Prev
print '		chk prevdocid'
        if ltrim(rtrim(isnull(@PreviousDocID,''))) like '<CHK:>%'
		begin --убираем вспомагатльные символы
			select @PreviousDocID = ltrim(rtrim(isnull(replace(@PreviousDocID,'<CHK:>',''),'')))
			select @Result = @@error if @Result <> 0 goto Err

			if ltrim(rtrim(isnull(@PreviousDocID,''))) <> '' 
			begin
	print '@PreviousDocID(проверка): ' + @PreviousDocID	
				If ltrim(rtrim(isnull(@PreviousDocID,''))) <> replace(@DocID, @strPart, isnull(replicate('0',@SPos - len(cast(@MaxCounter-1 as varchar(100)))),'') + cast(@MaxCounter-1 as varchar(100))) 
				begin
					set @Error = '<font color=red>ОШИБКА! </font> Несоответствие поля [' + isnull(@s_PreviousDocID,'Предыдущий док-т') + '] и параметров текущей карточки.(7).'
					set @Result = 1 
					goto Err
				end
			end
			else --значит поле не заполнено, а это может быть только, если счетчик = 1, т.е. это первый док-т
			begin
				If @MaxCounter <> 1
				begin
					set @Error = '<font color=red>ОШИБКА! </font> Поле [' + isnull(@s_PreviousDocID,'Предыдущий док-т') + '] не может быть пустым(8).'
					set @Result = 1 
					goto Err
				end
			end
		end
print '		chk prevdocid end'
------------------------------
		--окончательное формирование номера
		select @DocID = replace(@DocID, @strPart, isnull(replicate('0',@SPos - len(cast(@MaxCounter as varchar(100)))),'') + cast(@MaxCounter as varchar(100)))
		select @Result = @@error if @Result <> 0 goto Err

print '@DocID(после N): ' + @DocID	
	end

/************************************************************************************************/

print '@DocID(результат): ' + @DocID	

	If @DocID like '%{%' or @DocID like '%}%' or @DocID like '%(%' or @DocID like '%)%' 
	begin
		set @Error = '<font color=red>ОШИБКА! </font> Ошибка структуры номера(2). Для исправления обратитесь к администратору СЭД.'
		set @Result = 1 
		goto Err
	end

	If isnull(@DocID,'') = ''
	begin
		set @Error = '<font color=red>ОШИБКА! </font> Ошибка структуры номера(3). Для исправления обратитесь к администратору СЭД.'
		set @Result = 1 
		goto Err
	end

OK:
	select isnull(@Error,'') as 'Error', isnull(@DocID,'') as 'DocID'
	return @Result
Err:
	select /*isnull(@Error,'')*/ case isnull(@Error,'') when '' then '<font color=red>ОШИБКА! </font> Ошибка преобразования(SQL). Попробуйте еще раз или обратитесь к Администратору СЭД.' else isnull(@Error,'') end  as 'Error', isnull(@DocID,'') as 'DocID'
	return @Result



GO
/****** Object:  StoredProcedure [dbo].[PDX_NSIDGAprove] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

create proc [dbo].[PDX_NSIDGAprove]
	
as

declare @ClassDoc varchar(128), @OperationDate datetime

set @ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_OTHERS_DGC')

create table #dcs (DocIDInt int, DocID varchar(128),NameCreation varchar(128), UserID varchar(20), UserName varchar(128) )

insert into #dcs (DocID, DocIDInt, NameCreation)
select 
	D.DocID, D.DocIDInt, D.NameCreation
from dbo.Docs D
where D.ClassDoc = @ClassDoc
	and D.IsActive = 'Y'
	and not isnull(D.StatusDevelopment,'') in ('4', '0')
	and not isnull(D.StatusCompletion,'') = '0'
	and dbo.PDX_CompareReconcilationList(D.ListToReconcile, D.ListReconciled) = 1 --согласование завершено

update #dcs
set UserID = dbo.PDX_SubstringReturn(NameCreation,charindex('<',NameCreation),charindex('>',NameCreation))

update #dcs
set UserName = ltrim(rtrim(replace(replace(REPLACE(NameCreation,'<' + UserID + '>',''),'"',''),';','')))
	
set @OperationDate = GETDATE()

update D
set 
	NameApproved = D.NameAproval,
	DateApproved =@OperationDate,
	StatusDevelopment = '4'
from dbo.Docs D
inner join #dcs T on T.DocIDInt = D.DocIDInt

insert into dbo.Comments
(	UserID,
	UserName,
	ContactUserName,
	ContactUserID,
	PartnerName,
	DocID,
	DateCreation,
	DateEvent,
	DateEventEnd,
	Address,
	Subject,
	Comment,
	CommentType,
	SpecialInfo,
	FileName,
	--KeyField,
	PartnerID,
	Version,
	GUID,
	GUIDPartner,
	GUIDUser,
	GUIDDoc,
	Amount,
	FileNameOriginal,
	RIK_CommentType)
select
	UserID,
	UserName,
	null,--ContactUserName,
	null,--ContactUserID,
	null,--PartnerName,
	DocID,
	@OperationDate,--DateCreation,
	null,--DateEvent,
	null,--DateEventEnd,
	'',--Address,
	NULL,-- Subject,Завершено - Н. А. Цалай - 26.02.2019 14:37 
	'Утверждено(авт.) - ' + NameCreation + ' - ' + CONVERT(varchar(100), @OperationDate, 104) + SPACE(1) + CONVERT(varchar(5), @OperationDate, 114),--Comment,
	'APROVAL',--CommentType,
	'',--SpecialInfo,
	null,--FileName,
	--KeyField,
	null,--PartnerID,
	null,--Version,
	newid(),--GUID,
	null,--GUIDPartner,
	null,--GUIDUser,
	null,--GUIDDoc,
	null,--Amount,
	null,--FileNameOriginal,
	null--RIK_CommentType
from #dcs


drop table #dcs



GO
/****** Object:  StoredProcedure [dbo].[PDX_OrdPayDetails_Change] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_OrdPayDetails_Change]
	@Tx1 varchar(255),
	@Tx2 varchar(255),
	@Am1 varchar(128),
	@Tx3 varchar(255),
	@DocID varchar(128),
	@SetID uniqueidentifier,
	@NC varchar(128),
	@Act int, --1--ceate, 2-update,3 delete
	@Chk bit = 0
	
as
	declare  @Res int,
		@Am1_1 money,
		@Descr varchar(512),
		@UserID varchar(96),
		@UserName varchar(96),
		@Amount money,
		@DelSetID uniqueidentifier

	declare @ErrList varchar(1024),
		/*@ParentID int,*/ @Cnt int

	select @Res = 0,@ErrList = ''

	select
		@DocID = ltrim(rtrim(isnull(@DocID,''))),
		@Tx1 = ltrim(rtrim(isnull(@Tx1,''))),
		@Tx2 = ltrim(rtrim(isnull(@Tx2,''))),
		@Tx3 = ltrim(rtrim(isnull(@Tx3,'-'))),
		@Am1 = ltrim(rtrim(replace(replace(isnull(@Am1,'0'),',','.'),SPACE(1),''))),
		@NC  = ltrim(rtrim(isnull(@NC,'')))
	select @Res = @@error if @Res <> 0 goto Err

/************************************
ПРОВЕРКИ ВВЕДЕННЫХ ЗНАЧЕНИЙ
*************************************/

If @Act <> 3
BEGIN
	If @DocID = '' or not exists (select 1 from dbo.Docs where DocID = @DocID and ClassDoc in (dbo.PDX_CLSGet('RIK_CategoryName_FIN_ORDPAY'),dbo.PDX_CLSGet('RIK_CategoryName_KAZ_ORDPAY')))
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Системная ошибка! Некорректный ИД документа. Обратитесь к администратору СЭД.'
		goto NXT
	end
	
	If @Tx1 = ''
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Поле "Назначение платежного поручения" не может быть пустым'
		goto NXT
	end

	If @Tx2 = ''
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Поле "НДС" не может быть пустым'
		goto NXT
	end
	
	If not @Tx3 in ('-','1','2','3','4','5')
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Указано некорректное значение в поле "Код дохода"'
		goto NXT
	end
	
	If len(@Tx1) >= 256 
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Превышена максимально допустимая длина "Назначение платежного поручения" (всего - ' + cast(len(@Tx1) as varchar(100)) + ', макс. - 255)'
		goto NXT
	end

	If @Am1 = '' 
	begin
	  set @Am1_1 = 0
	  select @Res = @@error if @Res <> 0 goto Err
	end
	else
	begin
	  if ISNUMERIC(@Am1) = 1
	  begin
		set @Am1_1 = CAST(@Am1 as money)
		select @Res = @@error if @Res <> 0 goto Err
	  end
	  else
	  begin
  		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'В поле сумма должно быть указано числовое значение'
		goto NXT
	  end 
	end
END
/************************************/

NXT:

If @Chk = 0
begin --если это создание , то нужно генерить ошибкуесли она есть
	If @ErrList <> '' 
	begin
		RAISERROR (@ErrList, 16,1)
		goto Err
	end
end
else --если это проверка просто выводим сообщение, даже если оно пустое
begin
	select @ErrList as ErrList 
	select @Res = @@error if @Res <> 0 goto Err
end

IF @ErrList = '' and @Chk = 0
BEGIN
	if @Act = 2
	begin
		update dbo.PDXDocDetails
			set 
				Tx1 = @tx1,
				Tx2 = @tx2,
				Tx3 = @tx3,
				Am1 = @Am1_1,
				NLM = @NC,
				DLM = getdate()
		where SetID = @SetID
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 1
	begin
		insert into dbo.PDXDocDetails
			(DocID, Tx1, Tx2, Tx3, Am1, NC, DC, NLM, DLM)
		values 
			(@DocID, @Tx1, @Tx2, @Tx3, @Am1_1, @NC, getdate(), @NC, getdate())
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 3
	begin
		select @DelSetID = null
		
		select @Descr = '[' + cast(Am1 as varchar(128)) + ' - ' + isnull(Tx1,'') + ']',
			@Amount = Am1,
			@DelSetID = SetID,
			@DocID = DocID
		from dbo.PDXDocDetails where SetID = @SetID
		select @Res = @@error if @Res <> 0 goto Err
		
		if not @DelSetID is null --означает, что удаляемая строка нашлась
		begin
			delete from dbo.PDXDocDetails where SetID = @SetID
			select @Res = @@error if @Res <> 0 goto Err
			
			select @UserID = dbo.PDX_SubstringReturn(@NC, charindex('<',@NC),charindex('>',@NC)),
				@UserName = dbo.PDX_SubstringReturn(@NC, charindex('"',@NC),charindex('"',@NC,charindex('"',@NC)+1))
			select @Res = @@error if @Res <> 0 goto Err
				
			select @UserID = case ltrim(rtrim(isnull(@UserID,''))) when '' then 'Admin' else ltrim(rtrim(isnull(@UserID,''))) end,
				@UserName = case ltrim(rtrim(isnull(@UserName,''))) when '' then 'Admin' else ltrim(rtrim(isnull(@UserName,''))) end
			select @Res = @@error if @Res <> 0 goto Err
			
			insert into dbo.Comments	
				(UserID,
				UserName,
				ContactUserName,
				ContactUserID,
				PartnerName,
				DocID,
				DateCreation,
				DateEvent,
				DateEventEnd,
				Address,
				Subject,
				Comment,
				CommentType,
				SpecialInfo,
				FileName,
				--KeyField,
				PartnerID,
				Version,
				GUID,
				GUIDPartner,
				GUIDUser,
				GUIDDoc,
				Amount,
				FileNameOriginal,
				RIK_CommentType)
			values
				(@UserID,-- UserID,
				@UserName,--UserName,
				null,--ContactUserName,
				null,--ContactUserID,
				null,--PartnerName,
				@DocID,--DocID,
				getdate(),--DateCreation,
				null,--DateEvent,
				null,--DateEventEnd,
				null,--Address,
				null,--Subject,
				'удаление детальной строки ' + @Descr,-- Comment,
				'HISTORY',--CommentType,
				'',--SpecialInfo,
				null,--FileName,
				--KeyField,
				null,--PartnerID,
				cast(@DelSetID as varchar(40)),--Version,
				NewID(),--GUID,
				null,--GUIDPartner,
				null,--GUIDUser,
				null,--GUIDDoc,
				@Amount,--Amount,
				null,--FileNameOriginal,
				'pdxdocdetails')--RIK_CommentType)
			select @Res = @@error if @Res <> 0 goto Err
		end
	end
END
	select @Res = @@error if @Res <> 0 goto Err

OK:

	return @Res
Err:
	return @Res




GO
/****** Object:  StoredProcedure [dbo].[PDX_PAY_Unload] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO





CREATE proc [dbo].[PDX_PAY_Unload]
	@Date datetime
	
as
/*
ВСЕ ВОЗМОЖНЫЕ СТАТУСЫ - STATUS:
	-3 - ошибка в статусе
	-2 - отменен
	-1 - неактивен
	 0 - отказано в согласовании
	 1 - на согласовании
	 2 - утверждена
	 3 - оплачена
	 4 - отменена
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
данная процедура оперирует только статусами:
	-3 - ошибка в статусе
 	 0 - отказано в согласовании
	 1 - на согласовании
	 2 - утверждена
	 4 - отменена
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Процедура отбирает карточки документов "Заявка на оплату", которые были:
	АКТИВИРОВАНЫ - дата последней активации (DateActive из табл. Docs)
		(Изменения только полей карточке, загрузка файлов, написание комментариев к карточке не учитывается)
	ИЛИ
	ИЗМЕНЕНЫ - дата последнего изменения (DateLastModifacation из табл. Docs)
	ИЛИ
	УТВЕРЖДЕНЫ - дата последнего утверждения (DateApproved из табл. Docs)
после указанной даты (@Date)
    ИЛИ 
    ОТМЕНЕНЫ - статус отменено
В выборку также попадают документы, в которых после указанной даты (@Date) были отказы в согласовании.
Но если такой отказ был отозван(отправлено на повторное согласование или отказавший был исключен из ЛС), 
то карточка в выборку не попадает.
Это обусловлено тем, что нас интересует только ТЕКУЩИЙ(действительный) статус документа "отказано в согласоании".
Если отказ был отозван, то статус документа вернулся в состояние "требует согласования" и документ нас будет интересовать, 
если он попадает под DateActive/DateLastModification/DateApproved
	
Процедура возвращает след. данные:
	TrasferGUID, 	--УНИКАЛЬНЫЙ ИД ЗАПИСИС. (примеч. DocID - теоретически м.б. изменен)
	DocID,  		--Рег. номер
	DateActive, 	--дата последней активации
	STATUS,			--ТЕКУЩИЙ СТАТУС ДОКУМЕНТА

	UserFieldText8,	--Бизнес единица
	ID_UFT8,		--ИД Бизнес единицы

	PartnerName,  	--Отправитель\Получатель
	PNTaxID,		--ИНН Отправителя\Получателя

	Name,  			--Назначение
	Description,  	--Основание

	DocIDParent,  	--Номер Пайдокс осн. договора
	ParentID		--Бумажн. номер осн. договора,

	DocIDPrevious,  --Номер ПАйдокс "Для работ по договору"
	PreviousID,		--Бумажн. номер "Для работ по договору"

	UserFieldText2, --ЦФО
	ID_UFT2,		--ИД ЦФО

	UserFieldText3, --Направление
	ID_UFT3,		--ИД Направления

	UserFieldText5, --Статья ПРиЗ
	ID_UFT5,		--Полная "ветка" ЦФО. В угловых скобках указан код ЦФО

	UserFieldText7, --Наличный расчет  (ДА/НЕТ)

	UserFieldText4, --Проект
	ID_UFT4,		--Код Проекта

	UserFieldText6, --Счет
	ID_UFT6,		--ИД Счета

	Currency,  		--Код1 Валюты (из карточки)
	CurrCode2,		--Код2 Валюты (из справочника)

	AmountDoc,  	--Сумма
	AmountDescr,	--описание к сумме
	AmountID,		--ID сумме
	
	NameAproval,  	--Заявитель (утверждающий)
	NameCreation,  	--Автор (создатель карточки).  Д.б. NameAproval = NameCreation
	DateApproved, 	--дата утверждения
	DateSigned,  	--Дата оплаты  - NULL - если не стоит

	UserFieldText1, --Наименование листа согласования
	ListToReconcile --Лист согласования
*/
	
	declare  @Res int

	declare @DocID varchar(128),
		@StopRefuseFlag bit

	set nocount on

	create table #tbl_pay
		(DocID varchar(128),
		StatusDevelopment varchar(1),
		VisaRefuse bit,
		Flg bit default 0,
		DocIDParent varchar(128), 
		DocIDPrevious varchar(128),
		ParentID varchar(128), 
		PreviousID varchar(128),
		PartnerName varchar(512),
		TaxID varchar(32),
		LinkID varchar(128))

	create table #del_summ
		(DocID varchar(128),
		Am1 money,
		SetID uniqueidentifier,
		Tx1 varchar(255))
		
	declare @ErrList varchar(1024),
		@ClassName varchar(128)

	select @ClassName = DocType,
		@StopRefuseFlag = StopRefuseFlag 
	from dbo.PDXDocTypesConst
	where ConstName = 'RIK_CategoryName_FIN_ORDPAY'
	select @Res = @@error if @Res <> 0 goto Err

	select @Res = 0,@ErrList = ''
	
	--по датам из комментов
	--отказ в согласовании, причем только если этот отказ не был отозван
	insert into #tbl_pay
		(DocID,	StatusDevelopment, VisaRefuse, DocIDParent, DocIDPrevious, PartnerName)
	select distinct D.DocID, D.StatusDevelopment, 
			case --условие, что отказ не был отозван (отзыв отказа - это или удалили из ЛС отказника или отменили его оказ в согл.)
				when isnull(D.ListReconciled,'') like '%-<%' 
						and isnull(D.ListToReconcile,'') like '%<' + C.UserID + '>%'
						and isnull(D.ListReconciled,'') like '%-<' + C.UserID + '>%'
					then 1 
				else 0 
			end, D.DocIDParent, D.DocIDPrevious, D.PartnerName
	from dbo.Comments C
	inner join 	dbo.Docs D on C.DocID = D.DocID
		and D.ClassDoc = @ClassName --смотрим чтобы была нужная категория
		and year(isnull(D.DateSigned,'1900-01-01')) = 1900 -- "неоплаченая" заявка
		and Upper(isnull(D.isActive,'')) = 'Y' --активная карточка
		and isnull(D.StatusCompletion,'') <> '0' --неотмененая карточка (отмененные это отдельный блок)
		and case when isnull(ListReconciled,'') like '%-<%' then 1 else 0 end = 1
	where Upper(isnull(C.CommentType,'')) = 'VISA' --берем отказ в согласовании
		and Upper(isnull(C.SpecialInfo,'')) = 'VISAOKREFUSE'
		and C.DateCreation >= @Date
	select @Res = @@error if @Res <> 0 goto Err

	--по датам из комментов
	--отправка на повторное согласование - смысл в том, чтобы "засечь" изменение статуса с "приостановлено-есть отказ" на "требует согласоание"
	--вариант когда при отмене стаус не меняется нам в принципе не интересен, но так как отделить эти ситуации невозможно - будем "брать" все
	insert into #tbl_pay
		(DocID,	StatusDevelopment, VisaRefuse, DocIDParent, DocIDPrevious, PartnerName)
	select distinct D.DocID, D.StatusDevelopment, 
			dbo.PDX_fn_stopReconcilation(D.ListToReconcile, D.ListReconciled, @StopRefuseFlag),
			D.DocIDParent, D.DocIDPrevious, D.PartnerName
	from dbo.Comments C
	inner join 	dbo.Docs D on C.DocID = D.DocID
		and D.ClassDoc = @ClassName --смотрим чтобы была нужная категория
		and year(isnull(D.DateSigned,'1900-01-01')) = 1900 -- "неоплаченая" заявка
		and Upper(isnull(D.isActive,'')) = 'Y' --активная карточка
		and isnull(D.StatusCompletion,'') <> '0' --неотмененая карточка (отмененные это отдельный блок)
	where Upper(isnull(C.CommentType,'')) = 'VISA' --берем отказ в согласовании
		and Upper(isnull(C.SpecialInfo,'')) = 'PARTVISACANCEL'
		and C.DateCreation >= @Date
		and not exists(select 1 from #tbl_pay P where P.DocID = D.DocID)--не повторяемся, если карточка отобралась через отказ
	select @Res = @@error if @Res <> 0 goto Err

	--по датам из картчоки
	insert into #tbl_pay
		(DocID,	StatusDevelopment, VisaRefuse, DocIDParent, DocIDPrevious, PartnerName)
	select distinct D.DocID, D.StatusDevelopment, 
		dbo.PDX_fn_stopReconcilation(ListToReconcile, ListReconciled, @StopRefuseFlag), 
		D.DocIDParent, D.DocIDPrevious, D.PartnerName
	from dbo.Docs D
	where D.ClassDoc = @ClassName --смотрим чтобы была нужная категория
	and (isnull(D.DateActive,D.DateLastModification) >= @Date or --отбираем по дате последней активаци
		isnull(D.DateLastModification, D.DateCreation) >= @Date or --отбираем по дате последнего изм-я
		isnull(D.DateApproved,'1900-01-01') >= @Date) --отбираем по дате утв-я
	and year(isnull(D.DateSigned,'1900-01-01')) = 1900-- "неоплаченая" заявка
	and Upper(isnull(D.isActive,'')) = 'Y'--активная карточка
	and isnull(D.StatusCompletion,'') <> '0'	--неотмененая карточка (отмененные это отдельный блок)
	and not exists(select 1 from #tbl_pay P where P.DocID = D.DocID)--не повторяемся, если карточка отобралась через отказ
	select @Res = @@error if @Res <> 0 goto Err

	--по дате корректировке сумм
	insert into #tbl_pay
		(DocID,	StatusDevelopment, VisaRefuse, DocIDParent, DocIDPrevious, PartnerName)
	select distinct D.DocID, D.StatusDevelopment, 
		dbo.PDX_fn_stopReconcilation(ListToReconcile, ListReconciled, @StopRefuseFlag), 
		D.DocIDParent, D.DocIDPrevious, D.PartnerName
	from dbo.PDXDocDetails T
		inner join dbo.Docs D on D.DocID = T.DocID
			and  D.ClassDoc = @ClassName --смотрим чтобы была нужная категория
			and year(isnull(D.DateSigned,'1900-01-01')) = 1900-- "неоплаченая" заявка
			and Upper(isnull(D.isActive,'')) = 'Y'--активная карточка
			and isnull(D.StatusCompletion,'') <> '0'	--неотмененая карточка (отмененные это отдельный блок)
	where T.DLM >= @Date  --отбираем по дате последнего изм-я
	and not exists(select 1 from #tbl_pay P where P.DocID = D.DocID)--не повторяемся, если карточка отобралась через отказ
	select @Res = @@error if @Res <> 0 goto Err

	--по удалению сумм-детальной строки
	insert into #del_summ
		(DocID, Am1, SetID, Tx1)
	select distinct 
		T.DocID, T.Amount, cast(T.Version as uniqueidentifier), T.Comment
	from dbo.Comments T
		inner join dbo.Docs D on D.DocID = T.DocID
			and  D.ClassDoc = @ClassName --смотрим чтобы была нужная категория
			and year(isnull(D.DateSigned,'1900-01-01')) = 1900-- "неоплаченая" заявка
			and Upper(isnull(D.isActive,'')) = 'Y'--активная карточка
			and isnull(D.StatusCompletion,'') <> '0'	--неотмененая карточка (отмененные это отдельный блок)
	where T.DateCreation >= @Date  --отбираем по дате 
		and upper(T.CommentType) = 'HISTORY'
		and T.RIK_CommentType = 'pdxdocdetails'
	select @Res = @@error if @Res <> 0 goto Err
		
	insert into #tbl_pay
		(DocID,	StatusDevelopment, VisaRefuse, DocIDParent, DocIDPrevious, PartnerName)
	select distinct D.DocID, D.StatusDevelopment, 
		dbo.PDX_fn_stopReconcilation(ListToReconcile, ListReconciled, @StopRefuseFlag), 
		D.DocIDParent, D.DocIDPrevious, D.PartnerName
	from #del_summ S
	inner join dbo.Docs D on D.DocID = S.DocID
	and not exists(select 1 from #tbl_pay P where P.DocID = D.DocID)--не повторяемся, если карточка отобралась через отказ
	select @Res = @@error if @Res <> 0 goto Err

	
	--по датам из комментов
	---отмена платежа
	insert into #tbl_pay
		(DocID,	StatusDevelopment, VisaRefuse, DocIDParent, DocIDPrevious, PartnerName)
	select distinct D.DocID, D.StatusDevelopment, 
			dbo.PDX_fn_stopReconcilation(D.ListToReconcile, D.ListReconciled, @StopRefuseFlag),
			D.DocIDParent, D.DocIDPrevious, D.PartnerName
	from dbo.Comments C
	inner join 	dbo.Docs D on C.DocID = D.DocID
		and D.ClassDoc = @ClassName --смотрим чтобы была нужная категория
		and year(isnull(D.DateSigned,'1900-01-01')) = 1900 -- "неоплаченая" заявка
		and Upper(isnull(D.isActive,'')) = 'Y' --активная карточка
		and isnull(D.StatusCompletion,'') = '0' --отмененая карточка
	where Upper(isnull(C.CommentType,'')) = 'HISTORY' --берем отказ в согласовании
		and Upper(isnull(C.SpecialInfo,'')) = 'CANCELED'
		and C.DateCreation >= @Date
		and not exists(select 1 from #tbl_pay P where P.DocID = D.DocID)--не повторяемся, если карточка отобралась через отказ
	select @Res = @@error if @Res <> 0 goto Err

    /*************************************************************************************************/
    /*************************************************************************************************/
    /*************************************************************************************************/

	update P
		set ParentID = isnull(Par.DocIDIncoming,'')
	from #tbl_pay as P
	inner join dbo.Docs Par on Par.DocID = P.DocIDParent
	select @Res = @@error if @Res <> 0 goto Err

	update P
		set PreviousID = isnull(Prev.DocIDIncoming,'')
	from #tbl_pay as P
	left join dbo.Docs Prev on Prev.DocID = P.DocIDPrevious
	select @Res = @@error if @Res <> 0 goto Err
	
	update P
		set TaxID = isnull(PN.TaxID,'')
	from #tbl_pay as P
	left join dbo.Partners PN on PN.Name = P.PartnerName 
	select @Res = @@error if @Res <> 0 goto Err

	update P
		set LinkID = ltrim(rtrim(ISNULL(C.Subject,'')))
	from #tbl_pay as P
	inner join dbo.Comments C on C.DocID = P.DocID
		and upper(C.CommentType) = 'LINK' 
		and ltrim(rtrim(ISNULL(C.Subject,''))) <> ''
		and C.RIK_CommentType in (dbo.PDX_CLSGet('RIK_CategoryName_FIN_CORPAY'),dbo.PDX_CLSGet('RIK_CategoryName_FIN_PLNPAY'))
	select @Res = @@error if @Res <> 0 goto Err

	--тепер собираем информацию
	select
		D.TransferGUID, --УНИКАЛЬНЫЙ ИД ЗАПИСИС. DocID - теоретически м.б. изменен
		D.DocID,  --Рег. номер
		isnull(isnull(D.DateActive, D.DateActivation), D.DateCreation) as DateActive, --дата последней активации

		D.UserFieldText8,  --Бизнес единица
		dbo.PDX_fn_pay_FirmGET(D.UserFieldText8) as ID_UFT8,

		case 
			when isnull(D.StatusCompletion,'') = '0'
				then 4 -- отменена
			when isnull(D.StatusDevelopment,'') = '4'
				and P.VisaRefuse = 1
				then -3 --в утвержденной карточке не может быть отказов в согласовании
			when isnull(D.StatusDevelopment,'') = '4'
				then 2 --утверждена
			when P.VisaRefuse = 1
				then 0 --отказано в согласовании
			else 1 --на соглаовании
		end as STATUS,
		--****************************************
		P.PartnerName,  --Отправитель\Получатель
		isnull(P.TaxID,'') as PNTaxID, --ИНН
		--isnull(PN.TaxID,'') as PNTaxID, --ИНН

		D.Name,  --Назначение
		D.Description,  --Основание

		isnull(P.DocIDParent,'') as DocIDParent,  --Основной договор
		isnull(P.ParentID,'')as ParentID,
		--isnull(Par.DocIDIncoming,'') as ParentID,

		isnull(P.DocIDPrevious,'') as DocIDPrevious,  --Для работ по договору
		isnull(P.PreviousID,'')as PreviousID,
		--isnull(Prev.DocIDIncoming,'') as PreviousID,
		--****************************************
		D.UserFieldText2,  --ЦФО
		dbo.PDX_fn_pay_CFOGET(D.UserFieldText2) as ID_UFT2,

		D.UserFieldText3,  --Направление
		dbo.PDX_fn_pay_DirectionGET(D.UserFieldText3) as ID_UFT3,

		D.UserFieldText5,  --Статья ПРиЗ
		dbo.PDX_fn_pay_PRiZGET(D.UserFieldText5) as ID_UFT5,
			
		D.UserFieldText7,  --Наличный расчет

		D.UserFieldText4,  --Проект
		isnull(U.Field2,'') as ID_UFT4,

		D.UserFieldText6,  --Счет
		dbo.PDX_fn_pay_AccountGET(D.UserFieldText6) as ID_UFT6 ,
		--****************************************
		D.Currency,  --Валюта
		isnull(Curr.Code2,'') as CurrCode2,--

		---D.AmountDoc,  --Сумма
		isnull(T.Am1, 0) as AmountDoc,--Сумма
		isnull(T.Tx1,'') as AmountDescr, --описание к сумме
		T.SetID as AmountID, --ID сумме
		
		D.NameAproval,  --Заявитель
		isnull(NA.Name,'') as NameApp,
		D.NameCreation,  --Автор
		isnull(NC.Name,'') as NameCr,

		D.DateApproved, --дата утверждения
		case year(isnull(D.DateSigned,'1900-01-01')) 
			when 1900 then null 
			else D.DateSigned 
		end as DateSigned,  --Дата оплаты
		D.UserFieldText1,  --Наименование листа согласования
		D.ListToReconcile,  --Лист согласования
		P.LinkID		-- ссылка на ПЗ или КЗ
	from #tbl_pay P
	inner join dbo.Docs D on D.DocID = P.DocID
	inner join 
		(select X.Am1, X.SetID, X.Tx1, X.DocID from dbo.PDXDocDetails X 
					inner join #tbl_pay Z on X.DocID = Z.DocID
		union
		select 0 as Am1, Y.SetID, Y.Tx1, Y.DocID from #del_summ Y) as T
		on T.DocID = D.DocID
	left join dbo.UserDirValues U on U.UDKeyField = 35 and U.Field1 = D.UserFieldText4
	left join dbo.CurrencyRates Curr on Curr.Code = D.Currency
	left join dbo.Users NA on D.NameAproval like '%<' + NA.UserID + '>%'
	left join dbo.Users NC on D.NameCreation like '%<' + NC.UserID + '>%'
	order by P.DocID
	select @Res = @@error if @Res <> 0 goto Err


OK:
	set nocount off
	return @Res
Err:
	set nocount off
	return @Res





GO
/****** Object:  StoredProcedure [dbo].[PDX_payAccounts_Change] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE proc [dbo].[PDX_payAccounts_Change]
	@Name varchar(256),
	@Descr varchar(256),
	@Class varchar(1),
	@Code int,
	@SetID int,
	@NC varchar(128),
	@Act int, --1--ceate, 2-update,3 delete
	@Chk bit = 0
	
as
	declare  @Res int

	declare @ErrList varchar(1024)

	select @Res = 0,@ErrList = ''
	


	select
		@Name = ltrim(rtrim(isnull(@Name,''))),
		@Class = ltrim(rtrim(isnull(@Class,''))),
		@Descr  = ltrim(rtrim(isnull(@Descr,''))),
		@Code  = ltrim(rtrim(isnull(@Code,0))),
		@NC  = ltrim(rtrim(isnull(@NC,'')))
	select @Res = @@error if @Res <> 0 goto Err


/************************************
ПРОВЕРКИ ВВЕДЕННЫХ ЗНАЧЕНИЙ
*************************************/
If not @Class in ('0','1')
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Некорректный Тип счета'
	goto NXT
End
If @Name = ''
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Укажите счет'
	goto NXT
end
If len(@Name) > 64 
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Превышена максимально допустимая длина Наименования (всего - ' + cast(len(@Name) as varchar(100)) + ', макс. - 64)'
	goto NXT
end
If exists (select 1 from dbo.PDX_pay_Accounts where Name = @Name and Class = @Class
		and SetID <> isnull(@SetID,-1))
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Счет указанного типа в справочнике уже существует'
	select @Res = @@error if @Res <> 0 goto Err		
end

If exists (select 1 from dbo.PDX_pay_Accounts where Code = @Code
		and SetID <> isnull(@SetID,-1))
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Указанный код счета в справочнике уже существует'
	select @Res = @@error if @Res <> 0 goto Err		
end

/************************************/

NXT:

If @Chk = 0
begin --если это создание , то нужно генерить ошибкуесли она есть
	If @ErrList <> '' 
	begin
		RAISERROR (@ErrList, 16,1)
		goto Err
	end
end
else --если это проверка просто выводим сообщение, даже если оно пустое
begin
	select @ErrList as ErrList 
	select @Res = @@error if @Res <> 0 goto Err
end

IF @ErrList = '' and @Chk = 0
BEGIN
	if @Act = 2
	begin
		update dbo.PDX_pay_Accounts
			set 
				Name = @Name,
				Descr = @Descr,
				Class = @Class,
				Code = @Code,
				NLM = @NC,
				DLM = getdate()
		where SetID = @SetID
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 1
	begin
		insert into dbo.PDX_pay_Accounts
			(Name, Descr, Class, Code, NC, DC, NLM, DLM)
		values 
			(@Name, @Descr, @Class, @Code, @NC, getdate(), @NC, getdate())
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 3
	begin
		delete from dbo.PDX_pay_Accounts where SetID = @SetID
		select @Res = @@error if @Res <> 0 goto Err
	end
END
	select @Res = @@error if @Res <> 0 goto Err

OK:

	return @Res
Err:
	return @Res

GO
/****** Object:  StoredProcedure [dbo].[PDX_payAmountp_Load] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_payAmountp_Load]
 @TransferGUID uniqueidentifier,
 @DocID varchar(128) output,
 @Amount money = null,
 @Result int = 0 output,
 @AmountP money = null,--Сумма оплаты
 @DateP datetime = null, --Дата оплаты
 @RequestID varchar(36) = null, --Внутренний ID заявки 1С (36 символов)
 @bDocID varchar(256) = null --Номер ЗнП в 1С

	
as
	declare  @Res int
declare --@ClassName varchar(128),
	@DocID_1 varchar(128)
	
set nocount on
	select
		@DocID = ltrim(rtrim(isnull(@DocID,''))),
		@DocID_1 = null,
		@Result = 0
	select @Res = @@error if @Res <> 0 goto Err
/*
	select @ClassName = DocType
	from PayDoxOP.dbo.PDXDocTypesConst
	where ConstName = 'RIK_CategoryName_KAZ_ORDPAY'
	select @Res = @@error if @Res <> 0 goto Err
*/
	exec PayDoxOP.[dbo].[PDX_payAmountp_LoadIntoDB]
		@TransferGUID = @TransferGUID,
		@DocID = @DocID_1 output,
		@Amount = @Amount,
		--@ClassName = @ClassName,
		@Result = @Result out,
		@AmountP = @AmountP,--Сумма оплаты
		@DateP = @DateP, --Дата оплаты
		@RequestID = @RequestID, --Внутренний ID заявки 1С (36 символов)
		@bDocID = @bDocID --Номер ЗнП в 1С
	if @Res <> 0 goto Err

	
	If isnull(@DocID_1,'') = ''
	begin	
		select @Result = 2
		raiserror ('Указанный документ не найден',16,1)
		goto Err
	end
	
	select @DocID = @DocID_1	
	select @Res = @@error if @Res <> 0 goto Err
	
	select @DocID as DocID
	select @Res = @@error if @Res <> 0 goto Err

OK:
set nocount off
	return @Res
Err:
set nocount off
	return @Res











GO
/****** Object:  StoredProcedure [dbo].[PDX_payAmountp_LoadIntoDB] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_payAmountp_LoadIntoDB]
	@TransferGUID uniqueidentifier,
	@DocID varchar(128) output,
	@Amount money = null,
	--@ClassName varchar(128),
	@Result int = 0 output,
    @AmountP money = null,--Сумма оплаты
    @DateP datetime = null, --Дата оплаты
    @RequestID varchar(36) = null, --Внутренний ID заявки 1С (36 символов)
    @bDocID varchar(256) = null --Номер ЗнП в 1С
AS
set nocount on
declare 
	@DocID_1 varchar(128), @Date_1 datetime
	declare  @Res int, @DocIDInt int,
	@Cls1 varchar(128), @Cls2 varchar(128)
	
	select
		@DocID = ltrim(rtrim(isnull(@DocID,''))),
		@DocID_1 = null,
		--@AmountP = ISNULL(@AmountP,0),
		--@RequestID = ISNULL(@RequestID,''),
		@bDocID = ISNULL(@bDocID,'')
	select @Res = @@error if @Res <> 0 goto Err
	
	set @Cls1 = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_ORDPAY')
	set @Cls2 = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_BUDG')

	select @DocID_1 = DocID, @Date_1 = DateSigned
	from dbo.Docs 
	where TransferGUID = @TransferGUID 
		--and ClassDoc = @ClassName
		and ClassDoc in (@Cls1, @Cls2)
	select @Res = @@error if @Res <> 0 goto Err

	If not @DocID_1 is null
	begin
	
		select @DocID = @DocID_1
		select @Res = @@error if @Res <> 0 goto Err
		
		If year(isnull(@Date_1,'1900-01-01')) <> 1900 
		begin
			select @Result = 1
			--raiserror ('В документе уже проставлен статус Оплачено',16,1)
			--goto Err
		end		
				
		update dbo.Docs
			set
				UserFieldMoney1 = case 
									when @Amount IS null 
										then UserFieldMoney1 
									else @Amount 
								end
		where DocID = @DocID
		select @Res = @@error if @Res <> 0 goto Err
		
		if (@AmountP is null or @DateP is null or isnull(@RequestID,'') = '')
		begin
		print '3'
			--select @Result = 3
			--raiserror ('Не указанна сумма оплаты, дата оплаты или ИД заявки из 1С',16,1)
			--goto Err
		end
		else
		begin
			if exists (select 1 from dbo.PayDetails where TransferGUID = @TransferGUID
								and RequestID = @RequestID)
			begin
				update dbo.PayDetails
					set 
						Amount = @AmountP,
						Date = @DateP,
						bDocID = @bDocID,
						DLM = GETDATE()
				where TransferGUID = @TransferGUID
					and RequestID = @RequestID
				select @Res = @@error if @Res <> 0 goto Err
			end
			else
			begin
				insert into dbo.PayDetails
					(TransferGUID, RequestID, Amount, Date, bDocID, DC, DLM)
				values
					(@TransferGUID, @RequestID, @AmountP, @DateP, @bDocID, GETDATE(), GETDATE())
				select @Res = @@error if @Res <> 0 goto Err
			end
			select @Res = @@error if @Res <> 0 goto Err
		end
		insert into dbo.Comments
			(UserID,
			UserName,
			ContactUserName,
			ContactUserID,
			PartnerName,
			DocID,
			DateCreation,
			DateEvent,
			DateEventEnd,
			Address,
			Subject,
			Comment,
			CommentType,
			SpecialInfo,
			FileName,
			--KeyField,
			PartnerID,
			Version,
			GUID,
			GUIDPartner,
			GUIDUser,
			GUIDDoc,
			Amount,
			FileNameOriginal,
			RIK_CommentType)
		values
			('Admin',--UserID,
			'System Administrator',--UserName,
			null,--ContactUserName,
			null,--ContactUserID,
			null,--PartnerName,
			@DocID,--DocID,
			getdate(),--DateCreation,
			null,--DateEvent,
			null,--DateEventEnd,
			'',--Address,
			null,--Subject,
			'Проставлена сумма Оплаты: ' + isnull(CAST(@Amount as varchar(100)),'') ,--Comment,
			'HISTORY',--CommentType,
			'PAYMENT',--SpecialInfo,
			null,--FileName,
			--KeyField,
			null,--PartnerID,
			'',--Version,
			NewID(),--GUID,
			null,--GUIDPartner,
			null,--GUIDUser,
			null,--GUIDDoc,
			null,--Amount,
			null,--FileNameOriginal,
			null)--RIK_CommentType)
		select @Res = @@error if @Res <> 0 goto Err
			
	end

OK:
set nocount off
	return @Res
Err:
set nocount off
	return @Res





GO
/****** Object:  StoredProcedure [dbo].[PDX_payCFO_Change] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[PDX_payCFO_Change]
	@Name varchar(512),
	@Descr varchar(256),
	@Manager varchar(96),
	@Accounter varchar(96),
	@txtKeyField varchar(10),
	@SetID int,
	--@ParentName varchar(512),
	@NC varchar(128),
	@Act int, --1--ceate, 2-update,3 delete
	@Chk bit = 0
	
as
	declare  @Res int

	declare @ErrList varchar(1024),
		/*@ParentID int,*/ @Cnt int

	select @Res = 0,@ErrList = ''
	
	create table #cfo (SetID int, ParentID int)

	select
		@Name = ltrim(rtrim(isnull(@Name,''))),
		@Descr = ltrim(rtrim(isnull(@Descr,''))),
		@Manager = ltrim(rtrim(isnull(@Manager,''))),
		@Accounter = ltrim(rtrim(isnull(@Accounter,''))),
		@txtKeyField = ltrim(rtrim(isnull(@txtKeyField,''))),
		@NC  = ltrim(rtrim(isnull(@NC,''))),
		--@ParentID = null,
		--@ParentName = ltrim(rtrim(isnull(@ParentName,''))),
		@Cnt = 1
	select @Res = @@error if @Res <> 0 goto Err
/*
If @ParentName like '%<%>%'
begin
	select @ParentID = dbo.PDX_SubstringReturn(@ParentName, charindex('<',@ParentName), charindex('>',@ParentName))
	select @Res = @@error if @Res <> 0 goto Err
end
*/
/************************************
ПРОВЕРКИ ВВЕДЕННЫХ ЗНАЧЕНИЙ
*************************************/
If @Name = ''
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Укажите наименование'
	goto NXT
end

If len(@Name) > 256 
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Превышена максимально допустимая длина Наименования (всего - ' + cast(len(@Name) as varchar(100)) + ', макс. - 256)'
	goto NXT
end

If exists (select 1 from dbo.PDX_pay_CFO where Name = @Name 
		and SetID <> isnull(@SetID,0))
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'ЦФО с указаным названием в справочнике уже существует'
	select @Res = @@error if @Res <> 0 goto Err		
end

If not @Manager like '%<%>%'
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Не указан (или указан некорректно) фин. менеджер.'
	goto NXT
end
else
begin
	if not exists (select 1 from dbo.Users where @Manager like '%<' + UserID + '>%' 
							and StatusActive in ('1','-') 
							and DateExpirationSecurity >= convert(datetime, convert(varchar(100), getdate(),104),104))
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Указанный фин. менеджер в справочнике Пользователей не существует (или у него истек срок доступа).'
		goto NXT
	end
end

If not @Accounter like '%<%>%'
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Не указан (или указан некорректно) бухгалтер.'
	goto NXT
end
else
begin
	if not exists (select 1 from dbo.Users where @Accounter like '%<' + UserID + '>%' 
							and StatusActive in ('1','-') 
							and DateExpirationSecurity >= convert(datetime, convert(varchar(100), getdate(),104),104))
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Указанный бухгалтер в справочнике Пользователей не существует (или у него истек срок доступа).'
		goto NXT
	end
end

If @txtKeyField = ''
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Укажите идентифкационный код (для 1С)'
	goto NXT
end
else
begin
	If len(@txtKeyField) > 10 
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Превышена максимально допустимая длина идентиф. кода (всего - ' + cast(len(@txtKeyField) as varchar(100)) + ', макс. - 10)'
		goto NXT
	end
	If exists (select 1 from dbo.PDX_pay_CFO where txtKeyField = @txtKeyField 
		and SetID <> isnull(@SetID,0))
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'ЦФО с указаным идент. кодом в справочнике уже существует'
		select @Res = @@error if @Res <> 0 goto Err		
	end

end

/*
If not @ParentID is null
begin
	if not exists (select 1 from dbo.PDX_pay_CFO where SetID = @ParentID)
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Родительский ЦФО не существует'
		select @Res = @@error if @Res <> 0 goto Err		
	end
	IF @Act = 2 
	begin 
		insert into #cfo (SetID)
		values (@SetID)
		select @Res = @@error if @Res <> 0 goto Err	

		while @cnt > 0 and not exists (select 1 from #cfo where SetID = @ParentID)
		begin
			insert into #cfo (SetID)
			select C.SetID
			from dbo.PDX_pay_CFO C
			inner join #cfo F on F.SetID = C.ParentID
			where not exists (select 1 from #cfo V where V.SetID = C.SetID)
			select @cnt=@@rowcount,@Res = @@error if @Res <> 0 goto Err	
		end
		select @Res = @@error if @Res <> 0 goto Err	
		
		If exists (select 1 from #cfo where SetID = @ParentID)
		begin
			select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
				'Некорректно указан Родительский ЦФО (нельзя в качестве родителя указывать дочерний узел).'
			select @Res = @@error if @Res <> 0 goto Err		
		end
	end
end

IF @Act = 3
begin
	If exists (select 1 from dbo.PDX_pay_CFO where ParentID = @SetID)
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Нальзя удалить элемент, у него есть подчиненые.'
		select @Res = @@error if @Res <> 0 goto Err		
	end
end
*/
/************************************/

NXT:

If @Chk = 0
begin --если это создание , то нужно генерить ошибкуесли она есть
	If @ErrList <> '' 
	begin
		RAISERROR (@ErrList, 16,1)
		goto Err
	end
end
else --если это проверка просто выводим сообщение, даже если оно пустое
begin
	select @ErrList as ErrList 
	select @Res = @@error if @Res <> 0 goto Err
end

IF @ErrList = '' and @Chk = 0
BEGIN
	if @Act = 2
	begin
		update dbo.PDX_pay_CFO
			set 
				Name = @Name,
				Descr = @Descr,
				Manager = @Manager,
				Accounter = @Accounter,
				txtKeyField = @txtKeyField,
				--ParentID = @ParentID,
				NLM = @NC,
				DLM = getdate()
		where SetID = @SetID
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 1
	begin
		insert into dbo.PDX_pay_CFO
			(Name, Descr, Manager, Accounter, txtKeyField,/*ParentID,*/NC, DC, NLM, DLM)
		values 
			(@Name, @Descr, @Manager,@Accounter ,@txtKeyField,/*@ParentID, */@NC, getdate(), @NC, getdate())
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 3
	begin
		delete from dbo.PDX_pay_CFO where SetID = @SetID
		select @Res = @@error if @Res <> 0 goto Err
	end
END
	select @Res = @@error if @Res <> 0 goto Err

	drop table #cfo
OK:

	return @Res
Err:
	return @Res



GO
/****** Object:  StoredProcedure [dbo].[PDX_PAYCopy_Fill] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE proc [dbo].[PDX_PAYCopy_Fill] 
	@ActionLogID int,
	@DocIDInt int
as

set nocount on
	
	insert into dbo.PDX_KAZCopy_LogDocs 
		(ActionLogID,DocID,DocIDInt,newDocID,newDocIDInt)
	values
		(@ActionLogID, null, @DocIDInt, null, null)
	
GO
/****** Object:  StoredProcedure [dbo].[PDX_PAYCopy_Start] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE proc [dbo].[PDX_PAYCopy_Start] 
	@MonthF int,
	@YearF int,
	@MonthT int,
	@YearT int,
	@Category varchar(128),
	@UserID varchar(16),
	@CurrUserID varchar(16)
as

set nocount on


	declare  @ActionLogID int, @Err varchar(1024)
	set @Err = ''
	
	if not @MonthF between 1 and 12
		or not @MonthT between 1 and 12
		or not @YearF > 1900
		or not @YearT > 1900
		or not exists (select 1 from dbo.DocTypes where name = @Category)
		or not exists (select 1 from dbo.Users where UserID = @UserID)
	begin
			set @Err = 'Некорректные параметры!'
	end
	else
	begin
		if exists (
			select 1
			from dbo.Users
			where UserID = @CurrUserID
				and (ClassDoc like '%' +  @Category + '%' or ClassDoc + CHAR(13) +CHAR(13) like dbo.PDX_CLSGrGet(@Category) or ClassDoc like '%"ALL"%')
			)
		begin
			insert into dbo.PDX_KAZCopy_Log 
				(ClassDoc, ActionUserID,	ActionDate,	MonthF,	YearF,	MonthT,	YearT,	UserID)
			values (@Category, @CurrUserID, GETDATE(), @MonthF, @YearF, @MonthT, @YearT, @UserID)
			set @ActionLogID = @@IDENTITY
		end
		else
		begin
			set @Err = 'У Вас не прав на создание документов категории ' + @Category
		end
	end
	select @ActionLogID as ActionLogID, @Err as Err
	
GO
/****** Object:  StoredProcedure [dbo].[PDX_PAYCopyLog_Read] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE proc [dbo].[PDX_PAYCopyLog_Read] 
	@ActionLogID int
as

set nocount on


	
	select 	L.ActionLogID,			
		L.UserID as UserID,
		L.MonthF as MonthF,
		L.MonthT as MonthT,
		L.YearF as YearF,
		L.YearT as YearT,
		L.ClassDoc as ClassDoc
	from dbo.PDX_KAZCopy_Log L 
	where L.ActionLogID = @ActionLogID





GO
/****** Object:  StoredProcedure [dbo].[PDX_PAYCOR_Unload] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_PAYCOR_Unload] --ВЫГРУЗКА КОРРЕКТИРУЮЩИХ ЗАЯВОК
	@Date datetime
				--будем брать докмуенты завершенные после указанной даты/времени
as


set nocount on

	declare @Result int
	set @Result = 0

	declare @ClassName varchar(128)
	
	select @ClassName = dbo.PDX_CLSGet('RIK_CategoryName_FIN_CORPAY')
	select @Result = @@error if @Result <> 0 goto Err
	
	
	create table #tbl_pay
		(DocID varchar(128),
		StatusDevelopment varchar(1),
		DocIDParent varchar(128), 
		DocIDPrevious varchar(128),
		ParentID varchar(128), 
		PreviousID varchar(128),
		PartnerName varchar(512),
		TaxID varchar(32))
	
	insert into #tbl_pay (DocID, StatusDevelopment, DocIDParent, DocIDPrevious, PartnerName)
	select DocID, StatusDevelopment, DocIDParent, DocIDPrevious, PartnerName
	from dbo.Docs D
	where ClassDoc = @ClassName
		and UPPER(ISNULL(IsActive,'')) = 'Y'	
		and ISNULL(StatusDevelopment,'') ='4'
		and ISNULL(StatusCompletion,'') <>'0'
		and DateApproved >= @Date
	select @Result = @@error if @Result <> 0 goto Err
		
	update P
		set ParentID = isnull(Par.DocIDIncoming,'')
	from #tbl_pay as P
	inner join dbo.Docs Par on Par.DocID = P.DocIDParent
	select @Result = @@error if @Result <> 0 goto Err

	update P
		set PreviousID = isnull(Prev.DocIDIncoming,'')
	from #tbl_pay as P
	left join dbo.Docs Prev on Prev.DocID = P.DocIDPrevious
	select @Result = @@error if @Result <> 0 goto Err
	
	update P
		set TaxID = isnull(PN.TaxID,'')
	from #tbl_pay as P
	left join dbo.Partners PN on PN.Name = P.PartnerName 
	select @Result = @@error if @Result <> 0 goto Err

		--тепер собираем информацию
	select
		D.TransferGUID, --УНИКАЛЬНЫЙ ИД ЗАПИСИС. DocID - теоретически м.б. изменен
		D.DocID,  --Рег. номер
		D.UserFieldDate3, --рег. дата

		D.UserFieldText8,  --Бизнес единица
		dbo.PDX_fn_pay_FirmGET(D.UserFieldText8) as ID_UFT8,

		2 as STATUS,--утверждена
		
		--****************************************
		P.PartnerName,  --Отправитель\Получатель
		isnull(P.TaxID,'') as PNTaxID, --ИНН
		--isnull(PN.TaxID,'') as PNTaxID, --ИНН

		D.Name,  --Назначение
		D.Description,  --Основание

		isnull(P.DocIDParent,'') as DocIDParent,  --Основной договор
		isnull(P.ParentID,'')as ParentID,
		--isnull(Par.DocIDIncoming,'') as ParentID,

		isnull(P.DocIDPrevious,'') as DocIDPrevious,  --Для работ по договору
		isnull(P.PreviousID,'')as PreviousID,
		--isnull(Prev.DocIDIncoming,'') as PreviousID,
		--****************************************
		D.UserFieldText2,  --исх ЦФО
		dbo.PDX_fn_pay_CFOGET(D.UserFieldText2) as ID_UFT2,

		D.UserFieldText3,  --треб ЦФО
		dbo.PDX_fn_pay_CFOGET(D.UserFieldText3) as ID_UFT3,

		D.UserFieldText5,  --исх Статья ПРиЗ
		dbo.PDX_fn_pay_PRiZGET(D.UserFieldText5) as ID_UFT5,
			
		D.UserFieldText7,  --треб Статья ПРиЗ
		dbo.PDX_fn_pay_PRiZGET(D.UserFieldText7) as ID_UFT7,
		
		D.UserFieldText4,  --Проект
		isnull(U.Field2,'') as ID_UFT4,

		D.UserFieldText6,  --Счет
		dbo.PDX_fn_pay_AccountGET(D.UserFieldText6) as ID_UFT6 ,
		--****************************************
		D.Currency,  --Валюта
		isnull(Curr.Code2,'') as CurrCode2,--

		D.AmountDoc,--Сумма
		
		D.NameAproval,  --Фин директор
		isnull(NA.Name,'') as NameApp,
		D.NameCreation,  --Автор/Инициатор
		isnull(NC.Name,'') as NameCr,

		D.DateApproved, --дата утверждения
		D.UserFieldText1,  --Наименование листа согласования
		D.ListToReconcile  --Лист согласования
	from #tbl_pay P
	inner join dbo.Docs D on D.DocID = P.DocID
	left join dbo.UserDirValues U on U.UDKeyField = 35 and U.Field1 = D.UserFieldText4
	left join dbo.CurrencyRates Curr on Curr.Code = D.Currency
	left join dbo.Users NA on D.NameAproval like '%<' + NA.UserID + '>%'
	left join dbo.Users NC on D.NameCreation like '%<' + NC.UserID + '>%'
	order by D.DocID
	select @Result = @@error if @Result <> 0 goto Err
	
	
		
set nocount off
	return @Result
Err:

set nocount off
		return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_PAYCORn_Unload] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_PAYCORn_Unload] --ВЫГРУЗКА КОРРЕКТИРУЮЩИХ ЗАЯВОК
	@Date datetime 
as

set nocount on

	declare @Result int
	set @Result = 0
	--set @Date to 1 minute earlier then the last exchange session to avoid any missed time intervals
	set @Date = dateadd(mi, -1, @Date)

	create table #KAZC
	(	TransferGUID uniqueidentifier,
		DocID varchar(128),
		UserFieldDate3 datetime,
		UserFieldText8 varchar(1024),
		ID_UFT8 varchar(10),
		STATUS tinyint,
		PartnerName varchar(512),
		PNTaxID varchar(64),
		PortalID int,
		Name varchar(255),
		Description varchar(1024),
		DocIDParent varchar(128),
		ParentID varchar(128),
		DocIDPrevious varchar(128),
		PreviousID varchar(128),
		UserFieldText2 varchar(1024),
		ID_UFT2 varchar(1024),
		UserFieldText3 varchar(1024), 
		ID_UFT3 varchar(1024),
		UserFieldText5 varchar(1024),
		ID_UFT5 varchar(1024),			
		UserFieldText7 varchar(1024),
		ID_UFT7 varchar(1024),
		UserFieldText4 varchar(1024),
		ID_UFT4 varchar(1024),
		UserFieldText6 varchar(1024), 
		ID_UFT6 int,
		Currency varchar(12),
		CurrCode2 varchar(12),
		AmountDoc money,		
		NameAproval varchar(96),
		NameApp varchar(96),
		NameCreation varchar(96),  
		NameCr varchar(96),
		DateApproved datetime,
		UserFieldText1 varchar(1024),
		ListToReconcile varchar(1024))

	insert into #KAZC
	exec PayDoxOP.dbo.PDX_PAYCORn_UnloadFromDB
	@Date= @Date
	
	
	select * from #KAZC

	drop table #KAZC
	
set nocount off
	return @Result
Err:

set nocount off
		return @Result








GO
/****** Object:  StoredProcedure [dbo].[PDX_PAYCORn_UnloadFromDB] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
--drop proc [dbo].[PDX_PAYCORn_UnloadFromDB] 
CREATE proc [dbo].[PDX_PAYCORn_UnloadFromDB] --ВЫГРУЗКА КОРРЕКТИРУЮЩИХ ЗАЯВОК
	@Date datetime
				--будем брать докмуенты завершенные после указанной даты/времени
as


set nocount on

	declare @Result int
	set @Result = 0

	declare @ClassName varchar(128)
	
	select @ClassName = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_CORPAY')
	select @Result = @@error if @Result <> 0 goto Err
	
	
	create table #tbl_pay
		(DocID varchar(128),
		StatusDevelopment varchar(1),
		DocIDParent varchar(128), 
		DocIDPrevious varchar(128),
		ParentID varchar(128), 
		PreviousID varchar(128),
		PartnerName varchar(512),
		TaxID varchar(32),
		PortalID int)
	
	insert into #tbl_pay (DocID, StatusDevelopment, DocIDParent, DocIDPrevious, PartnerName)
	select DocID, StatusDevelopment, DocIDParent, DocIDPrevious, PartnerName
	from dbo.Docs D
	where ClassDoc = @ClassName
		and UPPER(ISNULL(IsActive,'')) = 'Y'	
		and ISNULL(StatusDevelopment,'') ='4'
		and ISNULL(StatusCompletion,'') <>'0'
		and DateApproved >= @Date
	select @Result = @@error if @Result <> 0 goto Err
		
	update P
		set ParentID = isnull(Par.DocIDIncoming,'')
	from #tbl_pay as P
	inner join dbo.Docs Par on Par.DocID = P.DocIDParent
	select @Result = @@error if @Result <> 0 goto Err

	update P
		set PreviousID = isnull(Prev.DocIDIncoming,'')
	from #tbl_pay as P
	left join dbo.Docs Prev on Prev.DocID = P.DocIDPrevious
	select @Result = @@error if @Result <> 0 goto Err
	
	update P
		set TaxID = isnull(PN.TaxID,''),
		PortalID = PN.PortalID
	from #tbl_pay as P
	left join dbo.Partners PN on PN.Name = P.PartnerName 
	select @Result = @@error if @Result <> 0 goto Err

		--тепер собираем информацию
	select
		D.TransferGUID, --УНИКАЛЬНЫЙ ИД ЗАПИСИС. DocID - теоретически м.б. изменен
		D.DocID,  --Рег. номер
		D.UserFieldDate3, --рег. дата

		D.UserFieldText8,  --Бизнес единица
		dbo.PDX_fn_pay_FirmGET(D.UserFieldText8) as ID_UFT8,

		2 as STATUS,--утверждена
		
		--****************************************
		P.PartnerName,  --Отправитель\Получатель
		isnull(P.TaxID,'') as PNTaxID, --ИНН
		P.PortalID as PortalID,
		--isnull(PN.TaxID,'') as PNTaxID, --ИНН

		D.Name,  --Назначение
		D.Description,  --Основание

		isnull(P.DocIDParent,'') as DocIDParent,  --Основной договор
		isnull(P.ParentID,'')as ParentID,
		--isnull(Par.DocIDIncoming,'') as ParentID,

		isnull(P.DocIDPrevious,'') as DocIDPrevious,  --Для работ по договору
		isnull(P.PreviousID,'')as PreviousID,
		--isnull(Prev.DocIDIncoming,'') as PreviousID,
		--****************************************
		
		D.UserFieldText2,  --исх ЦФО
		dbo.PDX_fn_pay_CFOGET(D.UserFieldText2) as ID_UFT2,
	
		D.UserFieldText3,  --треб ЦФО
		dbo.PDX_fn_pay_CFOGET(D.UserFieldText3) as ID_UFT3,

		D.UserFieldText5,  --исх Статья ПРиЗ
		dbo.PDX_fn_pay_ItemGET(D.UserFieldText5) as ID_UFT5,
			
		D.UserFieldText7,  --треб Статья ПРиЗ
		dbo.PDX_fn_pay_ItemGET(D.UserFieldText7) as ID_UFT7,
		
/**********изменение****************/
		D.UserFieldText4,  --Код ИСР
		dbo.PDX_SubstringReturn(D.UserFieldText4,CHARINDEX('<',D.UserFieldText4),CHARINDEX('>',D.UserFieldText4)) as ID_UFT4,
		--isnull(U.Field2,'') as ID_UFT4,
/***********************************/

		D.UserFieldText6,  --Счет
		dbo.PDX_fn_pay_AccountGET(D.UserFieldText6) as ID_UFT6 ,
		--****************************************
		D.Currency,  --Валюта
		isnull(Curr.Code2,'') as CurrCode2,--

		D.AmountDoc,--Сумма
		
		D.NameAproval,  --Фин директор
		isnull(NA.Name,'') as NameApp,
		D.NameCreation,  --Автор/Инициатор
		isnull(NC.Name,'') as NameCr,

		case
			when not D.DateApproved IS null and YEAR(D.DateApproved)>1900 then D.DateApproved
			else GETDATE()
		end as DateApproved, --дата утверждения
		D.UserFieldText1,  --Наименование листа согласования
		D.ListToReconcile  --Лист согласования
	from #tbl_pay P
	inner join dbo.Docs D on D.DocID = P.DocID
	--left join dbo.UserDirValues U on U.UDKeyField = 35 and U.Field1 = D.UserFieldText4
	left join dbo.CurrencyRates Curr on Curr.Code = D.Currency
	left join dbo.Users NA on D.NameAproval like '%<' + NA.UserID + '>%'
	left join dbo.Users NC on D.NameCreation like '%<' + NC.UserID + '>%'
	order by D.DocID
	select @Result = @@error if @Result <> 0 goto Err
	
	
		
set nocount off
	return @Result
Err:

set nocount off
		return @Result




GO
/****** Object:  StoredProcedure [dbo].[PDX_PayDetailsGet] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

create proc [dbo].[PDX_PayDetailsGet]
	@IDS xml
as
begin

begin try

;with dd (d,i,c) as
(
select
	d.DocID
	,d.DocIdInt
	,d.ClassDoc
from dbo.Docs d
	inner join (select
		T.id.value('text()[1]','nvarchar(255)') as docid
		from @IDS.nodes('root/id') as T(id)) as ids on ids.docid = d.DocID
where d.ClassDoc in (dbo.PDX_CLSGet('RIK_CategoryName_KAZ_ORDPAY'),dbo.PDX_CLSGet('RIK_CategoryName_KAZ_BUDG'))
	and d.IsActive='Y'
),
pays (id, tx1,am1,tx2,dlm,nlm) as
(
	select
		dd.i
		,p1.Tx1
		,p1.Am1
		,p1.Tx2
		,p1.DLM
		,p1.NLM
	from dbo.PDXDocDetails p1
		inner join dd on dd.d=p1.DocID and dd.c =dbo.PDX_CLSGet('RIK_CategoryName_KAZ_ORDPAY')
	union all
	select
		dd.i
		,p2.Purpose
		,p2.Amount
		,p2.VAT
		,p2.DLM
		,dbo.User_PaydoxLoginByParam(p2.NLM,u.Name)
	from dbo.DocsPayBudget p2
		inner join dd on dd.i=p2.DocIDInt and dd.c =dbo.PDX_CLSGet('RIK_CategoryName_KAZ_BUDG')
		left join Users u on p2.NLM = u.UserID
)
select
	d.DocID
	,d.DateActivation
	,d.UserFieldDate1
	,d.Currency
	,d.UserFieldText8
	,d.NameAproval
	,d.UserFieldText2
	,d.Author
	,d.PartnerName
	,d.UserFieldText4
	,d.UserFieldText5
	,d.Name
	,d.AmountDoc
	,d.UserFieldText3
	,d.DocIDParent
	,d.DocIDPrevious
	,d.UserFieldText6
	,d.NameCreation
	,d.DateSigned
	,d.UserFieldText1
	,d.ListToReconcile
	,d.Correspondent
	,d.UserFieldMoney1
	,d.UserFieldMoney2
	,d.IsActive
	,pays.tx1 as [Purpose]
	,pays.am1 as [Amount]
	,pays.tx2 as [VAT]
	,pays.dlm as [DLM]
	,pays.nlm as [NLM]
	,d.ClassDoc
from dbo.Docs d
	inner join pays on pays.id = d.DocIdInt

end try
begin catch
    declare @ErrorMessage nvarchar(max), @ErrorSeverity int, @ErrorState int;
    select @ErrorMessage = ERROR_MESSAGE() + ' Line ' + cast(ERROR_LINE() as nvarchar(5)), @ErrorSeverity = ERROR_SEVERITY(), @ErrorState = ERROR_STATE();

	select top 0
		d.DocID
		,d.DateActivation
		,d.UserFieldDate1
		,d.Currency
		,d.UserFieldText8
		,d.NameAproval
		,d.UserFieldText2
		,d.Author
		,d.PartnerName
		,d.UserFieldText4
		,d.UserFieldText5
		,d.Name
		,d.AmountDoc
		,d.UserFieldText3
		,d.DocIDParent
		,d.DocIDPrevious
		,d.UserFieldText6
		,d.NameCreation
		,d.DateSigned
		,d.UserFieldText1
		,d.ListToReconcile
		,d.Correspondent
		,d.UserFieldMoney1
		,d.UserFieldMoney2
		,d.IsActive
		,dd.Tx1 as [Purpose]
		,dd.Am1 as [Amount]
		,dd.Tx2 as [VAT]
		,dd.DLM
		,dd.NLM
		,d.ClassDoc
	from dbo.Docs d
		inner join dbo.PDXDocDetails dd on dd.DocID=d.DocID

    raiserror (@ErrorMessage, @ErrorSeverity, @ErrorState);
end catch
end

GO
/****** Object:  StoredProcedure [dbo].[PDX_payDirections_Change] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_payDirections_Change]
	@Name varchar(1024),
	@Descr varchar(256),
	@Project varchar(1024),
	@SetID int,
	@NC varchar(128),
	@Act int, --1--ceate, 2-update,3 delete
	@Chk bit = 0
	
as
	declare  @Res int

	declare @ErrList varchar(1024)

	select @Res = 0,@ErrList = ''
	


	select
		@Name = replace(ltrim(rtrim(isnull(@Name,''))), char(13)+char(10), ' '),
		@Project = ltrim(rtrim(isnull(@Project,''))),
		@Descr = ltrim(rtrim(isnull(@Descr,''))),
		@NC  = ltrim(rtrim(isnull(@NC,'')))
	select @Res = @@error if @Res <> 0 goto Err

If right(@Project,1) = '/'
begin
	select @Project = left(@Project, len(@Project)-1)
	select @Res = @@error if @Res <> 0 goto Err
end

/************************************
ПРОВЕРКИ ВВЕДЕННЫХ ЗНАЧЕНИЙ
*************************************/
If @Name = ''
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Укажите наименование'
	goto NXT
end
If len(@Name) > 768 
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Превышена максимально допустимая длина Наименования (всего - ' + cast(len(@Name) as varchar(100)) + ', макс. - 768)'
	goto NXT
end
If exists (select 1 from dbo.PDX_pay_Directions where Name = @Name 
		and SetID <> isnull(@SetID,-1))
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Направление с указаным названием в справочнике уже существует'
	select @Res = @@error if @Res <> 0 goto Err		
end

If @Project = ''
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Укажите наименование Проекта'
	goto NXT
end
else
begin
	If not exists (select 1 from dbo.UserDirValues where UDKeyField = 35 and Field1 = @Project)
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Указанный Проект не существует'
		goto NXT
	end
end
/************************************/

NXT:

If @Chk = 0
begin --если это создание , то нужно генерить ошибкуесли она есть
	If @ErrList <> '' 
	begin
		RAISERROR (@ErrList, 16,1)
		goto Err
	end
end
else --если это проверка просто выводим сообщение, даже если оно пустое
begin
	select @ErrList as ErrList 
	select @Res = @@error if @Res <> 0 goto Err
end

IF @ErrList = '' and @Chk = 0
BEGIN
	if @Act = 2
	begin
		update dbo.PDX_pay_Directions
			set 
				Name = @Name,
				Project = @Project,
				Descr = @Descr,
				NLM = @NC,
				DLM = getdate()
		where SetID = @SetID
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 1
	begin
		insert into dbo.PDX_pay_Directions
			(Name, Project, Descr, NC, DC, NLM, DLM)
		values 
			(@Name, @Project, @Descr, @NC, getdate(), @NC, getdate())
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 3
	begin
		delete from dbo.PDX_pay_Directions where SetID = @SetID
		select @Res = @@error if @Res <> 0 goto Err
	end
END
	select @Res = @@error if @Res <> 0 goto Err

OK:

	return @Res
Err:
	return @Res
GO
/****** Object:  StoredProcedure [dbo].[PDX_payDocData_Get] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE [dbo].[PDX_payDocData_Get] 
	-- Add the parameters for the stored procedure here
	@DocID varchar(128)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
    
create table #tbl (
		[DocID] varchar(128)--рег номер документа
      ,[GUID] uniqueidentifier-- не используется
      ,[DocIDadd]  varchar(128)-- проектный номер документа
      ,[DocIDIncoming] varchar(128)--№ договора контрагента
      ,[DocIDParent] varchar(128)--Осн.договор (для доп. соглаш.)
      ,[DocIDPrevious] varchar(128)--Для работ по договору
      ,[Author] varchar(1024)--не используется
      ,[Correspondent] varchar(4000)--список рассылки
      ,[Resolution] varchar(1024)--не используется
      ,[History] varchar(1024)--не используется
      ,[Result] varchar(1024)--не используется
      ,[PercentCompletion] int--не используется
      ,[Department] varchar(255)--Подразделение отв. за исполнение договора
      ,[Name] varchar(255) --Заголовок
      ,[Description] varchar(4000)--Предмет договор
      ,[LocationURL] varchar(128)--не используется
      ,[LocationPaper] varchar(128)--не используется
      ,[FileNamePrefix] varchar(255)--не используется
      ,[FileName] varchar(255)--не используется
      ,[FileNameNameLastModif1ication] varchar(1024)--не используется
      ,[FileNameDateLastAccessed] datetime--не используется
      ,[FileNameDateLastModification] datetime--не используется
      ,[LocationPath] varchar(1024)-- Принято в Бухгалтерию
      ,[ExtInt] char(1)--не используется
      ,[PartnerName]varchar(128)--Контрагент 2
      ,[StatusDevelopment] char(1)--статус разработки
      ,[StatusPayment] char(2)--не используется
      ,[StatusArchiv] char(1)--не используется
      ,[StatusCompletion] char(1)--не используется
      ,[StatusDelivery] char(1)--не используется
      ,[TypeDoc] char(1)--не используется
      ,[ClassDoc] varchar(64)--категория документа
      ,[ActDoc] varchar(64)--вид документа
      ,[InventoryUnit] varchar(64)--не используется
      ,[PaymentMethod] varchar(64)--не используется
      ,[AmountDoc] money--сумма докмуента
      ,[QuantityDoc] real--не используется
      ,[DateActivation] datetime--рег. дата
      ,[SecurityLevel] tinyint--уровень доступа
      ,[DateCreation] datetime--дата создания
      ,[DateCompletion] datetime--Дата прекращения срока действия
      ,[DateCompleted] datetime--не используется
      ,[DateExpiration] datetime--не используется
      ,[NameCreation]  varchar(96)--содатель документа
      ,[NameAproval] varchar(96)--Подписывающий 1
      ,[NameApproved] varchar(96)--фактический Подписант1(техническое поле)
      ,[DateApproved] datetime--дата подписания
      ,[ListToEdit] varchar(1024)--список редакторов
      ,[ListToReconcile] varchar(4096)--список согласующих
      ,[ListReconciled] varchar(4096)--список согласовавших
      ,[NameResponsible] varchar(96)--ответственный за исполнение
      ,[NameControl] varchar(96)--не используется
      ,[NameLastModification] varchar(96)--кто последний редактировал карточку
      ,[DateLastModification] datetime--дата последнего редактирования карточки
      ,[UserFieldText1] varchar(1024)--Наименование листа согласования
      ,[UserFieldText2] varchar(1024)--Вид договора
      ,[UserFieldText3] varchar(1024)--Сторона 1
      ,[UserFieldText4] varchar(1024)--Проект
      ,[UserFieldText5] varchar(1024)--Подписывающий 2
      ,[UserFieldText6] varchar(1024)--Дополнительные контрагенты -
      ,[UserFieldText7] varchar(1024)--Объект
      ,[UserFieldText8] varchar(1024)--не используется
      ,[UserFieldMoney1] money--в т.ч. НДС
      ,[UserFieldMoney2] money--не используется
      ,[UserFieldDate1] datetime--не используется
      ,[UserFieldDate2] datetime--не используется
      ,[UserFieldDate3] datetime--не используется
      ,[UserFieldDate4] datetime--не используется
      ,[UserFieldDate5] datetime--не используется
      ,[UserFieldDate6] datetime--не используется
      ,[UserFieldDate7] datetime--не используется
      ,[UserFieldDate8] datetime--не используется
      ,[IsActive] varchar(1)--статус Активен
      ,[DateActive] datetime--дата последней активации
      ,[BusinessProcessStep] varchar(255)--не используется
      ,[ExtPassword] varchar(48)--не используется
      ,[DateSigned] datetime--подписано Контрагентом(дата)
      ,[Currency] varchar(12)--валюта
      ,[CurrencyRate] money--не используется
      ,[Rank] varchar(64)--срочность соглаосвания
      ,[ListToView] varchar(4000)--не используется
      ,[Content] ntext--не используется
      ,[License] nvarchar(18)--не используется
      ,[TransferGUID] uniqueidentifier--GUID идентификатор
      ,CurrCode2 varchar(12)--цифровой код валюты из справочника Валют
	  ,NameApp varchar(128)--ФИО подписанта1
	  ,NameCr varchar(128)--ФИО создателя карточки
	  ,NameResp varchar(128)--ФИО ответственного исполнителя
	  ,RegDate_first datetime--дата регистрации(нажатия кнопки) первая
	  ,RegDate_last datetime--дата регистрации(нажатия кнопки) последняя
	  ,Reg_Count int--кол-во "регистраций"
	  ,ID_UFT7 varchar(64)--код Объекта
	  ,ID_UFT2 int--ИД Вида договора
	  ,CFO  varchar(10)  --ЦФО
	  ,isGP bit-- Содержит % генподряда  (значения 0 или 1)
	  ,GP decimal(5,2)--% генподряда
	  ,ExistAvans char(1)--Особый % зачета аванса
	  ,AvansPercent decimal(5,2))--% зачета аванса
	  
	  
	  insert into #tbl
	  exec PayDoxOP.[dbo].[PDX_payDocData_GetFromDB] @DocID = @DocID
	 
	  
	  select * from #tbl
	  drop table #tbl 
END











GO
/****** Object:  StoredProcedure [dbo].[PDX_payDocData_GetFromDB] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE  PROCEDURE [dbo].[PDX_payDocData_GetFromDB] 
	-- Add the parameters for the stored procedure here
	@DocID varchar(128)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	declare @RegDate_first datetime,
			@RegDate_last datetime,
			@Reg_Count int,
			@ClassDoc varchar(128)
			
	select @DocID = ltrim(rtrim(ISNULL(@DocID,''))),
		@ClassDoc = null
	
	select 
		@ClassDoc = ClassDoc	
	from dbo.Docs 
	where DocID = @DocID
	
	If not (@ClassDoc like 'Договоры / %'
		or @ClassDoc = 'Прочие / Договоры')
	begin
		select @DocID = null --делаем, так чтобы оставить результирующий select без изменений, 
		--т.е. чтобы рекордсет был всегда. когда передан не номер договора, то он будет пустой, но будет, это важно
	end
	
	If ISNULL(@DocID,'') <> ''
	begin
		--только для договоров		
		select 
			@RegDate_first = MIN (DateCreation),
			@RegDate_last = MAX (DateCreation),
			@Reg_Count = COUNT(*)
		from dbo.Comments 
		where UPPER(CommentType) = 'HISTORY'
			and DocID = @DocID
			and (Comment like 'Документ зарегистрирован , Информация изменена%'
				or Comment like 'Document registered , Information updated%')
		group by DocID
	end 
	
/*	
DocID   --рег номер документа
GUID -- не используется
DocIDadd -- проектный номер документа
DocIDIncoming --№ договора контрагента
DocIDParent --Осн.договор (для доп. соглаш.)
DocIDPrevious --Для работ по договору
Author --не используется
Correspondent --список рассылки
Resolution--не используется
History--не используется
Result--не используется
PercentCompletion--не используется
Department--Подразделение отв. за исполнение договора
Name --Заголовок
Description --Предмет договор
LocationURL--не используется
LocationPaper--не используется
FileNamePrefix--не используется
FileName--не используется
FileNameNameLastModification--не используется
FileNameDateLastAccessed--не используется
FileNameDateLastModification--не используется
LocationPath -- Принято в Бухгалтерию
ExtInt--не используется
PartnerName--Контрагент 2
StatusDevelopment --статус разработки
StatusPayment--не используется
StatusArchiv--не используется
StatusCompletion--не используется
StatusDelivery--не используется
TypeDoc--не используется
ClassDoc--категория документа
ActDoc--вид документа
InventoryUnit--не используется
PaymentMethod--не используется
AmountDoc--сумма докмуента
QuantityDoc--не используется
DateActivation--рег. дата
SecurityLevel --уровень доступа
DateCreation--дата создания
DateCompletion--Дата прекращения срока действия
DateCompleted--не используется
DateExpiration--не используется
NameCreation--содатель документа
NameAproval--Подписывающий 1
NameApproved--фактический Подписант1(техническое поле)
DateApproved--дата подписания
ListToEdit--список редакторов
ListToReconcile--список согласующих
ListReconciled--список согласовавших
NameResponsible--ответственный за исполнение
NameControl --не используется
NameLastModification --кто последний редактировал карточку
DateLastModification--дата последнего редактирования карточки
UserFieldText1--Наименование листа согласования
UserFieldText2--Вид договора
UserFieldText3--Сторона 1
UserFieldText4--Проект
UserFieldText5--Подписывающий 2
UserFieldText6--Дополнительные контрагенты -
UserFieldText7--Объект
UserFieldText8--не используется
UserFieldMoney1--в т.ч. НДС
UserFieldMoney2--не используется
UserFieldDate1--не используется
UserFieldDate2--не используется
UserFieldDate3--не используется
UserFieldDate4--не используется
UserFieldDate5--не используется
UserFieldDate6--не используется
UserFieldDate7--не используется
UserFieldDate8--не используется
IsActive --статус Активен
DateActive --дата последней активации
BusinessProcessStep--не используется
ExtPassword--не используется
DateSigned--подписано Контрагентом(дата)
Currency--валюта
CurrencyRate--не используется
Rank--срочность соглаосвания
ListToView--не используется
Content--не используется
License--не используется
TransferGUID--GUID идентификатор
CurrCode2 --цифровой код валюты из справочника Валют
NameApp--ФИО подписанта1
NameCr--ФИО создателя карточки
NameResp--ФИО ответственного исполнителя
RegDate_first --дата регистрации(нажатия кнопки) первая
RegDate_last--дата регистрации(нажатия кнопки) последняя
Reg_Count,--кол-во "регистраций"
ID_UFT7,--код Объекта
ID_UFT2,--ИД Вида договора
CFO, --ЦФО
isGP,-- Содержит % генподряда  (значения 0 или 1)
GP --% генподряда
ExistAvans --Особый % зачета аванса
AvansPercent--% зачета аванса
*/
    -- Insert statements for procedure here
SELECT D.[DocID]
      ,D.[GUID]
      ,D.[DocIDadd]
      ,D.[DocIDIncoming]
      ,D.[DocIDParent]
      ,D.[DocIDPrevious]
      ,D.[Author]
      ,D.[Correspondent]
      ,D.[Resolution]
      ,D.[History]
      ,D.[Result]
      ,D.[PercentCompletion]
      ,D.[Department]
      ,D.[Name]
      ,D.[Description]
      ,D.[LocationURL]
      ,D.[LocationPaper]
      ,D.[FileNamePrefix]
      ,D.[FileName]
      ,D.[FileNameNameLastModification]
      ,D.[FileNameDateLastAccessed]
      ,D.[FileNameDateLastModification]
      ,D.[LocationPath]
      ,D.[ExtInt]
      ,D.[PartnerName]
      ,D.[StatusDevelopment]
      ,D.[StatusPayment]
      ,D.[StatusArchiv]
      ,D.[StatusCompletion]
      ,D.[StatusDelivery]
      ,D.[TypeDoc]
      ,D.[ClassDoc]
      ,D.[ActDoc]
      ,D.[InventoryUnit]
      ,D.[PaymentMethod]
      ,D.[AmountDoc]
      ,D.[QuantityDoc]
      ,D.[DateActivation]
      ,D.[SecurityLevel]
      ,D.[DateCreation]
      ,D.[DateCompletion]
      ,D.[DateCompleted]
      ,D.[DateExpiration]
      ,D.[NameCreation]
      ,D.[NameAproval]
      ,D.[NameApproved]
      ,D.[DateApproved]
      ,D.[ListToEdit]
      ,D.[ListToReconcile]
      ,D.[ListReconciled]
      ,D.[NameResponsible]
      ,D.[NameControl]
      ,D.[NameLastModification]
      ,D.[DateLastModification]
      ,D.[UserFieldText1]
      ,D.[UserFieldText2]
      ,D.[UserFieldText3]
      ,D.[UserFieldText4]
      ,D.[UserFieldText5]
      ,D.[UserFieldText6]
      ,D.[UserFieldText7]
      ,D.[UserFieldText8]
      ,D.[UserFieldMoney1]
      ,D.[UserFieldMoney2]
      ,D.[UserFieldDate1]
      ,D.[UserFieldDate2]
      ,D.[UserFieldDate3]
      ,D.[UserFieldDate4]
      ,D.[UserFieldDate5]
      ,D.[UserFieldDate6]
      ,D.[UserFieldDate7]
      ,D.[UserFieldDate8]
      ,D.[IsActive]
      ,D.[DateActive]
      ,D.[BusinessProcessStep]
      ,D.[ExtPassword]
      ,D.[DateSigned]
      ,D.[Currency]
      ,D.[CurrencyRate]
      ,D.[Rank]
      ,D.[ListToView]
      ,D.[Content]
      ,D.[License]
      ,D.[TransferGUID]
      ,isnull(Curr.Code2,'') as CurrCode2
	  ,isnull(NA.Name,'') as NameApp
	  ,isnull(NC.Name,'') as NameCr
	  ,isnull(NR.Name,'') as NameResp
	  ,@RegDate_first as RegDate_first
	  ,@RegDate_last as RegDate_last
	  ,@Reg_Count AS Reg_Count,
	  dbo.PDX_SubstringReturn(D.UserFieldText7,CHARINDEX('<',D.UserFieldText7),CHARINDEX('>',D.UserFieldText7)) as ID_UFT7,
	  V.IntKeyField as ID_UFT2,
	  [dbo].[PDX_fn_pay_CFOGET] (F.CFO) as CFO,
	  cast(case F.ExistGPPercent when '1' then 1 else 0 end as bit) as isGP,
	  F.GPPercent as GP,
	  F.ExistAvans,
	  F.AvansPercent
  FROM [dbo].[Docs] as D
  left join dbo.CurrencyRates Curr on Curr.Code = D.Currency
  left join dbo.Users NA on NA.UserID = dbo.PDX_SubstringReturn(D.NameAproval, CHARINDEX('<',D.NameAproval), charindex('>',D.NameAproval))--D.NameAproval like '%<' + NA.UserID + '>%'
  left join dbo.Users NC on NC.UserID = dbo.PDX_SubstringReturn(D.NameCreation, CHARINDEX('<',D.NameCreation), charindex('>',D.NameCreation))--D.NameCreation like '%<' + NC.UserID + '>%'
  left join dbo.Users NR on NR.UserID = dbo.PDX_SubstringReturn(D.NameResponsible, CHARINDEX('<',D.NameResponsible), charindex('>',D.NameResponsible))--D.NameResponsible like '%<' + NR.UserID + '>%'  
  left join dbo.UserDirValues V on V.UDKeyField = 30 and V.Field1 = D.UserFieldText2
  left join dbo.[DocsCFO] F on F.DocIDInt = D.DocIDInt
  WHERE DocID = @DocID --если @docid=null, то рекордсет возвращае\тся заведомо пустой
END








GO
/****** Object:  StoredProcedure [dbo].[PDX_payFirms_Change] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_payFirms_Change]
	@Name varchar(512),
	--@Manager varchar(96),
	@Accounter varchar(128),
	@Descr varchar(256),
	@VO tinyint = 0,
	@Code varchar(10) = '',
	@SetID int,
	@NC varchar(128),
	@Act int, --1--ceate, 2-update,3 delete
	@Chk bit = 0
	
as
	declare  @Res int

	declare @ErrList varchar(1024)

	select @Res = 0,@ErrList = ''
	


	select
		@Name = ltrim(rtrim(isnull(@Name,''))),
		@Accounter = ltrim(rtrim(isnull(@Accounter,''))),
		--@Manager = ltrim(rtrim(isnull(@Manager,''))),
		@Descr = ltrim(rtrim(isnull(@Descr,''))),
		@VO = ltrim(rtrim(isnull(@VO,0))),
		@NC  = ltrim(rtrim(isnull(@NC,''))),
		@Code  = ltrim(rtrim(isnull(@Code,'')))
	select @Res = @@error if @Res <> 0 goto Err


/************************************
ПРОВЕРКИ ВВЕДЕННЫХ ЗНАЧЕНИЙ
*************************************/
If @Name = ''
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Укажите наименование'
	goto NXT
end
If @Code = ''
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Укажите код'
	goto NXT
end

If len(@Name) > 256 
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Превышена максимально допустимая длина Наименования (всего - ' + cast(len(@Name) as varchar(100)) + ', макс. - 256)'
	goto NXT
end

If exists (select 1 from dbo.PDX_pay_Firms where Name = @Name 
		and SetID <> isnull(@SetID,-1))
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Фирма с указаным названием в справочнике уже существует'
	select @Res = @@error if @Res <> 0 goto Err		
end

If exists (select 1 from dbo.PDX_pay_Firms where Code = @Code 
		and SetID <> isnull(@SetID,-1))
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Фирма с указаным кодом в справочнике уже существует'
	select @Res = @@error if @Res <> 0 goto Err		
end
/*
If not @Manager like '%<%>%'
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Не указан (или указан некорректно) фин. менеджер.'
	goto NXT
end
else
begin
	if not exists (select 1 from dbo.Users where @Manager like '%<' + UserID + '>%' 
							and StatusActive in ('1','-') 
							and DateExpirationSecurity >= convert(datetime, convert(varchar(100), getdate(),104),104))
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Указанный фин. менеджер в справочнике Пользователей не существует (или у него истек срок доступа).'
		goto NXT
	end
end
*/
/************************************/

NXT:

If @Chk = 0
begin --если это создание , то нужно генерить ошибкуесли она есть
	If @ErrList <> '' 
	begin
		RAISERROR (@ErrList, 16,1)
		goto Err
	end
end
else --если это проверка просто выводим сообщение, даже если оно пустое
begin
	select @ErrList as ErrList 
	select @Res = @@error if @Res <> 0 goto Err
end

IF @ErrList = '' and @Chk = 0
BEGIN
	if @Act = 2
	begin
		update dbo.PDX_pay_Firms
			set 
				Name = @Name,
				Accounter = @Accounter,
				--Manager = @Manager,
				Descr = @Descr,
				Vnutr_Oborot = @VO,
				Code = @Code,
				NLM = @NC,
				DLM = getdate()
		where SetID = @SetID
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 1
	begin
		insert into dbo.PDX_pay_Firms
			(Name, Accounter,/*Manager,*/ Descr, Vnutr_Oborot, Code, NC, DC, NLM, DLM)
		values 
			(@Name, @Accounter,/*@Manager, */@Descr, @VO, @Code, @NC, getdate(), @NC, getdate())
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 3
	begin
		delete from dbo.PDX_pay_Firms where SetID = @SetID
		select @Res = @@error if @Res <> 0 goto Err
	end
END
	select @Res = @@error if @Res <> 0 goto Err

OK:

	return @Res
Err:
	return @Res





GO
/****** Object:  StoredProcedure [dbo].[PDX_payItems_Change] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--drop proc [dbo].[PDX_payItems_Change]
--go
CREATE proc [dbo].[PDX_payItems_Change]
	@Name varchar(512),
	@Code varchar(128),
	@Descr varchar(256),
	@SetID int,
	@ParentName varchar(512),
	@NC varchar(128),
	@E1 char(1),
	@E2 char(1),
	@E3 char(1),
	@Gr varchar(256),
	@OT varchar(128) = null,
	@Ex tinyint = 0,
	@Actual varchar(3) = null,
	@Act int, --1--ceate, 2-update,3 delete
	@Chk bit = 0
	
as
	declare  @Res int

	declare @ErrList varchar(1024),
		@ParentID int, @Cnt int,
		@ParentCode varchar(64),
		@GrParent varchar(256),
		@blnInAct bit

	select @Res = 0,@ErrList = ''
	
	create table #cfo (SetID int, ParentID int)
/*
E1,E2

0 - проверка за месяц
2 - проверка за год
1 - нет проверки
*/
	set @Actual = ISNULL(@Actual,'')
	select
		@E1 = case when @E1 in ('1','2','0') then @E1 else '0' end,
		@E2 = case when @E2 in ('1','2','0') then @E2 else '0' end,
		@E3 = case @E3 when '1' then @E3 else '' end,
		@Name = ltrim(rtrim(isnull(@Name,''))),
		@Code = ltrim(rtrim(isnull(@Code,''))),
		@Descr = ltrim(rtrim(isnull(@Descr,''))),
		@NC  = ltrim(rtrim(isnull(@NC,''))),
		@ParentID = null,
		@ParentName = ltrim(rtrim(isnull(@ParentName,''))),
		@Cnt = 1,
		@OT = ltrim(rtrim(isnull(@Gr,''))),
		@Gr = 	ltrim(rtrim(isnull(@OT,''))),
		@Ex = ISNULL(@Ex,0)
	select @Res = @@error if @Res <> 0 goto Err
	
	set @blnInAct = case @Actual when 'ДА' then 0 else 1 end

If @ParentName like '%<%>%'
begin
	select @ParentCode = dbo.PDX_SubstringReturn(@ParentName, charindex('<',@ParentName), charindex('>',@ParentName))
	select @Res = @@error if @Res <> 0 goto Err
end

/************************************
ПРОВЕРКИ ВВЕДЕННЫХ ЗНАЧЕНИЙ
*************************************/
If @Act <> 3
begin
If @Name = ''
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Укажите наименование'
	goto NXT
end
If len(@Name) > 256 
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Превышена максимально допустимая длина Наименования (всего - ' + cast(len(@Name) as varchar(100)) + ', макс. - 256)'
	goto NXT
end
If @Code = ''
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Укажите код статьи'
	goto NXT
end
If len(@Code) > 64 
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Превышена максимально допустимая длина Кода (всего - ' + cast(len(@Code) as varchar(100)) + ', макс. - 64)'
	goto NXT
end
If @Gr = ''
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Укажите группу'
	goto NXT
end

/*If exists (select 1 from dbo.PDX_pay_Items where Name = @Name 
		and SetID <> isnull(@SetID,-1))
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Статья ПРиЗ с указаным названием в справочнике уже существует'
	select @Res = @@error if @Res <> 0 goto Err		
end*/

If exists (select 1 from dbo.PDX_pay_Items where Code = @Code 
		and SetID <> isnull(@SetID,-1))
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Статья ПРиЗ с указаным кодом в справочнике уже существует'
	select @Res = @@error if @Res <> 0 goto Err		
end

If not @ParentCode is null
begin
	select @ParentID = SetID,
		@GrParent = GrName
	from dbo.PDX_pay_Items 
	where Code = @ParentCode
	select @Res = @@error if @Res <> 0 goto Err
	
	If @ParentID is null
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Родительский Статья ПРиЗ не существует'
		select @Res = @@error if @Res <> 0 goto Err		
	end
	IF @Act = 2 
	begin 
		insert into #cfo (SetID)
		values (@SetID)
		select @Res = @@error if @Res <> 0 goto Err	

		while @cnt > 0 and not exists (select 1 from #cfo where SetID = @ParentID)
		begin
			insert into #cfo (SetID)
			select C.SetID
			from dbo.PDX_pay_Items C
			inner join #cfo F on F.SetID = C.ParentID
			where not exists (select 1 from #cfo V where V.SetID = C.SetID)
			select @cnt=@@rowcount,@Res = @@error if @Res <> 0 goto Err	
		end
		select @Res = @@error if @Res <> 0 goto Err	
		
		If exists (select 1 from #cfo where SetID = @ParentID)
		begin
			select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
				'Некорректно указана Родительская Статья ПРиЗ (нельзя в качестве родителя указывать дочерний узел).'
			select @Res = @@error if @Res <> 0 goto Err		
		end
	end
	
	If @Gr <> @GrParent 
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Группа, указанная для данной статьи, должна совпадать с группой родительской статьи'
		select @Res = @@error if @Res <> 0 goto Err		
	end
	
end --If not @ParentCode is null
end

IF @Act = 3
begin
	If exists (select 1 from dbo.PDX_pay_Items where ParentID = @SetID)
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Нальзя удалить элемент, у него есть подчиненые.'
		select @Res = @@error if @Res <> 0 goto Err		
	end
end
/************************************/

NXT:

If @Chk = 0
begin --если это создание , то нужно генерить ошибкуесли она есть
	If @ErrList <> '' 
	begin
		RAISERROR (@ErrList, 16,1)
		goto Err
	end
end
else --если это проверка просто выводим сообщение, даже если оно пустое
begin
	select @ErrList as ErrList 
	select @Res = @@error if @Res <> 0 goto Err
end

IF @ErrList = '' and @Chk = 0
BEGIN
	if @Act = 2
	begin
		update dbo.PDX_pay_Items
			set 
				Name = @Name,
				Code = @Code,
				Descr = @Descr,
				ParentID = @ParentID,
				NLM = @NC,
				e1 = @E1,
				e2 = @E2,
				e3 = @E3,
				GrName = @Gr,
				OType = @OT,
				Expens = @Ex,
				inActive = @blnInAct,
				DLM = getdate()
		where SetID = @SetID
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 1
	begin
		insert into dbo.PDX_pay_Items
			(Name, Code, Descr, ParentID, e1, e2, e3, GrName, OType, Expens, inActive, NC, DC, NLM, DLM)
		values 
			(@Name, @Code, @Descr, @ParentID, @E1, @E2, @E3, @Gr, @OT, @Ex,@blnInAct,@NC, getdate(), @NC, getdate())
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 3
	begin
		delete from dbo.PDX_pay_Items where SetID = @SetID
		select @Res = @@error if @Res <> 0 goto Err
	end
END
	select @Res = @@error if @Res <> 0 goto Err

	drop table #cfo
OK:

	return @Res
Err:
	return @Res











GO
/****** Object:  StoredProcedure [dbo].[PDX_payItems2016_Change] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--drop proc [dbo].[PDX_payItems2016_Change]
--go
CREATE proc [dbo].[PDX_payItems2016_Change]
	@Name varchar(512),
	@Code varchar(128),
	@Descr varchar(256),
	@SetID int,
	@ParentName varchar(512),
	@NC varchar(128),
	@E1 char(1),
	@E2 char(1),
	@E3 char(1),
	@Gr varchar(256),
	@OT varchar(128) = null,
	@Ex tinyint = 0,
	@Actual varchar(3) = null,
	@Act int, --1--ceate, 2-update,3 delete
	@Chk bit = 0
	
as
	declare  @Res int

	declare @ErrList varchar(1024),
		@ParentID int, @Cnt int,
		@ParentCode varchar(64),
		@GrParent varchar(256),
		@blnInAct bit

	select @Res = 0,@ErrList = ''
	
	create table #cfo (SetID int, ParentID int)
/*
E1,E2

0 - проверка за месяц
2 - проверка за год
1 - нет проверки
*/
	set @Actual = ISNULL(@Actual,'')
	select
		@E1 = case when @E1 in ('1','2','0') then @E1 else '0' end,
		@E2 = case when @E2 in ('1','2','0') then @E2 else '0' end,
		@E3 = case @E3 when '1' then @E3 else '' end,
		@Name = ltrim(rtrim(isnull(@Name,''))),
		@Code = ltrim(rtrim(isnull(@Code,''))),
		@Descr = ltrim(rtrim(isnull(@Descr,''))),
		@NC  = ltrim(rtrim(isnull(@NC,''))),
		@ParentID = null,
		@ParentName = ltrim(rtrim(isnull(@ParentName,''))),
		@Cnt = 1,
		@OT = ltrim(rtrim(isnull(@Gr,''))),
		@Gr = 	ltrim(rtrim(isnull(@OT,''))),
		@Ex = ISNULL(@Ex,0)
	select @Res = @@error if @Res <> 0 goto Err
	
	set @blnInAct = case @Actual when 'ДА' then 0 else 1 end

If @ParentName like '%<%>%'
begin
	select @ParentCode = dbo.PDX_SubstringReturn(@ParentName, charindex('<',@ParentName), charindex('>',@ParentName))
	select @Res = @@error if @Res <> 0 goto Err
end

/************************************
ПРОВЕРКИ ВВЕДЕННЫХ ЗНАЧЕНИЙ
*************************************/
If @Act <> 3
begin
If @Name = ''
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Укажите наименование'
	goto NXT
end
If len(@Name) > 256 
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Превышена максимально допустимая длина Наименования (всего - ' + cast(len(@Name) as varchar(100)) + ', макс. - 256)'
	goto NXT
end
If @Code = ''
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Укажите код статьи'
	goto NXT
end
If len(@Code) > 64 
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Превышена максимально допустимая длина Кода (всего - ' + cast(len(@Code) as varchar(100)) + ', макс. - 64)'
	goto NXT
end
If @Gr = ''
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Укажите группу'
	goto NXT
end

/*If exists (select 1 from dbo.PDX_pay_Items2016 where Name = @Name 
		and SetID <> isnull(@SetID,-1))
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Статья ПРиЗ с указаным названием в справочнике уже существует'
	select @Res = @@error if @Res <> 0 goto Err		
end*/

If exists (select 1 from dbo.PDX_pay_Items2016 where Code = @Code 
		and SetID <> isnull(@SetID,-1))
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Статья ПРиЗ с указаным кодом в справочнике уже существует'
	select @Res = @@error if @Res <> 0 goto Err		
end

If not @ParentCode is null
begin
	select @ParentID = SetID,
		@GrParent = GrName
	from dbo.PDX_pay_Items2016 
	where Code = @ParentCode
	select @Res = @@error if @Res <> 0 goto Err
	
	If @ParentID is null
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Родительский Статья ПРиЗ не существует'
		select @Res = @@error if @Res <> 0 goto Err		
	end
	IF @Act = 2 
	begin 
		insert into #cfo (SetID)
		values (@SetID)
		select @Res = @@error if @Res <> 0 goto Err	

		while @cnt > 0 and not exists (select 1 from #cfo where SetID = @ParentID)
		begin
			insert into #cfo (SetID)
			select C.SetID
			from dbo.PDX_pay_Items2016 C
			inner join #cfo F on F.SetID = C.ParentID
			where not exists (select 1 from #cfo V where V.SetID = C.SetID)
			select @cnt=@@rowcount,@Res = @@error if @Res <> 0 goto Err	
		end
		select @Res = @@error if @Res <> 0 goto Err	
		
		If exists (select 1 from #cfo where SetID = @ParentID)
		begin
			select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
				'Некорректно указана Родительская Статья ПРиЗ (нельзя в качестве родителя указывать дочерний узел).'
			select @Res = @@error if @Res <> 0 goto Err		
		end
	end
	
	If @Gr <> @GrParent 
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Группа, указанная для данной статьи, должна совпадать с группой родительской статьи'
		select @Res = @@error if @Res <> 0 goto Err		
	end
	
end --If not @ParentCode is null
end

IF @Act = 3
begin
	If exists (select 1 from dbo.PDX_pay_Items2016 where ParentID = @SetID)
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Нальзя удалить элемент, у него есть подчиненые.'
		select @Res = @@error if @Res <> 0 goto Err		
	end
end
/************************************/

NXT:

If @Chk = 0
begin --если это создание , то нужно генерить ошибкуесли она есть
	If @ErrList <> '' 
	begin
		RAISERROR (@ErrList, 16,1)
		goto Err
	end
end
else --если это проверка просто выводим сообщение, даже если оно пустое
begin
	select @ErrList as ErrList 
	select @Res = @@error if @Res <> 0 goto Err
end

IF @ErrList = '' and @Chk = 0
BEGIN
	if @Act = 2
	begin
		update dbo.PDX_pay_Items2016
			set 
				Name = @Name,
				Code = @Code,
				Descr = @Descr,
				ParentID = @ParentID,
				NLM = @NC,
				e1 = @E1,
				e2 = @E2,
				e3 = @E3,
				GrName = @Gr,
				OType = @OT,
				Expens = @Ex,
				inActive = @blnInAct,
				DLM = getdate()
		where SetID = @SetID
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 1
	begin
		insert into dbo.PDX_pay_Items2016
			(Name, Code, Descr, ParentID, e1, e2, e3, GrName, OType, Expens, inActive, NC, DC, NLM, DLM)
		values 
			(@Name, @Code, @Descr, @ParentID, @E1, @E2, @E3, @Gr, @OT, @Ex,@blnInAct,@NC, getdate(), @NC, getdate())
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 3
	begin
		delete from dbo.PDX_pay_Items2016 where SetID = @SetID
		select @Res = @@error if @Res <> 0 goto Err
	end
END
	select @Res = @@error if @Res <> 0 goto Err

	drop table #cfo
OK:

	return @Res
Err:
	return @Res












GO
/****** Object:  StoredProcedure [dbo].[PDX_payItemTree] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[PDX_payItemTree]
	
as
	declare  @Res int, @Cnt int

	select @Res = 0, @Cnt = 0
	
    declare @cfo table
		(Name varchar(456),  --ANTON: that's what I have changed to make it working after the 4-th level of nesting was added
		Code varchar(256),
		FullName varchar(4096),
		GrName varchar(256),
		Descr varchar(256),
		PKF int,
		OperType varchar(128),
		OI int)


	insert into @cfo
		(Name, Code, FullName, Descr,PKF, GrName, OperType)
	select
		F.Name + '<' + cast(F.Code as varchar(100)) + '>', 
		F.Code,
		'', 
		F.Descr, F.ParentID, F.GrName, F.OType
	from dbo.PDX_pay_Items F
	where not exists (select 1 from dbo.PDX_pay_Items C where C.ParentID = F.SetID)
	select @Res = @@error if @Res <> 0 goto Err

	select @Cnt = count(*) from @cfo
	select @Res = @@error if @Res <> 0 goto Err

	while @Cnt > 0 
	begin
		update C
			set
				PKF = F.ParentID,
				FullName = F.Name + '<' + cast(F.Code as varchar(100)) + '>/' + C.FullName
		from @cfo C
		inner join dbo.PDX_pay_Items F on F.SetID = C.PKF
		select @Cnt = @@rowcount, @Res = @@error if @Res <> 0 goto Err
	end
	
	--для сортировки
	if not exists (select 1 from @cfo
				where isnumeric(case when Code like '%.%' then charindex('.',Code) else Code end) = 0)
	begin
		update @cfo
			set OI = case when Code like '%.%' then Left(Code,charindex('.',Code)-1) else Code end
		select @Res = @@error if @Res <> 0 goto Err
	end
	select @Res = @@error if @Res <> 0 goto Err

	select Name, Code, FullName,GrName, OperType, Descr from @cfo 
    order by OI, Code,FullName
	select @Res = @@error if @Res <> 0 goto Err
	--drop table @cfo
OK:

	return @Res
Err:
	return @Res



GO
/****** Object:  StoredProcedure [dbo].[PDX_PAYn_Unload] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[PDX_PAYn_Unload] --ВЫГРУЗКА ЗАЯВОК
	@Date datetime 
as

set nocount on

	declare @Result int
	set @Result = 0
	--set @Date to 1 minute earlier then the last exchange session to avoid any missed time intervals
	set @Date = dateadd(mi, -1, @Date)
	
	create table #KAZ
	(TransferGUID uniqueidentifier,
	DocID varchar(128),
	DateActive datetime,
	UserFieldText8 varchar(1024),
	ID_UFT8 varchar(10),
	STATUS tinyint,
	PartnerName varchar(512),
	PNTaxID varchar(64),
	PortalID int,
	Name varchar(255),
	Description varchar(1024),
	DocIDParent varchar(128),
	ParentID varchar(128),
	DocIDPrevious varchar(128),
	PreviousID varchar(128),
	UserFieldText2 varchar(1024),
	ID_UFT2 varchar(1024),
	UserFieldText5 varchar(1024),
	ID_UFT5 varchar(1024),
	UserFieldText7 varchar(1024),
	UserFieldText4 varchar(1024),
	ID_UFT4 varchar(1024),
	UserFieldText6 varchar(1024),
	ID_UFT6 int,
	Currency varchar(12),
	CurrCode2 varchar(12),
	AmountDoc money,
	AmountDescr varchar(2048),
	AmountVAT varchar(255),
	AmountID uniqueidentifier,
	NameAproval varchar(96),
	NameApp varchar(96),
	NameCreation varchar(96),
	NameCr varchar(96),
	DateApproved datetime,
	DateSigned datetime,
	UserFieldText1 varchar(1024),
	ListToReconcile varchar(4096),
	LinkID varchar(512),
	Avans varchar(64),
	VnutrOborot tinyint,
	
	BUDescr varchar(264), --Основание платежа 
	ID_BUDescr varchar(264), --ИД Основания платежа 
	BUKBK varchar(128), --КБК 
	BUKPP varchar(128), --КПП 
	BUOKTMO varchar(128), --ОКТМО 
	BUMonth varchar(2), --Месяц 
	BUYear varchar(4), --Год периода 
	BUStatus varchar(512), --Статус платежа 
	ID_BUStatus varchar(512), --ИД Статуса платежа 
	BUPeriod varchar(264), --Налоговый период 
	ID_BUPeriod varchar(264), --ИД Налогового периода
	ClassDoc varchar(128),
	DateActivation datetime,
	UserFieldDate1 datetime,
	CurrentReconcile varchar(4096),
	UserFieldDate2 datetime,
	AmountCode varchar(255))

	insert into #KAZ
	exec PayDoxOP.dbo.PDX_PAYn_UnloadFromDB
	@Date = @Date
	
	select * from #KAZ

	drop table #KAZ
	
set nocount off
	return @Result
Err:

set nocount off
		return @Result





GO
/****** Object:  StoredProcedure [dbo].[PDX_PAYn_UnloadFromDB] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--drop proc [dbo].[PDX_PAYn_UnloadFromDB]
CREATE proc [dbo].[PDX_PAYn_UnloadFromDB]
	@Date datetime
	
as
/*
ВСЕ ВОЗМОЖНЫЕ СТАТУСЫ - STATUS:
	-3 - ошибка в статусе
	-2 - отменен
	-1 - неактивен
	 0 - отказано в согласовании
	 1 - на согласовании
	 2 - утверждена
	 3 - оплачена
	 4 - отменена
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
данная процедура оперирует только статусами:
	-3 - ошибка в статусе
 	 0 - отказано в согласовании
	 1 - на согласовании
	 2 - утверждена
	 4 - отменена
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Процедура отбирает карточки документов "Заявка на оплату", которые были:
	АКТИВИРОВАНЫ - дата последней активации (DateActive из табл. Docs)
		(Изменения только полей карточке, загрузка файлов, написание комментариев к карточке не учитывается)
	ИЛИ
	ИЗМЕНЕНЫ - дата последнего изменения (DateLastModifacation из табл. Docs)
	ИЛИ
	УТВЕРЖДЕНЫ - дата последнего утверждения (DateApproved из табл. Docs)
после указанной даты (@Date)
    ИЛИ 
    ОТМЕНЕНЫ - статус отменено
В выборку также попадают документы, в которых после указанной даты (@Date) были отказы в согласовании.
Но если такой отказ был отозван(отправлено на повторное согласование или отказавший был исключен из ЛС), 
то карточка в выборку не попадает.
Это обусловлено тем, что нас интересует только ТЕКУЩИЙ(действительный) статус документа "отказано в согласоании".
Если отказ был отозван, то статус документа вернулся в состояние "требует согласования" и документ нас будет интересовать, 
если он попадает под DateActive/DateLastModification/DateApproved
	
Процедура возвращает след. данные:
	TrasferGUID, 	--УНИКАЛЬНЫЙ ИД ЗАПИСИС. (примеч. DocID - теоретически м.б. изменен)
	DocID,  		--Рег. номер
	DateActive, 	--дата последней активации
	STATUS,			--ТЕКУЩИЙ СТАТУС ДОКУМЕНТА

	UserFieldText8,	--Бизнес единица
	ID_UFT8,		--ИД Бизнес единицы

	PartnerName,  	--Отправитель\Получатель
	PNTaxID,		--ИНН Отправителя\Получателя
	PortalID		--ид контрагента на портале

	Name,  			--Назначение
	Description,  	--Основание

	DocIDParent,  	--Номер Пайдокс осн. договора
	ParentID		--Бумажн. номер осн. договора,

	DocIDPrevious,  --Номер ПАйдокс "Для работ по договору"
	PreviousID,		--Бумажн. номер "Для работ по договору"

	UserFieldText2, --ЦФО
	ID_UFT2,		--ИД ЦФО
	
	UserFieldText5, --Статья ПРиЗ
	ID_UFT5,		--Полная "ветка" ЦФО. В угловых скобках указан код ЦФО

	UserFieldText7, --Наличный расчет  (ДА/НЕТ)

	UserFieldText4, --Код ИСР

	UserFieldText6, --Счет
	ID_UFT6,		--ИД Счета

	Currency,  		--Код1 Валюты (из карточки)
	CurrCode2,		--Код2 Валюты (из справочника)

	AmountDoc,  	--Сумма
	AmountDescr,	--описание к сумме
	AmountID,		--ID сумме
	
	NameAproval,  	--Заявитель (утверждающий)
	NameCreation,  	--Автор (создатель карточки).  Д.б. NameAproval = NameCreation
	DateApproved, 	--дата утверждения
	DateSigned,  	--Дата оплаты  - NULL - если не стоит

	UserFieldText1, --Наименование листа согласования
	ListToReconcile --Лист согласования
	
	DateActivation datetime, --рег дата
	UserFieldDate1 dattime --крайянаа дата оплаты
*/
	
	declare  @Res int

	declare @DocID varchar(128),
		@StopRefuseFlag bit,
		@StopRefuseFlag2 bit


	set nocount on

	create table #tbl_pay
		(DocIDInt int,
		DocID varchar(128),
		StatusDevelopment varchar(1),
		VisaRefuse bit,
		Flg bit default 0,
		DocIDParent varchar(128), 
		DocIDPrevious varchar(128),
		ParentID varchar(128), 
		PreviousID varchar(128),
		PartnerName varchar(512),
		TaxID varchar(32),
		PortalID int,
		LinkID varchar(512))

	create table #del_summ
		(DocIDInt int, 
		DocID varchar(128),
		Am1 money,
		SetID uniqueidentifier,
		Tx1 varchar(2048))
		
	declare @ErrList varchar(4000),
		@ClassName varchar(128),
		@ClassName2 varchar(128)

	select @ClassName = DocType,
		@StopRefuseFlag = StopRefuseFlag 
	from dbo.PDXDocTypesConst
	where ConstName = 'RIK_CategoryName_KAZ_ORDPAY'
	select @Res = @@error if @Res <> 0 goto Err

	select @ClassName2 = DocType,
		@StopRefuseFlag2 = StopRefuseFlag 
	from dbo.PDXDocTypesConst
	where ConstName = 'RIK_CategoryName_KAZ_BUDG'
	select @Res = @@error if @Res <> 0 goto Err

	select @Res = 0,@ErrList = ''
	
	--по датам из комментов
	--отказ в согласовании, причем только если этот отказ не был отозван
	insert into #tbl_pay
		(DocIDInt, DocID,	StatusDevelopment, VisaRefuse, DocIDParent, DocIDPrevious, PartnerName)
	select distinct D.DocIDInt, D.DocID, D.StatusDevelopment, 
			case --условие, что отказ не был отозван (отзыв отказа - это или удалили из ЛС отказника или отменили его оказ в согл.)
				when isnull(D.ListReconciled,'') like '%-<%' 
						and isnull(D.ListToReconcile,'') like '%<' + C.UserID + '>%'
						and isnull(D.ListReconciled,'') like '%-<' + C.UserID + '>%'
					then 1 
				else 0 
			end, D.DocIDParent, D.DocIDPrevious, D.PartnerName
	from dbo.Comments C
	inner join 	dbo.Docs D on C.DocIDInt = D.DocIDInt
		and D.ClassDoc in (@ClassName, @ClassName2) --смотрим чтобы была нужная категория
		and year(isnull(D.DateSigned,'1900-01-01')) = 1900 -- "неоплаченая" заявка
		and Upper(isnull(D.isActive,'')) = 'Y' --активная карточка
		and isnull(D.StatusCompletion,'') <> '0' --неотмененая карточка (отмененные это отдельный блок)
		and case when isnull(ListReconciled,'') like '%-<%' then 1 else 0 end = 1
	where Upper(isnull(C.CommentType,'')) = 'VISA' --берем отказ в согласовании
		and Upper(isnull(C.SpecialInfo,'')) = 'VISAOKREFUSE'
		and C.DateCreation >= @Date
	select @Res = @@error if @Res <> 0 goto Err

	--по датам из комментов
	--отправка на повторное согласование - смысл в том, чтобы "засечь" изменение статуса с "приостановлено-есть отказ" на "требует согласоание"
	--вариант когда при отмене стаус не меняется нам в принципе не интересен, но так как отделить эти ситуации невозможно - будем "брать" все
	
	--добавленяем все виды комментов, которые относятся к согл/отказ, т.к. тепреь хотим еще отслеживать обязательных согласующих
	insert into #tbl_pay
		(DocIDInt, DocID,	StatusDevelopment, VisaRefuse, DocIDParent, DocIDPrevious, PartnerName)
	select distinct D.DocIDInt, D.DocID, D.StatusDevelopment, 
			dbo.PDX_fn_stopReconcilation(D.ListToReconcile, D.ListReconciled, case D.ClassDoc when @ClassName then @StopRefuseFlag else @StopRefuseFlag2 end),
			D.DocIDParent, D.DocIDPrevious, D.PartnerName
	from dbo.Comments C
	inner join 	dbo.Docs D on C.DocIDInt = D.DocIDInt
		and D.ClassDoc in (@ClassName, @ClassName2) --смотрим чтобы была нужная категория
		and year(isnull(D.DateSigned,'1900-01-01')) = 1900 -- "неоплаченая" заявка
		and Upper(isnull(D.isActive,'')) = 'Y' --активная карточка
		and isnull(D.StatusCompletion,'') <> '0' --неотмененая карточка (отмененные это отдельный блок)
	where Upper(isnull(C.CommentType,'')) = 'VISA' --берем отказ в согласовании
		and Upper(isnull(C.SpecialInfo,'')) in ('PARTVISACANCEL','VISAOK','VISAOKREFUSE','VISAOKREFUSERESET','VISAOKRESET')
		and C.DateCreation >= @Date
		and not exists(select 1 from #tbl_pay P where P.DocIDInt = D.DocIDInt)--не повторяемся, если карточка отобралась через отказ
	select @Res = @@error if @Res <> 0 goto Err

	--по датам из картчоки
	insert into #tbl_pay
		(DocIDInt, DocID,	StatusDevelopment, VisaRefuse, DocIDParent, DocIDPrevious, PartnerName)
	select distinct D.DocIDInt, D.DocID, D.StatusDevelopment, 
		dbo.PDX_fn_stopReconcilation(ListToReconcile, ListReconciled, case D.ClassDoc when @ClassName then @StopRefuseFlag else @StopRefuseFlag2 end), 
		D.DocIDParent, D.DocIDPrevious, D.PartnerName
	from dbo.Docs D
	where D.ClassDoc  in (@ClassName, @ClassName2) --смотрим чтобы была нужная категория
	and (isnull(D.DateActive,D.DateLastModification) >= @Date or --отбираем по дате последней активаци
		isnull(D.DateLastModification, D.DateCreation) >= @Date or --отбираем по дате последнего изм-я
		isnull(D.DateApproved,'1900-01-01') >= @Date) --отбираем по дате утв-я
	and year(isnull(D.DateSigned,'1900-01-01')) = 1900-- "неоплаченая" заявка
	and Upper(isnull(D.isActive,'')) = 'Y'--активная карточка
	and isnull(D.StatusCompletion,'') <> '0'	--неотмененая карточка (отмененные это отдельный блок)
	and not exists(select 1 from #tbl_pay P where P.DocIDInt = D.DocIDInt)--не повторяемся, если карточка отобралась через отказ
	select @Res = @@error if @Res <> 0 goto Err

	--по дате корректировке сумм
	insert into #tbl_pay
		(DocIDInt, DocID,	StatusDevelopment, VisaRefuse, DocIDParent, DocIDPrevious, PartnerName)
	select distinct D.DocIDInt, D.DocID, D.StatusDevelopment, 
		dbo.PDX_fn_stopReconcilation(ListToReconcile, ListReconciled, case D.ClassDoc when @ClassName then @StopRefuseFlag else @StopRefuseFlag2 end), 
		D.DocIDParent, D.DocIDPrevious, D.PartnerName
	from dbo.PDXDocDetails T
		inner join dbo.Docs D on D.DocID = T.DocID
			and  D.ClassDoc = @ClassName --смотрим чтобы была нужная категория
			and year(isnull(D.DateSigned,'1900-01-01')) = 1900-- "неоплаченая" заявка
			and Upper(isnull(D.isActive,'')) = 'Y'--активная карточка
			and isnull(D.StatusCompletion,'') <> '0'	--неотмененая карточка (отмененные это отдельный блок)
	where T.DLM >= @Date  --отбираем по дате последнего изм-я
	and not exists(select 1 from #tbl_pay P where P.DocIDInt = D.DocIDInt)--не повторяемся, если карточка отобралась через отказ
	select @Res = @@error if @Res <> 0 goto Err

	--по дате из детализации заявки на платеж
	insert into #tbl_pay
		(DocIDInt, DocID,	StatusDevelopment, VisaRefuse, DocIDParent, DocIDPrevious, PartnerName)
	select distinct D.DocIDInt, D.DocID, D.StatusDevelopment, 
		dbo.PDX_fn_stopReconcilation(ListToReconcile, ListReconciled, case D.ClassDoc when @ClassName then @StopRefuseFlag else @StopRefuseFlag2 end), 
		D.DocIDParent, D.DocIDPrevious, D.PartnerName
	from dbo.DocsPayBudget T
		inner join dbo.Docs D on D.DocIDInt = T.DocIDInt
			and  D.ClassDoc = @ClassName2 --смотрим чтобы была нужная категория
			and year(isnull(D.DateSigned,'1900-01-01')) = 1900-- "неоплаченая" заявка
			and Upper(isnull(D.isActive,'')) = 'Y'--активная карточка
			and isnull(D.StatusCompletion,'') <> '0'	--неотмененая карточка (отмененные это отдельный блок)
	where T.DLM >= @Date  --отбираем по дате последнего изм-я
	and not exists(select 1 from #tbl_pay P where P.DocIDInt = D.DocIDInt)--не повторяемся, если карточка отобралась через отказ
	select @Res = @@error if @Res <> 0 goto Err
	
	--по удалению сумм-детальной строки
	insert into #del_summ
		(DocIDInt, DocID, Am1, SetID, Tx1)
	select distinct 
		T.DocIDInt, T.DocID, T.Amount, cast(T.Version as uniqueidentifier), T.Comment
	from dbo.Comments T
		inner join dbo.Docs D on D.DocIDInt = T.DocIDInt
			and  D.ClassDoc in (@ClassName, @ClassName2) --смотрим чтобы была нужная категория
			and year(isnull(D.DateSigned,'1900-01-01')) = 1900-- "неоплаченая" заявка
			and Upper(isnull(D.isActive,'')) = 'Y'--активная карточка
			and isnull(D.StatusCompletion,'') <> '0'	--неотмененая карточка (отмененные это отдельный блок)
	where T.DateCreation >= @Date  --отбираем по дате 
		and upper(T.CommentType) = 'HISTORY'
		and T.RIK_CommentType = 'pdxdocdetails'
	select @Res = @@error if @Res <> 0 goto Err
		
	insert into #tbl_pay
		(DocIDInt, DocID,	StatusDevelopment, VisaRefuse, DocIDParent, DocIDPrevious, PartnerName)
	select distinct D.DocIDInt, D.DocID, D.StatusDevelopment, 
		dbo.PDX_fn_stopReconcilation(ListToReconcile, ListReconciled, case D.ClassDoc when @ClassName then @StopRefuseFlag else @StopRefuseFlag2 end), 
		D.DocIDParent, D.DocIDPrevious, D.PartnerName
	from #del_summ S
	inner join dbo.Docs D on D.DocIDInt = S.DocIDInt
	and not exists(select 1 from #tbl_pay P where P.DocIDInt = D.DocIDInt)--не повторяемся, если карточка отобралась через отказ
	select @Res = @@error if @Res <> 0 goto Err

	
	--по датам из комментов
	---отмена платежа
	insert into #tbl_pay
		(DocIDInt, DocID,	StatusDevelopment, VisaRefuse, DocIDParent, DocIDPrevious, PartnerName)
	select distinct D.DocIDInt, D.DocID, D.StatusDevelopment, 
			dbo.PDX_fn_stopReconcilation(D.ListToReconcile, D.ListReconciled, case D.ClassDoc when @ClassName then @StopRefuseFlag else @StopRefuseFlag2 end),
			D.DocIDParent, D.DocIDPrevious, D.PartnerName
	from dbo.Comments C
	inner join 	dbo.Docs D on C.DocIDInt = D.DocIDInt
		and D.ClassDoc in (@ClassName, @ClassName2) --смотрим чтобы была нужная категория
		and year(isnull(D.DateSigned,'1900-01-01')) = 1900 -- "неоплаченая" заявка
		and Upper(isnull(D.isActive,'')) = 'Y' --активная карточка
		and isnull(D.StatusCompletion,'') = '0' --отмененая карточка
	where Upper(isnull(C.CommentType,'')) = 'HISTORY' --берем отказ в согласовании
		and Upper(isnull(C.SpecialInfo,'')) = 'CANCELED'
		and C.DateCreation >= @Date
		and not exists(select 1 from #tbl_pay P where P.DocIDInt = D.DocIDInt)--не повторяемся, если карточка отобралась через отказ
	select @Res = @@error if @Res <> 0 goto Err

    /*************************************************************************************************/
    /*************************************************************************************************/
    /*************************************************************************************************/

	update P
		set ParentID = isnull(Par.DocIDIncoming,'')
	from #tbl_pay as P
	inner join dbo.Docs Par on Par.DocID = P.DocIDParent
	select @Res = @@error if @Res <> 0 goto Err

	update P
		set PreviousID = isnull(Prev.DocIDIncoming,'')
	from #tbl_pay as P
	left join dbo.Docs Prev on Prev.DocID = P.DocIDPrevious
	select @Res = @@error if @Res <> 0 goto Err
	
	update P
		set TaxID = isnull(PN.TaxID,''),
		PortalID = PN.PortalID
	from #tbl_pay as P
	left join dbo.Partners PN on PN.Name = P.PartnerName 
	select @Res = @@error if @Res <> 0 goto Err

	update P
		set LinkID = ltrim(rtrim(ISNULL(C.Subject,'')))
	from #tbl_pay as P
	inner join dbo.Comments C on C.DocIDInt = P.DocIDInt
		and upper(C.CommentType) = 'LINK' 
		and ltrim(rtrim(ISNULL(C.Subject,''))) <> ''
		and C.RIK_CommentType in (dbo.PDX_CLSGet('RIK_CategoryName_KAZ_CORPAY'),dbo.PDX_CLSGet('RIK_CategoryName_KAZ_PLNPAY'))
	select @Res = @@error if @Res <> 0 goto Err

	--тепер собираем информацию
	select 
		D.TransferGUID, --УНИКАЛЬНЫЙ ИД ЗАПИСИС. DocID - теоретически м.б. изменен
		D.DocID,  --Рег. номер
		case
			when not D.DateActive IS null and YEAR(D.DateActive)>1900 then D.DateActive
			when not D.DateActivation IS null and YEAR(D.DateActivation)>1900 then D.DateActivation
			else D.DateCreation
		end as DateActive, --дата последней активации
		--isnull(isnull(D.DateActive, D.DateActivation), D.DateCreation) as DateActive, --дата последней активации

		D.UserFieldText8,  --Бизнес единица
		dbo.PDX_fn_pay_FirmGET(D.UserFieldText8) as ID_UFT8,
		
		case 
			when isnull(D.StatusCompletion,'') = '0'
				then 4 -- отменена
			when isnull(D.StatusDevelopment,'') = '4'
				and P.VisaRefuse = 1
				then -3 --в утвержденной карточке не может быть отказов в согласовании
			when isnull(D.StatusDevelopment,'') = '4'
				then 2 --утверждена
			when P.VisaRefuse = 1
				then 0 --отказано в согласовании
			else 1 --на соглаовании
		end as STATUS,
		--****************************************
		P.PartnerName,  --Отправитель\Получатель
		isnull(P.TaxID,'') as PNTaxID, --ИНН
		--isnull(PN.TaxID,'') as PNTaxID, --ИНН
		P.PortalID as PortalID,

		D.Name,  --Назначение
		D.Description,  --Основание

		isnull(P.DocIDParent,'') as DocIDParent,  --Основной договор
		isnull(P.ParentID,'')as ParentID,
		--isnull(Par.DocIDIncoming,'') as ParentID,

		isnull(P.DocIDPrevious,'') as DocIDPrevious,  --Для работ по договору
		isnull(P.PreviousID,'')as PreviousID,
		--isnull(Prev.DocIDIncoming,'') as PreviousID,
		--****************************************
		D.UserFieldText2,  --ЦФО
		dbo.PDX_fn_pay_CFOGET(D.UserFieldText2) as ID_UFT2,

/**********изменение****************/
		--D.UserFieldText3,  --
		-----------------------------dbo.PDX_fn_pay_DirectionGET(D.UserFieldText3) as ID_UFT3,
/**************************/
		D.UserFieldText5,  --Статья ПРиЗ
		dbo.PDX_fn_pay_ItemGET(D.UserFieldText5) as ID_UFT5,
			
		D.UserFieldText7,  --Наличный расчет

/**********изменение****************/
		D.UserFieldText4,  --код ИСР
		dbo.PDX_SubstringReturn(D.UserFieldText4,CHARINDEX('<',D.UserFieldText4),CHARINDEX('>',D.UserFieldText4)) as ID_UFT4,
		--isnull(U.Field2,'') as ID_UFT4,
/**************************/

		D.UserFieldText6,  --Счет
		dbo.PDX_fn_pay_AccountGET(D.UserFieldText6) as ID_UFT6 ,
		--****************************************
		D.Currency,  --Валюта
		isnull(Curr.Code2,'') as CurrCode2,--

		---D.AmountDoc,  --Сумма
		isnull(T.Am1, 0) as AmountDoc,--Сумма
		isnull(T.Tx1,'') as AmountDescr, --описание к сумме
		isnull(T.Tx2,'') as AmountVAT, --ндс к сумме
		T.SetID as AmountID, --ID сумме
		
		D.NameAproval,  --Заявитель
		isnull(NA.Name,'') as NameApp,
		D.NameCreation,  --Автор
		isnull(NC.Name,'') as NameCr,

		case
			when not D.DateApproved IS null and YEAR(D.DateApproved)>1900 then D.DateApproved
			else GETDATE()
		end as DateApproved, --дата утверждения
		case year(isnull(D.DateSigned,'1900-01-01')) 
			when 1900 then null 
			else D.DateSigned 
		end as DateSigned,  --Дата оплаты
		D.UserFieldText1,  --Наименование листа согласования
		D.ListToReconcile,  --Лист согласования
		P.LinkID,		-- ссылка на ПЗ или КЗ
		D.UserFieldText3 as Avans,
		cast(D.UserFieldMoney2 as tinyint) as VnutrOborot,
		
		'' as BUDescr, --Основание платежа 
		'' as ID_BUDescr, --ИД Основания платежа 
		'' as BUKBK, --КБК 
		'' as BUKPP, --КПП 
		'' as BUOKTMO, --ОКТМО 
		'' as BUMonth, --Месяц 
		'' as BUYear, --Год периода 
		'' as BUStatus, --Статус платежа 
		'' as ID_BUStatus , --ИД Статуса платежа 
		'' as BUPeriod, --Налоговый период
		'' as ID_BUPeriod, --ИД Налогового периода 
		D.ClassDoc,
		D.DateActivation,
		case year(D.UserFieldDate1) when 1900 then NULL else D.UserFieldDate1 end as UserFieldDate1,
		[dbo].[GetCurrentReconUsersByDocID](D.ListToReconcile, D.ListReconciled) as CurrentReconcile,
		case year(D.UserFieldDate2) when 1900 then NULL else D.UserFieldDate2 end as UserFieldDate2,
		isnull(T.Tx3,'') as AmountCode --код дохода
	from #tbl_pay P
	inner join dbo.Docs D on D.DocIDInt = P.DocIDInt
	inner join 
		(select X.Am1, X.SetID, X.Tx1, X.Tx2, X.Tx3, Z.DocIDInt/*X.DocID*/ from dbo.PDXDocDetails X 
					inner join #tbl_pay Z on X.DocID = Z.DocID
		union
		select 0 as Am1, Y.SetID, Y.Tx1, '' as Tx2, '' as Tx3, Y.DocIDInt/*Y.DocID*/ from #del_summ Y) as T
		on T.DocIDInt = D.DocIDInt
	left join dbo.CurrencyRates Curr on Curr.Code = D.Currency
	left join dbo.Users NA on D.NameAproval like '%<' + NA.UserID + '>%'
	left join dbo.Users NC on D.NameCreation like '%<' + NC.UserID + '>%'
	
	union
	
	select 
		D.TransferGUID, --УНИКАЛЬНЫЙ ИД ЗАПИСИС. DocID - теоретически м.б. изменен
		D.DocID,  --Рег. номер
		case
			when not D.DateActive IS null and YEAR(D.DateActive)>1900 then D.DateActive
			when not D.DateActivation IS null and YEAR(D.DateActivation)>1900 then D.DateActivation
			else D.DateCreation
		end as DateActive, --дата последней активации
		--isnull(isnull(D.DateActive, D.DateActivation), D.DateCreation) as DateActive, --дата последней активации

		D.UserFieldText8,  --Бизнес единица
		dbo.PDX_fn_pay_FirmGET(D.UserFieldText8) as ID_UFT8,
		
		case 
			when isnull(D.StatusCompletion,'') = '0'
				then 4 -- отменена
			when isnull(D.StatusDevelopment,'') = '4'
				and P.VisaRefuse = 1
				then -3 --в утвержденной карточке не может быть отказов в согласовании
			when isnull(D.StatusDevelopment,'') = '4'
				then 2 --утверждена
			when P.VisaRefuse = 1
				then 0 --отказано в согласовании
			else 1 --на соглаовании
		end as STATUS,
		--****************************************
		P.PartnerName,  --Отправитель\Получатель
		isnull(P.TaxID,'') as PNTaxID, --ИНН
		--isnull(PN.TaxID,'') as PNTaxID, --ИНН
		P.PortalID as PortalID,

		D.Name,  --Назначение
		D.Description,  --Основание

		isnull(P.DocIDParent,'') as DocIDParent,  --Основной договор
		isnull(P.ParentID,'')as ParentID,
		--isnull(Par.DocIDIncoming,'') as ParentID,

		isnull(P.DocIDPrevious,'') as DocIDPrevious,  --Для работ по договору
		isnull(P.PreviousID,'')as PreviousID,
		--isnull(Prev.DocIDIncoming,'') as PreviousID,
		--****************************************
		D.UserFieldText2,  --ЦФО
		dbo.PDX_fn_pay_CFOGET(D.UserFieldText2) as ID_UFT2,

/**********изменение****************/
		--D.UserFieldText3,  --
		-----------------------------dbo.PDX_fn_pay_DirectionGET(D.UserFieldText3) as ID_UFT3,
/**************************/
		D.UserFieldText5,  --Статья ПРиЗ
		dbo.PDX_fn_pay_ItemGET(D.UserFieldText5) as ID_UFT5,
			
		D.UserFieldText7,  --Наличный расчет

/**********изменение****************/
		D.UserFieldText4,  --код ИСР
		dbo.PDX_SubstringReturn(D.UserFieldText4,CHARINDEX('<',D.UserFieldText4),CHARINDEX('>',D.UserFieldText4)) as ID_UFT4,
		--isnull(U.Field2,'') as ID_UFT4,
/**************************/

		D.UserFieldText6,  --Счет
		dbo.PDX_fn_pay_AccountGET(D.UserFieldText6) as ID_UFT6 ,
		--****************************************
		D.Currency,  --Валюта
		isnull(Curr.Code2,'') as CurrCode2,--

		---D.AmountDoc,  --Сумма
		isnull(B.Amount, 0) as AmountDoc,--Сумма
		isnull(B.Purpose,'') as AmountDescr, --описание к сумме
		isnull(B.VAT,'') as AmountVAT, --ндс к сумме
		D.TransferGUID as AmountID, --ID сумме
		
		D.NameAproval,  --Заявитель
		isnull(NA.Name,'') as NameApp,
		D.NameCreation,  --Автор
		isnull(NC.Name,'') as NameCr,

		case
			when not D.DateApproved IS null and YEAR(D.DateApproved)>1900 then D.DateApproved
			else GETDATE()
		end as DateApproved, --дата утверждения
		case year(isnull(D.DateSigned,'1900-01-01')) 
			when 1900 then null 
			else D.DateSigned 
		end as DateSigned,  --Дата оплаты
		D.UserFieldText1,  --Наименование листа согласования
		D.ListToReconcile,  --Лист согласования
		P.LinkID,		-- ссылка на ПЗ или КЗ
		D.UserFieldText3 as Avans,
		cast(D.UserFieldMoney2 as tinyint) as VnutrOborot,
		
		B.[Description] as BUDescr, --Основание платежа 
		dbo.PDX_SubstringReturn(B.[Description], CHARINDEX('<', B.[Description]), CHARINDEX('>', B.[Description])) as ID_BUDescr, --ИД Основания платежа 
		B.KBK as BUKBK, --КБК 
		B.KPP as BUKPP, --КПП 
		B.OKTMO as BUOKTMO, --ОКТМО 
		right('0' + B.[Month],2) as BUMonth, --Месяц 
		B.[Year] as BUYear, --Год периода 
		B.[Status] as BUStatus, --Статус платежа 
		dbo.PDX_SubstringReturn(B.[Status], CHARINDEX('<', B.[Status]), CHARINDEX('>', B.[Status])) as ID_BUStatus , --ИД Статуса платежа 
		B.TaxPeriod as BUPeriod, --Налоговый период ,
		dbo.PDX_SubstringReturn(B.TaxPeriod, CHARINDEX('<', B.TaxPeriod), CHARINDEX('>', B.TaxPeriod)) as ID_BUPeriod, --ИД Налогового периода 
		D.ClassDoc,
		NULL as DateActivation,
		NULL as UserFieldDate1,
		[dbo].[GetCurrentReconUsersByDocID](D.ListToReconcile, D.ListReconciled) as CurrentReconcile,
		NULL as UserFieldDate2,
		'' as AmountCode --код дохода
	from #tbl_pay P
	inner join dbo.Docs D on D.DocIDInt = P.DocIDInt
	inner join dbo.[DocsPayBudget] B on D.DocIDInt = B.DocIDInt
	left join dbo.CurrencyRates Curr on Curr.Code = D.Currency
	left join dbo.Users NA on D.NameAproval like '%<' + NA.UserID + '>%'
	left join dbo.Users NC on D.NameCreation like '%<' + NC.UserID + '>%'
	
	order by 2
	select @Res = @@error if @Res <> 0 goto Err

OK:
	set nocount off
	return @Res
Err:
	set nocount off
	return @Res






GO
/****** Object:  StoredProcedure [dbo].[PDX_PAYORDn_Copy] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_PAYORDn_Copy] 
	@ActionLogID int
as

set nocount on


	declare @ClassName varchar(128)
	
	declare @ActDoc varchar(128), @DocIDParent varchar(128), @Department varchar(255), @DocID varchar(128), @DocIDInt int, @DocDate datetime, @newDocID varchar(128),
	@Error varchar(4000), @NC varchar(96),@newDocIDInt int, @UserID varchar(16), @LET varchar(128), @cnt int, @PLNCls varchar(128), @UserName varchar(128)
	
	declare @tbl table (ID int identity, DocID varchar(128), DocIDInt int, newDocID varchar(128),newDocIDInt int,
		NC varchar(96),LinkDocID varchar(128), DocIDParent varchar(128),	LinkName varchar(1024))
	
	declare @MonthT int, @YearT int
	--create table #num (Error varchar(4000),DocID varchar(128))
	
	select @ClassName = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_ORDPAY')
	select @PLNCls = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_PLNPAY')
	
	select @UserID = UserID, @MonthT = MonthT, @YearT = YearT from dbo.PDX_KAZCopy_Log where ActionLogID = @ActionLogID
	select @UserName = dbo.PDX_FIObyFullNameGet (Name) from dbo.Users where UserID = @UserID
	

	If @MonthT = MONTH(GETDATE()) and @YearT = YEAR(GETDATE())
	begin	
	
		set @DocDate = GETDATE()--CONVERT(date,CAST(@YearT as varchar(4)) + '-' + right('0' + CAST(@MonthT as varchar(3)),2) + '-01',120)
		
		insert into @tbl (DocID, DocIDInt,DocIDParent, NC)
		select
			D.DocID, --Рег. номер
			D.DocIDInt,
			D.DocIDParent,
			D.NameCreation			
		from dbo.PDX_KAZCopy_LogDocs L
		inner join dbo.Docs D on D.DocIDInt = L.DocIDInt
		where L.ActionLogID = @ActionLogID
		order by D.DateCreation
	
		;with Lnk as (
		select D.DocIDParent,MAX(D.DocID) as LinkDocID, MAX(D.Name) as LinkName
		from dbo.Docs D
			inner join (select distinct DocIDParent from @tbl where isnull(DocIDParent,'') <> '') as X on X.DocIDParent = D.DocIDParent
		where D.ClassDoc = @PLNCls
			and D.IsActive = 'Y'
			and isnull(D.StatusCompletion,'') <> '0'
			and D.StatusDevelopment = '4'
			and Month(D.UserFieldDate1) = @MonthT
			and YEAR(D.UserFieldDate1) = @YearT
		group by D.DocIDParent
		having count(*) = 1)
		
		update T
			set LinkDocID = Lnk.LinkDocID,
			LinkName = Lnk.LinkName
		from @tbl T
		inner join Lnk on Lnk.DocIDParent = T.DocIDParent
		where isnull(T.DocIDParent,'') <> ''
	
		select @LET = LETTER from dbo. PDXDocTypesConst where DocType = @ClassName
		select top 1 @cnt = cast(replace(DocID,@LET + '-','') as int) from dbo.Docs where ClassDoc = @ClassName order by DocIDInt desc
		
		update @tbl
		set newDocID = @LET + '-' + case when len(cast((@cnt + ID) as varchar(128))) >6 then cast((@cnt + ID) as varchar(128)) else right('000000' + cast((@cnt + ID) as varchar(128)),6) end
--select * from @tbl
		insert into dbo.Docs
			(
			DocID,
			GUID,
			DocIDadd,
			DocIDIncoming,
			DocIDParent,
			DocIDPrevious,
			Author,
			Correspondent,
			Resolution,
			History,
			Result,
			PercentCompletion,
			Department,
			Name,
			Description,
			LocationURL,
			LocationPaper,
			FileNamePrefix,
			FileName,
			FileNameNameLastModification,
			FileNameDateLastAccessed,
			FileNameDateLastModification,
			LocationPath,
			ExtInt,
			PartnerName,
			StatusDevelopment,
			StatusPayment,
			StatusArchiv,
			StatusCompletion,
			StatusDelivery,
			TypeDoc,
			ClassDoc,
			ActDoc,
			InventoryUnit,
			PaymentMethod,
			AmountDoc,
			QuantityDoc,
			DateActivation,
			SecurityLevel,
			DateCreation,
			DateCompletion,
			DateCompleted,
			DateExpiration,
			NameCreation,
			NameAproval,
			NameApproved,
			DateApproved,
			ListToEdit,
			ListToReconcile,
			ListReconciled,
			NameResponsible,
			NameControl,
			NameLastModification,
			DateLastModification,
			UserFieldText1,
			UserFieldText2,
			UserFieldText3,
			UserFieldText4,
			UserFieldText5,
			UserFieldText6,
			UserFieldText7,
			UserFieldText8,
			UserFieldMoney1,
			UserFieldMoney2,
			UserFieldDate1,
			UserFieldDate2,
			UserFieldDate3,
			UserFieldDate4,
			UserFieldDate5,
			UserFieldDate6,
			UserFieldDate7,
			UserFieldDate8,
			IsActive,
			DateActive,
			BusinessProcessStep,
			ExtPassword,
			DateSigned,
			Currency,
			CurrencyRate,
			Rank,
			ListToView)--,
			--Content)
		select
			T.newDocID,--DocID,
			newid(),--GUID,
			T.newDocID,--DocIDadd,
			D.DocIDIncoming,
			D.DocIDParent,
			D.DocIDPrevious,
			D.Author,
			D.Correspondent,
			D.Resolution,
			D.History,
			D.Result,
			D.PercentCompletion,
			D.Department,
			D.Name,
			D.Description,
			D.LocationURL,
			D.LocationPaper,
			D.FileNamePrefix,
			D.FileName,
			D.FileNameNameLastModification,
			D.FileNameDateLastAccessed,
			D.FileNameDateLastModification,
			D.LocationPath,
			D.ExtInt,
			D.PartnerName,
			'1',--StatusDevelopment,
			D.StatusPayment,
			D.StatusArchiv,
			D.StatusCompletion,
			D.StatusDelivery,
			D.TypeDoc,
			D.ClassDoc,
			D.ActDoc,
			D.InventoryUnit,
			D.PaymentMethod,
			D.AmountDoc,
			D.QuantityDoc,
			CAST(GETDATE() as date),--DateActivation,
			D.SecurityLevel,
			@DocDate,--DateCreation,
			D.DateCompletion,
			null,--DateCompleted,
			D.DateExpiration,
			D.NameCreation,
			D.NameAproval,
			null,--NameApproved,
			null,--DateApproved,
			D.ListToEdit,
			D.ListToReconcile,
			'',--ListReconciled,
			D.NameResponsible,
			D.NameControl,
			D.NameCreation,--NameLastModification,
			@DocDate,--DateLastModification,
			D.UserFieldText1,
			D.UserFieldText2,
			D.UserFieldText3,
			D.UserFieldText4,
			D.UserFieldText5,
			D.UserFieldText6,
			D.UserFieldText7,
			D.UserFieldText8,
			0,--UserFieldMoney1,
			D.UserFieldMoney2,
			D.UserFieldDate1,
			D.UserFieldDate2,
			D.UserFieldDate3,
			D.UserFieldDate4,
			D.UserFieldDate5,
			D.UserFieldDate6,
			D.UserFieldDate7,
			D.UserFieldDate8,
			'N',--IsActive,
			null,--DateActive,
			D.BusinessProcessStep,
			D.ExtPassword,
			null,--DateSigned,
			D.Currency,
			D.CurrencyRate,
			D.Rank,
			D.ListToView
		from dbo.Docs D
		inner join @tbl T on T.DocIDInt = D.DocIDInt
		
		insert into dbo.Comments
		(	UserID,
			UserName,
			ContactUserName,
			ContactUserID,
			PartnerName,
			DocID,
			DateCreation,
			DateEvent,
			DateEventEnd,
			Address,
			Subject,
			Comment,
			CommentType,
			SpecialInfo,
			FileName,
			--KeyField,
			PartnerID,
			Version,
			GUID,
			GUIDPartner,
			GUIDUser,
			GUIDDoc,
			Amount,
			FileNameOriginal,
			RIK_CommentType)
		select
			@UserID,
			@UserName,
			null,--ContactUserName,
			null,--ContactUserID,
			'',--PartnerName,
			newDocID,
			getdate(),--DateCreation,
			null,--DateEvent,
			null,--DateEventEnd,
			'',--Address,
			LinkDocID,-- Subject,
			'#red#boldПЛАНОВАЯ ЗАЯВКА: ' + ISNULL(LinkName,''),--Comment,
			'LINK',--CommentType,
			'',--SpecialInfo,
			null,--FileName,
			--KeyField,
			null,--PartnerID,
			'',--Version,
			newid(),--GUID,
			null,--GUIDPartner,
			null,--GUIDUser,
			null,--GUIDDoc,
			0,--Amount,
			null,--FileNameOriginal,
			@PLNCls--RIK_CommentType
		from @tbl
		where isnull(LinkDocID,'') <> ''
		
		insert into dbo.PDXDocDetails
			(SetID,
			DocID,
			ClassDoc,
			Tx1,
			Tx2,
			Tx3,
			Tx4,
			Tx5,
			TxL1,
			TxL2,
			Dt1,
			Dt2,
			Dt3,
			Dt4,
			Dt5,
			Am1,
			Am2,
			Am3,
			Am4,
			Am5,
			Bl1,
			Bl2,
			Bl3,
			Bl4,
			Bl5,
			NC,
			DC,
			NLM,
			DLM)
		select
			NewiD(),--SetID,
			T.newDocID,
			D.ClassDoc,
			D.Tx1,
			D.Tx2,
			D.Tx3,
			D.Tx4,
			D.Tx5,
			D.TxL1,
			D.TxL2,
			D.Dt1,
			D.Dt2,
			D.Dt3,
			D.Dt4,
			D.Dt5,
			D.Am1,
			D.Am2,
			D.Am3,
			D.Am4,
			D.Am5,
			D.Bl1,
			D.Bl2,
			D.Bl3,
			D.Bl4,
			D.Bl5,
			T.NC,--NC,
			getdate(),--DC,
			T.NC,--NLM,
			getdate()--DLM
		from dbo.PDXDocDetails D
		inner join @tbl T on T.DocID = D.DocID
		
			
	end --If @MonthT = MONTH(GETDATE()) and @YearT = YEAR(GETDATE())

	update L
	set
		DocID = T.DocID, 
		newDocID = T.newDocID, 
		newDocIDInt = D.DocIDInt
	from @tbl T
	inner join dbo.PDX_KAZCopy_LogDocs L on L.DocIDInt = T.DocIDInt
	inner join dbo.Docs D on D.DocID = T.newDocID
	
	

GO
/****** Object:  StoredProcedure [dbo].[PDX_PAYORDn_Read] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE proc [dbo].[PDX_PAYORDn_Read] 
	@ActionLogID int
as

set nocount on


	declare @ClassName varchar(128)
	
	select @ClassName = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_ORDPAY')
	
	;with KAZ as (
	select 
		D.DocID, --Рег. номер
		D.Currency, --Валюта
		D.UserFieldText7, --Наличный расчет
		D.UserFieldText8, --Бизнес единица
		D.NameAproval, --Заявитель
		D.UserFieldText2, --ЦФО
		D.PartnerName, --Отправитель\Получатель
		D.UserFieldText4, --Объект
		D.UserFieldText5, --Статья расходов
		D.Name, --Назначение
		D.AmountDoc, --Сумма (общая)
		D.UserFieldText3, --Аванс
		D.DocIDParent, --Оплата по договору №
		D.DocIDPrevious, --№ договора с Заказчиком
		D.UserFieldText6, --Счет
		D.Description, --Основание
		D.NameCreation, --Автор
		D.DateSigned, --Дата оплаты
		D.UserFieldText1, --Наименование листа согласования
		D.ListToReconcile, --Лист согласования
		D.Correspondent, --Список рассылки
		D.DateCreation,
		
		
		D.IsActive,
		D.ClassDoc,
		D.StatusCompletion,
		D.StatusDevelopment,
		D.StatusPayment,
		D.StatusArchiv,
		D.StatusDelivery,
		--D.ListToReconcile,
		D.ListReconciled,
		D.NameApproved,
		D.ListToView,
		--D.NameAproval,
		--D.Correspondent,
		D.NameResponsible,
		D.NameControl,
		D.LocationPath,
		D.DateCompleted,
		D.DateCompletion,
		--D.DateSigned,
		D.Resolution,
		D.DateApproved,
		D.TypeDoc
	from dbo.PDX_KAZCopy_LogDocs T
	inner join dbo.Docs D on T.newDocIDInt = D.DocIDInt
	where T.ActionLogID = @ActionLogID
	)

	select
		1 as OI,
		D.DocID, --Рег. номер
		D.Currency, --Валюта
		D.UserFieldText7, --Наличный расчет
		D.UserFieldText8, --Бизнес единица
		D.NameAproval, --Заявитель
		D.UserFieldText2, --ЦФО
		D.PartnerName, --Отправитель\Получатель
		D.UserFieldText4, --Объект
		D.UserFieldText5, --Статья расходов
		D.Name, --Назначение
		D.AmountDoc, --Сумма (общая)
		D.UserFieldText3, --Аванс
		D.DocIDParent, --Оплата по договору №
		D.DocIDPrevious, --№ договора с Заказчиком
		D.UserFieldText6, --Счет
		D.Description, --Основание
		D.NameCreation, --Автор
		D.DateSigned, --Дата оплаты
		D.UserFieldText1, --Наименование листа согласования
		D.ListToReconcile, --Лист согласования
		D.Correspondent, --Список рассылки
		D.DateCreation,
		
		D.IsActive,
		D.ClassDoc,
		D.StatusCompletion,
		D.StatusDevelopment,
		D.StatusPayment,
		D.StatusArchiv,
		D.StatusDelivery,
		--D.ListToReconcile,
		D.ListReconciled,
		D.NameApproved,
		D.ListToView,
		--D.NameAproval,
		--D.Correspondent,
		D.NameResponsible,
		D.NameControl,
		D.LocationPath,
		D.DateCompleted,
		D.DateCompletion,		
		--D.DateSigned,
		D.Resolution,
		D.DateApproved,
		D.TypeDoc
	from KAZ D

	union
	
	select
		2 as OI,
		null,--D.DocID, --Рег. номер
		D.Currency, --Валюта
		null,--D.UserFieldText7, --Наличный расчет
		null,--D.UserFieldText8, --Бизнес единица
		null,--D.NameAproval, --Заявитель
		null,--D.UserFieldText2, --ЦФО
		null,--D.PartnerName, --Отправитель\Получатель
		null,--D.UserFieldText4, --Объект
		null,--D.UserFieldText5, --Статья расходов
		null,--D.Name, --Назначение
		sum(D.AmountDoc) as AmountDoc, --Сумма (общая)
		null,--D.UserFieldText3, --Аванс
		null,--D.DocIDParent, --Оплата по договору №
		null,--D.DocIDPrevious, --№ договора с Заказчиком
		null,--D.UserFieldText6, --Счет
		null,--D.Description, --Основание
		null,--D.NameCreation, --Автор
		null,--D.DateSigned, --Дата оплаты
		null,--D.UserFieldText1, --Наименование листа согласования
		null,--D.ListToReconcile, --Лист согласования
		null,--D.Correspondent, --Список рассылки
		null,--D.DateCreation,
		
		null,--D.IsActive,
		null,--D.ClassDoc,
		null,--D.StatusCompletion,
		null,--D.StatusDevelopment,
		null,--D.StatusPayment,
		null,--D.StatusArchiv,
		null,--D.StatusDelivery,
		--null,--D.ListToReconcile,
		null,--D.ListReconciled,
		null,--D.NameApproved,
		null,--D.ListToView,
		--null,--D.NameAproval,
		--null,--D.Correspondent,
		null,--D.NameResponsible,
		null,--D.NameControl,
		null,--D.LocationPath,
		null,--D.DateCompleted,
		null,--D.DateCompletion,
		--null,--D.DateSigned,
		null,--D.Resolution,
		null,--D.DateApproved,
		null--D.TypeDoc,
	from KAZ D
	group by D.Currency
	
	order by 1,2,3

GO
/****** Object:  StoredProcedure [dbo].[PDX_PAYORDn_View] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE proc [dbo].[PDX_PAYORDn_View] 
	@Month int,
	@Year int,
	@UserID varchar(16)
as

set nocount on


	declare @ClassName varchar(128)
	
	select @ClassName = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_ORDPAY')
	
	;with KAZ as (
	select
		D.DocID, --Рег. номер
		D.UserFieldText7, --Наличный расчет
		D.Currency, --Валюта
		D.UserFieldText8, --Бизнес единица
		D.NameAproval, --Заявитель
		D.UserFieldText2, --ЦФО
		D.PartnerName, --Отправитель\Получатель
		D.UserFieldText4, --Объект
		D.UserFieldText5, --Статья расходов
		D.Name, --Назначение
		D.AmountDoc, --Сумма (общая)
		D.UserFieldText3, --Аванс
		D.DocIDParent, --Оплата по договору №
		D.DocIDPrevious, --№ договора с Заказчиком
		D.UserFieldText6, --Счет
		D.Description, --Основание
		D.NameCreation, --Автор
		D.DateSigned, --Дата оплаты
		D.UserFieldText1, --Наименование листа согласования
		D.ListToReconcile, --Лист согласования
		D.Correspondent, --Список рассылки
		D.DateCreation,
		D.DocIDInt,
				
		D.IsActive,
		D.ClassDoc,
		D.StatusCompletion,
		D.StatusDevelopment,
		D.StatusPayment,
		D.StatusArchiv,
		D.StatusDelivery,
		--D.ListToReconcile,
		D.ListReconciled,
		D.NameApproved,
		D.ListToView,
		--D.NameAproval,
		--D.Correspondent,
		D.NameResponsible,
		D.NameControl,
		D.LocationPath,
		D.DateCompleted,
		D.DateCompletion,
		--D.DateSigned,
		D.Resolution,
		D.DateApproved,
		D.TypeDoc
	from dbo.Docs D
	where D.ClassDoc = @ClassName
		and D.IsActive = 'Y'
		and isnull(D.StatusCompletion,'') <> '0'
		and D.StatusDevelopment = '4'
		and Month(D.DateCreation) = @Month
		and YEAR(D.DateCreation) = @Year
		and D.NameCreation like '%<' + @UserID + '>%'
	)
	
	select
		1 as OI,
		D.DateCreation,
		D.Currency, --Валюта
		D.DocID, --Рег. номер
		D.UserFieldText7, --Наличный расчет
		D.UserFieldText8, --Бизнес единица
		D.NameAproval, --Заявитель
		D.UserFieldText2, --ЦФО
		D.PartnerName, --Отправитель\Получатель
		D.UserFieldText4, --Объект
		D.UserFieldText5, --Статья расходов
		D.Name, --Назначение
		D.AmountDoc, --Сумма (общая)
		D.UserFieldText3, --Аванс
		D.DocIDParent, --Оплата по договору №
		D.DocIDPrevious, --№ договора с Заказчиком
		D.UserFieldText6, --Счет
		D.Description, --Основание
		D.NameCreation, --Автор
		D.DateSigned, --Дата оплаты
		D.UserFieldText1, --Наименование листа согласования
		D.ListToReconcile, --Лист согласования
		D.Correspondent, --Список рассылки,
		D.DocIDInt,
		
		
		D.IsActive,
		D.ClassDoc,
		D.StatusCompletion,
		D.StatusDevelopment,
		D.StatusPayment,
		D.StatusArchiv,
		D.StatusDelivery,
		--D.ListToReconcile,
		D.ListReconciled,
		D.NameApproved,
		D.ListToView,
		--D.NameAproval,
		--D.Correspondent,
		D.NameResponsible,
		D.NameControl,
		D.LocationPath,
		D.DateCompleted,
		D.DateCompletion,
		--D.DateSigned,
		D.Resolution,
		D.DateApproved,
		D.TypeDoc
	from KAZ D	
	
	union
	
	select
		2 as OI,
		null, --D.DateCreation,
		D.Currency, --Валюта
		null, --D.DocID, --Рег. номер
		null, --D.UserFieldText7, --Наличный расчет
		null, --D.UserFieldText8, --Бизнес единица
		null, --D.NameAproval, --Заявитель
		null, --D.UserFieldText2, --ЦФО
		null, --D.PartnerName, --Отправитель\Получатель
		null, --D.UserFieldText4, --Объект
		null, --D.UserFieldText5, --Статья расходов
		null, --D.Name, --Назначение
		sum(D.AmountDoc) as AmountDoc, --Сумма (общая)
		null, --D.UserFieldText3, --Аванс
		null, --D.DocIDParent, --Оплата по договору №
		null, --D.DocIDPrevious, --№ договора с Заказчиком
		null, --D.UserFieldText6, --Счет
		null, --D.Description, --Основание
		null, --D.NameCreation, --Автор
		null, --D.DateSigned, --Дата оплаты
		null, --D.UserFieldText1, --Наименование листа согласования
		null, --D.ListToReconcile, --Лист согласования
		null, --D.Correspondent, --Список рассылки,
		null, --D.DocIDInt,
		
		
		null, --D.IsActive,
		null, --D.ClassDoc,
		null, --D.StatusCompletion,
		null, --D.StatusDevelopment,
		null, --D.StatusPayment,
		null, --D.StatusArchiv,
		null, --D.StatusDelivery,
		--null, --D.ListToReconcile,
		null, --D.ListReconciled,
		null, --D.NameApproved,
		null, --D.ListToView,
		--null, --D.NameAproval,
		--null, --D.Correspondent,
		null, --D.NameResponsible,
		null, --D.NameControl,
		null, --D.LocationPath,
		null, --D.DateCompleted,
		null, --D.DateCompletion,
		--null, --D.DateSigned,
		null, --D.Resolution,
		null, --D.DateApproved,
		null --D.TypeDoc
	from KAZ D
	group by D.Currency
	
	order by 1,2,3





GO
/****** Object:  StoredProcedure [dbo].[PDX_PAYPLN_Unload] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_PAYPLN_Unload] --ВЫГРУЗКА ПЛАНОВЫХ ЗАЯВОК
	@Date datetime 
as

set nocount on

	declare @Result int
	set @Result = 0

	declare @ClassName varchar(128)
	
	select @ClassName = dbo.PDX_CLSGet('RIK_CategoryName_FIN_PLNPAY')
	select @Result = @@error if @Result <> 0 goto Err
	
	create table #tbl_pay
		(DocID varchar(128),
		StatusDevelopment varchar(1),
		DocIDParent varchar(128), 
		DocIDPrevious varchar(128),
		ParentID varchar(128), 
		PreviousID varchar(128),
		PartnerName varchar(512),
		TaxID varchar(32))
	
	insert into #tbl_pay (DocID, StatusDevelopment, DocIDParent, DocIDPrevious, PartnerName)
	select DocID, StatusDevelopment, DocIDParent, DocIDPrevious, PartnerName
	from dbo.Docs D
	where D.ClassDoc = @ClassName
		and UPPER(ISNULL(D.IsActive,'')) = 'Y'	
		and ISNULL(D.StatusDevelopment,'') ='4'
		and ISNULL(D.StatusCompletion,'') <>'0'
		and D.DateApproved >= @Date	
	select @Result = @@error if @Result <> 0 goto Err
		
	update P
		set ParentID = isnull(Par.DocIDIncoming,'')
	from #tbl_pay as P
	inner join dbo.Docs Par on Par.DocID = P.DocIDParent
	select @Result = @@error if @Result <> 0 goto Err

	update P
		set PreviousID = isnull(Prev.DocIDIncoming,'')
	from #tbl_pay as P
	left join dbo.Docs Prev on Prev.DocID = P.DocIDPrevious
	select @Result = @@error if @Result <> 0 goto Err
	
	update P
		set TaxID = isnull(PN.TaxID,'')
	from #tbl_pay as P
	left join dbo.Partners PN on PN.Name = P.PartnerName 
	select @Result = @@error if @Result <> 0 goto Err

		--тепер собираем информацию
	select
		D.TransferGUID, --УНИКАЛЬНЫЙ ИД ЗАПИСИС. DocID - теоретически м.б. изменен
		D.DocID,  --Рег. номер
		D.UserFieldDate3, --рег. дата
		D.UserFieldDate1, --плановая дата оплаты

		D.UserFieldText8,  --Бизнес единица
		dbo.PDX_fn_pay_FirmGET(D.UserFieldText8) as ID_UFT8,

		2 as STATUS,--утверждена
		
		--****************************************
		P.PartnerName,  --Отправитель\Получатель
		isnull(P.TaxID,'') as PNTaxID, --ИНН
		--isnull(PN.TaxID,'') as PNTaxID, --ИНН

		D.Name,  --Назначение
		D.Description,  --Основание

		isnull(P.DocIDParent,'') as DocIDParent,  --Основной договор
		isnull(P.ParentID,'')as ParentID,
		--isnull(Par.DocIDIncoming,'') as ParentID,

		isnull(P.DocIDPrevious,'') as DocIDPrevious,  --Для работ по договору
		isnull(P.PreviousID,'')as PreviousID,
		--isnull(Prev.DocIDIncoming,'') as PreviousID,
		--****************************************
		D.UserFieldText2,  --ЦФО
		dbo.PDX_fn_pay_CFOGET(D.UserFieldText2) as ID_UFT2,

		D.UserFieldText3,  --Направление
		dbo.PDX_fn_pay_DirectionGET(D.UserFieldText3) as ID_UFT3,

		D.UserFieldText5,  --Статья ПРиЗ
		dbo.PDX_fn_pay_PRiZGET(D.UserFieldText5) as ID_UFT5,
			
		D.UserFieldText7,  --Наличный расчет

		D.UserFieldText4,  --Проект
		isnull(U.Field2,'') as ID_UFT4,

		D.UserFieldText6,  --Счет
		dbo.PDX_fn_pay_AccountGET(D.UserFieldText6) as ID_UFT6 ,
		--****************************************
		D.Currency,  --Валюта
		isnull(Curr.Code2,'') as CurrCode2,--

		D.AmountDoc,--Сумма
		
		D.NameAproval,  --Фин директор
		isnull(NA.Name,'') as NameApp,
		D.NameCreation,  --Автор/Инициатор
		isnull(NC.Name,'') as NameCr,

		D.DateApproved, --дата утверждения
		D.UserFieldText1,  --Наименование листа согласования
		D.ListToReconcile,  --Лист согласования
		D.UserFieldMoney1 --возникновение обязательств
	from #tbl_pay P
	inner join dbo.Docs D on D.DocID = P.DocID
	left join dbo.UserDirValues U on U.UDKeyField = 35 and U.Field1 = D.UserFieldText4
	left join dbo.CurrencyRates Curr on Curr.Code = D.Currency
	left join dbo.Users NA on D.NameAproval like '%<' + NA.UserID + '>%'
	left join dbo.Users NC on D.NameCreation like '%<' + NC.UserID + '>%'
	order by D.DocID
	select @Result = @@error if @Result <> 0 goto Err

set nocount off
	return @Result
Err:

set nocount off
		return @Result

GO
/****** Object:  StoredProcedure [dbo].[PDX_PAYPLNn_Copy] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[PDX_PAYPLNn_Copy] 
	@ActionLogID int
as

set nocount on


	declare @ClassName varchar(128)
	
	declare @ActDoc varchar(128), @DocIDParent varchar(128), @Department varchar(255), @DocID varchar(128), @DocIDInt int, @DocDate datetime, @newDocID varchar(128),
	@Error varchar(4000), @NC varchar(96),@newDocIDInt int, @LET varchar(128), @cnt int, @DT varchar(10), @DocDate2 datetime, @UserID varchar(16)
	
	declare @tbl table (ID int identity, DocID varchar(128), DocIDInt int, newDocID varchar(128),newDocIDInt int,
		ActDoc varchar(128), DocIDParent varchar(128), Department varchar(255), UFT1 varchar(1024), LTR varchar(1024), NC varchar(96))
	
	declare @MonthT int, @YearT int, @MonthF int, @YearF int
	
	select @UserID = UserID from dbo.PDX_KAZCopy_Log where ActionLogID = @ActionLogID
	select @ClassName = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_PLNPAY')
		
	select @UserID = UserID, @MonthT = MonthT, @YearT = YearT, @MonthF = MonthF, @YearF = YearF  from dbo.PDX_KAZCopy_Log where ActionLogID = @ActionLogID

	If (@MonthT > MONTH(GETDATE()) and @YearT = YEAR(GETDATE())) or @YearT > YEAR(GETDATE())
	begin	
	
		set @DocDate = CONVERT(date,CAST(@YearT as varchar(4)) + '-' + right('0' + CAST(@MonthT as varchar(3)),2) + '-01',120)
		set @DocDate2 = GETDATE()
		set @DT = CAST(@YearT as varchar(4)) + right('0' + CAST(@MonthT as varchar(3)),2)
		
		insert into @tbl (DocID, DocIDInt, ActDoc, DocIDParent, Department, UFT1, NC)
		select
			D.DocID, --Рег. номер
			D.DocIDInt,
			
			D.ActDoc,
			D.DocIDParent,
			D.Department,
			D.UserFieldText1,
			D.NameCreation			
		from dbo.PDX_KAZCopy_LogDocs L 
		inner join dbo.Docs D on L.DocIDInt = D.DocIDInt
		where L.ActionLogID = @ActionLogID
		order by D.DateCreation	
	
		select @LET = LETTER from dbo. PDXDocTypesConst where DocType = @ClassName
		set @cnt = 0
		select top 1 @cnt = cast(replace(DocID,@LET + '-' + @DT + '-' ,'') as int) 
		from dbo.Docs where ClassDoc = @ClassName and YEAR(UserFieldDate1) = @YearT and MONTH(UserFieldDate1) = @MonthT order by DocIDInt desc
		
		update @tbl
		set newDocID = @LET + '-' + @DT + '-' + case when len(cast((@cnt + ID) as varchar(128))) >3 then cast((@cnt + ID) as varchar(128)) else right('000' + cast((@cnt + ID) as varchar(128)),3) end

		insert into dbo.Docs
			(
			DocID,
			GUID,
			DocIDadd,
			DocIDIncoming,
			DocIDParent,
			DocIDPrevious,
			Author,
			Correspondent,
			Resolution,
			History,
			Result,
			PercentCompletion,
			Department,
			Name,
			Description,
			LocationURL,
			LocationPaper,
			FileNamePrefix,
			FileName,
			FileNameNameLastModification,
			FileNameDateLastAccessed,
			FileNameDateLastModification,
			LocationPath,
			ExtInt,
			PartnerName,
			StatusDevelopment,
			StatusPayment,
			StatusArchiv,
			StatusCompletion,
			StatusDelivery,
			TypeDoc,
			ClassDoc,
			ActDoc,
			InventoryUnit,
			PaymentMethod,
			AmountDoc,
			QuantityDoc,
			DateActivation,
			SecurityLevel,
			DateCreation,
			DateCompletion,
			DateCompleted,
			DateExpiration,
			NameCreation,
			NameAproval,
			NameApproved,
			DateApproved,
			ListToEdit,
			ListToReconcile,
			ListReconciled,
			NameResponsible,
			NameControl,
			NameLastModification,
			DateLastModification,
			UserFieldText1,
			UserFieldText2,
			UserFieldText3,
			UserFieldText4,
			UserFieldText5,
			UserFieldText6,
			UserFieldText7,
			UserFieldText8,
			UserFieldMoney1,
			UserFieldMoney2,
			UserFieldDate1,
			UserFieldDate2,
			UserFieldDate3,
			UserFieldDate4,
			UserFieldDate5,
			UserFieldDate6,
			UserFieldDate7,
			UserFieldDate8,
			IsActive,
			DateActive,
			BusinessProcessStep,
			ExtPassword,
			DateSigned,
			Currency,
			CurrencyRate,
			Rank,
			ListToView)--,
			--Content)
		select
			T.newDocID,--DocID,
			newid(),--GUID,
			T.newDocID,--DocIDadd,
			D.DocIDIncoming,
			D.DocIDParent,
			D.DocIDPrevious,
			D.Author,
			D.Correspondent,
			D.Resolution,
			D.History,
			D.Result,
			D.PercentCompletion,
			D.Department,
			D.Name,
			D.Description,
			D.LocationURL,
			D.LocationPaper,
			D.FileNamePrefix,
			D.FileName,
			D.FileNameNameLastModification,
			D.FileNameDateLastAccessed,
			D.FileNameDateLastModification,
			D.LocationPath,
			D.ExtInt,
			D.PartnerName,
			'1',--StatusDevelopment,
			D.StatusPayment,
			D.StatusArchiv,
			D.StatusCompletion,
			D.StatusDelivery,
			D.TypeDoc,
			D.ClassDoc,
			D.ActDoc,
			D.InventoryUnit,
			D.PaymentMethod,
			D.AmountDoc,
			D.QuantityDoc,
			null,--DateActivation,
			D.SecurityLevel,
			GETDATE(),--DateCreation,
			D.DateCompletion,
			null,--DateCompleted,
			D.DateExpiration,
			D.NameCreation,
			D.NameAproval,
			null,--NameApproved,
			null,--DateApproved,
			D.ListToEdit,
			D.ListToReconcile,
			'',--ListReconciled,
			D.NameResponsible,
			D.NameControl,
			D.NameCreation,--NameLastModification,
			@DocDate,--DateLastModification,
			D.UserFieldText1,
			D.UserFieldText2,
			D.UserFieldText3,
			D.UserFieldText4,
			D.UserFieldText5,
			D.UserFieldText6,
			D.UserFieldText7,
			D.UserFieldText8,
			D.UserFieldMoney1,
			D.UserFieldMoney2,
			@DocDate, --D.UserFieldDate1,
			D.UserFieldDate2,
			@DocDate2,--D.UserFieldDate3,
			D.UserFieldDate4,
			D.UserFieldDate5,
			D.UserFieldDate6,
			D.UserFieldDate7,
			D.UserFieldDate8,
			'N',--IsActive,
			null,--DateActive,
			D.BusinessProcessStep,
			D.ExtPassword,
			D.DateSigned,
			D.Currency,
			D.CurrencyRate,
			D.Rank,
			D.ListToView
		from dbo.Docs D
		inner join @tbl T on T.DocIDInt = D.DocIDInt
		
		update T
			set newDocIDInt = D.DocIDInt
		from @tbl T
		inner join dbo.Docs D on D.DocID = T.newDocID
		/*
		insert into dbo.PayStatusDetails	
			(DocIDInt, FinStatus, Comment, NC, DC, NLM, DLM)
		select
			T.newDocIDInt, S.FinStatus, S.Comment, T.NC, GETDATE(), T.NC, GETDATE()
		from @tbl T
		inner join dbo.PayStatusDetails S on S.DocIDInt = T.DocIDInt
			*/
	end --If @MonthT = MONTH(GETDATE()) and @YearT = YEAR(GETDATE())

	update L
	set 
		DocID = T.DocID, 
		newDocID = T.newDocID, 
		newDocIDInt = T.newDocIDInt
	from @tbl T
	inner join dbo.PDX_KAZCopy_LogDocs L on L.DocIDInt = T.DocIDInt
	inner join dbo.Docs D on D.DocID = T.newDocID
	

GO
/****** Object:  StoredProcedure [dbo].[PDX_PAYPLNn_Read] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE proc [dbo].[PDX_PAYPLNn_Read] 
	@ActionLogID int
as

set nocount on


	declare @ClassName varchar(128)
	
	select @ClassName = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_PLNPAY')
	
	;with KAZ as (
	select
		D.DocID, --Рег. номер
		D.UserFieldDate3, --Рег. дата
		D.UserFieldDate1, --Плановая дата оплаты
		D.UserFieldText7, --Наличный расчет
		D.Currency, --Валюта
		D.UserFieldText8, --Бизнес единица
		D.NameAproval, --Фин. Менеджер
		D.UserFieldText2, --ЦФО
		D.PartnerName, --Отправитель\Получатель
		D.UserFieldText4, --Объект
		D.UserFieldText5, --Статья расходов
		D.Name, --Назначение
		D.AmountDoc, --Сумма
		D.DocIDParent, --Оплата по договору №
		D.DocIDPrevious, --№ договора с Заказчиком
		D.UserFieldText6, --Счет
		D.Description, --Основание
		D.UserFieldMoney1, --Возникновение обязательств
		D.NameCreation, --Заявитель
		D.UserFieldText1, --Наименование листа согласования
		D.ListToReconcile, --Лист согласования
		D.Correspondent, --Список рассылки
		D.ListToEdit, --Список имеющих право редактирования д-та
		F.FinStatus,
		
		D.IsActive,
		D.ClassDoc,
		D.StatusCompletion,
		D.StatusDevelopment,
		D.StatusPayment,
		D.StatusArchiv,
		D.StatusDelivery,
		--D.ListToReconcile,
		D.ListReconciled,
		D.NameApproved,
		D.ListToView,
		--D.NameAproval,
		--D.Correspondent,
		D.NameResponsible,
		D.NameControl,
		D.LocationPath,
		D.DateCompleted,
		D.DateCompletion,		
		D.DateSigned,
		D.Resolution,
		D.DateApproved,
		D.TypeDoc
	from dbo.PDX_KAZCopy_LogDocs T
	inner join dbo.Docs D on T.newDocIDInt = D.DocIDInt
	left join dbo.PayStatusDetails F on F.DocIDInt = D.DocIDInt
	where T.ActionLogID = @ActionLogID
	)
	
	select
		1 as OI,
		D.DocID, --Рег. номер
		D.Currency, --Валюта
		D.UserFieldDate3, --Рег. дата
		D.UserFieldDate1, --Плановая дата оплаты
		D.UserFieldText7, --Наличный расчет
		D.UserFieldText8, --Бизнес единица
		D.NameAproval, --Фин. Менеджер
		D.UserFieldText2, --ЦФО
		D.PartnerName, --Отправитель\Получатель
		D.UserFieldText4, --Объект
		D.UserFieldText5, --Статья расходов
		D.Name, --Назначение
		D.AmountDoc, --Сумма
		D.DocIDParent, --Оплата по договору №
		D.DocIDPrevious, --№ договора с Заказчиком
		D.UserFieldText6, --Счет
		D.Description, --Основание
		D.UserFieldMoney1, --Возникновение обязательств
		D.NameCreation, --Заявитель
		D.UserFieldText1, --Наименование листа согласования
		D.ListToReconcile, --Лист согласования
		D.Correspondent, --Список рассылки
		D.ListToEdit, --Список имеющих право редактирования д-та
		D.FinStatus,
		
		D.IsActive,
		D.ClassDoc,
		D.StatusCompletion,
		D.StatusDevelopment,
		D.StatusPayment,
		D.StatusArchiv,
		D.StatusDelivery,
		--D.ListToReconcile,
		D.ListReconciled,
		D.NameApproved,
		D.ListToView,
		--D.NameAproval,
		--D.Correspondent,
		D.NameResponsible,
		D.NameControl,
		D.LocationPath,
		D.DateCompleted,
		D.DateCompletion,		
		D.DateSigned,
		D.Resolution,
		D.DateApproved,
		D.TypeDoc
	from KAZ D
	
	union
	
	select
		2 as OI,
		null,--D.DocID, --Рег. номер
		D.Currency, --Валюта
		null,--D.UserFieldDate3, --Рег. дата
		null,--D.UserFieldDate1, --Плановая дата оплаты
		null,--D.UserFieldText7, --Наличный расчет
		null,--D.UserFieldText8, --Бизнес единица
		null,--D.NameAproval, --Фин. Менеджер
		null,--D.UserFieldText2, --ЦФО
		null,--D.PartnerName, --Отправитель\Получатель
		null,--D.UserFieldText4, --Объект
		null,--D.UserFieldText5, --Статья расходов
		null,--D.Name, --Назначение
		sum(D.AmountDoc) as AmounDoc, --Сумма
		null,--D.DocIDParent, --Оплата по договору №
		null,--D.DocIDPrevious, --№ договора с Заказчиком
		null,--D.UserFieldText6, --Счет
		null,--D.Description, --Основание
		null,--D.UserFieldMoney1, --Возникновение обязательств
		null,--D.NameCreation, --Заявитель
		null,--D.UserFieldText1, --Наименование листа согласования
		null,--D.ListToReconcile, --Лист согласования
		null,--D.Correspondent, --Список рассылки
		null,--D.ListToEdit, --Список имеющих право редактирования д-та
		null,--D.FinStatus
		
		null,--D.IsActive,
		null,--D.ClassDoc,
		null,--D.StatusCompletion,
		null,--D.StatusDevelopment,
		null,--D.StatusPayment,
		null,--D.StatusArchiv,
		null,--D.StatusDelivery,
		--null,--D.ListToReconcile,
		null,--D.ListReconciled,
		null,--D.NameApproved,
		null,--D.ListToView,
		--null,--D.NameAproval,
		--null,--D.Correspondent,
		null,--D.NameResponsible,
		null,--D.NameControl,
		null,--D.LocationPath,
		null,--D.DateCompleted,
		null,--D.DateCompletion,		
		null,--D.DateSigned,
		null,--D.Resolution,
		null,--D.DateApproved,
		null--D.TypeDoc,
	from KAZ D
	group by D.Currency
	
	order by 1,2,3

GO
/****** Object:  StoredProcedure [dbo].[PDX_PAYPLNn_Unload] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[PDX_PAYPLNn_Unload] --ВЫГРУЗКА ПЛАНОВЫХ ЗАЯВОК
	@Date datetime 
as

set nocount on

	declare @Result int
	set @Result = 0

	create table #KAZP
	(	TransferGUID uniqueidentifier,
		DocID varchar(128),
		UserFieldDate3 datetime,
		UserFieldDate1 datetime,
		UserFieldText8 varchar(1024),
		ID_UFT8 varchar(10),
		STATUS int,
		PartnerName varchar(512),
		PNTaxID varchar(64),
		PortalID int,
		Name varchar(256),
		Description varchar(1024),
		DocIDParent varchar(128),
		ParentID varchar(128),
		DocIDPrevious varchar(128),
		PreviousID varchar(128),
		UserFieldText2 varchar(1024),
		ID_UFT2 varchar(1024),
		UserFieldText5 varchar(1024),
		ID_UFT5 varchar(1024),		
		UserFieldText7 varchar(1024),
		UserFieldText4 varchar(1024),
		ID_UFT4 varchar(1024),
		UserFieldText6 varchar(1024),
		ID_UFT6 int,
		Currency varchar(12),
		CurrCode2 varchar(12),
		AmountDoc money,		
		NameAproval varchar(96),
		NameApp varchar(96),
		NameCreation varchar(96),
		NameCr varchar(96),
		DateApproved datetime,
		UserFieldText1 varchar(1024),
		ListToReconcile varchar(1024),
		UserFieldMoney1 money,
		VnutrOborot tinyint,
		FinStatus varchar(60),
		FinStatusComment varchar(4000))
		
	insert into #KAZP
	exec PayDoxOP.dbo.PDX_PAYPLNn_UnloadFromDB
	@Date = @Date
	
	
	select * from #KAZP

	drop table #KAZP
	
set nocount off
	return @Result
Err:

set nocount off
		return @Result










GO
/****** Object:  StoredProcedure [dbo].[PDX_PAYPLNn_UnloadFromDB] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--drop proc [dbo].[PDX_PAYPLNn_UnloadFromDB]
CREATE proc [dbo].[PDX_PAYPLNn_UnloadFromDB] --ВЫГРУЗКА ПЛАНОВЫХ ЗАЯВОК
	@Date datetime 
as

set nocount on

	declare @Result int
	set @Result = 0

	declare @ClassName varchar(128)
	
	select @ClassName = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_PLNPAY')
	select @Result = @@error if @Result <> 0 goto Err
	
	create table #tbl_pay
		(DocID varchar(128),
		StatusDevelopment varchar(1),
		DocIDParent varchar(128), 
		DocIDPrevious varchar(128),
		ParentID varchar(128), 
		PreviousID varchar(128),
		PartnerName varchar(512),
		TaxID varchar(32),
		PortalID int)
	
	insert into #tbl_pay (DocID, StatusDevelopment, DocIDParent, DocIDPrevious, PartnerName)
	select DocID, StatusDevelopment, DocIDParent, DocIDPrevious, PartnerName
	from dbo.Docs D
	where D.ClassDoc = @ClassName
		and UPPER(ISNULL(D.IsActive,'')) = 'Y'	
		and ISNULL(D.StatusDevelopment,'') ='4'
		and ISNULL(D.StatusCompletion,'') <>'0'
		and D.DateApproved >= @Date	
	select @Result = @@error if @Result <> 0 goto Err
		
	update P
		set ParentID = isnull(Par.DocIDIncoming,'')
	from #tbl_pay as P
	inner join dbo.Docs Par on Par.DocID = P.DocIDParent
	select @Result = @@error if @Result <> 0 goto Err

	update P
		set PreviousID = isnull(Prev.DocIDIncoming,'')
	from #tbl_pay as P
	left join dbo.Docs Prev on Prev.DocID = P.DocIDPrevious
	select @Result = @@error if @Result <> 0 goto Err
	
	update P
		set TaxID = isnull(PN.TaxID,''),
		PortalID = PN.PortalID
	from #tbl_pay as P
	left join dbo.Partners PN on PN.Name = P.PartnerName 
	select @Result = @@error if @Result <> 0 goto Err

		--тепер собираем информацию
	select
		D.TransferGUID, --УНИКАЛЬНЫЙ ИД ЗАПИСИС. DocID - теоретически м.б. изменен
		D.DocID,  --Рег. номер
		D.UserFieldDate3, --рег. дата
		D.UserFieldDate1, --плановая дата оплаты

		D.UserFieldText8,  --Бизнес единица
		dbo.PDX_fn_pay_FirmGET(D.UserFieldText8) as ID_UFT8,

		2 as STATUS,--утверждена
		
		--****************************************
		P.PartnerName,  --Отправитель\Получатель
		isnull(P.TaxID,'') as PNTaxID, --ИНН
		--isnull(PN.TaxID,'') as PNTaxID, --ИНН
		P.PortalID as PortalID,

		D.Name,  --Назначение
		D.Description,  --Основание

		isnull(P.DocIDParent,'') as DocIDParent,  --Основной договор
		isnull(P.ParentID,'')as ParentID,
		--isnull(Par.DocIDIncoming,'') as ParentID,

		isnull(P.DocIDPrevious,'') as DocIDPrevious,  --Для работ по договору
		isnull(P.PreviousID,'')as PreviousID,
		--isnull(Prev.DocIDIncoming,'') as PreviousID,
		--****************************************

		D.UserFieldText2,  --ЦФО
		dbo.PDX_fn_pay_CFOGET(D.UserFieldText2) as ID_UFT2,

/**********изменение****************/
		--D.UserFieldText3,  
		--dbo.PDX_fn_pay_DirectionGET(D.UserFieldText3) as ID_UFT3,
/***********************************/

		D.UserFieldText5,  --Статья ПРиЗ
		dbo.PDX_fn_pay_ItemGET(D.UserFieldText5) as ID_UFT5,
			
		D.UserFieldText7,  --Наличный расчет

/**********изменение****************/
		D.UserFieldText4,  --Код ИСР
		dbo.PDX_SubstringReturn(D.UserFieldText4,CHARINDEX('<',D.UserFieldText4),CHARINDEX('>',D.UserFieldText4)) as ID_UFT4,
		--isnull(U.Field2,'') as ID_UFT4,
/***********************************/

		D.UserFieldText6,  --Счет
		dbo.PDX_fn_pay_AccountGET(D.UserFieldText6) as ID_UFT6 ,
		--****************************************
		D.Currency,  --Валюта
		isnull(Curr.Code2,'') as CurrCode2,--

		D.AmountDoc,--Сумма
		
		D.NameAproval,  --Фин директор
		isnull(NA.Name,'') as NameApp,
		D.NameCreation,  --Автор/Инициатор
		isnull(NC.Name,'') as NameCr,

		case
			when not D.DateApproved IS null and YEAR(D.DateApproved)>1900 then D.DateApproved
			else GETDATE()
		end as DateApproved, --дата утверждения
		D.UserFieldText1,  --Наименование листа согласования
		D.ListToReconcile,  --Лист согласования
		D.UserFieldMoney1, --возникновение обязательств
		cast(D.UserFieldMoney2 as int) as VnutrOborot,
		PD.FinStatus,
		PD.Comment as FinStatusComment
	from #tbl_pay P
	inner join dbo.Docs D on D.DocID = P.DocID
	--left join dbo.UserDirValues U on U.UDKeyField = 35 and U.Field1 = D.UserFieldText4
	left join dbo.CurrencyRates Curr on Curr.Code = D.Currency
	left join dbo.Users NA on D.NameAproval like '%<' + NA.UserID + '>%'
	left join dbo.Users NC on D.NameCreation like '%<' + NC.UserID + '>%'
	left join dbo.[PayStatusDetails] PD on PD.DocIDInt = D.DocIDInt
	order by D.DocID
	select @Result = @@error if @Result <> 0 goto Err

set nocount off
	return @Result
Err:

set nocount off
		return @Result







GO
/****** Object:  StoredProcedure [dbo].[PDX_PAYPLNn_View] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE proc [dbo].[PDX_PAYPLNn_View] 
	@Month int,
	@Year int,
	@UserID varchar(16)
as

set nocount on


	declare @ClassName varchar(128)
	
	select @ClassName = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_PLNPAY')
	
	
	;with KAZ as (
	select
		D.UserFieldDate3, --Рег. дата
		D.DocID, --Рег. номер
		D.UserFieldDate1, --Плановая дата оплаты
		D.UserFieldText7, --Наличный расчет
		D.Currency, --Валюта
		D.UserFieldText8, --Бизнес единица
		D.NameAproval, --Фин. Менеджер
		D.UserFieldText2, --ЦФО
		D.PartnerName, --Отправитель\Получатель
		D.UserFieldText4, --Объект
		D.UserFieldText5, --Статья расходов
		D.Name, --Назначение
		D.AmountDoc, --Сумма
		D.DocIDParent, --Оплата по договору №
		D.DocIDPrevious, --№ договора с Заказчиком
		D.UserFieldText6, --Счет
		D.Description, --Основание
		D.UserFieldMoney1, --Возникновение обязательств
		D.NameCreation, --Заявитель
		D.UserFieldText1, --Наименование листа согласования
		D.ListToReconcile, --Лист согласования
		D.Correspondent, --Список рассылки
		D.ListToEdit, --Список имеющих право редактирования д-та
		P.FinStatus,
		D.DocIDInt,
		
		D.IsActive,
		D.ClassDoc,
		D.StatusCompletion,
		D.StatusDevelopment,
		D.StatusPayment,
		D.StatusArchiv,
		D.StatusDelivery,
		--D.ListToReconcile,
		D.ListReconciled,
		D.NameApproved,
		D.ListToView,
		--D.NameAproval,
		--D.Correspondent,
		D.NameResponsible,
		D.NameControl,
		D.LocationPath,
		D.DateCompleted,
		D.DateCompletion,		
		D.DateSigned,
		D.Resolution,
		D.DateApproved,
		D.TypeDoc
	from dbo.Docs D
	left join [dbo].[PayStatusDetails] P on P.DocIDInt = D.DocIDInt
	where D.ClassDoc = @ClassName
		and D.IsActive = 'Y'
		and isnull(D.StatusCompletion,'') <> '0'
		and D.StatusDevelopment = '4'
		and Month(D.UserFieldDate1) = @Month
		and YEAR(D.UserFieldDate1) = @Year
		and D.NameCreation like '%<' + @UserID + '>%'
		)
		
	select
		1 as OI,
		D.UserFieldDate3, --Рег. дата
		D.Currency, --Валюта
		D.DocID, --Рег. номер
		D.UserFieldDate1, --Плановая дата оплаты
		D.UserFieldText7, --Наличный расчет
		D.UserFieldText8, --Бизнес единица
		D.NameAproval, --Фин. Менеджер
		D.UserFieldText2, --ЦФО
		D.PartnerName, --Отправитель\Получатель
		D.UserFieldText4, --Объект
		D.UserFieldText5, --Статья расходов
		D.Name, --Назначение
		D.AmountDoc, --Сумма
		D.DocIDParent, --Оплата по договору №
		D.DocIDPrevious, --№ договора с Заказчиком
		D.UserFieldText6, --Счет
		D.Description, --Основание
		D.UserFieldMoney1, --Возникновение обязательств
		D.NameCreation, --Заявитель
		D.UserFieldText1, --Наименование листа согласования
		D.ListToReconcile, --Лист согласования
		D.Correspondent, --Список рассылки
		D.ListToEdit, --Список имеющих право редактирования д-та
		D.FinStatus,
		D.DocIDInt,
		
		D.IsActive,
		D.ClassDoc,
		D.StatusCompletion,
		D.StatusDevelopment,
		D.StatusPayment,
		D.StatusArchiv,
		D.StatusDelivery,
		--D.ListToReconcile,
		D.ListReconciled,
		D.NameApproved,
		D.ListToView,
		--D.NameAproval,
		--D.Correspondent,
		D.NameResponsible,
		D.NameControl,
		D.LocationPath,
		D.DateCompleted,
		D.DateCompletion,		
		D.DateSigned,
		D.Resolution,
		D.DateApproved,
		D.TypeDoc
	from KAZ D	
	
	union
	
	select
		2 as OI,
		null,--D.UserFieldDate3, --Рег. дата
		D.Currency, --Валюта
		null,--D.DocID, --Рег. номер
		null,--D.UserFieldDate1, --Плановая дата оплаты
		null,--D.UserFieldText7, --Наличный расчет
		null,--D.UserFieldText8, --Бизнес единица
		null,--D.NameAproval, --Фин. Менеджер
		null,--D.UserFieldText2, --ЦФО
		null,--D.PartnerName, --Отправитель\Получатель
		null,--D.UserFieldText4, --Объект
		null,--D.UserFieldText5, --Статья расходов
		null,--D.Name, --Назначение
		sum(D.AmountDoc) as AmountDoc, --Сумма
		null,--D.DocIDParent, --Оплата по договору №
		null,--D.DocIDPrevious, --№ договора с Заказчиком
		null,--D.UserFieldText6, --Счет
		null,--D.Description, --Основание
		null,--D.UserFieldMoney1, --Возникновение обязательств
		null,--D.NameCreation, --Заявитель
		null,--D.UserFieldText1, --Наименование листа согласования
		null,--D.ListToReconcile, --Лист согласования
		null,--D.Correspondent, --Список рассылки
		null,--D.ListToEdit, --Список имеющих право редактирования д-та
		null,--D.FinStatus,
		null,--D.DocIDInt,
		
		null,--D.IsActive,
		null,--D.ClassDoc,
		null,--D.StatusCompletion,
		null,--D.StatusDevelopment,
		null,--D.StatusPayment,
		null,--D.StatusArchiv,
		null,--D.StatusDelivery,
		--null,--D.ListToReconcile,
		null,--D.ListReconciled,
		null,--D.NameApproved,
		null,--D.ListToView,
		--null,--D.NameAproval,
		--null,--D.Correspondent,
		null,--D.NameResponsible,
		null,--D.NameControl,
		null,--D.LocationPath,
		null,--D.DateCompleted,
		null,--D.DateCompletion,		
		null,--D.DateSigned,
		null,--D.Resolution,
		null,--D.DateApproved,
		null--D.TypeDoc
	from KAZ D
	group by D.Currency
	
	order by 1,2,3




GO
/****** Object:  StoredProcedure [dbo].[PDX_PAYPLNn2_Unload] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_PAYPLNn2_Unload] --ВЫГРУЗКА ПЛАНОВЫХ ЗАЯВОК
	@Date datetime 
as

set nocount on

	declare @Result int
	set @Result = 0

	create table #KAZP
	(	TransferGUID uniqueidentifier,
		DocID varchar(128),
		DocIDInt int,
		PlnTblID int,
		UserFieldDate3 datetime,
		UserFieldDate1 datetime,
		PlanYear int,
		UserFieldText8 varchar(1024),
		ID_UFT8 varchar(10),
		STATUS int,
		PartnerName varchar(512),
		PNTaxID varchar(64),
		PortalID int,
		Name varchar(256),
		Description varchar(1024),
		DocIDParent varchar(128),
		ParentID varchar(128),
		DocIDPrevious varchar(128),
		PreviousID varchar(128),
		UserFieldText2 varchar(1024),
		ID_UFT2 varchar(1024),
		UserFieldText5 varchar(1024),
		ID_UFT5 varchar(1024),		
		UserFieldText7 varchar(1024),
		UserFieldText4 varchar(1024),
		ID_UFT4 varchar(1024),
		UserFieldText6 varchar(1024),
		ID_UFT6 int,
		Currency varchar(12),
		CurrCode2 varchar(12),
		AmountDoc money,		
		Jan money,
		Feb money,
		Mar money,
		Apr money,
		May money,
		Jun money,
		Jul money,
		Aug money,
		Sep money,
		Oct money,
		Nov money,
		[Dec] money,	
		NameAproval varchar(96),
		NameApp varchar(96),
		NameCreation varchar(96),
		NameCr varchar(96),
		DateApproved datetime,
		UserFieldText1 varchar(1024),
		ListToReconcile varchar(1024),
		UserFieldMoney1 money,
		VnutrOborot int,
		FinStatus varchar(60),
		FinStatusComment varchar(4000),
		CorrBudget int,
		OrderType tinyint,
		CurrentReconcile varchar(4096))
		
		
	insert into #KAZP
	exec PayDoxOP.dbo.PDX_PAYPLNn2_UnloadFromDB
	@Date = @Date
	
	
	insert into #KAZP
	exec PayDoxOP.dbo.PDX_PAYPLNTBLn_UnloadFromDB
	@Date = @Date
	
	
	select * from #KAZP

	drop table #KAZP
	
set nocount off
	return @Result
Err:

set nocount off
		return @Result


GO
/****** Object:  StoredProcedure [dbo].[PDX_PAYPLNn2_UnloadFromDB] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[PDX_PAYPLNn2_UnloadFromDB]
	@Date datetime
	
as
/*
ВСЕ ВОЗМОЖНЫЕ СТАТУСЫ - STATUS:
	-3 - ошибка в статусе
	-2 - отменен
	-1 - неактивен
	 0 - отказано в согласовании
	 1 - на согласовании
	 2 - утверждена
	 4 - отменена
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
данная процедура оперирует только статусами:
	-3 - ошибка в статусе
 	 0 - отказано в согласовании
	 1 - на согласовании
	 2 - утверждена
	 4 - отменена
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Процедура отбирает карточки документов "Плановая заявка", которые были:
	АКТИВИРОВАНЫ - дата последней активации (DateActive из табл. Docs)
		(Изменения только полей карточке, загрузка файлов, написание комментариев к карточке не учитывается)
	ИЛИ
	ИЗМЕНЕНЫ - дата последнего изменения (DateLastModifacation из табл. Docs)
	ИЛИ
	УТВЕРЖДЕНЫ - дата последнего утверждения (DateApproved из табл. Docs)
после указанной даты (@Date)
    ИЛИ 
    ОТМЕНЕНЫ - статус отменено
В выборку также попадают документы, в которых после указанной даты (@Date) были отказы в согласовании.
Но если такой отказ был отозван(отправлено на повторное согласование или отказавший был исключен из ЛС), 
то карточка в выборку не попадает.
Это обусловлено тем, что нас интересует только ТЕКУЩИЙ(действительный) статус документа "отказано в согласоании".
Если отказ был отозван, то статус документа вернулся в состояние "требует согласования" и документ нас будет интересовать, 
если он попадает под DateActive/DateLastModification/DateApproved
	
*/
	
	declare  @Res int

	declare @DocID varchar(128),
		@StopRefuseFlag bit

	set nocount on

	create table #tbl_pay
		(DocID varchar(128),
		StatusDevelopment varchar(1),
		VisaRefuse bit,
		Flg bit default 0,
		DocIDParent varchar(128), 
		DocIDPrevious varchar(128),
		ParentID varchar(128), 
		PreviousID varchar(128),
		PartnerName varchar(512),
		TaxID varchar(32),
		PortalID int)

	create table #del_summ
		(DocID varchar(128),
		Am1 money,
		SetID uniqueidentifier,
		Tx1 varchar(2048))
		
	declare @ErrList varchar(4000),
		@ClassName varchar(128)

	select @ClassName = DocType,
		@StopRefuseFlag = StopRefuseFlag 
	from dbo.PDXDocTypesConst
	where ConstName = 'RIK_CategoryName_KAZ_PLNPAY'
	select @Res = @@error if @Res <> 0 goto Err

	select @Res = 0,@ErrList = ''
	
	--по датам из комментов
	--отказ в согласовании, причем только если этот отказ не был отозван
	insert into #tbl_pay
		(DocID,	StatusDevelopment, VisaRefuse, DocIDParent, DocIDPrevious, PartnerName)
	select distinct D.DocID, D.StatusDevelopment, 
			case --условие, что отказ не был отозван (отзыв отказа - это или удалили из ЛС отказника или отменили его оказ в согл.)
				when isnull(D.ListReconciled,'') like '%-<%' 
						and isnull(D.ListToReconcile,'') like '%<' + C.UserID + '>%'
						and isnull(D.ListReconciled,'') like '%-<' + C.UserID + '>%'
					then 1 
				else 0 
			end, D.DocIDParent, D.DocIDPrevious, D.PartnerName
	from dbo.Comments C
	inner join 	dbo.Docs D on C.DocID = D.DocID
		and D.ClassDoc = @ClassName --смотрим чтобы была нужная категория
		and Upper(isnull(D.isActive,'')) = 'Y' --активная карточка
		and isnull(D.StatusCompletion,'') <> '0' --неотмененая карточка (отмененные это отдельный блок)
		and case when isnull(ListReconciled,'') like '%-<%' then 1 else 0 end = 1
	where Upper(isnull(C.CommentType,'')) = 'VISA' --берем отказ в согласовании
		and Upper(isnull(C.SpecialInfo,'')) = 'VISAOKREFUSE'
		and C.DateCreation >= @Date
	select @Res = @@error if @Res <> 0 goto Err

	--по датам из комментов
	--отправка на повторное согласование - смысл в том, чтобы "засечь" изменение статуса с "приостановлено-есть отказ" на "требует согласоание"
	--вариант когда при отмене стаус не меняется нам в принципе не интересен, но так как отделить эти ситуации невозможно - будем "брать" все
	
	--добавленяем все виды комментов, которые относятся к согл/отказ, т.к. тепреь хотим еще отслеживать обязательных согласующих
	insert into #tbl_pay
		(DocID,	StatusDevelopment, VisaRefuse, DocIDParent, DocIDPrevious, PartnerName)
	select distinct D.DocID, D.StatusDevelopment, 
			dbo.PDX_fn_stopReconcilation(D.ListToReconcile, D.ListReconciled, @StopRefuseFlag),
			D.DocIDParent, D.DocIDPrevious, D.PartnerName
	from dbo.Comments C
	inner join 	dbo.Docs D on C.DocID = D.DocID
		and D.ClassDoc = @ClassName --смотрим чтобы была нужная категория
		and Upper(isnull(D.isActive,'')) = 'Y' --активная карточка
		and isnull(D.StatusCompletion,'') <> '0' --неотмененая карточка (отмененные это отдельный блок)
	where Upper(isnull(C.CommentType,'')) = 'VISA' --берем отказ в согласовании
		and Upper(isnull(C.SpecialInfo,'')) in ('PARTVISACANCEL','VISAOK','VISAOKREFUSE','VISAOKREFUSERESET','VISAOKRESET')
		and C.DateCreation >= @Date
		and not exists(select 1 from #tbl_pay P where P.DocID = D.DocID)--не повторяемся, если карточка отобралась через отказ
	select @Res = @@error if @Res <> 0 goto Err

	--по датам из картчоки
	insert into #tbl_pay
		(DocID,	StatusDevelopment, VisaRefuse, DocIDParent, DocIDPrevious, PartnerName)
	select distinct D.DocID, D.StatusDevelopment, 
		dbo.PDX_fn_stopReconcilation(ListToReconcile, ListReconciled, @StopRefuseFlag), 
		D.DocIDParent, D.DocIDPrevious, D.PartnerName
	from dbo.Docs D
	where D.ClassDoc = @ClassName --смотрим чтобы была нужная категория
	and (isnull(D.DateActive,D.DateLastModification) >= @Date or --отбираем по дате последней активаци
		isnull(D.DateLastModification, D.DateCreation) >= @Date or --отбираем по дате последнего изм-я
		isnull(D.DateApproved,'1900-01-01') >= @Date) --отбираем по дате утв-я
	and Upper(isnull(D.isActive,'')) = 'Y'--активная карточка
	and isnull(D.StatusCompletion,'') <> '0'	--неотмененая карточка (отмененные это отдельный блок)
	and not exists(select 1 from #tbl_pay P where P.DocID = D.DocID)--не повторяемся, если карточка отобралась через отказ
	select @Res = @@error if @Res <> 0 goto Err
		

    /*************************************************************************************************/
    /*************************************************************************************************/
    /*************************************************************************************************/

	update P
		set ParentID = isnull(Par.DocIDIncoming,'')
	from #tbl_pay as P
	inner join dbo.Docs Par on Par.DocID = P.DocIDParent
	select @Res = @@error if @Res <> 0 goto Err

	update P
		set PreviousID = isnull(Prev.DocIDIncoming,'')
	from #tbl_pay as P
	left join dbo.Docs Prev on Prev.DocID = P.DocIDPrevious
	select @Res = @@error if @Res <> 0 goto Err
	
	update P
		set TaxID = isnull(PN.TaxID,''),
		PortalID = PN.PortalID
	from #tbl_pay as P
	left join dbo.Partners PN on PN.Name = P.PartnerName 
	select @Res = @@error if @Res <> 0 goto Err

	--тепер собираем информацию
	select
		D.TransferGUID, --УНИКАЛЬНЫЙ ИД ЗАПИСИС. DocID - теоретически м.б. изменен
		D.DocID,  --Рег. номер
		D.DocIDInt,
		null as PlnTblID,
		D.UserFieldDate3, --рег. дата
		D.UserFieldDate1, --плановая дата оплаты
		null as PlanYear,

		D.UserFieldText8,  --Бизнес единица
		dbo.PDX_fn_pay_FirmGET(D.UserFieldText8) as ID_UFT8,

		--2 as STATUS,--утверждена
		case 
			when isnull(D.StatusCompletion,'') = '0'
				then 4 -- отменена
			when isnull(D.StatusDevelopment,'') = '4'
				and P.VisaRefuse = 1
				then -3 --в утвержденной карточке не может быть отказов в согласовании
			when isnull(D.StatusDevelopment,'') = '4'
				then 2 --утверждена
			when P.VisaRefuse = 1
				then 0 --отказано в согласовании
			else 1 --на соглаовании
		end as STATUS ,
		--****************************************
		P.PartnerName,  --Отправитель\Получатель
		isnull(P.TaxID,'') as PNTaxID, --ИНН
		--isnull(PN.TaxID,'') as PNTaxID, --ИНН
		P.PortalID as PortalID,

		D.Name,  --Назначение
		D.Description,  --Основание

		isnull(P.DocIDParent,'') as DocIDParent,  --Основной договор
		isnull(P.ParentID,'')as ParentID,
		--isnull(Par.DocIDIncoming,'') as ParentID,

		isnull(P.DocIDPrevious,'') as DocIDPrevious,  --Для работ по договору
		isnull(P.PreviousID,'')as PreviousID,
		--isnull(Prev.DocIDIncoming,'') as PreviousID,
		--****************************************

		D.UserFieldText2,  --ЦФО
		dbo.PDX_fn_pay_CFOGET(D.UserFieldText2) as ID_UFT2,

/**********изменение****************/
		--D.UserFieldText3,  
		--dbo.PDX_fn_pay_DirectionGET(D.UserFieldText3) as ID_UFT3,
/***********************************/

		D.UserFieldText5,  --Статья ПРиЗ
		dbo.PDX_fn_pay_ItemGET(D.UserFieldText5) as ID_UFT5,
			
		D.UserFieldText7,  --Наличный расчет

/**********изменение****************/
		D.UserFieldText4,  --Код ИСР
		dbo.PDX_SubstringReturn(D.UserFieldText4,CHARINDEX('<',D.UserFieldText4),CHARINDEX('>',D.UserFieldText4)) as ID_UFT4,
		--isnull(U.Field2,'') as ID_UFT4,
/***********************************/

		D.UserFieldText6,  --Счет
		dbo.PDX_fn_pay_AccountGET(D.UserFieldText6) as ID_UFT6 ,
		--****************************************
		D.Currency,  --Валюта
		isnull(Curr.Code2,'') as CurrCode2,--

		D.AmountDoc,--Сумма
		null as Jan,
		null as Feb,
		null as Mar,
		null as Apr,
		null as May,
		null as Jun,
		null as Jul,
		null as Aug,
		null as Sep,
		null as Oct,
		null as Nov,
		null as Dec,
		
		D.NameAproval,  --Фин директор
		isnull(NA.Name,'') as NameApp,
		D.NameCreation,  --Автор/Инициатор
		isnull(NC.Name,'') as NameCr,

		case
			when not D.DateApproved IS null and YEAR(D.DateApproved)>1900 then D.DateApproved
			else GETDATE()
		end as DateApproved, --дата утверждения
		D.UserFieldText1,  --Наименование листа согласования
		D.ListToReconcile,  --Лист согласования
		D.UserFieldMoney1, --возникновение обязательств
		cast(D.UserFieldMoney2 as int) as VnutrOborot,
		PD.FinStatus,
		PD.Comment as FinStatusComment,
		cast(NULL as int) as CorrBudget,
		1 as OrderType,
		[dbo].[GetCurrentReconUsersByDocID](D.ListToReconcile, D.ListReconciled) as CurrentReconcile
	from #tbl_pay P
	inner join dbo.Docs D on D.DocID = P.DocID
	--left join dbo.UserDirValues U on U.UDKeyField = 35 and U.Field1 = D.UserFieldText4
	left join dbo.CurrencyRates Curr on Curr.Code = D.Currency
	left join dbo.Users NA on D.NameAproval like '%<' + NA.UserID + '>%'
	left join dbo.Users NC on D.NameCreation like '%<' + NC.UserID + '>%'
	left join dbo.[PayStatusDetails] PD on PD.DocIDInt = D.DocIDInt
	order by D.DocID
	select @Res = @@error if @Res <> 0 goto Err


OK:
	set nocount off
	return @Res
Err:
	set nocount off
	return @Res


GO
/****** Object:  StoredProcedure [dbo].[PDX_PAYPLNTBLn_UnloadFromDB] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_PAYPLNTBLn_UnloadFromDB]
	@Date datetime
	
as
/*
ВСЕ ВОЗМОЖНЫЕ СТАТУСЫ - STATUS:
	-3 - ошибка в статусе
	-2 - отменен
	-1 - неактивен
	 0 - отказано в согласовании
	 1 - на согласовании
	 2 - утверждена
	 4 - отменена
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
данная процедура оперирует только статусами:
	-3 - ошибка в статусе
 	 0 - отказано в согласовании
	 1 - на согласовании
	 2 - утверждена
	 4 - отменена
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Процедура отбирает карточки документов "Плановая заявка", которые были:
	АКТИВИРОВАНЫ - дата последней активации (DateActive из табл. Docs)
		(Изменения только полей карточке, загрузка файлов, написание комментариев к карточке не учитывается)
	ИЛИ
	ИЗМЕНЕНЫ - дата последнего изменения (DateLastModifacation из табл. Docs)
	ИЛИ
	УТВЕРЖДЕНЫ - дата последнего утверждения (DateApproved из табл. Docs)
после указанной даты (@Date)
    ИЛИ 
    ОТМЕНЕНЫ - статус отменено
В выборку также попадают документы, в которых после указанной даты (@Date) были отказы в согласовании.
Но если такой отказ был отозван(отправлено на повторное согласование или отказавший был исключен из ЛС), 
то карточка в выборку не попадает.
Это обусловлено тем, что нас интересует только ТЕКУЩИЙ(действительный) статус документа "отказано в согласоании".
Если отказ был отозван, то статус документа вернулся в состояние "требует согласования" и документ нас будет интересовать, 
если он попадает под DateActive/DateLastModification/DateApproved
	
*/
	
	declare  @Res int

	declare @DocID varchar(128),
		@StopRefuseFlag bit

	set nocount on

	create table #tbl_pay
		(DocIDInt int,
		TID int,
		StatusDevelopment varchar(1),
		VisaRefuse bit,
		Flg bit default 0,
		DocIDParent varchar(128), 
		DocIDPrevious varchar(128),
		ParentID varchar(128), 
		PreviousID varchar(128),
		PartnerName varchar(512),
		TaxID varchar(32),
		PortalID int)
		
	declare @ErrList varchar(4000),
		@ClassName varchar(128)

	select @ClassName = DocType,
		@StopRefuseFlag = StopRefuseFlag 
	from dbo.PDXDocTypesConst
	where ConstName = 'RIK_CategoryName_KAZ_PLNTBL'
	select @Res = @@error if @Res <> 0 goto Err

	select @Res = 0,@ErrList = ''
	
	--по датам из комментов
	--отказ в согласовании, причем только если этот отказ не был отозван
	insert into #tbl_pay
		(DocIDInt, TID,	StatusDevelopment, VisaRefuse, DocIDParent, DocIDPrevious, PartnerName)
	select distinct D.DocIDInt, T.ID, D.StatusDevelopment, 
			case --условие, что отказ не был отозван (отзыв отказа - это или удалили из ЛС отказника или отменили его оказ в согл.)
				when isnull(D.ListReconciled,'') like '%-<%' 
						and isnull(D.ListToReconcile,'') like '%<' + C.UserID + '>%'
						and isnull(D.ListReconciled,'') like '%-<' + C.UserID + '>%'
					then 1 
				else 0 
			end, T.PayCID, T.CustomerCID, T.PN
	from dbo.Comments C
	inner join 	dbo.Docs D on C.DocIDInt = D.DocIDInt
		and D.ClassDoc = @ClassName --смотрим чтобы была нужная категория
		and Upper(isnull(D.isActive,'')) = 'Y' --активная карточка
		and isnull(D.StatusCompletion,'') <> '0' --неотмененая карточка (отмененные это отдельный блок)
		and case when isnull(D.ListReconciled,'') like '%-<%' then 1 else 0 end = 1
	inner join dbo.DocsPLNTBL T on T.DocIDInt = D.DocIDInt
	where Upper(isnull(C.CommentType,'')) = 'VISA' --берем отказ в согласовании
		and Upper(isnull(C.SpecialInfo,'')) = 'VISAOKREFUSE'
		and C.DateCreation >= @Date
	select @Res = @@error if @Res <> 0 goto Err

	--по датам из комментов
	--отправка на повторное согласование - смысл в том, чтобы "засечь" изменение статуса с "приостановлено-есть отказ" на "требует согласоание"
	--вариант когда при отмене стаус не меняется нам в принципе не интересен, но так как отделить эти ситуации невозможно - будем "брать" все
	
	--добавленяем все виды комментов, которые относятся к согл/отказ, т.к. тепреь хотим еще отслеживать обязательных согласующих
	insert into #tbl_pay
		(DocIDInt, TID,	StatusDevelopment, VisaRefuse, DocIDParent, DocIDPrevious, PartnerName)
	select distinct D.DocIDInt, T.ID, D.StatusDevelopment, 
			dbo.PDX_fn_stopReconcilation(D.ListToReconcile, D.ListReconciled, @StopRefuseFlag),
			T.PayCID, T.CustomerCID, T.PN
	from dbo.Comments C
	inner join 	dbo.Docs D on C.DocIDInt = D.DocIDInt
		and D.ClassDoc = @ClassName --смотрим чтобы была нужная категория
		and Upper(isnull(D.isActive,'')) = 'Y' --активная карточка
		and isnull(D.StatusCompletion,'') <> '0' --неотмененая карточка (отмененные это отдельный блок)
	inner join dbo.DocsPLNTBL T on T.DocIDInt = D.DocIDInt
	where Upper(isnull(C.CommentType,'')) = 'VISA' --берем отказ в согласовании
		and Upper(isnull(C.SpecialInfo,'')) in ('PARTVISACANCEL','VISAOK','VISAOKREFUSE','VISAOKREFUSERESET','VISAOKRESET')
		and C.DateCreation >= @Date
		and not exists(select 1 from #tbl_pay P where P.TID = T.ID)--не повторяемся, если карточка отобралась через отказ
	select @Res = @@error if @Res <> 0 goto Err

	--по датам из картчоки
	insert into #tbl_pay
		(DocIDInt, TID, StatusDevelopment, VisaRefuse, DocIDParent, DocIDPrevious, PartnerName)
	select distinct D.DocIDInt, T.ID, D.StatusDevelopment, 
		dbo.PDX_fn_stopReconcilation(ListToReconcile, ListReconciled, @StopRefuseFlag), 
		T.PayCID, T.CustomerCID, T.PN
	from dbo.Docs D
	inner join dbo.DocsPLNTBL T on T.DocIDInt = D.DocIDInt
	where D.ClassDoc = @ClassName --смотрим чтобы была нужная категория
	and (isnull(D.DateActive,D.DateLastModification) >= @Date or --отбираем по дате последней активаци
		isnull(D.DateLastModification, D.DateCreation) >= @Date or --отбираем по дате последнего изм-я
		isnull(D.DateApproved,'1900-01-01') >= @Date) --отбираем по дате утв-я
	and Upper(isnull(D.isActive,'')) = 'Y'--активная карточка
	and isnull(D.StatusCompletion,'') <> '0'	--неотмененая карточка (отмененные это отдельный блок)
	and not exists(select 1 from #tbl_pay P where P.TID = T.ID)--не повторяемся, если карточка отобралась через отказ
	select @Res = @@error if @Res <> 0 goto Err
		

    /*************************************************************************************************/
    /*************************************************************************************************/
    /*************************************************************************************************/

	update P
		set ParentID = isnull(Par.DocIDIncoming,'')
	from #tbl_pay as P
	inner join dbo.Docs Par on Par.DocID = P.DocIDParent
	select @Res = @@error if @Res <> 0 goto Err

	update P
		set PreviousID = isnull(Prev.DocIDIncoming,'')
	from #tbl_pay as P
	left join dbo.Docs Prev on Prev.DocID = P.DocIDPrevious
	select @Res = @@error if @Res <> 0 goto Err
	
	update P
		set TaxID = isnull(PN.TaxID,''),
		PortalID = PN.PortalID
	from #tbl_pay as P
	left join dbo.Partners PN on PN.Name = P.PartnerName 
	select @Res = @@error if @Res <> 0 goto Err

	--тепер собираем информацию
	select
		D.TransferGUID, --УНИКАЛЬНЫЙ ИД ЗАПИСИС. DocID - теоретически м.б. изменен
		D.DocID,  --Рег. номер
		D.DocIDInt,
		T.ID as PlnTblID,
		D.UserFieldDate3, --рег. дата
		NULL as UserFieldDate1, 
		cast(D.UserFieldText7  as int) as PlanYear,
		
		D.UserFieldText8,  --Бизнес единица
		dbo.PDX_fn_pay_FirmGET(D.UserFieldText8) as ID_UFT8,

		case 
			when isnull(D.StatusCompletion,'') = '0'
				then 4 -- отменена
			when isnull(D.StatusDevelopment,'') = '4'
				and P.VisaRefuse = 1
				then -3 --в утвержденной карточке не может быть отказов в согласовании
			when isnull(D.StatusDevelopment,'') = '4'
				then 2 --утверждена
			when P.VisaRefuse = 1
				then 0 --отказано в согласовании
			else 1 --на соглаовании
		end as STATUS,
		--****************************************
		P.PartnerName,  --Отправитель\Получатель
		isnull(P.TaxID,'') as PNTaxID, --ИНН
		P.PortalID as PortalID,

		T.Name,  --Назначение
		NULL as Description,
		
		isnull(P.DocIDParent,'') as DocIDParent,  --Основной договор
		isnull(P.ParentID,'')as ParentID,

		isnull(P.DocIDPrevious,'') as DocIDPrevious,  --Для работ по договору
		isnull(P.PreviousID,'')as PreviousID,
		--****************************************

		D.UserFieldText2,  --ЦФО
		dbo.PDX_fn_pay_CFOGET(D.UserFieldText2) as ID_UFT2,

		T.Item as  UserFieldText5,  --Статья ПРиЗ
		dbo.PDX_fn_pay_ItemGET(T.Item) as ID_UFT5,
		
		null as UserFieldText7,

/**********изменение****************/
	 	T.Obj as UserFieldText4,  --Объект
		dbo.PDX_SubstringReturn(T.Obj,CHARINDEX('<',T.Obj),CHARINDEX('>',T.Obj)) as ID_UFT4,
/***********************************/

		T.Account as UserFieldText6,  --Счет
		dbo.PDX_fn_pay_AccountGET(T.Account) as ID_UFT6 ,
		--****************************************
		D.Currency,  --Валюта
		isnull(Curr.Code2,'') as CurrCode2,--

		null as AmountDoc,--Сумма
		T.Jan,
		T.Feb,
		T.Mar,
		T.Apr,
		T.May,
		T.Jun,
		T.Jul,
		T.Aug,
		T.Sep,
		T.Oct,
		T.Nov,
		T.Dec,
		
		D.NameAproval,  --Фин директор
		isnull(NA.Name,'') as NameApp,
		D.NameCreation,  --Автор/Инициатор
		isnull(NC.Name,'') as NameCr,

		case
			when not D.DateApproved IS null and YEAR(D.DateApproved)>1900 then D.DateApproved
			else GETDATE()
		end as DateApproved, --дата утверждения
		D.UserFieldText1,  --Наименование листа согласования
		D.ListToReconcile,  --Лист согласования
		null as UserFieldMoney1, --возникновение обязательств
		cast(T.Intrn as int) as VnutrOborot,
		PD.FinStatus,
		PD.Comment as FinStatusComment,		
		cast(case D.UserFieldText6 when 'да' then 1 else 0 end as int) as CorrBudget,
		2 as OrderType,
		[dbo].[GetCurrentReconUsersByDocID](D.ListToReconcile, D.ListReconciled) as CurrentReconcile
	from #tbl_pay P
	inner join dbo.Docs D on D.DocIDInt = P.DocIDInt
	inner join dbo.DocsPLNTBL T on P.TID = T.ID
	left join dbo.CurrencyRates Curr on Curr.Code = D.Currency
	left join dbo.Users NA on D.NameAproval like '%<' + NA.UserID + '>%'
	left join dbo.Users NC on D.NameCreation like '%<' + NC.UserID + '>%'
	left join dbo.[PayStatusDetails] PD on PD.DocIDInt = D.DocIDInt
	order by D.DocID,T.ID
	select @Res = @@error if @Res <> 0 goto Err


OK:
	set nocount off
	return @Res
Err:
	set nocount off
	return @Res


GO
/****** Object:  StoredProcedure [dbo].[PDX_payPRiZ_Change] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE proc [dbo].[PDX_payPRiZ_Change]
	@Name varchar(512),
	@Code varchar(128),
	@Descr varchar(256),
	@SetID int,
	@ParentName varchar(512),
	@NC varchar(128),
	@E1 char(1),
	@E2 char(1),
	@E3 char(1),
	@Gr varchar(256),
	@Act int, --1--ceate, 2-update,3 delete
	@Chk bit = 0
	
as
	declare  @Res int

	declare @ErrList varchar(1024),
		@ParentID int, @Cnt int,
		@ParentCode varchar(64),
		@GrParent varchar(256)

	select @Res = 0,@ErrList = ''
	
	create table #cfo (SetID int, ParentID int)

	select
		@E1 = case @E1 when '1' then @E1 else '' end,
		@E2 = case @E2 when '1' then @E2 else '' end,
		@E3 = case @E3 when '1' then @E3 else '' end,
		@Name = ltrim(rtrim(isnull(@Name,''))),
		@Code = ltrim(rtrim(isnull(@Code,''))),
		@Descr = ltrim(rtrim(isnull(@Descr,''))),
		@NC  = ltrim(rtrim(isnull(@NC,''))),
		@ParentID = null,
		@ParentName = ltrim(rtrim(isnull(@ParentName,''))),
		@Cnt = 1,
		@Gr = 	ltrim(rtrim(isnull(@Gr,'')))
	select @Res = @@error if @Res <> 0 goto Err

If @ParentName like '%<%>%'
begin
	select @ParentCode = dbo.PDX_SubstringReturn(@ParentName, charindex('<',@ParentName), charindex('>',@ParentName))
	select @Res = @@error if @Res <> 0 goto Err
end

/************************************
ПРОВЕРКИ ВВЕДЕННЫХ ЗНАЧЕНИЙ
*************************************/
If @Act <> 3
begin
If @Name = ''
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Укажите наименование'
	goto NXT
end
If len(@Name) > 256 
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Превышена максимально допустимая длина Наименования (всего - ' + cast(len(@Name) as varchar(100)) + ', макс. - 256)'
	goto NXT
end
If @Code = ''
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Укажите код статьи'
	goto NXT
end
If len(@Code) > 64 
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Превышена максимально допустимая длина Кода (всего - ' + cast(len(@Code) as varchar(100)) + ', макс. - 64)'
	goto NXT
end
If @Gr = ''
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Укажите группу'
	goto NXT
end

/*If exists (select 1 from dbo.PDX_pay_PRiZ where Name = @Name 
		and SetID <> isnull(@SetID,-1))
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Статья ПРиЗ с указаным названием в справочнике уже существует'
	select @Res = @@error if @Res <> 0 goto Err		
end*/

If exists (select 1 from dbo.PDX_pay_PRiZ where Code = @Code 
		and SetID <> isnull(@SetID,-1))
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Статья ПРиЗ с указаным кодом в справочнике уже существует'
	select @Res = @@error if @Res <> 0 goto Err		
end

If not @ParentCode is null
begin
	select @ParentID = SetID,
		@GrParent = GrName
	from dbo.PDX_pay_PRiZ 
	where Code = @ParentCode
	select @Res = @@error if @Res <> 0 goto Err
	
	If @ParentID is null
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Родительский Статья ПРиЗ не существует'
		select @Res = @@error if @Res <> 0 goto Err		
	end
	IF @Act = 2 
	begin 
		insert into #cfo (SetID)
		values (@SetID)
		select @Res = @@error if @Res <> 0 goto Err	

		while @cnt > 0 and not exists (select 1 from #cfo where SetID = @ParentID)
		begin
			insert into #cfo (SetID)
			select C.SetID
			from dbo.PDX_pay_PRiZ C
			inner join #cfo F on F.SetID = C.ParentID
			where not exists (select 1 from #cfo V where V.SetID = C.SetID)
			select @cnt=@@rowcount,@Res = @@error if @Res <> 0 goto Err	
		end
		select @Res = @@error if @Res <> 0 goto Err	
		
		If exists (select 1 from #cfo where SetID = @ParentID)
		begin
			select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
				'Некорректно указана Родительская Статья ПРиЗ (нельзя в качестве родителя указывать дочерний узел).'
			select @Res = @@error if @Res <> 0 goto Err		
		end
	end
	
	If @Gr <> @GrParent 
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Группа, указанная для данной статьи, должна совпадать с группой родительской статьи'
		select @Res = @@error if @Res <> 0 goto Err		
	end
	
end --If not @ParentCode is null
end

IF @Act = 3
begin
	If exists (select 1 from dbo.PDX_pay_PRiZ where ParentID = @SetID)
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Нальзя удалить элемент, у него есть подчиненые.'
		select @Res = @@error if @Res <> 0 goto Err		
	end
end
/************************************/

NXT:

If @Chk = 0
begin --если это создание , то нужно генерить ошибкуесли она есть
	If @ErrList <> '' 
	begin
		RAISERROR (@ErrList, 16,1)
		goto Err
	end
end
else --если это проверка просто выводим сообщение, даже если оно пустое
begin
	select @ErrList as ErrList 
	select @Res = @@error if @Res <> 0 goto Err
end

IF @ErrList = '' and @Chk = 0
BEGIN
	if @Act = 2
	begin
		update dbo.PDX_pay_PRiZ
			set 
				Name = @Name,
				Code = @Code,
				Descr = @Descr,
				ParentID = @ParentID,
				NLM = @NC,
				e1 = @E1,
				e2 = @E2,
				e3 = @E3,
				GrName = @Gr,
				DLM = getdate()
		where SetID = @SetID
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 1
	begin
		insert into dbo.PDX_pay_PRiZ
			(Name, Code, Descr, ParentID, e1, e2, e3, GrName, NC, DC, NLM, DLM)
		values 
			(@Name, @Code, @Descr, @ParentID, @E1, @E2, @E3, @Gr, @NC, getdate(), @NC, getdate())
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 3
	begin
		delete from dbo.PDX_pay_PRiZ where SetID = @SetID
		select @Res = @@error if @Res <> 0 goto Err
	end
END
	select @Res = @@error if @Res <> 0 goto Err

	drop table #cfo
OK:

	return @Res
Err:
	return @Res






GO
/****** Object:  StoredProcedure [dbo].[PDX_payStatus_Load] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO




CREATE proc [dbo].[PDX_payStatus_Load]
	@TransferGUID uniqueidentifier,
	@DocID varchar(128) output,
	@Date datetime 
	
as
	declare  @Res int
declare @ClassName varchar(128),
	@DocID_1 varchar(128),
	@Date_1 datetime
set nocount on
	select
		@DocID = ltrim(rtrim(isnull(@DocID,''))),
		@DocID_1 = null
	select @Res = @@error if @Res <> 0 goto Err

	select @ClassName = DocType
	from dbo.PDXDocTypesConst
	where ConstName = 'RIK_CategoryName_FIN_ORDPAY'
	select @Res = @@error if @Res <> 0 goto Err

    select @DocID_1 = DocID,
		@Date_1 = DateSigned 
	from dbo.Docs 
	where TransferGUID = @TransferGUID 
		and ClassDoc = @ClassName
	select @Res = @@error if @Res <> 0 goto Err

	If @DocID_1 is null
	begin
		raiserror ('Указанный документ не найден',16,1)
		goto Err
	end
	else 
	begin
		--If @DocID <> @DocID_1
		--begin
		select @DocID = @DocID_1
		select @Res = @@error if @Res <> 0 goto Err
		--end
		
		--только если дата оплаты еще не стоит 
		If ISNULL(@Date_1,'1900-01-01') <> 1900
		begin
			update dbo.Docs
				set
					DateSigned = @Date
			where DocID = @DocID
			select @Res = @@error if @Res <> 0 goto Err
			
			insert into dbo.Comments
				(UserID,
				UserName,
				ContactUserName,
				ContactUserID,
				PartnerName,
				DocID,
				DateCreation,
				DateEvent,
				DateEventEnd,
				Address,
				Subject,
				Comment,
				CommentType,
				SpecialInfo,
				FileName,
				--KeyField,
				PartnerID,
				Version,
				GUID,
				GUIDPartner,
				GUIDUser,
				GUIDDoc,
				Amount,
				FileNameOriginal,
				RIK_CommentType)
			values
				('Admin',--UserID,
				'System Administrator',--UserName,
				null,--ContactUserName,
				null,--ContactUserID,
				null,--PartnerName,
				@DocID,--DocID,
				getdate(),--DateCreation,
				null,--DateEvent,
				null,--DateEventEnd,
				'',--Address,
				null,--Subject,
				'Проставлен статус Оплачено',--Comment,
				'HISTORY',--CommentType,
				'PAYMENT',--SpecialInfo,
				null,--FileName,
				--KeyField,
				null,--PartnerID,
				'',--Version,
				NewID(),--GUID,
				null,--GUIDPartner,
				null,--GUIDUser,
				null,--GUIDDoc,
				null,--Amount,
				null,--FileNameOriginal,
				null)--RIK_CommentType)
			select @Res = @@error if @Res <> 0 goto Err
		end
	end
	
	select @DocID as DocID
	select @Res = @@error if @Res <> 0 goto Err

OK:
set nocount off
	return @Res
Err:
set nocount off
	return @Res




GO
/****** Object:  StoredProcedure [dbo].[PDX_payStatusp_Load] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[PDX_payStatusp_Load]
	@TransferGUID uniqueidentifier,
	@DocID varchar(128) output,
	@Date datetime,
	@Amount money = null
	
as
	declare  @Res int
declare --@ClassName varchar(128),
	@DocID_1 varchar(128),
	@Date_1 datetime
	
set nocount on
	select
		@DocID = ltrim(rtrim(isnull(@DocID,''))),
		--@Amount = isnull(@Amount,0),
		@DocID_1 = null
	select @Res = @@error if @Res <> 0 goto Err
/*
	select @ClassName = DocType
	from PayDoxOP.dbo.PDXDocTypesConst
	where ConstName = 'RIK_CategoryName_KAZ_ORDPAY'
	select @Res = @@error if @Res <> 0 goto Err
*/

	exec PayDoxOP.[dbo].[PDX_payStatusp_LoadIntoDB]
		@TransferGUID = @TransferGUID,
		@DocID = @DocID_1 output,
		@Date = @Date,
		@Amount = @Amount--,
		--@ClassName = @ClassName

	
	If isnull(@DocID_1,'') = ''
	begin
		raiserror ('Указанный документ не найден',16,1)
		goto Err
	end
	
	select @DocID = @DocID_1	
	select @Res = @@error if @Res <> 0 goto Err
	
	select @DocID as DocID
	select @Res = @@error if @Res <> 0 goto Err

OK:
set nocount off
	return @Res
Err:
set nocount off
	return @Res











GO
/****** Object:  StoredProcedure [dbo].[PDX_payStatusp_LoadIntoDB] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[PDX_payStatusp_LoadIntoDB]
	@TransferGUID uniqueidentifier,
	@DocID varchar(128) output,
	@Date datetime,
	@Amount money = null--,
	--@ClassName varchar(128)
as
	declare  @Res int
declare 
	@DocID_1 varchar(128),
	@Date_1 datetime,
	@Cls1 varchar(128), @Cls2 varchar(128)
set nocount on
	select
		@DocID = ltrim(rtrim(isnull(@DocID,''))),
		--@Amount = isnull(@Amount,0),
		@DocID_1 = null
	select @Res = @@error if @Res <> 0 goto Err

	set @Cls1 = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_ORDPAY')
	set @Cls2 = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_BUDG')

	select @DocID_1 = DocID,
		@Date_1 = DateSigned 
	from dbo.Docs 
	where TransferGUID = @TransferGUID 
		--and ClassDoc = @ClassName
		and ClassDoc in (@Cls1, @Cls2)
	select @Res = @@error if @Res <> 0 goto Err

	If not @DocID_1 is null
	begin
		--If @DocID <> @DocID_1
		--begin
		select @DocID = @DocID_1
		select @Res = @@error if @Res <> 0 goto Err
		--end
		
		--только если дата оплаты еще не стоит 
		If ISNULL(@Date_1,'1900-01-01') <> 1900
		begin
			update dbo.Docs
				set
					DateSigned = @Date,
					UserFieldMoney1 = case 
										when @Amount IS null 
											then UserFieldMoney1 
										else @Amount 
									  end
			where DocID = @DocID
			select @Res = @@error if @Res <> 0 goto Err
			
			insert into dbo.Comments
				(UserID,
				UserName,
				ContactUserName,
				ContactUserID,
				PartnerName,
				DocID,
				DateCreation,
				DateEvent,
				DateEventEnd,
				Address,
				Subject,
				Comment,
				CommentType,
				SpecialInfo,
				FileName,
				--KeyField,
				PartnerID,
				Version,
				GUID,
				GUIDPartner,
				GUIDUser,
				GUIDDoc,
				Amount,
				FileNameOriginal,
				RIK_CommentType)
			values
				('Admin',--UserID,
				'System Administrator',--UserName,
				null,--ContactUserName,
				null,--ContactUserID,
				null,--PartnerName,
				@DocID,--DocID,
				getdate(),--DateCreation,
				null,--DateEvent,
				null,--DateEventEnd,
				'',--Address,
				null,--Subject,
				'Проставлен статус Оплачено /сумма: ' + isnull(CAST(@Amount as varchar(100)),'') + '/',--Comment,
				'HISTORY',--CommentType,
				'PAYMENT',--SpecialInfo,
				null,--FileName,
				--KeyField,
				null,--PartnerID,
				'',--Version,
				NewID(),--GUID,
				null,--GUIDPartner,
				null,--GUIDUser,
				null,--GUIDDoc,
				null,--Amount,
				null,--FileNameOriginal,
				null)--RIK_CommentType)
			select @Res = @@error if @Res <> 0 goto Err
		end
	end

OK:
set nocount off
	return @Res
Err:
set nocount off
	return @Res




GO
/****** Object:  StoredProcedure [dbo].[PDX_PDXTrip_Change] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[PDX_PDXTrip_Change]
	@DocID varchar(128),
	@AVIA bit = NULL, -- АВИА / Ж/Д БИЛЕТЫ
	@VISA bit = NULL, -- ВИЗОВАЯ ПОДДЕРЖКА
	@VIP bit = NULL, -- VIP ОБСЛУЖИВАНИЕ
	@HOTEL bit = NULL, -- ГОСТИНИЦА
	@INSURE bit = NULL, -- СТРАХОВКА
	@TRANSFER bit = NULL, -- ТРАНСФЕр
	@Obj varchar(1024) = NULL, -- ТРАНСФЕр
	@NC varchar(128) = NULL,
	@Act int, --1--ceate, 2-update,3 delete
	@Chk bit = 0
	
as
	declare  @Res int,
		@Descr varchar(512),
		@UserID varchar(96),
		@UserName varchar(96),
		@Amount money,
		@Koeff_ money,
		@DocIDInt int,
		@DelSetID uniqueidentifier,
		@UFT6 varchar(1024)

	declare @ErrList varchar(1024),
		/*@ParentID int,*/ @Cnt int, @flg tinyint, @NC2 varchar(96)

	select @Res = 0,@ErrList = ''

	select
		@DocID = ltrim(rtrim(isnull(@DocID,''))),
		@AVIA = ltrim(rtrim(isnull(@AVIA,0))),
		@VISA = ltrim(rtrim(isnull(@VISA,0))),
		@VIP = ltrim(rtrim(isnull(@VIP,0))),
		@HOTEL = ltrim(rtrim(isnull(@HOTEL,0))),
		@INSURE = ltrim(rtrim(isnull(@INSURE,0))),
		@TRANSFER = ltrim(rtrim(isnull(@TRANSFER,0))),
		@Obj = ltrim(rtrim(isnull(@Obj,''))),
		@NC  = ltrim(rtrim(isnull(@NC,''))),
		@flg = 0
	select @Res = @@error if @Res <> 0 goto Err

/************************************
ПРОВЕРКИ ВВЕДЕННЫХ ЗНАЧЕНИЙ
*************************************/

If @Act <> 3
BEGIN
	select 
		@DocIDInt = DocIDInt, 
		@NC2 = NameCreation ,
		@UFT6 = UserFieldText6
	from dbo.Docs 
	where DocID = @DocID 
		and ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_OTHERS_TRP')
	
	If @DocID = '' or @DocIDInt is null
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Системная ошибка! Некорректный ИД документа. Обратитесь к администратору СЭД.'
		goto NXT
	end
	
	If @Obj <> ''
	begin
		if not exists (select top 1 1 from dbo.UserDir_ISR where @Obj like '%<' + Code + '>%')
		begin
			select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
				'<font color=red>ОШИБКА! </font> Поле [Объект]: значение [' + @Obj + '] в справочнике не существует</font>'
			goto NXT
		end
		
	end
	
END
/************************************/

NXT:

If @Chk = 0
begin --если это создание , то нужно генерить ошибкуесли она есть
	If @ErrList <> '' 
	begin
		RAISERROR (@ErrList, 16,1)
		goto Err
	end
end
else --если это проверка просто выводим сообщение, даже если оно пустое
begin
	select @ErrList as ErrList 
	select @Res = @@error if @Res <> 0 goto Err
end

IF @ErrList = '' and @Chk = 0
BEGIN
	if @Act = 2
	begin
		update dbo.[PDXTrip]
			set 				
				[AVIA] = @AVIA, -- АВИА / Ж/Д БИЛЕТЫ
				[VISA] = @VISA, -- ВИЗОВАЯ ПОДДЕРЖКА
				[VIP] = @VIP, -- VIP ОБСЛУЖИВАНИЕ
				[HOTEL] = @HOTEL, -- ГОСТИНИЦА
				[INSURE] = @INSURE, -- СТРАХОВКА
				[TRANSFER] = @TRANSFER,
				Obj = @Obj,
				NLM = @NC,
				DLM = getdate()
		where [DocIDInt] = @DocIDInt
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 1
	begin
		if @NC = '' set @NC = @NC2
		insert into dbo.[PDXTrip]
			(DocIDInt, [AVIA],[VISA],[VIP],[HOTEL],[INSURE],[TRANSFER], Obj, NC, DC, NLM, DLM)
		values 
			(@DocIDInt, @AVIA, @VISA, @VIP, @HOTEL, @INSURE, @TRANSFER,@Obj, @NC, getdate(), @NC, getdate())
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 3
	begin
			delete from dbo.[PDXTrip] where [DocIDInt] = @DocIDInt
			select @Res = @@error if @Res <> 0 goto Err
	
	end
END

OK:

	return @Res
Err:
	return @Res





GO
/****** Object:  StoredProcedure [dbo].[PDX_PDXZPR_Change] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_PDXZPR_Change]
	@DocID varchar(128),
	@AVIA bit = NULL, -- АВИА / Ж/Д БИЛЕТЫ
	@VISA bit = NULL, -- ВИЗОВАЯ ПОДДЕРЖКА
	@VIP bit = NULL, -- VIP ОБСЛУЖИВАНИЕ
	@HOTEL bit = NULL, -- ГОСТИНИЦА
	@INSURE bit = NULL, -- СТРАХОВКА
	@TRANSFER bit = NULL, -- ТРАНСФЕр
	@NC varchar(128) = NULL,
	@Act int, --1--ceate, 2-update,3 delete
	@Chk bit = 0
	
as
	declare  @Res int,
		@Descr varchar(512),
		@UserID varchar(96),
		@UserName varchar(96),
		@Amount money,
		@Koeff_ money,
		@DocIDInt int,
		@DelSetID uniqueidentifier

	declare @ErrList varchar(1024),
		/*@ParentID int,*/ @Cnt int, @flg tinyint, @NC2 varchar(96)

	select @Res = 0,@ErrList = ''

	select
		@DocID = ltrim(rtrim(isnull(@DocID,''))),
		@AVIA = ltrim(rtrim(isnull(@AVIA,0))),
		@VISA = ltrim(rtrim(isnull(@VISA,0))),
		@VIP = ltrim(rtrim(isnull(@VIP,0))),
		@HOTEL = ltrim(rtrim(isnull(@HOTEL,0))),
		@INSURE = ltrim(rtrim(isnull(@INSURE,0))),
		@TRANSFER = ltrim(rtrim(isnull(@TRANSFER,0))),
		@NC  = ltrim(rtrim(isnull(@NC,''))),
		@flg = 0
	select @Res = @@error if @Res <> 0 goto Err

/************************************
ПРОВЕРКИ ВВЕДЕННЫХ ЗНАЧЕНИЙ
*************************************/

If @Act <> 3
BEGIN
	select @DocIDInt = DocIDInt, @NC2 = NameCreation from dbo.Docs where DocID = @DocID and ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_OTHERS_ZPR')
	If @DocID = '' or @DocIDInt is null
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Системная ошибка! Некорректный ИД документа. Обратитесь к администратору СЭД.'
		goto NXT
	end
	
END
/************************************/

NXT:

If @Chk = 0
begin --если это создание , то нужно генерить ошибкуесли она есть
	If @ErrList <> '' 
	begin
		RAISERROR (@ErrList, 16,1)
		goto Err
	end
end
else --если это проверка просто выводим сообщение, даже если оно пустое
begin
	select @ErrList as ErrList 
	select @Res = @@error if @Res <> 0 goto Err
end

IF @ErrList = '' and @Chk = 0
BEGIN
	if @Act = 2
	begin
		update dbo.[PDXZPR]
			set 				
				[AVIA] = @AVIA, -- АВИА / Ж/Д БИЛЕТЫ
				[VISA] = @VISA, -- ВИЗОВАЯ ПОДДЕРЖКА
				[VIP] = @VIP, -- VIP ОБСЛУЖИВАНИЕ
				[HOTEL] = @HOTEL, -- ГОСТИНИЦА
				[INSURE] = @INSURE, -- СТРАХОВКА
				[TRANSFER] = @TRANSFER,
				NLM = @NC,
				DLM = getdate()
		where [DocIDInt] = @DocIDInt
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 1
	begin
		if @NC = '' set @NC = @NC2
		insert into dbo.[PDXZPR]
			(DocIDInt, [AVIA],[VISA],[VIP],[HOTEL],[INSURE],[TRANSFER], NC, DC, NLM, DLM)
		values 
			(@DocIDInt, @AVIA, @VISA, @VIP, @HOTEL, @INSURE, @TRANSFER, @NC, getdate(), @NC, getdate())
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 3
	begin
			delete from dbo.[PDXZPR] where [DocIDInt] = @DocIDInt
			select @Res = @@error if @Res <> 0 goto Err
	
	end
END

OK:

	return @Res
Err:
	return @Res





GO
/****** Object:  StoredProcedure [dbo].[PDX_PLNPAY_Aprove] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_PLNPAY_Aprove]
	@UserID varchar(128),
	@NameAproval varchar(128),
	@Date datetime,
	@Flg bit = 0
	
as
	declare 
	@Res int,
	@StopRefuseFlag bit,
	@ClassDoc varchar(128)

	create table #Apptmp (DocID varchar(128), Name varchar(256),
		UFT8 varchar(1024), UFT2 varchar(1024), AmountDoc money, Currency varchar(64))

	select @NameAproval = dbo.PDX_SubstringReturn(@NameAproval, CHARINDEX('<',@NameAproval), charindex('>',@NameAproval))
	select @Res = @@error if @Res <> 0 goto Err
	
	select @StopRefuseFlag = StopRefuseFlag,
		@ClassDoc = DocType
	from dbo.PDXDocTypesConst
	where ConstName = 'RIK_CategoryName_FIN_PLNPAY'
	select @Res = @@error if @Res <> 0 goto Err

	insert into #Apptmp
		(DocID, Name, UFT2, UFT8, AmountDoc, Currency)
	SELECT 
		D.DocID, 
		D.Name,  D.Userfieldtext2, D.Userfieldtext8, D.AmountDoc, D.Currency
	FROM dbo.Docs AS D 
	WHERE D.ClassDoc = @ClassDoc
		AND CHARINDEX('<' + @NameAproval + '>', D.NameAproval) > 0 
		AND UPPER(ISNULL(D.IsActive, '')) = 'Y'
		AND NOT (ISNULL(D.StatusCompletion, '') IN ('1', '0')) 
		AND isnull(D.StatusDevelopment,'') <> '0'
		AND ltrim(rtrim(isnull(D.NameApproved,''))) = ''
		AND dbo.PDX_CompareReconcilationList(D.ListToReconcile, D.ListReconciled) = 1
		and dbo.PDX_fn_stopReconcilation (D.ListToReconcile, D.ListReconciled, @StopRefuseFlag) = 0
		and MONTH(D.UserFieldDate1) = MONTH(@Date)
		and year(D.UserFieldDate1) = year(@Date)
	select @Res = @@error if @Res <> 0 goto Err


	If @Flg = 1
	begin
		update D
		set StatusDevelopment='4',
			DateApproved = @Date,
			NameApproved=D.NameAproval
		from #Apptmp A
		inner join dbo.Docs D on D.DocID = A.DocID
		select @Res = @@error if @Res <> 0 goto Err
		
		insert into Comments	
			(UserID,
			UserName,
			ContactUserName,
			ContactUserID,
			PartnerName,
			DocID,
			DateCreation,
			DateEvent,
			DateEventEnd,
			Address,
			Subject,
			Comment,
			CommentType,
			SpecialInfo,
			FileName,
			--KeyField,
			PartnerID,
			Version,
			GUID,
			GUIDPartner,
			GUIDUser,
			GUIDDoc,
			Amount,
			FileNameOriginal,
			RIK_CommentType)
		select
			dbo.PDX_SubstringReturn(@UserID, charindex('<',@UserID), charindex('>', @UserID)), -- UserID,
			ltrim(rtrim(replace(replace(@UserID,dbo.PDX_SubstringReturn(@UserID, charindex('<',@UserID), charindex('>', @UserID)),''),'"',''))),--UserName,
			null,--ContactUserName,
			null,--ContactUserID,
			null,--PartnerName,
			DocID,--DocID,
			getdate(),--DateCreation,
			null,--DateEvent,
			null,--DateEventEnd,
			null,--Address,
			null,--Subject,
			'Завершено Автоматически на дату ' + CONVERT(varchar(100), @Date, 104),--Comment,
			'APROVAL',--CommentType,
			'',-- SpecialInfo,
			null,--FileName,
			--KeyField,
			null,--PartnerID,
			null,--Version,
			newid(),--GUID,
			null,--GUIDPartner,
			null,--GUIDUser,
			null,--GUIDDoc,
			null,--Amount,
			null,--FileNameOriginal,
			null--RIK_CommentType
		FROM #Apptmp
		select @Res = @@error if @Res <> 0 goto Err
	end
	
	select * from #Apptmp order by DocID
	select @Res = @@error if @Res <> 0 goto Err
		
	drop table #Apptmp
OK:

	return @Res
Err:
	return @Res
GO
/****** Object:  StoredProcedure [dbo].[PDX_PLNRespCreate] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*drop  proc [dbo].[PDX_PLNRespCreate] 
go
*/
CREATE proc [dbo].[PDX_PLNRespCreate] 
	@DocIDInt int,
	@UFT2 int,
	@PN int,
	@UserID varchar(16),
	@RoleID varchar(16)
as

set nocount on


	declare @PLNCls varchar(128), @Date datetime, @DocDate datetime, @NewDocID varchar(128)	, @Error varchar(1024), @UName varchar(96), @UName2 varchar(96), @DocID varchar(128),
	@UFT22 varchar(1024), @PN2 varchar(1024), @FM varchar(128),@PLNCls2 varchar(128), @chk tinyint, @UNameR varchar(128), @UNameR2 varchar(128)
	
	create table #tbl (Error varchar(4000), DocID  varchar(128))
	
	set @DocDate = GETDATE()
	select @PLNCls = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_PLNPAY')	
	select @PLNCls2 = dbo.PDX_CLSGrGet('RIK_CategoryName_KAZ_PLNPAY')	
	set @UName = dbo.User_PaydoxLogin(@UserID) 
	set @UName2 = rtrim(replace(LEFT(@UName,CHARINDEX('<', @UName)-1),'"',''))
	
	set @UNameR = ''
	if ISNULL(@RoleID,'')<>''
	begin
		set @UNameR = dbo.User_PaydoxLogin(@RoleID) 
		if ISNULL(@UNameR,'') <> '' 
		begin
			set @UNameR2 = rtrim(LEFT(@UNameR,CHARINDEX('<', @UNameR)-1))
			set @UName = @UNameR2 + ' / ' + @UName
			set @UNameR = ' / ' + @UNameR		
		end		
	end

	select @DocID = DocID,
	@Date = UserFieldDate1
	from dbo.Docs
	where DocIDInt = @DocIDInt

	select  @chk = [dbo].[PDX_CheckPLNPesp](@DocID)

-- 0 - внешний
-- 1 - внутренний, ответной заявки еще нет
-- 2 - внутренний заявка уже есть
-- 3 - по статусу "не проходит"	
	If @chk = 0 
	begin
		select @Error = '<font color=red>ОШИБКА! </font>Данная карточка создана для внешнего платежа. Для таких карточек не требуется создание ответной заявки.'
		goto OK
	end		
	If @chk = 2 
	begin
		select @Error = '<font color=red>ОШИБКА! </font>Для данной карточки уже создана ответная заявка со стороны второго контрагента. Создание новой заявки не требуется.'
		goto OK
	end
	If @chk = 2 
	begin
		select @Error = '<font color=red>ОШИБКА! </font>Создание ответного платежа невозможно (ошибка статуса исходного документа)' 
		goto OK
	end
	
	
	if exists (select 1 from dbo.Users where UserID = @UserID and 
			(char(13)+char(10)+ClassDoc+char(13)+char(10) like '%' + char(13)+char(10) + @PLNCls + char(13)+char(10) + '%'
				or char(13)+char(10)+ClassDoc+char(13)+char(10) like '%' + char(13)+char(10) + @PLNCls2 + char(13)+char(10) + '%') 
				or ClassDoc like '%"ALL"%'
			)
	begin
	
		insert into #tbl (Error, DocID)
		exec [dbo].[PDX_NC_NumberCalculate]
		@Activity ='', --вид деят-ти
		@Department = '', --подразделение 
		--!!!!подразделение М.Б. задано с ключевым словом "<BYUSER:>" - это значит, что подразделение определяется через переданного в этой переменной пользователя
		@ParentDocID ='', --номер родит. 
		@ClassDoc =@PLNCls,--категория
		@DocDate =@Date,--дата
		@OrderIndex =null, --пользовательский счетчик/код  (задается через интерфейс) - может быть дополнен 0 до определенного кол-ва знаков
		@isReg = 0,	--признак расчета рег. номера

		@OldDocID ='',--старый номер документа (тот, который хотим изменить/проверить: при регистрации это введенный регистратором номер, иначе введенный пользователем номер)
		@RealDocID  = null,--тот номер под которым в данный момент находится документ в системе
		@StatusActive ='',--статус активный
		@PreviousDocID  = null, --для проверки предыдущей версии (новый номер д.б. = Prev + 1)? для этого значение должно быть указано в формате "<CHK:>номер док-та"
		@Error  = @Error out , --сообщение об ошибке
		@DocID  = @NewDocID out, --рассчитанный номер документа
		--параметры для формирования сообщений об ошибке
		@s_Activity  = null,
		@s_Department = null,
		@s_OrderIndex  = null,
		@s_PreviousDocID  = null,
		@s_ParentDocID = null,
		@s_DocDate  = null
		
		
		if ltrim(ISNULL(@Error,'')) = ''
		begin
			set @UFT22 = ''
			set @PN2 = ''
			set @FM = ''
			
			if @UFT2 <> 0 
			begin
				select @UFT22 = Name, @FM = Manager from dbo.PDX_pay_CFO where SetID = @UFT2
			end
			
			if @PN <> 0 
			begin
				select @PN2 = Name from dbo.Partners where KeyField = @PN
			end
			
				
			insert into dbo.Docs
				(
				DocID,
				GUID,
				DocIDadd,
				DocIDIncoming,
				DocIDParent,
				DocIDPrevious,
				Author,
				Correspondent,
				Resolution,
				History,
				Result,
				PercentCompletion,
				Department,
				Name,
				Description,
				LocationURL,
				LocationPaper,
				FileNamePrefix,
				FileName,
				FileNameNameLastModification,
				FileNameDateLastAccessed,
				FileNameDateLastModification,
				LocationPath,
				ExtInt,
				PartnerName,
				StatusDevelopment,
				StatusPayment,
				StatusArchiv,
				StatusCompletion,
				StatusDelivery,
				TypeDoc,
				ClassDoc,
				ActDoc,
				InventoryUnit,
				PaymentMethod,
				AmountDoc,
				QuantityDoc,
				DateActivation,
				SecurityLevel,
				DateCreation,
				DateCompletion,
				DateCompleted,
				DateExpiration,
				NameCreation,
				NameAproval,
				NameApproved,
				DateApproved,
				ListToEdit,
				ListToReconcile,
				ListReconciled,
				NameResponsible,
				NameControl,
				NameLastModification,
				DateLastModification,
				UserFieldText1,
				UserFieldText2,
				UserFieldText3,
				UserFieldText4,
				UserFieldText5,
				UserFieldText6,
				UserFieldText7,
				UserFieldText8,
				UserFieldMoney1,
				UserFieldMoney2,
				UserFieldDate1,
				UserFieldDate2,
				UserFieldDate3,
				UserFieldDate4,
				UserFieldDate5,
				UserFieldDate6,
				UserFieldDate7,
				UserFieldDate8,
				IsActive,
				DateActive,
				BusinessProcessStep,
				ExtPassword,
				DateSigned,
				Currency,
				CurrencyRate,
				Rank,
				ListToView)--,
				--Content)
			select
				@NewDocID,--DocID,
				newid(),--GUID,
				@NewDocID,--DocIDadd,
				D.DocIDIncoming,
				D.DocIDParent,
				D.DocIDPrevious,
				D.Author,
				D.Correspondent,
				D.Resolution,
				D.History,
				D.Result,
				D.PercentCompletion,
				D.Department,
				D.Name,
				D.Description,
				D.LocationURL,
				D.LocationPaper,
				D.FileNamePrefix,
				D.FileName,
				D.FileNameNameLastModification,
				D.FileNameDateLastAccessed,
				D.FileNameDateLastModification,
				D.LocationPath,
				D.ExtInt,
				@PN2,--D.PartnerName,
				'1',--StatusDevelopment,
				D.StatusPayment,
				D.StatusArchiv,
				D.StatusCompletion,
				D.StatusDelivery,
				D.TypeDoc,
				D.ClassDoc,
				D.ActDoc,
				D.InventoryUnit,
				D.PaymentMethod,
				D.AmountDoc,
				D.QuantityDoc,
				null,--DateActivation,
				D.SecurityLevel,
				@DocDate,--DateCreation,
				D.DateCompletion,
				null,--DateCompleted,
				D.DateExpiration,
				@UName,--D.NameCreation,
				@FM,--D.NameAproval,
				null,--NameApproved,
				null,--DateApproved,
				D.ListToEdit,
				@FM,--D.ListToReconcile,
				'',--ListReconciled,
				D.NameResponsible,
				D.NameControl,
				@UName,--NameLastModification,
				@DocDate,--DateLastModification,
				'',--D.UserFieldText1,
				@UFT22,--D.UserFieldText2,
				D.UserFieldText3,
				D.UserFieldText4,
				'',--D.UserFieldText5,
				'',--D.UserFieldText6,
				D.UserFieldText7,
				'',--D.UserFieldText8,
				0,--UserFieldMoney1,
				D.UserFieldMoney2,
				D.UserFieldDate1,
				D.UserFieldDate2,
				D.UserFieldDate3,
				D.UserFieldDate4,
				D.UserFieldDate5,
				D.UserFieldDate6,
				D.UserFieldDate7,
				'',--D.UserFieldDate8,
				'N',--IsActive,
				null,--DateActive,
				D.BusinessProcessStep,
				D.ExtPassword,
				null,--DateSigned,
				D.Currency,
				D.CurrencyRate,
				D.Rank,
				D.ListToView
			from dbo.Docs D
			where DocIDInt = @DocIDInt
				
			insert into dbo.Comments
			(	UserID,
				UserName,
				ContactUserName,
				ContactUserID,
				PartnerName,
				DocID,
				DateCreation,
				DateEvent,
				DateEventEnd,
				Address,
				Subject,
				Comment,
				CommentType,
				SpecialInfo,
				FileName,
				--KeyField,
				PartnerID,
				Version,
				GUID,
				GUIDPartner,
				GUIDUser,
				GUIDDoc,
				Amount,
				FileNameOriginal,
				RIK_CommentType)
			values (
				@UserID,
				@UName2,
				null,--ContactUserName,
				null,--ContactUserID,
				'',--PartnerName,
				@NewDocID,
				getdate(),--DateCreation,
				null,--DateEvent,
				null,--DateEventEnd,
				'',--Address,
				@DocID,-- Subject,
				'#red#boldОтветная плановая заявка' + @UNameR,--Comment,
				'LINK',--CommentType,
				'',--SpecialInfo,
				null,--FileName,
				--KeyField,
				null,--PartnerID,
				'',--Version,
				newid(),--GUID,
				null,--GUIDPartner,
				null,--GUIDUser,
				null,--GUIDDoc,
				0,--Amount,
				null,--FileNameOriginal,
				'RESPPLN'--RIK_CommentType
			)
				
				
				
			insert into dbo.Comments
			(	UserID,
				UserName,
				ContactUserName,
				ContactUserID,
				PartnerName,
				DocID,
				DateCreation,
				DateEvent,
				DateEventEnd,
				Address,
				Subject,
				Comment,
				CommentType,
				SpecialInfo,
				FileName,
				--KeyField,
				PartnerID,
				Version,
				GUID,
				GUIDPartner,
				GUIDUser,
				GUIDDoc,
				Amount,
				FileNameOriginal,
				RIK_CommentType)
			values (
				@UserID,
				@UName2,
				null,--ContactUserName,
				null,--ContactUserID,
				'',--PartnerName,
				@DocID,
				getdate(),--DateCreation,
				null,--DateEvent,
				null,--DateEventEnd,
				'',--Address,
				@NewDocID,-- Subject,
				'#red#boldОтветная плановая заявка' + @UNameR,--Comment,
				'LINK',--CommentType,
				'',--SpecialInfo,
				null,--FileName,
				--KeyField,
				null,--PartnerID,
				'',--Version,
				newid(),--GUID,
				null,--GUIDPartner,
				null,--GUIDUser,
				null,--GUIDDoc,
				0,--Amount,
				null,--FileNameOriginal,
				'RESPPLN'--RIK_CommentType
			)
				
		end
	end
	else
	begin
		select @Error = '<font color=red>ОШИБКА! </font>У Вас нет прав на создание документов категории ' + @PLNCls
	end
	
	drop table #tbl
OK:	
	select @NewDocID as DocID, @DocID as oldDocID, ltrim(isnull(@Error,'')) as Err
GO
/****** Object:  StoredProcedure [dbo].[PDX_Portal_ClearAllBindings] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:		A. Belyaev
-- Create date: 
-- Description:	Удаление всех привязок контрагентов к порталу
-- =============================================
CREATE PROCEDURE [dbo].[PDX_Portal_ClearAllBindings]
AS
BEGIN
	update Partners
	set
		PortalID=null,
		[GUID]=null,
		PortalMappingStatus=0
	where PortalID is not null
END
GO
/****** Object:  StoredProcedure [dbo].[PDX_Portal_CreatePartner] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


-- =============================================
-- Author:		A. Belyaev
-- Create date: 
-- Description:	Создание нового контрагента
-- =============================================
CREATE PROCEDURE [dbo].[PDX_Portal_CreatePartner]
	@PortalID int,
	@PortalMappingStatus int,
	@UID uniqueidentifier,
	@Title varchar(128),				--Name
	@ShortTitle varchar(64)=NULL,		--ShortName
	@FullTitle varchar(2048)=NULL,		--AddInfo или игнорировать
	@TaxID varchar(32)=NULL,
	@OKPO varchar(32)=NULL,				--RegCode
	@PostalAddress varchar(128)=NULL,	--PostAddress1
	@LegalAddress varchar(128)=NULL,	--PostAddress2
	@ActualAddress varchar(128)=NULL,	--PostAddress
	@Phone varchar(64)=NULL,
	@Fax varchar(64)=NULL,
	@EMail varchar(96)=NULL,
	@WebLink varchar(96)=NULL,
	@Author varchar(48)=NULL,			--NameCreation,NameLastModification
	@PStatus varchar (100)=NULL, -- статус контрагента который пока не ясно как использовать
	@ContractsPermitted bit=NULL, -- признак - заключение контрактов с этим контрагентом РАЗРЕШЕНО
	@PDocList varchar (4000)=NULL, -- Список недостающих документов для активации договора
	@PFieldList varchar (4000)=NULL --Список незаполненных полей для активации договора
AS
BEGIN TRANSACTION
	if exists(select 1 from Partners where [GUID]=@UID)
	begin
		select 'Контрагент с указанным уникальным идентификатором уже существует' as Error
		goto error
	end
	
	if exists (select 1 from Partners where Name=@Title)
	begin
		select 'Контрагент с указанным названием уже существует' as Error
		goto error
	end

	declare @now datetime
	set @now = GETDATE()
	
	insert into Partners
	(
		PortalID,
		PortalMappingStatus,
		[GUID],
		Name,
		ShortName,
		AddInfo,
		TaxID,
		RegCode,
		PostAddress1,
		PostAddress2,
		PostAddress,
		Phone,
		Fax,
		EMail,
		WebLink,
		PartnerStatus,
		ContractsPermitted,
		PDocList,
		PFieldList,
		DateCreation,
		DateLastModification,
		NameCreation,
		NameLastModification
	)
	values
	(
		@PortalID,
		@PortalMappingStatus,
		@UID,
		@Title,
		@ShortTitle,
		@FullTitle,
		@TaxID,
		@OKPO,
		@PostalAddress,
		@LegalAddress,
		@ActualAddress,
		@Phone,
		@Fax,
		@EMail,
		@WebLink,
		@PStatus,
		@ContractsPermitted,
		@PDocList,
		@PFieldList,
		@now,
		@now,
		@Author,
		@Author
	)
	
	select cast(scope_identity() as int) as Code
	commit transaction
	return

error:
if @@trancount>0 rollback transaction


GO
/****** Object:  StoredProcedure [dbo].[PDX_Portal_GetAllPartners] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:		A. Belyaev
-- Create date: 
-- Description:	Возвращает все записи из таблицы контрагентов (с указанием имен значений)
-- =============================================
CREATE PROCEDURE [dbo].[PDX_Portal_GetAllPartners]
AS
BEGIN
	select
		KeyField as Code,
		[GUID] as [UID],
		PortalID,
		PortalMappingStatus,
		ShortName as Title,
		Name as TitleShort,
		AddInfo,
		TaxID,
		RegCode as OKPO,
		PostAddress1 as PostalAddress,
		PostAddress2 as LegalAddress,
		PostAddress as ActualAddress,
		Phone,
		Fax,
		EMail,
		WebLink,
		ManagerName,
		ManagerPosition,
		ManagerPhoneNo,
		DateCreation as DateCreated,
		DateLastModification as DateModified
	from partners
END
GO
/****** Object:  StoredProcedure [dbo].[PDX_Portal_GetNextPartner] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:		A. Belyaev
-- Create date: 
-- Description:	Возвращает следующего по коду контрагента с указанным статусом привязки к порталу
-- =============================================
CREATE PROCEDURE [dbo].[PDX_Portal_GetNextPartner]
	@Code int = 0,
	@PortalMappingStatus int
AS
BEGIN
	select top 1
		KeyField as Code,
		[GUID] as [UID],
		PortalID,
		PortalMappingStatus,
		ShortName as Title,
		Name as TitleShort,
		AddInfo,
		TaxID,
		RegCode as OKPO,
		PostAddress1 as PostalAddress,
		PostAddress2 as LegalAddress,
		PostAddress as ActualAddress,
		Phone,
		Fax,
		EMail,
		WebLink,
		ManagerName,
		ManagerPosition,
		ManagerPhoneNo,
		DateCreation as DateCreated,
		DateLastModification as DateModified
	from partners
	where KeyField>@Code and PortalMappingStatus=@PortalMappingStatus
	order by KeyField
END
GO
/****** Object:  StoredProcedure [dbo].[PDX_Portal_GetPartner] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:		A. Belyaev
-- Create date: 
-- Description:	Возвращает контрагента по коду
-- =============================================
CREATE PROCEDURE [dbo].[PDX_Portal_GetPartner]
	@Code int
AS
BEGIN
	select
		KeyField as Code,
		[GUID] as [UID],
		PortalID,
		PortalMappingStatus,
		ShortName as Title,
		Name as TitleShort,
		AddInfo,
		TaxID,
		RegCode as OKPO,
		PostAddress1 as PostalAddress,
		PostAddress2 as LegalAddress,
		PostAddress as ActualAddress,
		Phone,
		Fax,
		EMail,
		WebLink,
		ManagerName,
		ManagerPosition,
		ManagerPhoneNo,
		DateCreation as DateCreated,
		DateLastModification as DateModified
	from partners
	where KeyField=@Code
END
GO
/****** Object:  StoredProcedure [dbo].[PDX_Portal_GetPartnerByGuid] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:		A. Belyaev
-- Create date: 
-- Description:	Возвращает контрагента по коду
-- =============================================
CREATE PROCEDURE [dbo].[PDX_Portal_GetPartnerByGuid]
	@Guid uniqueidentifier
AS
BEGIN
	select
		KeyField as Code,
		[GUID] as [UID],
		PortalID,
		PortalMappingStatus,
		ShortName as Title,
		Name as TitleShort,
		AddInfo,
		TaxID,
		RegCode as OKPO,
		PostAddress1 as PostalAddress,
		PostAddress2 as LegalAddress,
		PostAddress as ActualAddress,
		Phone,
		Fax,
		EMail,
		WebLink,
		ManagerName,
		ManagerPosition,
		ManagerPhoneNo,
		DateCreation as DateCreated,
		DateLastModification as DateModified
	from partners
	where [GUID]=@Guid
END
GO
/****** Object:  StoredProcedure [dbo].[PDX_Portal_GetPartnerCodeByGuid] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:		A. Belyaev
-- Create date: 
-- Description:	Возвращает код контрагента по уникальному идентификатору
-- =============================================
CREATE PROCEDURE [dbo].[PDX_Portal_GetPartnerCodeByGuid]
	@Guid uniqueidentifier
AS
BEGIN
	select
		KeyField as Code
		from Partners
		where [GUID] = @Guid
END
GO
/****** Object:  StoredProcedure [dbo].[PDX_Portal_GetPartnerCodeByName] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:		A. Belyaev
-- Create date: 
-- Description:	Возвращает контрагента по коду
-- =============================================
CREATE PROCEDURE [dbo].[PDX_Portal_GetPartnerCodeByName]
	@Name varchar(128)
AS
BEGIN
	select
		KeyField as Code
		from Partners
		where Name = @Name
END
GO
/****** Object:  StoredProcedure [dbo].[PDX_Portal_GetPartnerCounts] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:		A. Belyaev
-- Create date: 
-- Description:	Возвращает количество записей в таблице контрагентов и количество контрагентов, имеющих привязку к порталу.
-- =============================================
CREATE PROCEDURE [dbo].[PDX_Portal_GetPartnerCounts]
AS
BEGIN
	SELECT
		count (*) as [Count],
		SUM(case when PortalMappingStatus=0 then 1 else 0 end) as NotMapped,
		SUM(case when PortalMappingStatus=1 then 1 else 0 end) as Mapped,
		SUM(case when PortalMappingStatus=2 then 1 else 0 end) as Retracted,
		SUM(case when PortalMappingStatus=3 then 1 else 0 end) as [Disabled]
		from Partners
END
GO
/****** Object:  StoredProcedure [dbo].[PDX_Portal_UpdatePartner] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
--======================================
-- Author:		A. Belyaev
-- Create date: 
-- Description:	Изменение данных контрагента
-- =============================================
CREATE PROCEDURE [dbo].[PDX_Portal_UpdatePartner]
	@PortalID int,
	@Title varchar(128),				--Name - при обновлении игнорируется
	@ShortTitle varchar(64)=NULL,		--ShortName
	@FullTitle varchar(2048)=NULL,		--AddInfo или игнорировать
	@TaxID varchar(32)=NULL,
	@OKPO varchar(32)=NULL,				--RegCode
	@PostalAddress varchar(128)=NULL,	--PostAddress1
	@LegalAddress varchar(128)=NULL,	--PostAddress2
	@ActualAddress varchar(128)=NULL,	--PostAddress
	@Phone varchar(64)=NULL,
	@Fax varchar(64)=NULL,
	@EMail varchar(96)=NULL,
	@WebLink varchar(96)=NULL,
	@Author varchar(48)=NULL,			--NameCreation,NameLastModification
	@PStatus varchar (100)=NULL, -- статус контрагента который пока не ясно как использовать
	@ContractsPermitted bit=NULL, -- признак - заключение контрактов с этим контрагентом РАЗРЕШЕНО
	@PDocList varchar (4000)=NULL, -- Список недостающих документов для активации договора
	@PFieldList varchar (4000)=NULL --Список незаполненных полей для активации договора
AS
BEGIN TRANSACTION
	if not exists(select 1 from Partners where [PortalID]=@PortalID)
	begin
		select 'Контрагент с указанным идентификатором портала не найден' as Error
		goto error
	end

	declare @now datetime
	set @now = GETDATE()
	
	update Partners set
		ShortName=@ShortTitle,
		AddInfo=@FullTitle,
		TaxID=@TaxID,
		RegCode=@OKPO,
		PostAddress1=@PostalAddress,
		PostAddress2=@LegalAddress,
		PostAddress=@ActualAddress,
		Phone=@Phone,
		Fax=@Fax,
		EMail=@EMail,
		WebLink=@WebLink,
		PartnerStatus = @PStatus,
		ContractsPermitted = @ContractsPermitted,
		PDocList = @PDocList,
		PFieldList = @PFieldList,
		DateLastModification=@now,
		NameLastModification=@Author
	where PortalID=@PortalID
	
	if @@error <> 0 goto error	

	select Name as Title from Partners where PortalId=@PortalID
	
	commit transaction
	return

error:
if @@trancount>0 rollback transaction


GO
/****** Object:  StoredProcedure [dbo].[PDX_Portal_UpdatePartnerBinding] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:		A. Belyaev
-- Create date: 
-- Description:	Обновление привязки контрагента к порталу
-- =============================================
CREATE PROCEDURE [dbo].[PDX_Portal_UpdatePartnerBinding] 
	@ID int,
	@UID uniqueidentifier=null,
	@PortalID int = null,
	@PortalMappingStatus int = 0
AS
BEGIN
	update Partners
	set
		[GUID]=@UID,
		PortalID=@PortalID,
		PortalMappingStatus=@PortalMappingStatus
	where KeyField=@ID
END
GO
/****** Object:  StoredProcedure [dbo].[PDX_PRiZTree] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_PRiZTree]
	
as
	declare  @Res int, @Cnt int

	select @Res = 0, @Cnt = 0
	
    declare @cfo table
		(Name varchar(456),  --ANTON: that's what I have changed to make it working after the 4-th level of nesting was added
		Code varchar(256),
		FullName varchar(4096),
		GrName varchar(256),
		Descr varchar(256),
		PKF int,
		OI int)


	insert into @cfo
		(Name, Code, FullName, Descr,PKF, GrName)
	select
		F.Name + '<' + cast(F.Code as varchar(100)) + '>', 
		F.Code,
		'', 
		F.Descr, F.ParentID, F.GrName
	from dbo.PDX_pay_PRiZ F
	where not exists (select 1 from dbo.PDX_pay_PRiZ C where C.ParentID = F.SetID)
	select @Res = @@error if @Res <> 0 goto Err

	select @Cnt = count(*) from @cfo
	select @Res = @@error if @Res <> 0 goto Err

	while @Cnt > 0 
	begin
		update C
			set
				PKF = F.ParentID,
				FullName = F.Name + '<' + cast(F.Code as varchar(100)) + '>/' + C.FullName
		from @cfo C
		inner join dbo.PDX_pay_PRiZ F on F.SetID = C.PKF
		select @Cnt = @@rowcount, @Res = @@error if @Res <> 0 goto Err
	end
	
	--для сортировки
	if not exists (select 1 from @cfo
				where isnumeric(case when Code like '%.%' then charindex('.',Code) else Code end) = 0)
	begin
		update @cfo
			set OI = case when Code like '%.%' then Left(Code,charindex('.',Code)-1) else Code end
		select @Res = @@error if @Res <> 0 goto Err
	end
	select @Res = @@error if @Res <> 0 goto Err

	select Name, Code, FullName,GrName, Descr from @cfo 
    order by OI, Code,FullName
	select @Res = @@error if @Res <> 0 goto Err
	--drop table @cfo
OK:

	return @Res
Err:
	return @Res

GO
/****** Object:  StoredProcedure [dbo].[PDX_ProectNumberGet] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_ProectNumberGet]
	@Activity varchar(255) = '',
	@ProectName varchar(255) = '',
	@Proect varchar(255) = null out,
	@Error varchar(255) = null out
as
	declare @Result int
	set @Result = 0

    select @Proect = '' --то, что мы должны вычислить	    
    --определяем имеем дело с деят-тью по проекту или филиалу
    If lower(LTrim(RTrim(@Activity))) = lower('Проект') 
 	begin
    	--получаем код выбранного проекта из справочника
    	select @Proect =  dbo.PDX_GetUserDirValue (35,@ProectName,1,2)  		
		select @Result = @@error if @Result <> 0 goto Err
	    
		--допускаем, что нам может быть передан сразу код проекта
		if @Proect = ''
		begin
			select @Proect =  dbo.PDX_GetUserDirValue (35,@ProectName,2,2)  		
			select @Result = @@error if @Result <> 0 goto Err
		end

		If @Proect = '' 	--в справочнике такого проекта не оказалось
		begin
	    	select @Error = '<font color=red>ОШИБКА! </font> Необходимо указать код проекта'
			goto OK
		  	--raiserror (@Error,16,1)
			select @Result = @@error goto Err
	    End
	end    
	Else If charindex('>',@Activity) > 1 and charindex('<',@Activity) > 1
	begin
		--код из указанного вида деятельности
	    select @Proect = dbo.PDX_SubstringReturn(@Activity,charindex('<',@Activity),charindex('>',@Activity))--RIK_GetCodeFromStr(strActivity)
		select @Result = @@error if @Result <> 0 goto Err
	end
	Else
	begin
		select @Error = '<font color=red>ОШИБКА! </font> Не выбран (или выбран некорректный) вид деятельности'
		goto OK
		--raiserror (@Error,16,1)
		select @Result = @@error goto Err
	end

OK:	
	return @Result
Err:
	
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_ReconcilationListCheck] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_ReconcilationListCheck]
	@DocID varchar(250),
	@ClassDoc varchar(2000),
	@Type int,
	
	@isActive char(1) = null, --состояние активности, в кот. документ будет после действия (если null - то ориентируемся по тому, какое у него состояние сейчас)
	@ActDoc varchar(64) = null,

	@RList varchar(4096) = null,--ЛС
	@RLName varchar(255) = null, --наименование ЛС,
	@FirstInRList varchar(1024) = '',
	@LastInRList varchar(1024) = '',

	@ReturnSelect bit = 1,
	@FromRecL varchar(8000) = '' out
as
	-- 0 - OnCre 
	-- 1 - OnAct 
	-- 2 - OnApr
	-- 3 - OnReg
	-- 4 - SAVE

	declare @Result int
	set @Result = 0
	
	declare @Tbl table
		(UserName varchar(255))
	
	declare @EmptyRL table
		(RLName varchar(255),
		RLText varchar(255))

	declare @TblRec table (RecName varchar(96), UserID varchar(32), Type int)
	declare @TblDelegate table (DT datetime,UserID varchar(32), ToUserID varchar(32), blnType bit default 0) --1 - делегирование, 0 - добавление

	declare @isActive2 char(1), --состояние Активен
			@SQLStatement varchar(8000),
			@ConstName varchar(255),--название категории документа
			@NameCreation varchar(255), --имя Автора документа
			
			@Ind int,
			@OneValue1 varchar(255),
			@OneValue varchar(255),
			@BLS varchar(4096), --базовый ЛС
			@BLS1 varchar(4096), --базовый ЛС (только логины)
			@DocDate datetime,
			@Counter int,
			@DelegateDate datetime,
			@isErrLS bit,
			@ErrCount int

	--добавляем в список проверки обязательных согласующих первого и последнего 
	insert into @TblRec (RecName, UserID, Type)
	values (@FirstInRList, isnull(ltrim(rtrim(
							case when @FirstInRList like '%<%>%' 
								then dbo.PDX_SubstringReturn(@FirstInRList,charindex('<',@FirstInRList),charindex('>',@FirstInRList))
							else @FirstInRList end
						)),''), 1)		
	select @Result = @@error if @Result <> 0 goto Err

	insert into @TblRec (RecName, UserID, Type)
	values (@LastInRList, isnull(ltrim(rtrim(
							case when @LastInRList like '%<%>%' 
								then dbo.PDX_SubstringReturn(@LastInRList,charindex('<',@LastInRList),charindex('>',@LastInRList))
							else @LastInRList end
						)),''), 2)
	select @Result = @@error if @Result <> 0 goto Err

	select 
		@SQLStatement = ''
	select @Result = @@error if @Result <> 0 goto Err

	--получаем инфу о делегировании/добавлении
	insert into @TblDelegate(UserID, ToUserID, blnType, DT)
	select UserID, dbo.PDX_SubstringReturn(Comment,charindex('<',Comment),charindex('>',Comment)), case upper(isnull(SpecialInfo,'')) when 'DELEGATE' then 1 else 0 end,
	DateCreation
	from dbo.Comments
	where DocID = @DocID
		and upper(CommentType) = 'VISA'
		and (
				upper(isnull(SpecialInfo,'')) = 'DELEGATE' or (isnull(SpecialInfo,'') = '' and Comment like 'Пользователь добавлен в список согласующих:%') 
			)
	select @Result = @@error if @Result <> 0 goto Err

--т.е. если @isActive передан, то это кто-то модифицирует документ с правами супервайзера, 
--а значит новый статус документа нужно брать с клиента, а не из БД
	select 
		@isActive = case when @isActive is null 
							then lower(IsActive) 
			 			 else 
							case @isActive 
								when 0 
									then '' 
								else 'y' 
							end 
					     end,
		@isActive2 = lower(IsActive),
		@NameCreation = NameCreation + case right(rtrim(NameCreation),1) when ';' then '' else ';' end,
		@RList = case when @RList is  null
					then ListToReconcile
					else @RList
				end,
		@RLName = case when @RLName is null
					then UserFieldText1
					else @RLName
				  end,
		@ActDoc = case when @ActDoc is null 
						then ActDoc
					else @ActDoc 
					end,
		@DocDate = isnull(DateCreation,getdate()),
		@ClassDoc = case isnull(@ClassDoc,'') when '' then ClassDoc else @ClassDoc end
	from dbo.Docs with (nolock)
	where DocID = @DocID
	select @Result = @@error if @Result <> 0 goto Err

	--проверка и обработка ЛС
	exec @Result = dbo.PDX_ReconcilationListContent
		@ListToReconcile = @RList out,
		@ErrorStr = @SQLStatement out
	if @Result <> 0 goto Err

	If @SQLStatement <> '' goto OK

	--если так и не удалось определить статус Активности, считаем, что документ неактивен
	select @isActive = case when @isActive is null then '' else @isActive end
	select @Result = @@error if @Result <> 0 goto Err

	select --привязывемся не к назв. к категории, а к константе
		@ConstName = ConstName
	from dbo.PDXDocTypesConst with (nolock)
	where DocType = @ClassDoc
	select @Result = @@error if @Result <> 0 goto Err

	--наименование ЛС есть только в Договорах
	If not @ConstName in ('RIK_CategoryName_DOGOVORY_B',
						'RIK_CategoryName_DOGOVORY_C',
						'RIK_CategoryName_DOGOVORY_E',
						'RIK_CategoryName_DOGOVORY_F',							
						'RIK_CategoryName_DOGOVORY_H',
						'RIK_CategoryName_DOGOVORY_P',
						'RIK_CategoryName_DOGOVORY_R',
						'RIK_CategoryName_DOGOVORY_S',
						'RIK_CategoryName_DOGOVORY_T',
						'RIK_CategoryName_DOGOVORY_X',
						'RIK_CategoryName_DOGOVORY_Y',
						'RIK_CategoryName_DOGOVORY_Z',
						'RIK_CategoryName_DOGOVORY_L',
						'RIK_CategoryName_DOGOVORY_M')
	begin
		select @RLName = ''
		select @Result = @@error if @Result <> 0 goto Err
	end

	--это те ЛС, для которых проверки не нужны или они ограничены
	insert into @EmptyRL (RLName, RLText)
	select Field1, ltrim(rtrim(isnull(Field2,'')))
	from dbo.UserDirValues with (nolock)
	where UDKeyField = 34
		and ltrim(rtrim(replace(replace(replace(Field2, char(10),''),char(13),''),'(#$)',''))) = ''
	select @Result = @@error if @Result <> 0 goto Err

	select @RLName = ltrim(rtrim(isnull(@RLName,'')))
	select @Result = @@error if @Result <> 0 goto Err
	If @RLName <> ''
	begin
		select @isErrLS = null

		select  --получаем ЛС из справочника, который соответствуен указанному наименованию
			@BLS = Field2,
			@isErrLS = case 
						when (isnull(Field4,'') = '' or isnull(Field4,'') like '%' + @ActDoc + '%')
							and (isnull(Field3,'') = '' or isnull(Field3,'') like '%' + @ClassDoc + '%')
							and Field1 = @RLName
							then 1
						else 0
					   end							
		from dbo.UserDirValues with (nolock)
		where UDKeyField = 34
			and Field1 = @RLName
		select @Result = @@error if @Result <> 0 goto Err

		if @isErrLS = 0
		begin
			select @SQLStatement = @SQLStatement + 
						case len(@SQLStatement) when 0 then '' else '<BR>' end + 
						'<font color=red>ОШИБКА!</font> Выбрано недопустимое для данного вида деят-ти и/или категории наименование Листа согласования. '
			select @Result = @@error if @Result <> 0 goto Err		end

	end

	if ltrim(rtrim(isnull(@BLS,''))) <> ''
	begin
		--проверка и обработка ЛС, на правильность логинов (подсчет угловых скобок и убирание лишненй инфы и переменной)
		exec @Result = dbo.PDX_ReconcilationListContent
			@ListToReconcile = @BLS out,
			@ErrorStr = null
		if @Result <> 0 goto Err
	end

	select @BLS1 = @BLS --чтоьы осуществлять проверки  и без делегирования
	select @Result = @@error if @Result <> 0 goto Err

	--теперь в справочном листе сделаем подмены согласно делегированию и добавлению
	if len(@BLS)>0
	begin
		select @DelegateDate = '1900-01-01' --данные перебираем строго по дате их появления
		select @Result = @@error if @Result <> 0 goto Err
		--обрабатываем делегирование
		while exists (select 1 from @TblDelegate where @BLS like '%<' + UserID + '>%' and blnType = 1 
						and DT > @DelegateDate)
		begin
			select top 1
				@BLS = replace(@BLS,'<'+UserID+'>','<'+ToUserID+'>'),
				@DelegateDate = DT
			from @TblDelegate
			where @BLS like '%<' + UserID + '>%' 
				and blnType = 1
				and DT > @DelegateDate
			order by DT
			select @Result = @@error if @Result <> 0 goto Err
		end 
		select @Result = @@error if @Result <> 0 goto Err

		If not @RLName like '(БЛС)%'
		begin
			select @DelegateDate = '1900-01-01' --это нужно для листов, кот не явл. (БЛС)
			select @Result = @@error if @Result <> 0 goto Err
			--обрабатываем добавление
			while exists (select 1 from @TblDelegate where @BLS like '%<' + UserID + '>%' 
							and not @BLS like '%<' + UserID + '><' + ToUserID + '>%' and blnType = 0 
							and DT > @DelegateDate)
			begin
				select top 1
					@BLS = replace(@BLS,'<'+UserID+'>','<'+UserID+'><'+ToUserID+'>'),
					@DelegateDate = DT
				from @TblDelegate
				where @BLS like '%<' + UserID + '>%' 
					and not @BLS like '%<' + UserID + '><' + ToUserID + '>%' 
					and blnType = 0
					and DT > @DelegateDate
				order by DT
				select @Result = @@error if @Result <> 0 goto Err
			end 
		end
		select @Result = @@error if @Result <> 0 goto Err
	end
	--АКТИВАЦИЯ/СОХРАНЕНИЕ после активации/ВОЗОБНОВЛЕНИЕ 
	if (@Type in (1) 
		or (@Type = 4 and @isActive = 'y'))
	begin
		if @ConstName in (  'RIK_CategoryName_DOGOVORY_B',
							'RIK_CategoryName_DOGOVORY_C',
							'RIK_CategoryName_DOGOVORY_E',
							'RIK_CategoryName_DOGOVORY_F',							
							'RIK_CategoryName_DOGOVORY_H',
							'RIK_CategoryName_DOGOVORY_P',
							'RIK_CategoryName_DOGOVORY_R',
							'RIK_CategoryName_DOGOVORY_S',
							'RIK_CategoryName_DOGOVORY_T',
							'RIK_CategoryName_DOGOVORY_X',
							'RIK_CategoryName_DOGOVORY_Y',
							'RIK_CategoryName_DOGOVORY_Z',
							'RIK_CategoryName_DOGOVORY_L',
							'RIK_CategoryName_DOGOVORY_M')
		begin	
			--проверка на соответствие ЛС наименованию: 2 варианта: ЛС базовый(все лица из БЛС есть в ЛС) и ЛС фиксированный(ЛС = %ФЛС%)
			if not @RLName in (select lower(RLName) from @EmptyRL union select '') --ЛС произвольного содержания не проверяем
			begin
				if @RLName like '(БЛС)%' --анализируем базовый ЛС
				begin --БЛС
					--так как параллельность/последовательность на не интересует, то убираем Enter-ы из листов
					select @BLS = replace(@BLS,char(13)+char(10),''),
							@BLS1 = replace(@BLS1,char(13)+char(10),'')
					select @Result = @@error if @Result <> 0 goto Err

					while isnull(len(@BLS),0) <> 0 --разбираем пофамильно, проверяя наличие в ЛС
					begin
						select @Ind = 0,@OneValue = ''--обнуляем переменные
						select @Result = @@error if @Result <> 0 goto Err
						select @Ind = charindex('>',@BLS,1) --находим ближайший разделитель
						select @Result = @@error if @Result <> 0 goto Err
						if @Ind = 0 select @Ind = len(@BLS) --если он не найден имеем дело с последним значением
						select @Result = @@error if @Result <> 0 goto Err
						select @OneValue = substring(@BLS,1,@Ind)--получаем первую фамилию из списка
						select @Result = @@error if @Result <> 0 goto Err
						select @BLS = ltrim(rtrim(replace(@BLS,@OneValue,''))) --удаляем из исходного списка выделенное значение
						select @Result = @@error if @Result <> 0 goto Err
						
						select @Ind = 0,@OneValue1 = ''--обнуляем переменные
						select @Result = @@error if @Result <> 0 goto Err
						select @Ind = charindex('>',@BLS1,1) --находим ближайший разделитель
						select @Result = @@error if @Result <> 0 goto Err
						if @Ind = 0 select @Ind = len(@BLS1) --если он не найден имеем дело с последним значением
						select @Result = @@error if @Result <> 0 goto Err
						select @OneValue1 = substring(@BLS1,1,@Ind)--получаем первую фамилию из списка
						select @Result = @@error if @Result <> 0 goto Err
						select @BLS1 = ltrim(rtrim(replace(@BLS1,@OneValue1,''))) --удаляем из исходного списка выделенное значение
						select @Result = @@error if @Result <> 0 goto Err

 						if @OneValue like '%<%>%' or @OneValue1 like '%<%>%' 
 						begin
							If not @RList like '%' + @OneValue + '%' and not @RList like '%' + @OneValue1 + '%' --пользователь не встречается в ЛС 
							begin
								select 
									@SQLStatement = @SQLStatement + 
									case len(@SQLStatement) when 0 then '' else '<BR>' end + 
									'<font color=red>ОШИБКА!</font> Не все пользователи выбранного базового листа согласования указаны в листе согласования карточки. '
								select @Result = @@error if @Result <> 0 goto Err
								break --при ошибке сразу выходим из цикла
							end
						end
						select @Result = @@error if @Result <> 0 goto Err
					end		
				end --БЛС
				else --анализируем фиксированный ЛС
				begin --ФЛС
					--ПРОВЕРЯЕМ, ЧТО НАИМЕНОВАНИЕ СООТВЕТСТВУЕТ ЛИСТУ СОГЛАСОВАНИЯ
					If not @RList like '%' + @BLS + '%' and not @RList like '%' + @BLS1 + '%'
					begin
						select 
							@SQLStatement = @SQLStatement + 
								case len(@SQLStatement) when 0 then '' else '<BR>' end + 
								'<font color=red>ОШИБКА!</font> Наименование списка согласующих лиц не соответствует указанному листу согласования. '
						select @Result = @@error if @Result <> 0 goto Err
					end
				end --ФЛС
			end --if not isnull(lower(@RLName),'') in ('','произвольный')
			else if @RLName in (select lower(RLName) from @EmptyRL where isnull(RLText,'') <> '')
			begin
				If @RList <> '' 
				begin
					select 
						@SQLStatement = @SQLStatement + 
							case len(@SQLStatement) when 0 then '' else '<BR>' end + 
							'<font color=red>ОШИБКА!</font> Наименование списка согласующих лиц не соответствует указанному листу согласования. '
					select @Result = @@error if @Result <> 0 goto Err
				end
			end
		end

		if @ConstName in (  'RIK_CategoryName_DOGOVORY_B',
							'RIK_CategoryName_DOGOVORY_C',
							'RIK_CategoryName_DOGOVORY_E',
							'RIK_CategoryName_DOGOVORY_F',							
							'RIK_CategoryName_DOGOVORY_H',
							'RIK_CategoryName_DOGOVORY_P',
							'RIK_CategoryName_DOGOVORY_R',
							'RIK_CategoryName_DOGOVORY_S',
							'RIK_CategoryName_DOGOVORY_T',
							'RIK_CategoryName_DOGOVORY_X',
							'RIK_CategoryName_DOGOVORY_Y',
							'RIK_CategoryName_DOGOVORY_Z',
							'RIK_CategoryName_DOGOVORY_L',
							'RIK_CategoryName_DOGOVORY_M')
		begin
			--проверяем, что лист согласования соответствует категории
			if @RLName <> '' 
			begin
				if not exists (select 1 from dbo.UserDirValues with (nolock)
								where UDKeyField = 34--справочник ЛС
									and @RLName = Field1
									and (Field3 like '%'+@ClassDoc+'%' or LTRIM(RTRIM(Field3)) = '')
									--and (Field3 like '%'+@ClassDoc+'%' or Field3 = case @ConstName when 'RIK_CategoryName_DOGOVORY_L' then @ClassDoc else '' end)
									--and	Field3 in (@ClassDoc,case @ConstName when 'RIK_CategoryName_DOGOVORY_L' then @ClassDoc else '' end)
								)
				begin
					select 
						@SQLStatement = @SQLStatement + 
							case len(@SQLStatement) when 0 then '' else '<BR>' end + 
							'<font color=red>ОШИБКА!</font> Выбрано недопустимое(несуществующее) наименование списка согласующих лиц.'
					select @Result = @@error if @Result <> 0 goto Err
				end
			end --if isnull(@RLName,'') <> '' 
		end --if @ConstName in

  		if not @RLName in (select lower(RLName) from @EmptyRL where RLText <> '')
		begin
			select @ErrCount = 15
			select @Result = @@error if @Result <> 0 goto Err

			--обязательные согласующие из доп. настроек 
			--обязат. согласующие, которых нет в ЛС
			insert into @TblRec (RecName, UserID, Type)
			select RecName, dbo.PDX_SubstringReturn(RecName,charindex('<',RecName),charindex('>',RecName)), 0
			from dbo.PDXRLSpecial S with (nolock)
			where DocTypes like '%' + @ClassDoc + '%'
			  and ActDoc like '%' + @ActDoc + '%'
			  and @DocDate between isnull(DateFrom,getdate()) and isnull(DateEnd, getdate())
			select @Result = @@error if @Result <> 0 goto Err

			delete from @TblRec where RecName = '' or UserID = ''
			select @Result = @@error if @Result <> 0 goto Err

			--удфляем тех, то в ЛС на своих местах (в начале ЛС, в конце или в любом месте)		
			delete from @TblRec where @RList like case when Type in (0,2) then '%' else '' end + '<' + UserID + '>' + case when Type in (0,1) then '%' else '' end
			select @Result = @@error if @Result <> 0 goto Err

			--может быть они делегировали?
			if exists (select 1 from @TblRec)
			begin
				--да есть делегирование от этих пользователей
				if exists(select 1 from @TblDelegate D inner join @TblRec R on R.UserID = D.UserID where blnType = 1)
				begin 
					select @Counter = 1,@ErrCount = 15 --раскручиваем цепочку делегирования
--@ErrCount  - защита от зацикливания.
--т.к. в СЭД не хранится история измения ЛС, то иногда его невозможно корректно сопоставить коммент. о делегировании
--возникает зацикливание, кот. "обходим" таким образом
					while @Counter > 0 and exists(select 1 from @TblRec) and @ErrCount > 0
					begin
						update R --смотрим кому было делегирование
							set UserID = D.ToUserID
						from @TblRec R 		
						inner join @TblDelegate D on D.UserID = R.UserID
						where blnType = 1
						select @Counter = @@rowcount, @Result = @@error if @Result <> 0 goto Err

						--если тот кому делегировали в ЛС на своем месте то, все ок
						delete R from @TblRec R where @RList like case when Type in (0,2) then '%' else '' end + '<' + UserID + '>' + case when Type in (0,1) then '%' else '' end	
						select @Result = @@error if @Result <> 0 goto Err
		
						select @ErrCount = @ErrCount - 1
						select @Result = @@error if @Result <> 0 goto Err
					end
					select @Result = @@error if @Result <> 0 goto Err
				end
				select @Counter = @@rowcount, @Result = @@error if @Result <> 0 goto Err

				--удаляем последнего согласующего если он есть в ЛС и от его имени было добавление пользователей
				--(корректный разбор добавления очень тяжелый)
				delete T 
				from @TblRec T
				inner join @TblDelegate D on D.UserID = T.UserID and blnType = 0
				where T.Type = 2 and @RList like '%<' + T.UserID + '>%'
				select @Result = @@error if @Result <> 0 goto Err

				If @ErrCount > 0 --ошибки выводим только если раскрутка делегирования прошла без сбоя
				begin
					--если остались "неучтенные" согласующие - добавляем ошибку
					select 
						@SQLStatement = @SQLStatement + case len(@SQLStatement) when 0 then '' else '<BR>' end + 
						case Type 
							when 1 
								then '<font color=red>ОШИБКА! </font>Первым согласующим в данном документе должен быть '
							when 2
								then '<font color=red>ОШИБКА! </font>В листе согласования последним должен стоять пользователь '
							else '<font color=red>ОШИБКА! </font>Обязательным согласующим по данной категории документа и данному виду деят-ти является пользователь ' 
						end	+ RecName
					from @TblRec
					select @Result = @@error if @Result <> 0 goto Err
				end
			end
			select @Result = @@error if @Result <> 0 goto Err
		end 
	End    

OK:
	if @SQLStatement <> ''  select @SQLStatement = @SQLStatement + '<BR>'
	select @Result = @@error if @Result <> 0 goto Err
	select @FromRecL = @SQLStatement
	select @Result = @@error if @Result <> 0 goto Err
	
	if @ReturnSelect = 1 select @SQLStatement
	select @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:
	
	return @Result


GO
/****** Object:  StoredProcedure [dbo].[PDX_ReconcilationListContent] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_ReconcilationListContent]
	@ListToReconcile varchar(4096) out,
	@ErrorStr varchar(1024) out,
	@FieldName varchar(128) = null
as

	
	declare @Pos int, @Pos2 int, @Result int,
		@LTR varchar(8000)

	select @Result = 0

	select @ErrorStr = '',
		@FieldName = isnull(@FieldName,'Лист согласования')

	--убираем спец символы
	select @ListToReconcile = space(1) + replace(@ListToReconcile,'<(#!)>','(#!)') + space(1)

	select @LTR = space(1) + @ListToReconcile + space(1)
	--проверяем, что выбрано все корректно (кол-во и последовательность угловых скобок)
	while @LTR like '%<%>%'
	begin--подряд одинаковые скобки
		select @Pos = charindex('<',@LTR), @Pos2 = charindex('>',@LTR)
		--select @Result = @@error if @Result <> 0 goto Err

		If @Pos2 <= @Pos or dbo.PDX_SubstringReturn(@LTR, @Pos, @Pos2) like '%<%' 
		begin 
			select
				@ErrorStr = @ErrorStr +
					case len(@ErrorStr) when 0 then '' else '<BR>' end + 
						'<font color=red>ОШИБКА! </font>' + @FieldName + ': допущена ошибка при выборе пользователей (проверьте лишние/недостающие угловые скобки в логинах пользователей)'
			select @Result = @@error if @Result <> 0 goto Err
			goto OK
		end
		select @Result = @@error if @Result <> 0 goto Err
		 
		select @LTR = STUFF(@LTR,@Pos,@Pos2 - @Pos + 1, '')
		select @Result = @@error if @Result <> 0 goto Err
	end

Ex1:
	If @LTR like '%<%' or @LTR like '%>%'
	begin --непарное кол-во скобок
		select 
			@ErrorStr = @ErrorStr +
				case len(@ErrorStr) when 0 then '' else '<BR>' end + 
					'<font color=red>ОШИБКА! </font>' + @FieldName + ': допущена ошибка при выборе пользователей (проверьте лишние/недостающие угловые скобки в логинах пользователей)'
		select @Result = @@error if @Result <> 0 goto Err
		goto OK
	end

	--проверка на точки с запятой
	select @LTR = replace(replace(@ListToReconcile,space(1),''),'>;','')
	If @LTR like '%>%'
	begin --не хватает точек с запятой. при их отсутствии могут быть проблемы с делегированием/добавлением
		select 
			@ErrorStr = @ErrorStr +
				case len(@ErrorStr) when 0 then '' else '<BR>' end + 
					'<font color=red>ОШИБКА! </font>' + @FieldName + ': после каждого логина (после закрывающейся угловой скобки) должна стоять точка с запятой'
		select @Result = @@error if @Result <> 0 goto Err
		goto OK
	end

	set @ListToReconcile = REPLACE(@ListToReconcile,CHAR(13)+CHAR(10),'#')
	declare @Val table (Val varchar(4096), ID int identity, Flg bit default 0)
	insert into @Val (Val)
    select Value
    from dbo.inline_split_with_param(@ListToReconcile, '#')
    
    while exists (select 1 from @Val where Flg = 0)
    begin
		select top 1
			 @LTR = '',
			 @ListToReconcile = Val
		from @Val
		where Flg = 0	
		
		select @LTR = @LTR + '<' + value + '> '
		from dbo.inline_split_with_params(@ListToReconcile, '<','>')
		
		update @Val
			set Val = @LTR,
			Flg = 1
		where Val = @ListToReconcile
    end
    set @LTR = ''
    select @LTR = @LTR + case @LTR when '' then '' else CHAR(13)+CHAR(10) end + VAL
    from @Val
    
    set @ListToReconcile = @LTR
OK:
--select @ListToReconcile

	return @Result
Err:
	
	return @Result





GO
/****** Object:  StoredProcedure [dbo].[PDX_ReconcilationListRules] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE proc [dbo].[PDX_ReconcilationListRules]
	@DocID varchar(250),
	@Type int,
	
	@isActive char(1) = null, --состояние активности, в кот. документ будет после действия (если null - то ориентируемся по тому, какое у него состояние сейчас)
	@ClassDoc varchar(64),
	@ActDoc varchar(64) = null,
	@UFT2 varchar(1024) = null,
	@NameAproval varchar(96),

	@RList varchar(4096) = null,--ЛС
	@RLName varchar(255) = null, --наименование ЛС,
	@Parametr1 varchar(512)=null,
	@Parametr2 varchar(512)=null,
	@Parametr3 varchar(512)=null,

	@ReturnSelect bit = 1,
	@FromRecL varchar(8000) = '' out
as
	-- 0 - OnCre 
	-- 1 - OnAct 
	-- 2 - OnApr
	-- 3 - OnReg
	-- 4 - SAVE

	--declare @Result int
	--set @Result = 0
	
	declare @TblRec table (RecName varchar(96), UserID varchar(32), RLPos int, Val varchar(1024), Typ tinyint, KeyFld int identity, Flg bit default 0)
	declare @TblDelegate table (DT datetime,UserID varchar(32), ToUserID varchar(32), blnType bit default 0, KeyField int identity) --1 - делегирование, 0 - добавление
	declare @Tbl_BLS table (Val varchar(64), Pos int, Flag bit, ToUserID varchar(64), DelegateDate datetime default '1900-01-01', isSystem bit default 0, ErrMessage varchar(255), KeyFld int identity)
	declare @Tbl_LS table (Val varchar(64), Pos int, Flag bit, Flg bit default 0)

	declare @isActive2 char(1), --состояние Активен
			@SQLStatement varchar(8000),
			@ConstName varchar(255),--название категории документа
			@BLS varchar(4096), --базовый ЛС
			@DocDate datetime,
			@isErrLS int,
			@ClassGr varchar(64),
			@ErrCnt int,
			@KeyFld int,
			@KeyWord varchar(64),

			@UserID varchar(64),
			@UserID2 varchar(64),
			@UserName varchar(1024),
			
			@PosMax int, 
			@PosMin int,
			
			@OI_Bprev int,
			@OI_prev int,
			--@OI int,
			
			@Pos_bls int,
			@Pos_ls int,
			
			@Flag_bls bit,
			@Flag_ls bit,
		
			@isOrdered bit,
			@isSystem bit,
			@ErrMessage varchar(255),
			@LastPos int,
			@Dept varchar(1024),
			@DT varchar(1024),
			@WithUsers bit,
			@PayClass varchar(128), @CFO varchar(1024), @BE varchar(1024),
			@Amount money,
			@Currency varchar(128), @DocIDInt int

	set @WithUsers = 1
    set @PayClass = dbo.PDX_CLSGrGet('RIK_CategoryName_KAZ_ORDPAY')
    
	--этот счетчик от зацикливания. в связи с тем, что инф-я о версиях ЛС и делегировании/добавлении хранится 
	--без строго соответствия друг другу. приходится вставлять "тупую" защиту от делегирования 
	select 
		@SQLStatement = '',
		@isOrdered = 0,
		@LastPos = 10000
	--select @Result = @@error if @Result <> 0 goto Err

--т.е. если @isActive передан, то это кто-то модифицирует документ с правами супервайзера, 
--а значит новый статус документа нужно брать с клиента, а не из БД
	select 
		@isActive = case when @isActive is null 
							then lower(IsActive) 
			 			 else 
							case @isActive 
								when 0 
									then '' 
								else 'y' 
							end 
					     end,
		@isActive2 = lower(IsActive),
		--@NameCreation = NameCreation + case right(rtrim(NameCreation),1) when ';' then '' else ';' end,
		@RList = case when @RList is  null
					then ListToReconcile
					else @RList
				end,
		@RLName = case when @RLName is null
					then 
						case when ClassDoc in (
										dbo.PDX_CLSGet('RIK_CategoryName_ISHO_VNESH'),
										dbo.PDX_CLSGet('RIK_CategoryName_ISHO_VNUTR'))
							then UserFieldText3
							else UserFieldText1
						end
					else @RLName
				  end,
		@ActDoc = case when @ActDoc is null 
						then ActDoc
					else @ActDoc 
					end,
		--@DocDate = convert(datetime, convert(varchar(50),isnull(DateCreation,getdate()),104),104),
		@DocDate = convert(datetime, convert(varchar(50),getdate(),104),104),
		@NameAproval = case when isnull(@NameAproval,'') = ''
					then NameAproval
					else @NameAproval
				end,
		@ClassDoc = case isnull(@ClassDoc,'') when '' then ClassDoc else @ClassDoc end,
		@Dept = ISNULL(Department,''),
		@UFT2 = case when @UFT2 is null and ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_OTHERS_NSI')
						then UserFieldText2
					when @UFT2 is null and ClassDoc IN (dbo.PDX_CLSGet('RIK_CategoryName_KAZ_PLNPAY'),
														dbo.PDX_CLSGet('RIK_CategoryName_KAZ_ORDPAY'),
														dbo.PDX_CLSGet('RIK_CategoryName_KAZ_BUDG'),
														dbo.PDX_CLSGet('RIK_CategoryName_KAZ_PLNTBL'))
						then UserFieldText2
					when @UFT2 is null and ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_CORPAY')
						then UserFieldText2
					when @UFT2 is null and ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_ACCRUAL')
						then UserFieldText2
					else @UFT2 
					end,
		@DT = case when ClassDoc IN (dbo.PDX_CLSGet('RIK_CategoryName_DOGOVORY_B'),
									dbo.PDX_CLSGet('RIK_CategoryName_DOGOVORY_C'),
									dbo.PDX_CLSGet('RIK_CategoryName_DOGOVORY_E'),
									dbo.PDX_CLSGet('RIK_CategoryName_DOGOVORY_F'),
									dbo.PDX_CLSGet('RIK_CategoryName_DOGOVORY_H'),
									dbo.PDX_CLSGet('RIK_CategoryName_DOGOVORY_L'),
									dbo.PDX_CLSGet('RIK_CategoryName_DOGOVORY_M'),
									dbo.PDX_CLSGet('RIK_CategoryName_DOGOVORY_P'),
									dbo.PDX_CLSGet('RIK_CategoryName_DOGOVORY_S'),
									dbo.PDX_CLSGet('RIK_CategoryName_DOGOVORY_T'),
									dbo.PDX_CLSGet('RIK_CategoryName_DOGOVORY_X'),
									dbo.PDX_CLSGet('RIK_CategoryName_DOGOVORY_Y'),
									dbo.PDX_CLSGet('RIK_CategoryName_DOGOVORY_Z'),
									dbo.PDX_CLSGet('RIK_CategoryName_VHOD_VNESH'),
									dbo.PDX_CLSGet('RIK_CategoryName_OTHERS_DOG'))
					then UserFieldText2
				when ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_RAB_SOGLAS')
					then UserFieldText1
				else ''
			end,
		@CFO = case when ClassDoc IN (dbo.PDX_CLSGet('RIK_CategoryName_KAZ_ACCRUAL'),
									dbo.PDX_CLSGet('RIK_CategoryName_KAZ_ORDPAY'),
									dbo.PDX_CLSGet('RIK_CategoryName_KAZ_PLNPAY'),
									dbo.PDX_CLSGet('RIK_CategoryName_KAZ_BUDG'),
									dbo.PDX_CLSGet('RIK_CategoryName_KAZ_PLNTBL'))
						then UserFieldText2
					when ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_CORPAY')
						then UserFieldText3
				end,
		@BE = case when ClassDoc IN (dbo.PDX_CLSGet('RIK_CategoryName_KAZ_ACCRUAL'),
									dbo.PDX_CLSGet('RIK_CategoryName_KAZ_ORDPAY'),
									dbo.PDX_CLSGet('RIK_CategoryName_KAZ_PLNPAY'),
									dbo.PDX_CLSGet('RIK_CategoryName_KAZ_CORPAY'),
									dbo.PDX_CLSGet('RIK_CategoryName_KAZ_BUDG'),
									dbo.PDX_CLSGet('RIK_CategoryName_KAZ_PLNTBL'))
						then UserFieldText8
				end,
		@Currency = Currency,
		@Amount = AmountDoc,
		@DocIDInt = DocIDInt
	from dbo.Docs with (nolock)
	where DocID = @DocID
	--select @Result = @@error if @Result <> 0 goto Err

    If @ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_ORDPAY')
    begin
		select @Amount = SUM(Am1) from dbo.PDXDocDetails where DocID = @DocID
    end
    else If @ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_ACCRUAL')
    begin
		select @Amount = SUM(Amount) from dbo.PDXAccrual where DocIDInt = @DocIDInt
    end
    else If @ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_BUDG')
    begin
		select @Amount = SUM(Amount) from dbo.DocsPayBudget where DocIDInt = @DocIDInt
    end
    select @Amount = ISNULL(@Amount, 0)
    --сумма нужна по модулю
    if @Amount < 0 set @Amount = -1 * @Amount
    
	--название группы категории (если группа не выделяется, будет = самой категории)
	select @ClassGr = case when @ClassDoc like '%/%' 
						then substring(@ClassDoc, 1, charindex('/',@ClassDoc))
						else @ClassDoc
					  end,
			@NameAproval = case when @NameAproval like '%<%>%'
								then '<'+dbo.PDX_SubstringReturn(@NameAproval, charindex('<',@NameAproval), charindex('>',@NameAproval))+'>'
								else ''	
							end
	--select @Result = @@error if @Result <> 0 goto Err

	--проверка и обработка ЛС
	exec /*@Result = */dbo.PDX_ReconcilationListContent
		@ListToReconcile = @RList out,
		@ErrorStr = @SQLStatement out
	--if @Result <> 0 goto Err

	--************************************
	If @SQLStatement <> '' goto OK --если есть ошибки при проверки листа на данном этапе. остальные ошибки нас не интересуют - сразу "выходим отсюда"
	--************************************
--select @ClassDoc,@ClassGr,@ActDoc,@NameAproval,@DocDate
	--получаем обязательных согласующих
	insert into @TblRec (RecName, UserID, RLPos, Val,Typ)
	exec [dbo].[PDX_CheckLTRByAccounter]
		@DocID = @DocID
		
	insert into @TblRec (RecName, UserID, RLPos)
	select distinct
		UserName,
		 case when UserName like '%<%>%'
			then dbo.PDX_SubstringReturn(UserName, charindex('<',UserName), charindex('>',UserName))
			else ''	
		 end, 
		 RLPos
	from dbo.PDXReconcilationRules
	where ClassDoc in (@ClassDoc,@ClassGr) and Not ClassDoc like @PayClass + '%'
		and ActDoc = @ActDoc
		and not NotAppr like '%' + case @NameAproval when '' then '+_)(*&^%$#@' else @NameAproval end + '%'	
		--чтобы условие работало, когда нет утверждающего, подставляем заведомо невозможное значение 
		and @DocDate between DateFrom and DateTo
		and (Dept is null or @Dept like Dept + '%')	
		and (DocType = '' or DocType = @DT)
	--select @Result = @@error if @Result <> 0 goto Err

	insert into @TblRec (RecName, UserID, RLPos)
	select distinct
		UserName,
		 case when UserName like '%<%>%'
			then dbo.PDX_SubstringReturn(UserName, charindex('<',UserName), charindex('>',UserName))
			else ''	
		 end, 
		 RLPos
	from dbo.PDXRecPayRules
	where ClassDoc = @ClassDoc
		and @DocDate between DateFrom and DateTo
		and (BE = @BE or BE = '')
		and CFO = @CFO
		and @Amount between 
			case @Currency
				when 'РУБ' then AmRUBmin
				when 'USD' then AmUSDmin
				when 'EUR' then AmEURmin
				else	
					case 
						when AmRUBmin < AmEURmin and AmRUBmin < AmUSDmin then AmRUBmin
						when AmEURmin < AmRUBmin and AmEURmin < AmUSDmin then AmEURmin
						when AmUSDmin < AmRUBmin and AmUSDmin < AmEURmin then AmUSDmin
						else 0
					end
			end
			and
			case @Currency
				when 'РУБ' then AmRUBmax
				when 'USD' then AmUSDmax
				when 'EUR' then AmEURmax
				else 
					case 
						when AmRUBmax > AmEURmax and AmRUBmax > AmUSDmax then AmRUBmax
						when AmEURmax > AmRUBmax and AmEURmax > AmUSDmax then AmEURmax
						when AmUSDmax > AmRUBmax and AmUSDmax > AmEURmax then AmUSDmax
						else 0
					end
			end
		
--select @NameAproval,* from @TblRec

	--разбираем Ext Значения в циле попорядку
--select * from @TblRec
	while exists(select 1 from @TblRec where ltrim(rtrim(RecName)) like '{%}' and Flg = 0)
	begin --берем одно вычисляемое значение
		select top 1
			@KeyFld = KeyFld,
			@KeyWord = RecName,
			@UserName = ''
		from @TblRec 
		where ltrim(rtrim(RecName)) like '{%}' and Flg = 0 
		--select @Result = @@error if @Result <> 0 goto Err

		--вычисляем значения
		select @UserName = dbo.PDX_PDXRecRulesStatmentCreate(@DocID,@KeyWord,@Parametr1,@Parametr2,@Parametr3)
		--select @Result = @@error if @Result <> 0 goto Err

		--сохраняем рзультат и параллелеьно говорим, что для этой записи больше вычислять ничего не нужно (Ext2 = '')
		update @TblRec
			set Flg = 1,
			RecName = @UserName,
			UserID = case when @UserName like '%<%>%'
						then dbo.PDX_SubstringReturn(@UserName, charindex('<',@UserName), charindex('>',@UserName))
						else ''	
					end
		where KeyFld = @KeyFld
		--select @Result = @@error if @Result <> 0 goto Err
	end
--select * from @TblRec
	--если есть "пустоты" удаляем
	delete from @TblRec where ltrim(rtrim(isnull(UserID,''))) = ''
	--select @Result = @@error if @Result <> 0 goto Err
--select * from @TblRec
	--первый и последний согласующий - строго по одному
	if (select count(distinct UserID) from @TblRec R where R.RLPos = 1) > 1
	begin
		select @SQLStatement = @SQLStatement + 
					case len(@SQLStatement) when 0 then '' else '<BR>' end + 
					'<font color=red>ОШИБКА!</font> Ошибка при определении первого согласующего по документу(1). Для исправления ошибки обратитесь к Администратору СЭД.'
		--select @Result = @@error if @Result <> 0 goto Err		
	end
	if (select count(distinct UserID) from @TblRec R where R.RLPos = 0) > 1
	begin
		select @SQLStatement = @SQLStatement + 
					case len(@SQLStatement) when 0 then '' else '<BR>' end + 
					'<font color=red>ОШИБКА!</font> Ошибка при определении последнего согласующего по документу(2). Для исправления ошибки обратитесь к Администратору СЭД.'
		--select @Result = @@error if @Result <> 0 goto Err		
	end

	--************************************
	If @SQLStatement <> '' goto OK --если есть ошибки при проверки листа на данном этапе. остальные ошибки нас не интересуют - сразу "выходим отсюда"
	--************************************
--select 1,* from @TblRec
	--получаем инфу о делегировании/добавлении
	insert into @TblDelegate(UserID, ToUserID, blnType, DT)
	select 
		UserID, 
		dbo.PDX_SubstringReturn(Comment,charindex('<',Comment),charindex('>',Comment)), 
		case upper(isnull(SpecialInfo,'')) when 'DELEGATE' then 1 else 0 end,
		DateCreation
	from dbo.Comments
	where DocID = @DocID
		and upper(CommentType) = 'VISA'
		and upper(isnull(SpecialInfo,'')) = 'DELEGATE'
	--select @Result = @@error if @Result <> 0 goto Err
--select 2,* from @TblDelegate
	--если так и не удалось определить статус Активности, считаем, что документ неактивен
	select @isActive = case when @isActive is null then '' else @isActive end
	--select @Result = @@error if @Result <> 0 goto Err

	select --привязывемся не к назв. к категории, а к константе
		@ConstName = ConstName
	from dbo.PDXDocTypesConst with (nolock)
	where DocType = @ClassDoc
	--select @Result = @@error if @Result <> 0 goto Err

	--перечисляем категории, где есть наименование ЛС, в остальных его нет
	If not @ConstName in ('RIK_CategoryName_DOGOVORY_B',
						'RIK_CategoryName_DOGOVORY_C',
						'RIK_CategoryName_DOGOVORY_E',
						'RIK_CategoryName_DOGOVORY_F',							
						'RIK_CategoryName_DOGOVORY_H',
						'RIK_CategoryName_DOGOVORY_P',
						'RIK_CategoryName_DOGOVORY_R',
						'RIK_CategoryName_DOGOVORY_S',
						'RIK_CategoryName_DOGOVORY_T',
						'RIK_CategoryName_DOGOVORY_X',
						'RIK_CategoryName_DOGOVORY_Y',
						'RIK_CategoryName_DOGOVORY_Z',
						'RIK_CategoryName_DOGOVORY_L',
						'RIK_CategoryName_DOGOVORY_M',
						'RIK_CategoryName_ATTORNEYID',
						'RIK_CategoryName_FIN_ORDPAY',
						'RIK_CategoryName_OTHERS_DOG',
						'RIK_CategoryName_OTHERS_TRP',
						'RIK_CategoryName_OTHERS_ZPR',
						'RIK_CategoryName_CLEARING_C',
						'RIK_CategoryName_KAZ_PLNPAY',
						'RIK_CategoryName_KAZ_ORDPAY',
						'RIK_CategoryName_KAZ_BUDG',
						'RIK_CategoryName_KAZ_CORPAY',
						'RIK_CategoryName_ISHO_VNESH',
						'RIK_CategoryName_ISHO_VNUTR',
						'RIK_CategoryName_ORDER_CONT',
						'RIK_CategoryName_OTHERS_NSI',
						'RIK_CategoryName_OTHERS_ISR',
						'RIK_CategoryName_OTHERS_MOB',
						'RIK_CategoryName_OTHERS_DGC',
						'RIK_CategoryName_OTHERS_N_Z',
						'RIK_CategoryName_OTHERS_ZOO',
						'RIK_CategoryName_ATTORNEY',
						'RIK_CategoryName_KAZ_ACCRUAL',
						'RIK_CategoryName_OTHERS_TMC',
						'RIK_CategoryName_KAZ_PLNTBL')
	begin
		select @RLName = ''
		--select @Result = @@error if @Result <> 0 goto Err
	end

	select @RLName = ltrim(rtrim(isnull(@RLName,'')))
	--select @Result = @@error if @Result <> 0 goto Err

	If @RLName <> ''
	begin
		select @isErrLS = -1
		--select @Result = @@error if @Result <> 0 goto Err
--select @UFT2, @ConstName, @RLName
		select  --получаем ЛС из справочника, который соответствуен указанному наименованию
			@BLS = replace(ltrim(rtrim(isnull(Field2,''))), @NameAproval, ''),
			@isErrLS = case  
						when @ConstName = 'RIK_CategoryName_OTHERS_NSI'
							then 
								case 
								when (isnull(Field3,'') = '' or isnull(Field3,'') like '%' + @UFT2 + '%')
									and Field1 = @RLName
									then 1
								else 0
							   end
						when @ConstName IN('RIK_CategoryName_KAZ_PLNPAY',
											'RIK_CategoryName_KAZ_ORDPAY',
											'RIK_CategoryName_KAZ_BUDG',
											'RIK_CategoryName_KAZ_CORPAY',
											'RIK_CategoryName_KAZ_ACCRUAL',
											'RIK_CategoryName_KAZ_PLNTBL')
							then 
								case 
								when (isnull(Field4,'') = '' or char(13)+char(10)+isnull(Field4,'')+char(13)+char(10) like '%' + char(13)+char(10) + @UFT2 + char(13)+char(10) + '%')
									and (isnull(Field3,'') = '' or isnull(Field3,'') like '%' + @ClassDoc + '%')
									and Field1 = @RLName
									then 1
								else 0
							   end	   					
						else
						   case 
							when (isnull(Field4,'') = '' or isnull(Field4,'') like '%' + @ActDoc + '%')
								and (isnull(Field3,'') = '' or isnull(Field3,'') like '%' + @ClassDoc + '%')
								and Field1 = @RLName
								then 1
							else 0
						   end
						end,
			@isOrdered = case ltrim(rtrim(Field5)) when '1' then 1 else 0 end
		from dbo.UserDirValues with (nolock)
		where UDKeyField = case  
								when @ConstName = 'RIK_CategoryName_OTHERS_NSI' 
									then 215 
								when @ConstName IN('RIK_CategoryName_KAZ_PLNPAY',
											'RIK_CategoryName_KAZ_ORDPAY',
											'RIK_CategoryName_KAZ_BUDG',
											'RIK_CategoryName_KAZ_CORPAY',
											'RIK_CategoryName_KAZ_ACCRUAL',
											'RIK_CategoryName_KAZ_PLNTBL')
									then 219
								else 34 
							end
			and Field1 = @RLName
		--select @Result = @@error if @Result <> 0 goto Err

		select @WithUsers = case when @BLS like '%(#$)%' then 0 else 1 end
		
		If @WithUsers = 0 and @RList like '%<%>%'
		begin
			select @SQLStatement = @SQLStatement + 
						case len(@SQLStatement) when 0 then '' else '<BR>' end + 
						'<font color=red>ОШИБКА!</font> При выбранном наименовании Листа согласования список согласующих должен быть пустым.'
			--select @Result = @@error if @Result <> 0 goto Err		
		end
		
		--ОШИБКА - некорректно выбрано наименование ЛС
		if @isErrLS <= 0
		begin
			select @SQLStatement = @SQLStatement + 
						case len(@SQLStatement) when 0 then '' else '<BR>' end + 
						case  
							when @ConstName = 'RIK_CategoryName_OTHERS_NSI'
								then
									case @isErrLS 
										when 0 then '<font color=red>ОШИБКА!</font> Выбрано недопустимое для данного [Названия справочника] наименование Листа согласования. '
										else '<font color=red>ОШИБКА!</font> Указанное наименование Листа согласования не существует. '
									end
							when @ConstName IN ('RIK_CategoryName_KAZ_PLNPAY',
											'RIK_CategoryName_KAZ_ORDPAY',
											'RIK_CategoryName_KAZ_BUDG',
											'RIK_CategoryName_KAZ_PLNTBL')
								then
									case @isErrLS 
										when 0 then '<font color=red>ОШИБКА!</font> Выбрано недопустимое для указанного ЦФО наименование Листа согласования. '
										else '<font color=red>ОШИБКА!</font> Указанное наименование Листа согласования не существует. '
									end
							when @ConstName IN ('RIK_CategoryName_KAZ_CORPAY')
								then
									case @isErrLS 
										when 0 then '<font color=red>ОШИБКА!</font> Выбрано недопустимое для указанного исх. ЦФО наименование Листа согласования. '
										else '<font color=red>ОШИБКА!</font> Указанное наименование Листа согласования не существует. '
									end
							when @ConstName IN ('RIK_CategoryName_KAZ_ACCRUAL')
								then
									case @isErrLS 
										when 0 then '<font color=red>ОШИБКА!</font> Выбрано недопустимое для указанного исх. ЦФО наименование Листа согласования. '
										else '<font color=red>ОШИБКА!</font> Указанное наименование Листа согласования не существует. '
									end
							else	
								case @isErrLS 
									when 0 then '<font color=red>ОШИБКА!</font> Выбрано недопустимое для данного вида деят-ти и/или категории наименование Листа согласования. '
									else '<font color=red>ОШИБКА!</font> Указанное наименование Листа согласования не существует. '
								end
						end

			--select @Result = @@error if @Result <> 0 goto Err		

			--************************************
			If @SQLStatement <> '' goto OK --если есть ошибки при проверки листа на данном этапе. остальные ошибки нас не интересуют - сразу "выходим отсюда"
			--************************************
		end
	end

	--"переводим" справчоный ЛС в таблицу
	if len(@BLS)>0
	begin
		insert into @Tbl_BLS (Val,Pos,Flag)
		exec dbo.PDX_ArrayToTable
			@Separator1 ='<',
			@Separator2 ='>',
			@Value = @BLS
		--select @Result = @@error if @Result <> 0 goto Err
	end

	select @PosMax = null, @PosMin = null
	--select @Result = @@error if @Result <> 0 goto Err

	--вычисляем номера первой и последней позиций
	select @PosMax = max(Pos), @PosMin = min(Pos)
	from @Tbl_BLS	
	--select @Result = @@error if @Result <> 0 goto Err
	
	if @PosMax is null 
	begin
		select @PosMax = @LastPos
	end
	if @PosMin is null 
	begin
		select @PosMin = 1
	end

/*
	If @PosMin <> 1  --такая "бессмысленная" проверка, на всякий случай
	begin
		select 
			@SQLStatement = @SQLStatement + 
			case len(@SQLStatement) when 0 then '' else '<BR>' end + 
			'<font color=red>ОШИБКА!</font> Тип ошибки - №1. Обратитесь к Администратору СЭД. '
		select @Result = @@error if @Result <> 0 goto Err

		--************************************
		If @SQLStatement <> '' goto OK --если есть ошибки при проверки листа на данном этапе. остальные ошибки нас не интересуют - сразу "выходим отсюда"
		--************************************
	end*/


	--проверяем на последнего согласующего. если он еще не в списке добавляем, на @LastPos позицию
--	If not exists (select 1 from @TblRec R 
--					inner join (select Val from @Tbl_BLS where Pos = @PosMax) X on X.Val = R.UserID)
	--обработка последнего согласующего
	--если БЛС без "порядка", то если находим нужного пользователя, то помечаем его последним
--ПРОВЕРК НА ПОСЛЕДНЕГО СОГЛАСУЮЩЕГО В НАЧАЛЕ, ТАК КАК "ПЕРВЫЙ" МОЖЕТ "подпортить" НУМЕРАЦИЮ
	if @isOrdered = 0 and exists (select 1 from @TblRec R 
									inner join @Tbl_BLS B on B.Val = R.UserID 
									where R.RLPos = 0)
	begin
		select 
			@Pos_bls = Pos
		from @TblRec R 
		inner join @Tbl_BLS B on B.Val = R.UserID 
		where R.RLPos = 0
		--select @Result = @@error if @Result <> 0 goto Err
		
		update @Tbl_BLS
			set Pos = case 
						when Pos = @Pos_bls	then @LastPos
						when Pos > @Pos_bls then Pos - 1
						else Pos
					  end
		--select @Result = @@error if @Result <> 0 goto Err

	end--есси нужного пользователя нет на последней позиции, добавляем
	else If not exists (select 1 from @TblRec R 
						inner join @Tbl_BLS B on B.Val = R.UserID and B.Pos = @PosMax
						where R.RLPos = 0)
	begin
		insert into @Tbl_BLS (Val,Pos,Flag)
		select top 1
			UserID, @LastPos, 1--'это всегда будет @PosMax-я параллель 
		from @TblRec where RLPos = 0
		--select @Result = @@error if @Result <> 0 goto Err
	end
	else--если он есть, упомечаем его номером позиции=@LastPos
	begin
		update T set Pos = @LastPos
		from @Tbl_BLS T
		inner join @TblRec R on R.UserID = T.Val and R.RLPos = 0
		where T.Pos = @PosMax

		--select @Result = @@error if @Result <> 0 goto Err
	end
	--select @Result = @@error if @Result <> 0 goto Err

	select @PosMax = @LastPos
	--select @Result = @@error if @Result <> 0 goto Err

	--проверяем на первого согласующего. 
	--если он есть в списке с "неважным" порядком, и он еще не первый, изменяем его позицию на первую
	If @isOrdered = 0 and exists (select 1 from @TblRec R 
					inner join @Tbl_BLS X on X.Val = R.UserID and X.Pos <> 1
					where R.RLPos = 1)
	begin
		select @Pos_bls = X.Pos
		from @TblRec R 
		inner join @Tbl_BLS X on X.Val = R.UserID
		where R.RLPos = 1
		--select @Result = @@error if @Result <> 0 goto Err

		update @Tbl_BLS
			set Pos = case 
						when Pos = @Pos_bls	then 1
						when Pos < @Pos_bls and Pos <> @LastPos then Pos + 1
						else Pos
					  end
		--select @Result = @@error if @Result <> 0 goto Err
		
	end--если он еще не в списке на первой позиции, то добавляем, сдвигая существующие позиции
	else If not exists (select 1 from @TblRec R 
					inner join @Tbl_BLS X on X.Val = R.UserID and X.Pos = @PosMin
					where R.RLPos = 1)
	begin
		update @Tbl_BLS set Pos = Pos + 1
		where Pos <> @LastPos -- сдвигаем позициию ТАК КАК 1-я позиция всегда "забронирована"
		--select @Result = @@error if @Result <> 0 goto Err

		insert into @Tbl_BLS (Val,Pos,Flag)
		select top 1
			UserID, @PosMin, 0--'это всегда будет @PosMin-я параллель 
		from @TblRec where RLPos = 1
		--select @Result = @@error if @Result <> 0 goto Err
	end
	--select @Result = @@error if @Result <> 0 goto Err

	--первый и последний согласующий - строго по одному
	if (select count(distinct Val) from @Tbl_BLS R where R.Pos = @PosMin) > 1
	begin
		select @SQLStatement = @SQLStatement + 
					case len(@SQLStatement) when 0 then '' else '<BR>' end + 
					'<font color=red>ОШИБКА!</font> Ошибка при определении первого согласующего по документу(3). Для исправления ошибки обратитесь к Администратору СЭД.'
		--select @Result = @@error if @Result <> 0 goto Err	
		--************************************
		If @SQLStatement <> '' goto OK --если есть ошибки при проверки листа на данном этапе. остальные ошибки нас не интересуют - сразу "выходим отсюда"
		--************************************
	end
	if (select count(distinct Val) from @Tbl_BLS R where R.Pos = @PosMax) > 1
	begin
		select @SQLStatement = @SQLStatement + 
					case len(@SQLStatement) when 0 then '' else '<BR>' end + 
					'<font color=red>ОШИБКА!</font> Ошибка при определении последнего согласующего по документу(4). Для исправления ошибки обратитесь к Администратору СЭД.'
		--select @Result = @@error if @Result <> 0 goto Err		
		--************************************
		If @SQLStatement <> '' goto OK --если есть ошибки при проверки листа на данном этапе. остальные ошибки нас не интересуют - сразу "выходим отсюда"
		--************************************
	end

	--добавляем ЛЮБЫХ согласующих
	while exists(select 1 from @TblRec where RLPos = 2)
	begin
		select top 1
			@KeyFld = KeyFld, @UserID = UserID
		from @TblRec where RLPos = 2
		--select @Result = @@error if @Result <> 0 goto Err
		
		--только , если они еще не встречаются в ЛС
		if not exists (select 1 from @Tbl_BLS where Val = @UserID)
		begin
			insert into @Tbl_BLS (Val,Pos,Flag)
			values (@UserID, null, 0) --'это всегда будет null-я параллель 
			--select @Result = @@error if @Result <> 0 goto Err
		end
		--select @Result = @@error if @Result <> 0 goto Err
		
		update @TblRec set RLPos = -100 where KeyFld = @KeyFld
		--select @Result = @@error if @Result <> 0 goto Err
	end

	--не может быть задвоеных юзеров
	if exists(select count(*) from @Tbl_BLS R group by Val having count(*) > 1)
	begin
		select @SQLStatement = @SQLStatement + 
					case len(@SQLStatement) when 0 then '' else '<BR>' end + 
					'<font color=red>ОШИБКА!</font> Ошибка в определении справочного ЛС. Задвоение ползователей.(5). Для исправления ошибки обратитесь к Администратору СЭД.'
		--select @Result = @@error if @Result <> 0 goto Err		
	end

	--ВЫЯСНЕЯМ есть ли среди логинов системные
	update B
		set isSystem = 1,
			ErrMessage = cast(Addinfo as varchar(255))
	from @Tbl_BLS B
	inner join dbo.Users U on U.UserID = B.Val and U.Comment like '%$RLsyslogin$%'
	--select @Result = @@error if @Result <> 0 goto Err		
--select 3,* from @Tbl_BLS

	--РАЗБИРАЕМ ДЕЛЕГИРОВАНИЕ
	update @Tbl_BLS set ToUserID = Val
	--select @Result = @@error if @Result <> 0 goto Err

	select @ErrCnt = 50 --так как в ПД есть проблема с установкой соответсвия м-ду версией ЛС и делегированием, то нужно "тупая защита"
	--полагаем, что в одном документе больше 50 делегирований никогда не будет
	--обрабатываем делегирование
	while exists (select 1 from @Tbl_BLS T inner join @TblDelegate D on T.ToUserID = D.UserID and D.DT > T.DelegateDate)
		and @ErrCnt > 0
	begin
--select @ErrCnt
		-- ищем от первого комментария о делегировании по каждому пользователю
		update B
			set ToUserID = X.ToUserID,
				DelegateDate = X.DT
		from @Tbl_BLS B
		inner join (
			select M.* from @TblDelegate M 
				inner join (
				select D.UserID, min(D.DT) as DT
				from @TblDelegate D 
				inner join @Tbl_BLS L on L.ToUserID = D.UserID  and D.DT > L.DelegateDate
				group by D.UserID
							) Y on Y.UserID = M.UserID and Y.DT = M.DT
					) X on X.UserID = B.ToUserID and X.DT > B.DelegateDate
		--select @Result = @@error if @Result <> 0 goto Err

		select @ErrCnt = @ErrCnt - 1
		--select @Result = @@error if @Result <> 0 goto Err
	end 
	--select @Result = @@error if @Result <> 0 goto Err

	select @UserID = ''
	--select @Result = @@error if @Result <> 0 goto Err
--select * from @Tbl_BLS
	--ПОЛУЧАЕМ ТЕКУЩИЙ ЛС в таблицу
	--если ЛС  не пустой, обрабатываем  его
	if len(@RList)>0
	begin
		insert into @Tbl_LS (Val,Pos,Flag)
		exec dbo.PDX_ArrayToTable
			@Separator1 ='<',
			@Separator2 ='>',
			@Value = @RList
		--select @Result = @@error if @Result <> 0 goto Err
--select * from @Tbl_LS
		--не может быть задвоеных юзеров
		if exists(select count(*) from @Tbl_LS R group by Val having count(*) > 1)
		begin
			select @SQLStatement = @SQLStatement + 
						case len(@SQLStatement) when 0 then '' else '<BR>' end + 
						'<font color=red>ОШИБКА!</font> Любой пользователь в листе согласования может быть указан только один раз.'
			--select @Result = @@error if @Result <> 0 goto Err		
		end
	end
	--ДАЛЬШЕ НАЧИНАЮТСЯ проверки, но они все нужны, если базовый лист оказался непустой
	If exists (select 1 from @Tbl_BLS)
	begin
		--если нет обязательного первого согласующего, сдвигаем позицию на 1
		If not exists (select 1 from @Tbl_BLS where Pos = @PosMin)
		begin
			update @Tbl_LS
				set Pos = Pos + 1
			--select @Result = @@error if @Result <> 0 goto Err
		end
		--select @Result = @@error if @Result <> 0 goto Err

		--если есть обязательный последний согласующий. То помечаем его номером, последнего согласующего из ЛС карточки
		If exists (select 1 from @Tbl_BLS where Pos = @PosMax)
		begin
			update @Tbl_LS
				set Pos = @PosMax
			where Pos = (select max(Pos) from @Tbl_LS)
			--select @Result = @@error if @Result <> 0 goto Err
		end
		--select @Result = @@error if @Result <> 0 goto Err

		--первый и последний согласующий - строго по одному
		if (select count(distinct Val) from @Tbl_LS R where R.Pos = @PosMin) > 1
		begin
			select @UserName = ''
			select --получаем имя пользователя для формирования сообщения об ошибке
				@UserName = U.Name + case B.Val when B.ToUserID then '' else ' (или ' + U1.Name + ')' end
			from @Tbl_BLS B
			inner join dbo.Users U on B.Val = U.UserID 
			inner join dbo.Users U1 on B.ToUserID = U1.UserID
			where B.Pos = @PosMin
			--select @Result = @@error if @Result <> 0 goto Err

			select @SQLStatement = @SQLStatement + 
						case len(@SQLStatement) when 0 then '' else '<BR>' end + 
						'<font color=red>ОШИБКА!</font> В первой строке листа согласования может быть указан только один пользователь' + 
						case @UserName when '' then '.' else ' - ' + @UserName + '.' end
			--select @Result = @@error if @Result <> 0 goto Err		
		end
		if (select count(distinct Val) from @Tbl_LS R where R.Pos = @PosMax) > 1
		begin
			select @UserName = ''
			select --получаем имя пользователя для формирования сообщения об ошибке
				@UserName = U.Name + case B.Val when B.ToUserID then '' else ' (или ' + U1.Name + ')' end
			from @Tbl_BLS B
			inner join dbo.Users U on B.Val = U.UserID 
			inner join dbo.Users U1 on B.ToUserID = U1.UserID
			where B.Pos = @PosMax
			--select @Result = @@error if @Result <> 0 goto Err

			select @SQLStatement = @SQLStatement + 
						case len(@SQLStatement) when 0 then '' else '<BR>' end + 
						'<font color=red>ОШИБКА!</font> В последней строке листа согласования может быть указан только один пользователь' + 
						case @UserName when '' then '.' else ' - ' + @UserName + '.' end
			--select @Result = @@error if @Result <> 0 goto Err		
		end
--*****************************************
--select * from @Tbl_BLS
		select @isErrLS = 0
		--select @Result = @@error if @Result <> 0 goto Err
--select * from @Tbl_BLS
		if (@Type in (1) 
			or (@Type = 4 and @isActive = 'y'))
		BEGIN
			--СРАВНЕНИЕ ЛИСТОВ СОГЛАСОВАНИЯ
			select @OI_prev = @PosMin + 1
			--"отталкиваемся" от справочного ЛС
			while exists (select 1 from @Tbl_BLS )
			begin
				select top 1
					@UserID = Val,
					@UserID2 = ToUserID,
					@KeyFld = KeyFld,
					@Pos_bls = Pos,
					@Flag_bls = Flag,
					@isSystem = isSystem,
					@ErrMessage = ErrMessage,
					@Pos_ls = 0,
					@UserName = ''
				from @Tbl_BLS--сначала обработаем первую и последнюю позиции
				order by case when Pos in (@PosMin, @PosMax) then 0 else 1 end asc, isnull(Pos,@LastPos+1) asc
				--select @Result = @@error if @Result <> 0 goto Err
				
				----для первой и последней позиции
				If @Pos_bls in (@PosMin, @PosMax)
				begin--проверяем наличие первого и последнего в ЛС из карточки, если не находятся, то ошибка
					If not exists (select 1 from @Tbl_LS where Val in (@UserID,@UserID2) and Pos = @Pos_bls)
					begin
						select --получаем имя пользователя для формирования сообщения об ошибке
							@UserName = Name
						from dbo.Users 
						where UserID = @UserID
						--select @Result = @@error if @Result <> 0 goto Err

						select --формируем сообщение
							@SQLStatement = @SQLStatement + case len(@SQLStatement) when 0 then '' else '<BR>' end + 
							case @Pos_bls 
								when @PosMin 
									then '<font color=red>ОШИБКА! </font>Первым согласующим в данном документе должен быть пользователь: '
								when @PosMax
									then '<font color=red>ОШИБКА! </font>Последним согласующим в данном документе должен быть пользователь: '
							end	+ case ltrim(rtrim(isnull(@UserName,''))) when '' then @UserID else @UserName end
						--select @Result = @@error if @Result <> 0 goto Err

					end--If not exists (select 1 from @Tbl_LS where Val in (@UserID,ToUserID) and Pos = @Pos)
				end--If @Pos in (@PosMin, @PosMax)
				else--ДЛЯ ОСТАЛЬНЫХ ПОЗИЦИЙ (кроме первой и последней)
				begin
					select top 1  --ищем в ЛС карточки пользователя выбранного из справочного ЛС, 
						--причем в первую очередь ищем "делегированного", а во вторую исходного пользователя
						--@OI = Pos,
						@Flag_ls = Flag,
						@Pos_ls = Pos
					from @Tbl_LS
					where Val in (@UserID,@UserID2)
					order by case Val when @UserID2 then 0 else 1 end, Pos
					--select @Result = @@error if @Result <> 0 goto Err

					If @Pos_ls = 0 --если пользователя не находим, формируем ошибку
					begin								
						If @isSystem = 0 --если не нашелся системныйй, то вс ОК, а вот если настоящий, то ошибка
						begin	
							set @UserName = ''
							select @UserName = case R.Typ
												when 1 then '<font color=red>ОШИБКА!</font> Для бизнес-единицы [' + R.Val + '] в данной карточке среди согласующих должен быть указан глав.бухгалтер [' + RecName + ']'
												when 2 then '<font color=red>ОШИБКА!</font> Для контрагента [' + R.Val + '] в данной карточке среди согласующих должен быть указан глав.бухгалтер [' + RecName + ']'
												else ''
												end
							from @TblRec R
							where UserID = @UserID
								and RLPos = -100
							
							if @UserName = ''
							begin
								select --получаем имя пользователя для формирования сообщения об ошибке
									@UserName = Name
								from dbo.Users 
								where UserID = @UserID
								--select @Result = @@error if @Result <> 0 goto Err
								
								set @UserName = '<font color=red>ОШИБКА! </font> В листе согласования обязательно должен быть указан пользователь: '
								+ case ltrim(rtrim(isnull(@UserName,''))) when '' then @UserID else @UserName end
							end 
							
							select -- формируем ошибку
								---@SQLStatement = @SQLStatement + case len(@SQLStatement) when 0 then '' else '<BR>' end + 
								--'<font color=red>ОШИБКА! </font> В листе согласования обязательно должен быть указан пользователь: '
								--+ case ltrim(rtrim(isnull(@UserName,''))) when '' then @UserID else @UserName end
								@SQLStatement = @SQLStatement + case len(@SQLStatement) when 0 then '' else '<BR>' end + @UserName
							--select @Result = @@error if @Result <> 0 goto Err
						end
					end
					else
					begin--пользователь нашелся					
						If @isSystem = 1--обработка системного пользователя
						begin
							select --формируем сообщение
									@SQLStatement = @SQLStatement + case len(@SQLStatement) when 0 then '' else '<BR>' end + 
									+ '<font color=red>ОШИБКА! </font>' +
									case ltrim(rtrim(isnull(@ErrMessage,''))) when 'Системный логин -[' + @UserID + '] не может использоваться в Листе согласования. Замените его на реального пользователя.'  then '' else ltrim(rtrim(isnull(@ErrMessage,''))) end
							--select @Result = @@error if @Result <> 0 goto Err
						end
						else If @isOrdered = 0 or @Pos_bls is null-- и нам неважна его позиция в ЛС 
						--это допустимо в 2-х случаях: 1) у нас БЛС или мы уже обрабатываем пользователей позиция, которых не важна
						--они согласно в сортировке в первом цикле будут последними
						begin
							select @OI_prev = @PosMin /*+ 1*/ --запомниаем позицию, с которй будем искать следующего согласующего
							--select @Result = @@error if @Result <> 0 goto Err-- в данном случае всегда ищем со 1-ой
						end
						else
						begin --нам важно его местоположение и послед/параллельность в ЛС
/*select * from @Tbl_BLS
select * from @Tbl_LS
select @Flag_ls, @Pos_ls
select @Flag_bls, @Pos_bls, @UserID*/
							If @Flag_bls < @Flag_ls or --не может быть так, что в БЛС пользователь определен в параллели(0), а карточном ЛС он оказался без паралелли(1)
								@Pos_ls < @OI_prev or --пользователь должен быть в ЛС строго не раньше предыдущего обработанного
								(@Flag_bls > @Flag_ls and @Pos_bls-@OI_Bprev > @Pos_ls-@OI_prev)--это условие проверяет, что пользователи, кот д.бю. указаны последовательно, не оказались указаны параллельно
							begin --Пользователь не соответствует позиции
								if @isErrLS <> 1  --по этому флагу ориентируемся, записали мы эту ошибку уже или нет
								begin--не выходим из цикла при первом ее возникновении, так как хотим показать все ошибки типа "пользователь должне быть в ЛС"
									select 
										@SQLStatement = @SQLStatement + case len(@SQLStatement) when 0 then '' else '<BR>' end + 
										'<font color=red>ОШИБКА! </font> Порядок  согласования документа Согласующими не соответствует выбранному листу согласования'
									--select @Result = @@error if @Result <> 0 goto Err

									select @isErrLS = 1
									--select @Result = @@error if @Result <> 0 goto Err
								end
							end --If @Flag_bls < @Flag_ls or @Pos_ls < @OI_prev

							--запоминаем позицию, не выше которой д.б. след. пользователь
							select @OI_prev = @Pos_ls--@OI 
							--select @Result = @@error if @Result <> 0 goto Err

						end --If @RLName like '(БЛС)%' or @Pos_bls is null
					end--If/Else @Pos_ls = 0
				end --If/Else @Pos_bls in (@PosMin, @PosMax)
NXT:
				--запоминаем позицию, не выше которой д.б. след. пользователь по базовому - придется учитывать, что текущий и предыдущий в ЛС и в БЛС на одной или разных позициях
				select @OI_Bprev = @Pos_Bls
				--select @Result = @@error if @Result <> 0 goto Err

				delete @Tbl_BLS where KeyFld = @KeyFld
				--select @Result = @@error if @Result <> 0 goto Err
			end--while exists (select 1 from @Tbl_BLS where Flg = 0)
		END

--*****************************************
	end--if len(@RList)>0

	
OK:
	if @SQLStatement <> ''  select @SQLStatement = @SQLStatement
	--select @Result = @@error if @Result <> 0 goto Err
	select @FromRecL = @SQLStatement
	--select @Result = @@error if @Result <> 0 goto Err
	
	if @ReturnSelect = 1 select @SQLStatement as err
	--select @Result = @@error if @Result <> 0 goto Err

	--return @Result
--Err:
	
	--return @Result































GO
/****** Object:  StoredProcedure [dbo].[PDX_ReconcilationListRules2] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE proc [dbo].[PDX_ReconcilationListRules2]
	@DocID varchar(250),
	@Type int,
	
	@isActive char(1) = null, --состояние активности, в кот. документ будет после действия (если null - то ориентируемся по тому, какое у него состояние сейчас)
	@ClassDoc varchar(64),
	@ActDoc varchar(64) = null,
	@UFT2 varchar(1024) = null,
	@NameAproval varchar(96),

	@RList varchar(4096) = null,--ЛС
	@RLName varchar(255) = null, --наименование ЛС,
	@Parametr1 varchar(512)=null,
	@Parametr2 varchar(512)=null,
	@Parametr3 varchar(512)=null,

	@ReturnSelect bit = 1,
	@FromRecL varchar(8000) = '' out
as
	-- 0 - OnCre 
	-- 1 - OnAct 
	-- 2 - OnApr
	-- 3 - OnReg
	-- 4 - SAVE

	declare @Result int
	set @Result = 0
	
	declare @TblRec table (RecName varchar(96), UserID varchar(32), RLPos int, Val varchar(1024), Typ tinyint, KeyFld int identity, Flg bit default 0)
	declare @TblDelegate table (DT datetime,UserID varchar(32), ToUserID varchar(32), blnType bit default 0, KeyField int identity) --1 - делегирование, 0 - добавление
	declare @Tbl_BLS table (Val varchar(64), Pos int, Flag bit, ToUserID varchar(64), DelegateDate datetime default '1900-01-01', isSystem bit default 0, ErrMessage varchar(255), KeyFld int identity)
	declare @Tbl_LS table (Val varchar(64), Pos int, Flag bit, Flg bit default 0)

	declare @isActive2 char(1), --состояние Активен
			@SQLStatement varchar(8000),
			@ConstName varchar(255),--название категории документа
			@BLS varchar(4096), --базовый ЛС
			@DocDate datetime,
			@isErrLS int,
			@ClassGr varchar(64),
			@ErrCnt int,
			@KeyFld int,
			@KeyWord varchar(64),

			@UserID varchar(64),
			@UserID2 varchar(64),
			@UserName varchar(1024),
			
			@PosMax int, 
			@PosMin int,
			
			@OI_Bprev int,
			@OI_prev int,
			--@OI int,
			
			@Pos_bls int,
			@Pos_ls int,
			
			@Flag_bls bit,
			@Flag_ls bit,
		
			@isOrdered bit,
			@isSystem bit,
			@ErrMessage varchar(255),
			@LastPos int,
			@Dept varchar(1024)


	--этот счетчик от зацикливания. в связи с тем, что инф-я о версиях ЛС и делегировании/добавлении хранится 
	--без строго соответствия друг другу. приходится вставлять "тупую" защиту от делегирования 
	select 
		@SQLStatement = '',
		@isOrdered = 0,
		@LastPos = 10000
	select @Result = @@error if @Result <> 0 goto Err

--т.е. если @isActive передан, то это кто-то модифицирует документ с правами супервайзера, 
--а значит новый статус документа нужно брать с клиента, а не из БД
	select 
		@isActive = case when @isActive is null 
							then lower(IsActive) 
			 			 else 
							case @isActive 
								when 0 
									then '' 
								else 'y' 
							end 
					     end,
		@isActive2 = lower(IsActive),
		--@NameCreation = NameCreation + case right(rtrim(NameCreation),1) when ';' then '' else ';' end,
		@RList = case when @RList is  null
					then ListToReconcile
					else @RList
				end,
		@RLName = case when @RLName is null
					then 
						case when ClassDoc in (
										dbo.PDX_CLSGet('RIK_CategoryName_ISHO_VNESH'),
										dbo.PDX_CLSGet('RIK_CategoryName_ISHO_VNUTR'))
							then UserFieldText3
							else UserFieldText1
						end
					else @RLName
				  end,
		@ActDoc = case when @ActDoc is null 
						then ActDoc
					else @ActDoc 
					end,
		--@DocDate = convert(datetime, convert(varchar(50),isnull(DateCreation,getdate()),104),104),
		@DocDate = convert(datetime, convert(varchar(50),getdate(),104),104),
		@NameAproval = case when isnull(@NameAproval,'') = ''
					then NameAproval
					else @NameAproval
				end,
		@ClassDoc = case isnull(@ClassDoc,'') when '' then ClassDoc else @ClassDoc end,
		@Dept = ISNULL(Department,''),
		@UFT2 = case when @UFT2 is null and ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_OTHERS_NSI')
						then UserFieldText2
					when @UFT2 is null and ClassDoc IN (dbo.PDX_CLSGet('RIK_CategoryName_KAZ_PLNPAY'),
														dbo.PDX_CLSGet('RIK_CategoryName_KAZ_ORDPAY'))
						then UserFieldText2
					when @UFT2 is null and ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_CORPAY')
						then UserFieldText2
					else @UFT2 
					end
	from dbo.Docs with (nolock)
	where DocID = @DocID
	select @Result = @@error if @Result <> 0 goto Err

	--название группы категории (если группа не выделяется, будет = самой категории)
	select @ClassGr = case when @ClassDoc like '%/%' 
						then substring(@ClassDoc, 1, charindex('/',@ClassDoc))
						else @ClassDoc
					  end,
			@NameAproval = case when @NameAproval like '%<%>%'
								then '<'+dbo.PDX_SubstringReturn(@NameAproval, charindex('<',@NameAproval), charindex('>',@NameAproval))+'>'
								else ''	
							end
	select @Result = @@error if @Result <> 0 goto Err

	--проверка и обработка ЛС
	exec @Result = dbo.PDX_ReconcilationListContent
		@ListToReconcile = @RList out,
		@ErrorStr = @SQLStatement out
	if @Result <> 0 goto Err

	--************************************
	If @SQLStatement <> '' goto OK --если есть ошибки при проверки листа на данном этапе. остальные ошибки нас не интересуют - сразу "выходим отсюда"
	--************************************
--select @ClassDoc,@ClassGr,@ActDoc,@NameAproval,@DocDate
	--получаем обязательных согласующих
	insert into @TblRec (RecName, UserID, RLPos, Val,Typ)
	exec [dbo].[PDX_CheckLTRByAccounter]
		@DocID = @DocID
		
	insert into @TblRec (RecName, UserID, RLPos)
	select distinct
		UserName,
		 case when UserName like '%<%>%'
			then dbo.PDX_SubstringReturn(UserName, charindex('<',UserName), charindex('>',UserName))
			else ''	
		 end, 
		 RLPos
	from dbo.PDXReconcilationRules
	where ClassDoc in (@ClassDoc,@ClassGr)
		and ActDoc = @ActDoc
		and not NotAppr like '%' + case @NameAproval when '' then '+_)(*&^%$#@' else @NameAproval end + '%'	
		--чтобы условие работало, когда нет утверждающего, подставляем заведомо невозможное значение 
		and @DocDate between DateFrom and DateTo
		and (Dept is null or @Dept like Dept + '%')	
	select @Result = @@error if @Result <> 0 goto Err

--select @NameAproval,* from @TblRec

	--разбираем Ext Значения в циле попорядку
--select * from @TblRec
	while exists(select 1 from @TblRec where ltrim(rtrim(RecName)) like '{%}' and Flg = 0)
	begin --берем одно вычисляемое значение
		select top 1
			@KeyFld = KeyFld,
			@KeyWord = RecName,
			@UserName = ''
		from @TblRec 
		where ltrim(rtrim(RecName)) like '{%}' and Flg = 0 
		select @Result = @@error if @Result <> 0 goto Err

		--вычисляем значения
		select @UserName = dbo.PDX_PDXRecRulesStatmentCreate(@DocID,@KeyWord,@Parametr1,@Parametr2,@Parametr3)
		select @Result = @@error if @Result <> 0 goto Err

		--сохраняем рзультат и параллелеьно говорим, что для этой записи больше вычислять ничего не нужно (Ext2 = '')
		update @TblRec
			set Flg = 1,
			RecName = @UserName,
			UserID = case when @UserName like '%<%>%'
						then dbo.PDX_SubstringReturn(@UserName, charindex('<',@UserName), charindex('>',@UserName))
						else ''	
					end
		where KeyFld = @KeyFld
		select @Result = @@error if @Result <> 0 goto Err
	end
--select * from @TblRec
	--если есть "пустоты" удаляем
	delete from @TblRec where ltrim(rtrim(isnull(UserID,''))) = ''
	select @Result = @@error if @Result <> 0 goto Err
--select * from @TblRec
	--первый и последний согласующий - строго по одному
	if (select count(distinct UserID) from @TblRec R where R.RLPos = 1) > 1
	begin
		select @SQLStatement = @SQLStatement + 
					case len(@SQLStatement) when 0 then '' else '<BR>' end + 
					'<font color=red>ОШИБКА!</font> Ошибка при определении первого согласующего по документу(1). Для исправления ошибки обратитесь к Администратору СЭД.'
		select @Result = @@error if @Result <> 0 goto Err		
	end
	if (select count(distinct UserID) from @TblRec R where R.RLPos = 0) > 1
	begin
		select @SQLStatement = @SQLStatement + 
					case len(@SQLStatement) when 0 then '' else '<BR>' end + 
					'<font color=red>ОШИБКА!</font> Ошибка при определении последнего согласующего по документу(2). Для исправления ошибки обратитесь к Администратору СЭД.'
		select @Result = @@error if @Result <> 0 goto Err		
	end

	--************************************
	If @SQLStatement <> '' goto OK --если есть ошибки при проверки листа на данном этапе. остальные ошибки нас не интересуют - сразу "выходим отсюда"
	--************************************
--select 1,* from @TblRec
	--получаем инфу о делегировании/добавлении
	insert into @TblDelegate(UserID, ToUserID, blnType, DT)
	select 
		UserID, 
		dbo.PDX_SubstringReturn(Comment,charindex('<',Comment),charindex('>',Comment)), 
		case upper(isnull(SpecialInfo,'')) when 'DELEGATE' then 1 else 0 end,
		DateCreation
	from dbo.Comments
	where DocID = @DocID
		and upper(CommentType) = 'VISA'
		and upper(isnull(SpecialInfo,'')) = 'DELEGATE'
	select @Result = @@error if @Result <> 0 goto Err
--select 2,* from @TblDelegate
	--если так и не удалось определить статус Активности, считаем, что документ неактивен
	select @isActive = case when @isActive is null then '' else @isActive end
	select @Result = @@error if @Result <> 0 goto Err

	select --привязывемся не к назв. к категории, а к константе
		@ConstName = ConstName
	from dbo.PDXDocTypesConst with (nolock)
	where DocType = @ClassDoc
	select @Result = @@error if @Result <> 0 goto Err

	--перечисляем категории, где есть наименование ЛС, в остальных его нет
	If not @ConstName in ('RIK_CategoryName_DOGOVORY_B',
						'RIK_CategoryName_DOGOVORY_C',
						'RIK_CategoryName_DOGOVORY_E',
						'RIK_CategoryName_DOGOVORY_F',							
						'RIK_CategoryName_DOGOVORY_H',
						'RIK_CategoryName_DOGOVORY_P',
						'RIK_CategoryName_DOGOVORY_R',
						'RIK_CategoryName_DOGOVORY_S',
						'RIK_CategoryName_DOGOVORY_T',
						'RIK_CategoryName_DOGOVORY_X',
						'RIK_CategoryName_DOGOVORY_Y',
						'RIK_CategoryName_DOGOVORY_Z',
						'RIK_CategoryName_DOGOVORY_L',
						'RIK_CategoryName_DOGOVORY_M',
						'RIK_CategoryName_ATTORNEYID',
						'RIK_CategoryName_FIN_ORDPAY',
						'RIK_CategoryName_OTHERS_DOG',
						'RIK_CategoryName_OTHERS_TRP',
						'RIK_CategoryName_CLEARING_C',
						'RIK_CategoryName_KAZ_PLNPAY',
						'RIK_CategoryName_KAZ_ORDPAY',
						'RIK_CategoryName_KAZ_CORPAY',
						'RIK_CategoryName_ISHO_VNESH',
						'RIK_CategoryName_ISHO_VNUTR',
						'RIK_CategoryName_ORDER_CONT',
						'RIK_CategoryName_OTHERS_NSI',
						'RIK_CategoryName_OTHERS_ISR',
						'RIK_CategoryName_OTHERS_MOB',
						'RIK_CategoryName_OTHERS_DGC',
						'RIK_CategoryName_OTHERS_N_Z')
	begin
		select @RLName = ''
		select @Result = @@error if @Result <> 0 goto Err
	end

	select @RLName = ltrim(rtrim(isnull(@RLName,'')))
	select @Result = @@error if @Result <> 0 goto Err

	If @RLName <> ''
	begin
		select @isErrLS = -1
		select @Result = @@error if @Result <> 0 goto Err
--select @UFT2, @ConstName, @RLName
		select  --получаем ЛС из справочника, который соответствуен указанному наименованию
			@BLS = replace(ltrim(rtrim(isnull(Field2,''))), @NameAproval, ''),
			@isErrLS = case  
						when @ConstName = 'RIK_CategoryName_OTHERS_NSI'
							then 
								case 
								when (isnull(Field3,'') = '' or isnull(Field3,'') like '%' + @UFT2 + '%')
									and Field1 = @RLName
									then 1
								else 0
							   end
						when @ConstName IN('RIK_CategoryName_KAZ_PLNPAY',
											'RIK_CategoryName_KAZ_ORDPAY',
											'RIK_CategoryName_KAZ_CORPAY')
							then 
								case 
								when (isnull(Field4,'') = '' or char(13)+char(10)+isnull(Field4,'')+char(13)+char(10) like '%' + char(13)+char(10) + @UFT2 + char(13)+char(10) + '%')
									and (isnull(Field3,'') = '' or isnull(Field3,'') like '%' + @ClassDoc + '%')
									and Field1 = @RLName
									then 1
								else 0
							   end	   					
						else
						   case 
							when (isnull(Field4,'') = '' or isnull(Field4,'') like '%' + @ActDoc + '%')
								and (isnull(Field3,'') = '' or isnull(Field3,'') like '%' + @ClassDoc + '%')
								and Field1 = @RLName
								then 1
							else 0
						   end
						end,
			@isOrdered = case ltrim(rtrim(Field5)) when '1' then 1 else 0 end
		from dbo.UserDirValues with (nolock)
		where UDKeyField = case  
								when @ConstName = 'RIK_CategoryName_OTHERS_NSI' 
									then 215 
								when @ConstName IN('RIK_CategoryName_KAZ_PLNPAY',
											'RIK_CategoryName_KAZ_ORDPAY',
											'RIK_CategoryName_KAZ_CORPAY')
									then 219
								else 34 
							end
			and Field1 = @RLName
		select @Result = @@error if @Result <> 0 goto Err

		--ОШИБКА - некорректно выбрано наименование ЛС
		if @isErrLS <= 0
		begin
			select @SQLStatement = @SQLStatement + 
						case len(@SQLStatement) when 0 then '' else '<BR>' end + 
						case  
							when @ConstName = 'RIK_CategoryName_OTHERS_NSI'
								then
									case @isErrLS 
										when 0 then '<font color=red>ОШИБКА!</font> Выбрано недопустимое для данного [Названия справочника] наименование Листа согласования. '
										else '<font color=red>ОШИБКА!</font> Указанное наименование Листа согласования не существует. '
									end
							when @ConstName IN ('RIK_CategoryName_KAZ_PLNPAY',
											'RIK_CategoryName_KAZ_ORDPAY')
								then
									case @isErrLS 
										when 0 then '<font color=red>ОШИБКА!</font> Выбрано недопустимое для указанного ЦФО наименование Листа согласования. '
										else '<font color=red>ОШИБКА!</font> Указанное наименование Листа согласования не существует. '
									end
							when @ConstName IN ('RIK_CategoryName_KAZ_CORPAY')
								then
									case @isErrLS 
										when 0 then '<font color=red>ОШИБКА!</font> Выбрано недопустимое для указанного исх. ЦФО наименование Листа согласования. '
										else '<font color=red>ОШИБКА!</font> Указанное наименование Листа согласования не существует. '
									end
							else	
								case @isErrLS 
									when 0 then '<font color=red>ОШИБКА!</font> Выбрано недопустимое для данного вида деят-ти и/или категории наименование Листа согласования. '
									else '<font color=red>ОШИБКА!</font> Указанное наименование Листа согласования не существует. '
								end
						end

			select @Result = @@error if @Result <> 0 goto Err		

			--************************************
			If @SQLStatement <> '' goto OK --если есть ошибки при проверки листа на данном этапе. остальные ошибки нас не интересуют - сразу "выходим отсюда"
			--************************************
		end
	end

	--"переводим" справчоный ЛС в таблицу
	if len(@BLS)>0
	begin
		insert into @Tbl_BLS (Val,Pos,Flag)
		exec dbo.PDX_ArrayToTable
			@Separator1 ='<',
			@Separator2 ='>',
			@Value = @BLS
		select @Result = @@error if @Result <> 0 goto Err
	end

	select @PosMax = null, @PosMin = null
	select @Result = @@error if @Result <> 0 goto Err

	--вычисляем номера первой и последней позиций
	select @PosMax = max(Pos), @PosMin = min(Pos)
	from @Tbl_BLS	
	select @Result = @@error if @Result <> 0 goto Err
	
	if @PosMax is null 
	begin
		select @PosMax = @LastPos
	end
	if @PosMin is null 
	begin
		select @PosMin = 1
	end

/*
	If @PosMin <> 1  --такая "бессмысленная" проверка, на всякий случай
	begin
		select 
			@SQLStatement = @SQLStatement + 
			case len(@SQLStatement) when 0 then '' else '<BR>' end + 
			'<font color=red>ОШИБКА!</font> Тип ошибки - №1. Обратитесь к Администратору СЭД. '
		select @Result = @@error if @Result <> 0 goto Err

		--************************************
		If @SQLStatement <> '' goto OK --если есть ошибки при проверки листа на данном этапе. остальные ошибки нас не интересуют - сразу "выходим отсюда"
		--************************************
	end*/


	--проверяем на последнего согласующего. если он еще не в списке добавляем, на @LastPos позицию
--	If not exists (select 1 from @TblRec R 
--					inner join (select Val from @Tbl_BLS where Pos = @PosMax) X on X.Val = R.UserID)
	--обработка последнего согласующего
	--если БЛС без "порядка", то если находим нужного пользователя, то помечаем его последним
--ПРОВЕРК НА ПОСЛЕДНЕГО СОГЛАСУЮЩЕГО В НАЧАЛЕ, ТАК КАК "ПЕРВЫЙ" МОЖЕТ "подпортить" НУМЕРАЦИЮ
	if @isOrdered = 0 and exists (select 1 from @TblRec R 
									inner join @Tbl_BLS B on B.Val = R.UserID 
									where R.RLPos = 0)
	begin
		select 
			@Pos_bls = Pos
		from @TblRec R 
		inner join @Tbl_BLS B on B.Val = R.UserID 
		where R.RLPos = 0
		select @Result = @@error if @Result <> 0 goto Err
		
		update @Tbl_BLS
			set Pos = case 
						when Pos = @Pos_bls	then @LastPos
						when Pos > @Pos_bls then Pos - 1
						else Pos
					  end
		select @Result = @@error if @Result <> 0 goto Err

	end--есси нужного пользователя нет на последней позиции, добавляем
	else If not exists (select 1 from @TblRec R 
						inner join @Tbl_BLS B on B.Val = R.UserID and B.Pos = @PosMax
						where R.RLPos = 0)
	begin
		insert into @Tbl_BLS (Val,Pos,Flag)
		select top 1
			UserID, @LastPos, 1--'это всегда будет @PosMax-я параллель 
		from @TblRec where RLPos = 0
		select @Result = @@error if @Result <> 0 goto Err
	end
	else--если он есть, упомечаем его номером позиции=@LastPos
	begin
		update T set Pos = @LastPos
		from @Tbl_BLS T
		inner join @TblRec R on R.UserID = T.Val and R.RLPos = 0
		where T.Pos = @PosMax

		select @Result = @@error if @Result <> 0 goto Err
	end
	select @Result = @@error if @Result <> 0 goto Err

	select @PosMax = @LastPos
	select @Result = @@error if @Result <> 0 goto Err

	--проверяем на первого согласующего. 
	--если он есть в списке с "неважным" порядком, и он еще не первый, изменяем его позицию на первую
	If @isOrdered = 0 and exists (select 1 from @TblRec R 
					inner join @Tbl_BLS X on X.Val = R.UserID and X.Pos <> 1
					where R.RLPos = 1)
	begin
		select @Pos_bls = X.Pos
		from @TblRec R 
		inner join @Tbl_BLS X on X.Val = R.UserID
		where R.RLPos = 1
		select @Result = @@error if @Result <> 0 goto Err

		update @Tbl_BLS
			set Pos = case 
						when Pos = @Pos_bls	then 1
						when Pos < @Pos_bls and Pos <> @LastPos then Pos + 1
						else Pos
					  end
		select @Result = @@error if @Result <> 0 goto Err
		
	end--если он еще не в списке на первой позиции, то добавляем, сдвигая существующие позиции
	else If not exists (select 1 from @TblRec R 
					inner join @Tbl_BLS X on X.Val = R.UserID and X.Pos = @PosMin
					where R.RLPos = 1)
	begin
		update @Tbl_BLS set Pos = Pos + 1
		where Pos <> @LastPos -- сдвигаем позициию ТАК КАК 1-я позиция всегда "забронирована"
		select @Result = @@error if @Result <> 0 goto Err

		insert into @Tbl_BLS (Val,Pos,Flag)
		select top 1
			UserID, @PosMin, 0--'это всегда будет @PosMin-я параллель 
		from @TblRec where RLPos = 1
		select @Result = @@error if @Result <> 0 goto Err
	end
	select @Result = @@error if @Result <> 0 goto Err

	--первый и последний согласующий - строго по одному
	if (select count(distinct Val) from @Tbl_BLS R where R.Pos = @PosMin) > 1
	begin
		select @SQLStatement = @SQLStatement + 
					case len(@SQLStatement) when 0 then '' else '<BR>' end + 
					'<font color=red>ОШИБКА!</font> Ошибка при определении первого согласующего по документу(3). Для исправления ошибки обратитесь к Администратору СЭД.'
		select @Result = @@error if @Result <> 0 goto Err	
		--************************************
		If @SQLStatement <> '' goto OK --если есть ошибки при проверки листа на данном этапе. остальные ошибки нас не интересуют - сразу "выходим отсюда"
		--************************************
	end
	if (select count(distinct Val) from @Tbl_BLS R where R.Pos = @PosMax) > 1
	begin
		select @SQLStatement = @SQLStatement + 
					case len(@SQLStatement) when 0 then '' else '<BR>' end + 
					'<font color=red>ОШИБКА!</font> Ошибка при определении последнего согласующего по документу(4). Для исправления ошибки обратитесь к Администратору СЭД.'
		select @Result = @@error if @Result <> 0 goto Err		
		--************************************
		If @SQLStatement <> '' goto OK --если есть ошибки при проверки листа на данном этапе. остальные ошибки нас не интересуют - сразу "выходим отсюда"
		--************************************
	end

	--добавляем ЛЮБЫХ согласующих
	while exists(select 1 from @TblRec where RLPos = 2)
	begin
		select top 1
			@KeyFld = KeyFld, @UserID = UserID
		from @TblRec where RLPos = 2
		select @Result = @@error if @Result <> 0 goto Err
		
		--только , если они еще не встречаются в ЛС
		if not exists (select 1 from @Tbl_BLS where Val = @UserID)
		begin
			insert into @Tbl_BLS (Val,Pos,Flag)
			values (@UserID, null, 0) --'это всегда будет null-я параллель 
			select @Result = @@error if @Result <> 0 goto Err
		end
		select @Result = @@error if @Result <> 0 goto Err
		
		update @TblRec set RLPos = -100 where KeyFld = @KeyFld
		select @Result = @@error if @Result <> 0 goto Err
	end

	--не может быть задвоеных юзеров
	if exists(select count(*) from @Tbl_BLS R group by Val having count(*) > 1)
	begin
		select @SQLStatement = @SQLStatement + 
					case len(@SQLStatement) when 0 then '' else '<BR>' end + 
					'<font color=red>ОШИБКА!</font> Ошибка в определении справочного ЛС. Задвоение ползователей.(5). Для исправления ошибки обратитесь к Администратору СЭД.'
		select @Result = @@error if @Result <> 0 goto Err		
	end

	--ВЫЯСНЕЯМ есть ли среди логинов системные
	update B
		set isSystem = 1,
			ErrMessage = cast(Addinfo as varchar(255))
	from @Tbl_BLS B
	inner join dbo.Users U on U.UserID = B.Val and U.Comment like '%$RLsyslogin$%'
	select @Result = @@error if @Result <> 0 goto Err		
--select 3,* from @Tbl_BLS

	--РАЗБИРАЕМ ДЕЛЕГИРОВАНИЕ
	update @Tbl_BLS set ToUserID = Val
	select @Result = @@error if @Result <> 0 goto Err

	select @ErrCnt = 50 --так как в ПД есть проблема с установкой соответсвия м-ду версией ЛС и делегированием, то нужно "тупая защита"
	--полагаем, что в одном документе больше 50 делегирований никогда не будет
	--обрабатываем делегирование
	while exists (select 1 from @Tbl_BLS T inner join @TblDelegate D on T.ToUserID = D.UserID and D.DT > T.DelegateDate)
		and @ErrCnt > 0
	begin
--select @ErrCnt
		-- ищем от первого комментария о делегировании по каждому пользователю
		update B
			set ToUserID = X.ToUserID,
				DelegateDate = X.DT
		from @Tbl_BLS B
		inner join (
			select M.* from @TblDelegate M 
				inner join (
				select D.UserID, min(D.DT) as DT
				from @TblDelegate D 
				inner join @Tbl_BLS L on L.ToUserID = D.UserID  and D.DT > L.DelegateDate
				group by D.UserID
							) Y on Y.UserID = M.UserID and Y.DT = M.DT
					) X on X.UserID = B.ToUserID and X.DT > B.DelegateDate
		select @Result = @@error if @Result <> 0 goto Err

		select @ErrCnt = @ErrCnt - 1
		select @Result = @@error if @Result <> 0 goto Err
	end 
	select @Result = @@error if @Result <> 0 goto Err

	select @UserID = ''
	select @Result = @@error if @Result <> 0 goto Err
--select * from @Tbl_BLS
	--ПОЛУЧАЕМ ТЕКУЩИЙ ЛС в таблицу
	--если ЛС  не пустой, обрабатываем  его
	if len(@RList)>0
	begin
		insert into @Tbl_LS (Val,Pos,Flag)
		exec dbo.PDX_ArrayToTable
			@Separator1 ='<',
			@Separator2 ='>',
			@Value = @RList
		select @Result = @@error if @Result <> 0 goto Err
--select * from @Tbl_LS
		--не может быть задвоеных юзеров
		if exists(select count(*) from @Tbl_LS R group by Val having count(*) > 1)
		begin
			select @SQLStatement = @SQLStatement + 
						case len(@SQLStatement) when 0 then '' else '<BR>' end + 
						'<font color=red>ОШИБКА!</font> Любой пользователь в листе согласования может быть указан только один раз.'
			select @Result = @@error if @Result <> 0 goto Err		
		end
	end
	--ДАЛЬШЕ НАЧИНАЮТСЯ проверки, но они все нужны, если базовый лист оказался непустой
	If exists (select 1 from @Tbl_BLS)
	begin
		--если нет обязательного первого согласующего, сдвигаем позицию на 1
		If not exists (select 1 from @Tbl_BLS where Pos = @PosMin)
		begin
			update @Tbl_LS
				set Pos = Pos + 1
			select @Result = @@error if @Result <> 0 goto Err
		end
		select @Result = @@error if @Result <> 0 goto Err

		--если есть обязательный последний согласующий. То помечаем его номером, последнего согласующего из ЛС карточки
		If exists (select 1 from @Tbl_BLS where Pos = @PosMax)
		begin
			update @Tbl_LS
				set Pos = @PosMax
			where Pos = (select max(Pos) from @Tbl_LS)
			select @Result = @@error if @Result <> 0 goto Err
		end
		select @Result = @@error if @Result <> 0 goto Err

		--первый и последний согласующий - строго по одному
		if (select count(distinct Val) from @Tbl_LS R where R.Pos = @PosMin) > 1
		begin
			select @UserName = ''
			select --получаем имя пользователя для формирования сообщения об ошибке
				@UserName = U.Name + case B.Val when B.ToUserID then '' else ' (или ' + U1.Name + ')' end
			from @Tbl_BLS B
			inner join dbo.Users U on B.Val = U.UserID 
			inner join dbo.Users U1 on B.ToUserID = U1.UserID
			where B.Pos = @PosMin
			select @Result = @@error if @Result <> 0 goto Err

			select @SQLStatement = @SQLStatement + 
						case len(@SQLStatement) when 0 then '' else '<BR>' end + 
						'<font color=red>ОШИБКА!</font> В первой строке листа согласования может быть указан только один пользователь' + 
						case @UserName when '' then '.' else ' - ' + @UserName + '.' end
			select @Result = @@error if @Result <> 0 goto Err		
		end
		if (select count(distinct Val) from @Tbl_LS R where R.Pos = @PosMax) > 1
		begin
			select @UserName = ''
			select --получаем имя пользователя для формирования сообщения об ошибке
				@UserName = U.Name + case B.Val when B.ToUserID then '' else ' (или ' + U1.Name + ')' end
			from @Tbl_BLS B
			inner join dbo.Users U on B.Val = U.UserID 
			inner join dbo.Users U1 on B.ToUserID = U1.UserID
			where B.Pos = @PosMax
			select @Result = @@error if @Result <> 0 goto Err

			select @SQLStatement = @SQLStatement + 
						case len(@SQLStatement) when 0 then '' else '<BR>' end + 
						'<font color=red>ОШИБКА!</font> В последней строке листа согласования может быть указан только один пользователь' + 
						case @UserName when '' then '.' else ' - ' + @UserName + '.' end
			select @Result = @@error if @Result <> 0 goto Err		
		end
--*****************************************
--select * from @Tbl_BLS
		select @isErrLS = 0
		select @Result = @@error if @Result <> 0 goto Err
--select * from @Tbl_BLS
		if (@Type in (1) 
			or (@Type = 4 and @isActive = 'y'))
		BEGIN
			--СРАВНЕНИЕ ЛИСТОВ СОГЛАСОВАНИЯ
			select @OI_prev = @PosMin + 1
			--"отталкиваемся" от справочного ЛС
			while exists (select 1 from @Tbl_BLS )
			begin
				select top 1
					@UserID = Val,
					@UserID2 = ToUserID,
					@KeyFld = KeyFld,
					@Pos_bls = Pos,
					@Flag_bls = Flag,
					@isSystem = isSystem,
					@ErrMessage = ErrMessage,
					@Pos_ls = 0,
					@UserName = ''
				from @Tbl_BLS--сначала обработаем первую и последнюю позиции
				order by case when Pos in (@PosMin, @PosMax) then 0 else 1 end asc, isnull(Pos,@LastPos+1) asc
				select @Result = @@error if @Result <> 0 goto Err
				
				----для первой и последней позиции
				If @Pos_bls in (@PosMin, @PosMax)
				begin--проверяем наличие первого и последнего в ЛС из карточки, если не находятся, то ошибка
					If not exists (select 1 from @Tbl_LS where Val in (@UserID,@UserID2) and Pos = @Pos_bls)
					begin
						select --получаем имя пользователя для формирования сообщения об ошибке
							@UserName = Name
						from dbo.Users 
						where UserID = @UserID
						select @Result = @@error if @Result <> 0 goto Err

						select --формируем сообщение
							@SQLStatement = @SQLStatement + case len(@SQLStatement) when 0 then '' else '<BR>' end + 
							case @Pos_bls 
								when @PosMin 
									then '<font color=red>ОШИБКА! </font>Первым согласующим в данном документе должен быть пользователь: '
								when @PosMax
									then '<font color=red>ОШИБКА! </font>Последним согласующим в данном документе должен быть пользователь: '
							end	+ case ltrim(rtrim(isnull(@UserName,''))) when '' then @UserID else @UserName end
						select @Result = @@error if @Result <> 0 goto Err

					end--If not exists (select 1 from @Tbl_LS where Val in (@UserID,ToUserID) and Pos = @Pos)
				end--If @Pos in (@PosMin, @PosMax)
				else--ДЛЯ ОСТАЛЬНЫХ ПОЗИЦИЙ (кроме первой и последней)
				begin
					select top 1  --ищем в ЛС карточки пользователя выбранного из справочного ЛС, 
						--причем в первую очередь ищем "делегированного", а во вторую исходного пользователя
						--@OI = Pos,
						@Flag_ls = Flag,
						@Pos_ls = Pos
					from @Tbl_LS
					where Val in (@UserID,@UserID2)
					order by case Val when @UserID2 then 0 else 1 end, Pos
					select @Result = @@error if @Result <> 0 goto Err

					If @Pos_ls = 0 --если пользователя не находим, формируем ошибку
					begin								
						If @isSystem = 0 --если не нашелся системныйй, то вс ОК, а вот если настоящий, то ошибка
						begin	
							set @UserName = ''
							select @UserName = case R.Typ
												when 1 then 'Для бизнес-единицы [' + R.Val + '] в данной карточке среди согласующих должен быть указан глав.бухгалтер [' + RecName + ']'
												when 2 then 'Для контрагента [' + R.Val + '] в данной карточке среди согласующих должен быть указан глав.бухгалтер [' + RecName + ']'
												end
							from @TblRec R
							where UserID = @UserID
								and RLPos = -100
							
							if @UserName = ''
							begin
								select --получаем имя пользователя для формирования сообщения об ошибке
									@UserName = Name
								from dbo.Users 
								where UserID = @UserID
								select @Result = @@error if @Result <> 0 goto Err
								
								set @UserName = '<font color=red>ОШИБКА! </font> В листе согласования обязательно должен быть указан пользователь: '
								+ case ltrim(rtrim(isnull(@UserName,''))) when '' then @UserID else @UserName end
							end 
							
							select -- формируем ошибку
								---@SQLStatement = @SQLStatement + case len(@SQLStatement) when 0 then '' else '<BR>' end + 
								--'<font color=red>ОШИБКА! </font> В листе согласования обязательно должен быть указан пользователь: '
								--+ case ltrim(rtrim(isnull(@UserName,''))) when '' then @UserID else @UserName end
								@SQLStatement = @SQLStatement + case len(@SQLStatement) when 0 then '' else '<BR>' end + @UserName
							select @Result = @@error if @Result <> 0 goto Err
						end
					end
					else
					begin--пользователь нашелся					
						If @isSystem = 1--обработка системного пользователя
						begin
							select --формируем сообщение
									@SQLStatement = @SQLStatement + case len(@SQLStatement) when 0 then '' else '<BR>' end + 
									+ '<font color=red>ОШИБКА! </font>' +
									case ltrim(rtrim(isnull(@ErrMessage,''))) when 'Системный логин -[' + @UserID + '] не может использоваться в Листе согласования. Замените его на реального пользователя.'  then '' else ltrim(rtrim(isnull(@ErrMessage,''))) end
							select @Result = @@error if @Result <> 0 goto Err
						end
						else If @isOrdered = 0 or @Pos_bls is null-- и нам неважна его позиция в ЛС 
						--это допустимо в 2-х случаях: 1) у нас БЛС или мы уже обрабатываем пользователей позиция, которых не важна
						--они согласно в сортировке в первом цикле будут последними
						begin
							select @OI_prev = @PosMin /*+ 1*/ --запомниаем позицию, с которй будем искать следующего согласующего
							select @Result = @@error if @Result <> 0 goto Err-- в данном случае всегда ищем со 1-ой
						end
						else
						begin --нам важно его местоположение и послед/параллельность в ЛС
/*select * from @Tbl_BLS
select * from @Tbl_LS
select @Flag_ls, @Pos_ls
select @Flag_bls, @Pos_bls, @UserID*/
							If @Flag_bls < @Flag_ls or --не может быть так, что в БЛС пользователь определен в параллели(0), а карточном ЛС он оказался без паралелли(1)
								@Pos_ls < @OI_prev or --пользователь должен быть в ЛС строго не раньше предыдущего обработанного
								(@Flag_bls > @Flag_ls and @Pos_bls-@OI_Bprev > @Pos_ls-@OI_prev)--это условие проверяет, что пользователи, кот д.бю. указаны последовательно, не оказались указаны параллельно
							begin --Пользователь не соответствует позиции
								if @isErrLS <> 1  --по этому флагу ориентируемся, записали мы эту ошибку уже или нет
								begin--не выходим из цикла при первом ее возникновении, так как хотим показать все ошибки типа "пользователь должне быть в ЛС"
									select 
										@SQLStatement = @SQLStatement + case len(@SQLStatement) when 0 then '' else '<BR>' end + 
										'<font color=red>ОШИБКА! </font> Порядок  согласования документа Согласующими не соответствует выбранному листу согласования'
									select @Result = @@error if @Result <> 0 goto Err

									select @isErrLS = 1
									select @Result = @@error if @Result <> 0 goto Err
								end
							end --If @Flag_bls < @Flag_ls or @Pos_ls < @OI_prev

							--запоминаем позицию, не выше которой д.б. след. пользователь
							select @OI_prev = @Pos_ls--@OI 
							select @Result = @@error if @Result <> 0 goto Err

						end --If @RLName like '(БЛС)%' or @Pos_bls is null
					end--If/Else @Pos_ls = 0
				end --If/Else @Pos_bls in (@PosMin, @PosMax)
NXT:
				--запоминаем позицию, не выше которой д.б. след. пользователь по базовому - придется учитывать, что текущий и предыдущий в ЛС и в БЛС на одной или разных позициях
				select @OI_Bprev = @Pos_Bls
				select @Result = @@error if @Result <> 0 goto Err

				delete @Tbl_BLS where KeyFld = @KeyFld
				select @Result = @@error if @Result <> 0 goto Err
			end--while exists (select 1 from @Tbl_BLS where Flg = 0)
		END

--*****************************************
	end--if len(@RList)>0

	
OK:
	if @SQLStatement <> ''  select @SQLStatement = @SQLStatement
	select @Result = @@error if @Result <> 0 goto Err
	select @FromRecL = @SQLStatement
	select @Result = @@error if @Result <> 0 goto Err
	
	if @ReturnSelect = 1 select @SQLStatement as err
	select @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:
	
	return @Result




















GO
/****** Object:  StoredProcedure [dbo].[PDX_ReconcilationListRUS] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--формирование бумажного листа согласования - таблица "Согласование"
CREATE proc [dbo].[PDX_ReconcilationListRUS]
	@DocID varchar(250)
as
declare 
	@Result int,
	@ListToreconcile varchar(4096), 
	@ListReconciled varchar(4096),
	@OneValue varchar(255),
	@Suspend bit,
	@IsActive varchar(10),
	@Lev int,
	@rowcount int

	declare @AllVisaComments table --все комментарии раздела VISA 
	(UserID varchar(255),
	DateEvent datetime,
	DateEventEnd datetime,
	DateCreation datetime,
	Comment varchar(5000),
	SpecialInfo varchar(512),
	Amount decimal(18,5),
	KeyField int)
	
	declare @ToReconcile table --Таблица со списком всех согласующих
	(OrderIndex int identity,
	UserID varchar(255), --имя пользователя
	Comment varchar(5000), --содержание
	DateFrom datetime, --Дата события 
	OI decimal(18,5), -- для сортировки (для поля Amount таблицы Comments)
	OrderIndex1 int, -- нужно для правильной сортировки (строк по делегированию и согласованию)
	Signature varchar(10), --для п/п(т.е. для уже согласовавших)
	Department varchar(512),	
	UserName varchar(255),
	DateDelegate datetime,
    vType varchar(512),

	Pos int, Flag bit) 

--Val,Pos,Flag
	
	declare @Delegate table --Таблица со списком всех согласующих
	(UserID varchar(255), --имя пользователя
	Comment varchar(5000), --содержание
	DateFrom datetime, --Дата события 
	OI decimal(18,5), -- для сортировки (для поля Amount таблицы Comments)
	OrderIndex1 int, -- нужно для правильной сортировки (строк по делегированию и согласованию)
	DateDelegate datetime,
	KeyField int,
	Lev int) 

	insert into dbo.Log
		(DateTime,UserID,DocID,Action,UserName,DocName,IPAddress)
	values
		(getdate(),'sql',@DocID,'Формирование листа согласования (start)','sql','','')
	select @Result = @@error if @Result <> 0 goto Err

	select
		@ListToreconcile = '',
		@ListReconciled = ''
/*
	--еще избавимся от лишних записей "основная версия документ изменен"
	update dbo.Comments
		set Comment = replace(Comment,'Основная версия документа, файл заменен' + char(13) + char(10),'')
	where DocID = @DocID
		and CommentType = 'VISA'
		and Comment like '%Основная версия документа, файл заменен%'
		--and isnull(FileName,'') = ''
	select @Result = @@error if @Result <> 0 goto Err
*/
	--Получаем в переменные списки тех кто должен согласовать и уже согласовал
	select
		--@ListToReconcile = replace(replace(replace(replace(isnull(ListToReconcile,''),'(#$)',''),'(#!)',''),char(10),''),char(13),'') ,
		--@ListReconciled = replace(replace(replace(replace(isnull(ListReconciled,''),'(#$)',''),'(#!)',''),char(10),''),char(13),''),
		@ListToReconcile = replace(replace(replace(replace(replace(isnull(ListToReconcile,''),'<(#!)>',''),'(#$)',''),'(#!)',''),char(10),''),char(13),'') ,
		@ListReconciled = replace(replace(replace(replace(replace(isnull(ListReconciled,''),'<(#!)>',''),'(#$)',''),'(#!)',''),char(10),''),char(13),''),
		@IsActive = IsActive,
		@Suspend = case when ListToReconcile like '%(#!)%' then 1 else 0 end -- приостановлен
	from dbo.Docs with (nolock)
	where DocID = @DocID
	select @Result = @@error if @Result <> 0 goto Err

	insert into @ToReconcile (UserID,Pos,Flag)
	exec dbo.PDX_ArrayToTable
			@Separator1 ='<',
			@Separator2 ='>',
			@Value = @ListToReconcile
	select @Result = @@error if @Result <> 0 goto Err

	update @ToReconcile
		set Signature = case 
							when @ListReconciled like '%<' + UserID + '>%' 
								then 'OK' 
							else '' 
						end
	select @Result = @@error if @Result <> 0 goto Err

	update @ToReconcile
		set UserName = case when @ListToReconcile like '%"%" <' + UserID + '>%'
							then reverse(left(REVERSE(left(@ListToReconcile,patindex('%" <' + UserID + '>%', @ListToReconcile)-1)), CHARINDEX('"',REVERSE(left(@ListToReconcile,patindex('%" <' + UserID + '>%', @ListToReconcile)-1)))-1 ) )
							else UserID
							end
    update @ToReconcile
    set  UserName = UserID
    where UserName like '%[<>]%'

	select @ListToReconcile = dbo.REC_ReconcilationTimeBound(@ListToReconcile)
	select @Result = @@error if @Result <> 0 goto Err

	If @ListToReconcile <> '' and @IsActive = 'Y'  --если список согласования есть и документ активен
	begin
		--все комментарии во врем. табл (для быстроты к ним последующего обращения)
		insert into @AllVisaComments
			(UserID,DateEvent,DateEventEnd,DateCreation,Comment,SpecialInfo,Amount, KeyField)
		select
			UserID,DateEvent,DateEventEnd,DateCreation,Comment,SpecialInfo,Amount, KeyField
		from dbo.Comments with (nolock)
		where DocID = @DocID
			and CommentType = 'VISA'
		select @Result = @@error if @Result <> 0 goto Err
	
/*		--в виде таблицы - список тех кто должен согласовать
		while @ListToReconcile like '%<%>%'--len(@ListToReconcile) <> 0
		begin
			select @OneValue = ''
			select @OneValue  = dbo.PDX_SubstringReturn (@ListToReconcile, charindex('<',@ListToReconcile), charindex('>',@ListToReconcile))
			select @Result = @@error if @Result <> 0 goto Err

			--из исходной строки "убираем" выделенного пользователя
			select @ListToReconcile = replace(@ListToReconcile,'<' + @OneValue + '>','')
			select @Result = @@error if @Result <> 0 goto Err

			if @OneValue <> ''
			begin
				--сохраняем информацию в таблице
				insert into @ToReconcile 
					(UserID, Signature) 
				values (@OneValue, case 
										when @ListReconciled like '%<' + @OneValue + '>%' 
											then 'OK' 
										else '' 
									end)
				select @Result = @@error if @Result <> 0 goto Err
			end
			else
			begin --
				delete from @ToReconcile
				select @Result = @@error if @Result <> 0 goto Err

				insert into @ToReconcile 
					(UserID, Signature) 
				values ('ОШИБКА!!!','')
				select @Result = @@error if @Result <> 0 goto Err
				goto FTH
			end
		end
*/
FTH:
		--информация по уже согласованному
		update R 
		set Comment = (select top 1 /*case C.SpecialInfo
									when 'VISAOK' then 'Согласовано '
									when 'VISAOKREFUSE' then 'Отказано ' end + */
							case when C.Comment like '%/%"%"%<%>%' then  
								replace(replace(reverse(substring(reverse(C.Comment),charindex('<',reverse(C.Comment))+1,charindex('/',reverse(C.Comment))-charindex('<',reverse(C.Comment)))),'(*)',''),'"','')
							else '' end +
							char(13) + char(10)+
							convert(varchar(255),DateEventEnd,104) + ' ' + convert(varchar(5),DateEventEnd,108)  from @AllVisaComments C 
						where C.UserID = R.UserID
						and C.SpecialInfo in ('VISAOK','VISAOKREFUSE') 
						order by DateEventEnd desc),
		 DateFrom = (select top 1 DateEvent from @AllVisaComments C 
						where C.UserID = R.UserID
						and C.SpecialInfo in ('VISAOK','VISAOKREFUSE') 
						order by DateEventEnd desc),
		 OI = (select top 1 Amount from @AllVisaComments C 
						where C.UserID = R.UserID
						and C.SpecialInfo in ('VISAOK','VISAOKREFUSE') 
						order by DateEventEnd desc),
		 vType = (select top 1 C.SpecialInfo 
						from @AllVisaComments C
						where C.UserID = R.UserID
						and C.SpecialInfo in ('VISAOK','VISAOKREFUSE') 
						order by DateEventEnd desc)
		from @ToReconcile R
		where R.Signature <> '' --уже согласовавшие
		select @Result = @@error if @Result <> 0 goto Err
	
		if @Suspend = 0 --если не приостановлен
		begin
			--информация по текущему согласованию	
			update R
				set 
					Comment = 'На Согласовании',
					DateFrom = C.DateEvent,
					OI = C.Amount
			from @ToReconcile R 
			inner join @AllVisaComments C on R.UserID = C.UserID 
				and C.SpecialInfo = 'VISAWAITING'
			where R.Signature = '' --для еще не согласовавших
			select @Result = @@error if @Result <> 0 goto Err
		end
		/*else
		begin --если приостановлен
			--кто сейчас приостановлен (из еще не согласовавших)
			update R 	
				set
					Comment = 'Приостановлен' + char(13) + char(10)+
							convert(varchar(255),U.DateEventEnd,104) + ' ' + convert(varchar(5),U.DateEventEnd,108),
					DateFrom = U.DateEvent,
					OI = U.Amount
			from
			(select max(DateCreation) as DateCreation from @AllVisaComments C
			where SpecialInfo = 'VISASUSPENDING') S
			inner join @AllVisaComments U on U.DateCreation = U.DateEventEnd
				and U.SpecialInfo = 'VISASUSPENDINGUSER'
			inner join @ToReconcile R on R.UserID = U.UserID 
				and R.Signature = '' --для еще не согласовавших
			select @Result = @@error if @Result <> 0 goto Err
		end	*/

		select @Lev = 1
		--информация по делегированию - последний шаг делегирования
		insert into @Delegate
			(UserID,Comment, DateFrom,OI, OrderIndex1,DateDelegate, KeyField, Lev)
		select --передадим в asp фамилию, а там уже преобразум к "красивому виду"
			A.UserID, /*replace(C.Comment,'Делегировать свои полномочия по согласованию другому пользователю:',''),*/
			--replace(A.Comment,' свои полномочия по согласованию другому пользователю',' ') + char(13) + char(10) + convert(varchar(255),A.DateCreation,121),
			--dbo.PDX_SubstringReturn(A.Comment,charindex('<',A.Comment),charindex('>', A.Comment)),
			
			case when A.Comment like '%"%" <' + L.UserID + '>%'
							then reverse(left(REVERSE(left(A.Comment,patindex('%" <' + L.UserID + '>%', A.Comment)-1)), CHARINDEX('"',REVERSE(left(A.Comment,patindex('%" <' + L.UserID + '>%', A.Comment)-1)))-1 ) )
							else L.UserID
							end,
			
			isnull(L.DateFrom,A.DateCreation),
			A.Amount, L.OrderIndex,
			A.DateCreation,
			A.KeyField,
			@Lev
		from @ToReconcile L
		inner join 
			(select C.UserID,C.Comment,max(C.DateCreation) as DateCreation,C.Amount,max(C.KeyField) as KeyField
			from @AllVisaComments C where upper(C.SpecialInfo) = upper('DELEGATE')--C.Comment like 'Делегировать свои полномочия по согласованию другому пользователю:%'
			group by C.UserID,C.Comment,C.Amount) as A on A.Comment like '%<' + L.UserID + '>%' 
		select @Result = @@error if @Result <> 0 goto Err

		--"раскручиваем" делегирование до самого первого
		select @rowcount = 1
		while @rowcount <> 0
		begin
			select @Lev = @Lev +1 
			insert into @Delegate
				(UserID,Comment, DateFrom,OI, OrderIndex1,DateDelegate, KeyField, Lev)
			select --передадим в asp фамилию, а там уже преобразум к "красивому виду"
				A.UserID, 
				--replace(A.Comment,' свои полномочия по согласованию другому пользователю',' ') + char(13) + char(10) + convert(varchar(255),A.DateCreation,121),
				dbo.PDX_SubstringReturn(A.Comment,charindex('<',A.Comment),charindex('>', A.Comment)),
				L.DateFrom,
				A.Amount, L.OrderIndex1,
				A.DateCreation,
				A.KeyField, 
				@Lev
			from @Delegate L
			inner join 
				(select C.UserID,C.Comment,max(C.DateCreation) as DateCreation,C.Amount,max(C.KeyField) as KeyField
				from @AllVisaComments C where upper(C.SpecialInfo) = upper('DELEGATE')--C.Comment like 'Делегировать свои полномочия по согласованию другому пользователю:%'
				and not C.KeyField in (select KeyField from @Delegate)
				group by C.UserID,C.Comment,C.Amount) as A on A.Comment like '%<' + L.UserID + '>%'
					and A.DateCreation <= L.DateDelegate
			where L.Lev = @Lev - 1
			select @rowcount = @@rowcount, @Result = @@error if @Result <> 0 goto Err	
		end

		--добавляем инф-ю о делегировании в рез.табл.
		insert into @ToReconcile (UserID,Comment, DateFrom,OI, OrderIndex1,DateDelegate)
		select
			D.UserID,'Делегировать: ' + isnull(U.Name,/*'***Пользователь "' +*/ D.Comment /*+ '" не существует***'*/) + char(13) + char(10) + convert(varchar(255),D.DateDelegate,121), D.DateFrom,D.OI, D.OrderIndex1,D.DateDelegate
		from @Delegate D
		left join dbo.Users U on U.UserID = D.Comment
		select @rowcount = @@rowcount, @Result = @@error if @Result <> 0 goto Err	
	End

	--получаем подразделение пользователя и исключаем из него коды
	update T
		set
			UserName = isnull(U.Name,T.UserName),
			Department = isnull(U.Department + ' - ' +  U.Position,'***пользователь_не_существует***')
	from  @ToReconcile T
		left join dbo.Users U with (nolock) on U.UserID = T.UserID
	select @Result = @@error if @Result <> 0 goto Err
/*--неактуально
	--исключаем коды
	--while exists (select 1 from @ToReconcile where Department like '%<%' and Department like '%>%')
	while exists (select 1 from @ToReconcile where Department like '%{%' and Department like '%}%')
	begin
		update @ToReconcile 
			set 
				Department = STUFF(Department, charindex('<',Department), charindex('>',Department)-charindex('<',Department)+1, '')
		where Department like '%<%' and Department like '%>%'
		--		Department = STUFF(Department, charindex('{',Department), charindex('}',Department)-charindex('{',Department)+1, '')
		--where Department like '%{%' and Department like '%}%'
		select @Result = @@error if @Result <> 0 goto Err
	end
	select @Result = @@error if @Result <> 0 goto Err
*/
	insert into dbo.Log
		(DateTime,UserID,DocID,Action,UserName,DocName,IPAddress)
	values
		(getdate(),'sql',@DocID,'Формирование листа согласования (end)','sql','','')
	select @Result = @@error if @Result <> 0 goto Err

	--результат
	select 
		T.UserID,
		T.UserName,
		T.Department,
		T.DateFrom,
		isnull(case upper(T.vType)
				when 'VISAOK'
					then 'Согласовано '
				when 'VISAOKREFUSE'
					then 'Отказано '
				else ''
			   end,'') + isnull(T.Comment,'') as Comment,
		isnull(case upper(T.vType)
				when 'VISAOK'
					then 'п/п'
				when 'VISAOKREFUSE'
					then 'Х'
				else ''
			   end,'') as Signature,
		/*case 
			when exists(select 1 from @AllVisaComments C
							where T.UserID = C.UserID
							and not upper(C.SpecialInfo) in ('VISAOK','VISAOKREFUSE','VISAWAITING'))
				then 'Да'
			else 'Нет'
		end*/'' as 'HasComment',
		T.vType
	from  @ToReconcile T
	order by isnull(T.OrderIndex1,T.OrderIndex), T.OI, isnull(T.DateDelegate,'2500-01-01')
	select @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:
	
	return @Result




GO
/****** Object:  StoredProcedure [dbo].[PDX_ReconcilationListRUS_BP] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_ReconcilationListRUS_BP]
	@DocID varchar(250)
as
declare 
	@Result int

	declare @Comm varchar(1024),
			@Subj varchar(512),
			@cnt int

    declare @tmp table
  		(UserID varchar(16),
		UserName varchar(128),
		DateCreation datetime,
		Subject varchar(512),
		Comment varchar(1024),
		SpecialInfo varchar(512),
		Version varchar(64))

	declare @res table
		(OI int identity,
		Subject varchar(512),
		Result varchar(128),
		Comment varchar(1024),
		Flg bit default 0,
		Version varchar(64))

	insert into @tmp
		(UserID, UserName, DateCreation, Subject, Comment, SpecialInfo, Version)
	select 
		UserID, UserName, DateCreation, Subject, cast(Comment as varchar(1024)), SpecialInfo, Version
	from dbo.Comments
	where DocID = @DocID 
		and upper(CommentType) = upper('BUSINESSPROCESS')
	select @Result = @@error if @Result <> 0 goto Err

	insert into @res
		( Subject)
	select
		 Subject
	from @tmp
	where upper(Version) = upper('BPStepName')
	order by DateCreation
	select @Result = @@error if @Result <> 0 goto Err

	update R 
		set Result = case T.Version 
						when 1
							then 'ОДОБРЕНО'
						when 2 
							then 'ОТКЛОНЕНО'
						when 3
							then 'ТРЕБУЕТ РАССМОТРЕНИЯ СД ОК РУСАЛ'
						else 'ошибка!'
					end,
		Version = T.Version,
		Comment = T.Comment
	from @res R
	inner join @tmp T on T.Subject = R.Subject
		and upper(T.SpecialInfo) = upper('BPOK')
	select @Result = @@error if @Result <> 0 goto Err
/*
	select @cnt = max(OI) from @res where version = 3
	select @Result = @@error if @Result <> 0 goto Err
	if isnull(@cnt,0) > 0
	begin
		update @res
			set Result = '***не требуется***'
		where OI > @cnt 
		and isnull(Result,'') = ''
		select @Result = @@error if @Result <> 0 goto Err
	end 
*/
	while exists(select 1 from @res where Flg = 0)
	begin
		select top 1
		 @Subj = Subject
		from @res
		where Flg = 0
		select @Result = @@error if @Result <> 0 goto Err

		select @Comm = ''
		select @Comm = @Comm + '<BR>(' + UserName + ', ' + convert(varchar(100), DateCreation, 104) + ') - ' + Comment
		from @tmp 
		where Subject = @Subj
			and ltrim(rtrim(SpecialInfo))  = ''
			and ltrim(rtrim(Version))  = ''
		order by DateCreation desc

		update @res set Flg = 1, Comment = Comment + @Comm
		where Subject = @Subj
		select @Result = @@error if @Result <> 0 goto Err
	end

	select * from @res order by OI
	select @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:
	
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_ReconcilationListRUS_C] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_ReconcilationListRUS_C]
	@DocID varchar(250)
as
declare 
	@Result int

    declare @tmp table
  		(UserID varchar(16),
		UserName varchar(64),
		Department varchar(512),
		DateFrom datetime,
		Comment varchar(4096),
		Amount money,
		vType varchar(512))

	insert into @tmp
		(UserID, UserName, Department, DateFrom, Comment,Amount, vType)
	select
		C.UserID,
		U.Name as UserName,
		U.Department + char(13) + char(10) +  U.Position as 'Department',
		C.DateCreation as DateFrom,
	    case when isnull(C.FileName,'')<>'' then 'ФАЙЛ: ' else '' end + C.Comment,
		C.Amount,
		C.SpecialInfo
	from dbo.Comments C with (nolock)
		inner join dbo.Users U with (nolock) on U.UserID = C.UserID
	where C.DocID = @DocID
		and C.CommentType = 'VISA'
		and not isnull(C.SpecialInfo,'') in ('VISAOK',/*'VISAOKREFUSE',*/'VISAWAITING')
		and isnull(C.Amount,0) <> 0.9
	--order by C.DateCreation, C.Amount
	select @Result = @@error if @Result <> 0 goto Err

/*
    --исключаем коды
	--while exists (select 1 from @ToReconcile where Department like '%<%' and Department like '%>%')
	while exists (select 1 from @tmp where Department like '%{%' and Department like '%}%')
	begin
		update @tmp 
			set 
				Department = STUFF(Department, charindex('<',Department), charindex('>',Department)-charindex('<',Department)+1, '')
		where Department like '%<%' and Department like '%>%'
		--		Department = STUFF(Department, charindex('{',Department), charindex('}',Department)-charindex('{',Department)+1, '')
		--where Department like '%{%' and Department like '%}%'
		select @Result = @@error if @Result <> 0 goto Err
	end
	select @Result = @@error if @Result <> 0 goto Err
*/
	select
		UserID, UserName, Department, DateFrom, Comment, isnull(vType,'') as vType
	from @tmp
	order by DateFrom, Amount
	select @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:
	
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_ReconciliationSuspendApr] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[PDX_ReconciliationSuspendApr]
	@DocID varchar(128),
	@Mess varchar(1024),
	@UserID varchar(128),
	@UserName varchar(128),
	@Role varchar(128)
	
as
declare 
	@Res int, @Resp int
	
	select @Res = 0, @Resp = 0
	declare @ClassDoc varchar(128),
	@UserSendTo varchar(128),
	@RoleName varchar(128),
	@Date datetime
	
	set 
		@Role = rtrim(ISNULL(@Role,''))
	if @Role <> ''
	begin
		select @RoleName = [dbo].PDX_FIObyFullNameGet(Name)
		from dbo.Users 
		where UserID = @Role
	
		set @Role = ' / "' + @RoleName + '" <' + @Role + '>;'
	end
		
	select
		@ClassDoc = ClassDoc,
		@UserSendTo = NameCreation,
		@Date = GETDATE()
	from dbo.Docs
	where DocID = @DocID
	
	if @ClassDoc in (dbo.PDX_CLSGet('RIK_CategoryName_ORDER_CONT'),
		dbo.PDX_CLSGet('RIK_CategoryName_OTHERS_NSI'))
	begin

		update dbo.Docs
			set ListToReconcile = ListToReconcile + ' <(#!)>'
		where DocID = @DocID
		select @Res = @@error if @Res <> 0 goto Err

		update dbo.Comments
			set DateCreation = @Date,
				DateEventEnd = @Date,
				Comment = CONVERT(varchar(10),@Date,104) + ' ' + 
						CONVERT(varchar(5),@Date,108) + '(' + CONVERT(varchar(10),DateEvent,104) + 
						') Отправлен на доработку' + @Role,
				SpecialInfo = 'VISASUSPENDINGUSER'
		where DocID = @DocID
			and CommentType  = 'VISA'
			and SpecialInfo = 'VISAWAITING'
			
		insert into dbo.Comments
			(UserID,
			UserName,
			ContactUserName,
			ContactUserID,
			PartnerName,
			DocID,
			DateCreation,
			DateEvent,
			DateEventEnd,
			Address,
			Subject,
			Comment,
			CommentType,
			SpecialInfo,
			FileName,
			--KeyField,
			PartnerID,
			Version,
			GUID,
			GUIDPartner,
			GUIDUser,
			GUIDDoc,
			Amount)
		values (
			@UserID,
			@UserName,
			null,--ContactUserName,
			null,--ContactUserID,
			null,--PartnerName,
			@DocID,--DocID,
			@Date,--DateCreation,
			@Date,--DateEvent,
			null,--DateEventEnd,
			'',--Address,
			null,--Subject,
			'Отправлен на доработку - ' + @Mess + @Role,--Comment,
			'VISA',--CommentType,
			'VISASUSPENDING',--SpecialInfo,
			null,--FileName,
			--KeyField,
			null,--PartnerID,
			null,--Version,
			NewID(),--GUID,
			null,--GUIDPartner,
			null,--GUIDUser,
			null,--GUIDDoc,
			null)--Amount)
		select @Res = @@error if @Res <> 0 goto Err

		select @Resp = 1
		select @Res = @@error if @Res <> 0 goto Err
	end
OK:

	select @Resp as 'ires', @UserSendTo as 'UserSendTo'
	return @Res
Err:
	select @Resp as 'ires', @UserSendTo as 'UserSendTo'
	return @Res


GO
/****** Object:  StoredProcedure [dbo].[PDX_RemoveNAprFromCorresp] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[PDX_RemoveNAprFromCorresp]
	@DocID varchar(128)
	
as
declare 
	@Res int, @NApr varchar(96), @Corr varchar(4000), @LTV varchar(4000)

	select @Res = 0

	select
		@NApr = NameAproval,
		@Corr = Correspondent,
		@LTV = ListToView
	from dbo.Docs
	where DocID = @DocID

	If @Corr like '%' + @NApr + '%' or @LTV like '%' + @NApr + '%'
	begin
		update dbo.Docs
			set Correspondent = REPLACE(Correspondent,@NApr,''),
			ListToView = REPLACE(ListToView,@NApr,'')
		where DocID = @DocID
		select @Res = @@error if @Res <> 0 goto Err
		
		
		insert into dbo.Log
			(DateTime, UserID, DocID,Action, UserName,DocName,IPAddress)
		values 
			(GETDATE(), 'Admin', @DocID, 'исключение подписанта из списков ' +
					isnull(case
						when @Corr like '%' + @NApr + '%' then '/Corr'
					end,'') +
					isnull(case
						when @LTV like '%' + @NApr + '%' then '/LTV'
					end,'') ,'','','')
	end

OK:

	return @Res
Err:
	return @Res



GO
/****** Object:  StoredProcedure [dbo].[PDX_RenameCategory] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_RenameCategory]
	@OldName varchar(255),
	@NewName varchar(255)
as
	declare @Result int
	set @Result = 0
	
	--raiserror('Временно заблокировано (хр.пр. dbo.PDX_RenameCategory)',16,1)
	--goto Err

	--меняем названия категорий в существующих документах
	update dbo.Docs
	set
		ClassDoc = @NewName
	where ClassDoc = @OldName
	select @Result = @@error if @Result <> 0 goto Err

	--меняем название в категориях
	update dbo.DocTypes
	set Name = @NewName
	where Name = @OldName
	select @Result = @@error if @Result <> 0 goto Err

	--наши настроечные таблицы
	update dbo.PDXDocTypesConst
		set DocType = @NewName
	where DocType = @OldName
	select @Result = @@error if @Result <> 0 goto Err

	update dbo.PDXUserSettingDocTypes
		set DocType = @NewName
	where DocType = @OldName
	select @Result = @@error if @Result <> 0 goto Err

	--права пользователей на категорию
	update Users
		set ClassDoc = replace(ClassDoc,@OldName,@NewName)
	where ClassDoc like '%' + @OldName + '%'
	select @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_RenameFieldRUSScript] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_RenameFieldRUSScript]
	@UFRename bit = 0,
	@DocType varchar(255)
as
	declare @Result int
	set @Result = 0

	declare @List nvarchar(4000)	,
		@SQLScript varchar(4000)

	--raiserror('Временно заблокировано (хр.пр. dbo.PDX_RenameFieldRUSScript)',16,1)
	--goto Err


	select @List = ''
	select @List = @List + '  DOCS_' + 
	case lower(FieldName)
		when lower('ActDoc')
			then 'ACT'
		when lower('Docrank')
			then 'Rank'
		when lower('LocationPath')
			then 'ListToRegister'
		else FieldName
	end + 
	/*isnull(replicate('	',3-len ('  DOCS_' + 
	case lower(FieldName)
		when lower('ActDoc')
			then 'ACT'
		when lower('Docrank')
			then 'Rank'
	else FieldName
	end)/8),' ') + */
	'= "' + RUSName + '"
' 
	from dbo.PDXUserSettingDocTypes	
	where DocType = @DocType
		--and not lower(FieldName) like lower('UserField%')
		and OrderIndex <> 100
		and RUSName <> '--'
	order by OrderIndex
	select @Result = @@error if @Result <> 0 goto Err

	--переименовать пользовательские поля (ОНИ в таблице DocTypes)
	if @UFRename  = 1
	begin
		select @SQLScript = ''
		select @SQLScript = @SQLScript + case len(@SQLScript) when 0 then '' else ',' end +
			'Name' + FieldName + ' = ''' + RUSName + '''' 
		from dbo.PDXUserSettingDocTypes	
		where DocType = @DocType
			and lower(FieldName) like lower('UserField%')
			and OrderIndex <> 100
			and RUSName <> '--'
		select @Result = @@error if @Result <> 0 goto Err

		if len(@SQLScript) <> 0 
		begin
			select @SQLScript = 'update dbo.DocTypes set ' + @SQLScript +
				' where Name = ''' + @DocType + ''''
			select @Result = @@error if @Result <> 0 goto Err
			
			print @SQLScript
			exec (@SQLScript)
			select @Result = @@error if @Result <> 0 goto Err
		end
	end


	select @List = ConstName + ' = "' + DocType + '"' +
'
If CurrentClassDoc = ' + ConstName + ' then' + '
' + @List + 'End If'
	from dbo.PDXDocTypesConst
	where DocType = @DocType
	select @Result = @@error if @Result <> 0 goto Err

	select '''' + suser_sname() + ' ' + convert(varchar(100),getdate(),121) + ' auto
' + @List
	select @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_Accr_Find] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
--drop proc [dbo].[PDX_REP_Accr_Find]
--go

CREATE proc [dbo].[PDX_REP_Accr_Find] --ПОИСК плановых заявок по основным реквизитам (казначейство)
	@DID varchar(128),
	@UFD3f datetime,
	@UFD3t datetime,
	@UFD1f datetime,
	@UFD1t datetime,
	
	@UFM1 int,
	@NApr varchar(128),
	
	@Currency varchar(64),
	@UFT8 varchar(512),
	@UFT2 varchar(512),
	@PN varchar(512),
	@UFT4 varchar(512),
	@UFT3 varchar(512),
	
	@DIDPar varchar(128),
	@UFM2 int,
	
	@Oborot varchar(128),
    @Koeff1 int,
    @Koeff2 int,
    @Grp varchar(128),
      
	@NCr varchar(96),
	@State int, --1 - все, кроме отмен, 2- на согл, 3 - треб утв, 4 утв, 5 - отмен
	@Access bit = 1
as
	declare @Result int, @Cls varchar(128)
	set @Result = 0

	set @Cls= dbo.PDX_CLSGet('RIK_CategoryName_KAZ_ACCRUAL')
	select @UFT2 = ltrim(rtrim(ISNULL(@UFT2,''))),
		@UFT4 = ltrim(rtrim(ISNULL(@UFT4,''))),
		@UFM1 = ltrim(rtrim(ISNULL(@UFM1,0))),
		@UFM2 = ltrim(rtrim(ISNULL(@UFM2,0))),
		@UFT3 = ltrim(rtrim(ISNULL(@UFT3,''))),
		@UFT8 = ltrim(rtrim(ISNULL(@UFT8,''))),
		@Currency = ltrim(rtrim(ISNULL(@Currency,''))),
		@PN = ltrim(rtrim(ISNULL(@PN,''))),
		@DIDPar = ltrim(rtrim(ISNULL(@DIDPar,''))),
		@NCr = case when ISNULL(@NCr,'') like '%<%>%' 
					then dbo.PDX_SubstringReturn(ISNULL(@NCr,''), CHARINDEX('<',ISNULL(@NCr,'')), charindex('>',ISNULL(@NCr,'')))
					else ltrim(rtrim(ISNULL(@NCr,''))) end,
		@NApr = case when ISNULL(@NApr,'') like '%<%>%' 
					then dbo.PDX_SubstringReturn(ISNULL(@NApr,''), CHARINDEX('<',ISNULL(@NApr,'')), charindex('>',ISNULL(@NApr,'')))
					else ltrim(rtrim(ISNULL(@NApr,''))) end,
		@Oborot = case when ISNULL(@Oborot,'') like '%<%>%' 
					then dbo.PDX_SubstringReturn(ISNULL(@Oborot,''), CHARINDEX('<',ISNULL(@Oborot,'')), charindex('>',ISNULL(@Oborot,'')))
					else ltrim(rtrim(ISNULL(@Oborot,''))) end,
		@Grp = case when ISNULL(@Grp,'') like '%<%>%' 
					then dbo.PDX_SubstringReturn(ISNULL(@Grp,''), CHARINDEX('<',ISNULL(@Grp,'')), charindex('>',ISNULL(@Grp,'')))
					else ltrim(rtrim(ISNULL(@Grp,''))) end
	select @Result = @@error if @Result <> 0 goto Err
 
	create table #treeRes (Code varchar(128))
	
	if @UFT4 like '<%>%'
	begin		
		-- и еще раз достраиваем нижние уровни
		;with treeResFirst2 (KeyField, ParentKeyField, code, descr)
		as
		(
			-- сами узелки
			select T1.KeyField, T1.ParentKeyField, cast(T1.Code as varchar(max)), cast(T1.descr as varchar(max))
			from UserDir_ISR T1
			where '<'+Code+'>'=LEFT(@UFT4, charindex('>',@UFT4))
			-- нижние
			union all
			select	I.KeyField, I.ParentKeyField,
					cast(I.Code as varchar(max)) as Code,
					cast(I.descr as varchar(max))
			from UserDir_ISR I 
				inner join treeResFirst2 T on T.KeyField = I.ParentKeyField
			
			
		)
		
			insert into #treeRes (Code)
			select '<' + Code + '>'
			from treeResFirst2
	end
	
	if not exists (select 1 from #treeRes)
	begin
		if @UFT4 <> ''
		begin
			insert into #treeRes (Code) values (@UFT4)
		end
		else
		begin
			insert into #treeRes (Code) values ('')
		end
	end
	
	;with RES as (
	select distinct
		D.DocIDInt,
		case @Access when 1 then 'system_report' else D.DocID end as DocID,
		D.DocID as strID, 
		D.UserFieldDate3, --Рег. дата
		D.UserFieldDate1, --Плановая дата оплаты
		D.UserFieldText3, --сценарий
		D.Currency, --Валюта
		D.UserFieldText8, --Бизнес единица
		D.NameAproval, --Фин. Менеджер
		D.UserFieldText2, --ЦФО
		D.PartnerName, --КА
		D.UserFieldText4, --Код ИСР
		D.DocIDParent, --договор
		D.UserFieldText6, --Счет
		F1.Descr as UFM1, --.UserFieldMoney1,
		F2.Descr as UFM2,-- D.UserFieldMoney2,
		D.NameCreation, --Заявитель
		D.UserFieldText1, --Наименование листа согласования
		D.ListToReconcile, --Лист согласования
		dbo.REC_DocStatusRead(1,D.isActive,D.StatusCompletion,D.StatusDevelopment,
			D.ListToReconcile, D.ListReconciled, D.LocationPath) as Status,
		
		A.Oborot,A.Grp,A.Koeff, case A.blnType when 0 then A.Amount else 0 end as AmountDoc,
		case A.blnType when 1 then A.Amount else 0 end as AmountDoc1
	from dbo.Docs D
	inner join dbo.PDXAccrual A on A.DocIDInt = D.DocIDInt and A.isDel = 0
	inner join #treeRes R on D.UserFieldText4 like R.Code + '%'
	inner join [dbo].[SelectValueForUFM] F1 on F1.UFM_Num = 1 and F1.ClsConstName = 'RIK_CategoryName_KAZ_ACCRUAL' and F1.Val = D.UserFieldMoney1
	inner join [dbo].[SelectValueForUFM] F2 on F2.UFM_Num = 2 and F2.ClsConstName = 'RIK_CategoryName_KAZ_ACCRUAL' and F2.Val = D.UserFieldMoney2
	where D.ClassDoc = @Cls
		and UPPER(ISNULL(D.IsActive,'')) = 'Y'
		and (D.DocID like '%' + @DID + '%' or @DID = '')
		and D.UserFieldDate3 between @UFD3f and @UFD3t
		and D.UserFieldDate1 between @UFD1f and @UFD1t
		and (D.Currency = @Currency or @Currency = '')
		and (D.UserFieldText8 = @UFT8 or @UFT8 = '')
		and (D.UserFieldText2 = @UFT2 or @UFT2 = '')
		and (D.UserFieldText3 = @UFT3 or @UFT3 = '')
		and (D.UserFieldMoney1 = @UFM1 or @UFM1 = 0)
		and (D.UserFieldMoney2 = @UFM2 or @UFM2 = 0)
		and (D.PartnerName = @PN or @PN = '')
		and (D.DocIDParent = @DIDPar or @DIDPar = '')
		and (D.NameCreation like '%<' + @NCr + '>%' or @NCr = '')
		and (D.NameAproval like '%<' + @NApr + '>%' or @NApr = '')
		and isnull(D.StatusDevelopment,'') = case @State when 4 then '4' else D.StatusDevelopment end
		and isnull(D.StatusDevelopment,'') <> case when @State in (2,3) then '4' else '-' end
		and dbo.PDX_CompareReconcilationList(D.listToReconcile, D.ListReconciled) = case @State when 3 then 1 else dbo.PDX_CompareReconcilationList(D.listToReconcile, D.ListReconciled) end
		and isnull(D.StatusCompletion,'') = case @State when 5 then '0' else isnull(D.StatusCompletion,'') end
		and isnull(D.StatusCompletion,'') <> case @State when 5 then '%^&*^(*' else '0' end
		
		and (A.Oborot like '%<' + @Oborot + '>%' or @Oborot = '')
		and (A.Grp like '%<' + @Grp + '>%' or @Grp = '')
		and (A.Koeff between @Koeff1 and @Koeff2)
	)
	/*
	select X.*, Y.AmountDoc,Y.AmountDoc1
	from RES X
	inner join (
		select A.DocIDINt, SUM(case P.blnType when 0 then P.Amount else 0 end) as AmountDoc, SUM(case P.blnType when 1 then P.Amount else 0 end) as AmountDoc1
		from RES A
		inner join dbo.PDXAccrual P on P.DocIDInt = A.DocIDINt
		group by A.DocIDInt) Y on X.DocIDINt = Y.DocIDINt
	order by X.UserFieldDate3, X.strID
	*/
	select
	*
	from RES X
	order by X.UserFieldDate3, X.strID, X.Oborot
	
	return @Result
Err:

	return @Result



GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_AdvancedSearch] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_REP_AdvancedSearch]
	@DocID varchar(128),
	@FlgDocID int,
	@ClassDoc varchar(255),
	@UserName varchar(128),
	@Context varchar(255)

as

declare @Result int
select @Result = 0

	declare @SQL varchar(8000)

	select @UserName = case dbo.PDX_SubstringReturn(@UserName,charindex('<',@UserName),charindex('>',@UserName))
						when ''
							then @UserName
						else '<'+dbo.PDX_SubstringReturn(@UserName,charindex('<',@UserName),charindex('>',@UserName))+'>'
					  end,
		   @DocID = replace(isnull(ltrim(rtrim(@DocID)),''),'''',''''''),
		   @ClassDoc = replace(isnull(ltrim(rtrim(@ClassDoc)),''),'''',''''''),	
		   @Context = replace(isnull(ltrim(rtrim(@Context)),''),'''','''''')
	select @Result = @@error if @Result <> 0 goto Err
	
	select @SQL = ''
	select @Result = @@error if @Result <> 0 goto Err

	if @DocID <> '' 
	begin
		select @SQL = @SQL + ' AND (DocID like ''%' + @DocID + '%''' +
							 ' OR DocID_AddNumber like ''%' + @DocID + '%'''
		select @Result = @@error if @Result <> 0 goto Err
	end

	if @DocID <> '' and @FlgDocID = 1
	begin
		select @SQL = @SQL + ' OR DocIDAdd like ''%' + @DocID + '%''' +
							 ' OR DocIDIncoming like ''%' + @DocID + '%''' +
							 ' OR DocIDPrevious like ''%' + @DocID + '%''' +
							 ' OR DocIDParent like ''%' + @DocID + '%''' 
		select @Result = @@error if @Result <> 0 goto Err
	end
	if @DocID <> '' 
	begin
		select @SQL = @SQL + ')'
		select @Result = @@error if @Result <> 0 goto Err
	end

 	if @ClassDoc <> '' 
	begin
		select @SQL = @SQL + ' AND ClassDoc like ''' + @ClassDoc + '%'''
		select @Result = @@error if @Result <> 0 goto Err
	end

	if @UserName <> '' 
	begin
		select @SQL = @SQL + ' AND (NameCreation like ''%' + @UserName + '%''' +
							 ' OR NameAproval like ''%' + @UserName + '%''' +
							 ' OR NameResponsible like ''%' + @UserName + '%''' +
							 ' OR NameControl like ''%' + @UserName + '%''' +
							 ' OR Author like ''%' + @UserName + '%''' +
							 ' OR Correspondent like ''%' + @UserName + '%''' +
							 ' OR ListToView like ''%' + @UserName + '%''' +
							 ' OR LocationPath like ''%' + @UserName + '%''' +
							 ' OR ListToEdit like ''%' + @UserName + '%''' +
							 ' OR ListToReconcile like ''%' + @UserName + '%'')'
		select @Result = @@error if @Result <> 0 goto Err
	end

	if @Context <> '' 
	begin
		select @SQL = @SQL + ' AND (Name like ''%' + @Context + '%''' + 
							 ' OR Description like ''%' + @Context + '%''' +
							 ' OR Content like ''%' + @Context + '%''' +
							 ' OR DocIDIncoming like ''%' + @Context + '%''' +
							 ' OR UserFieldText1 like ''%' + @Context + '%''' +
							 ' OR UserFieldText2 like ''%' + @Context + '%''' +
							 ' OR UserFieldText3 like ''%' + @Context + '%''' +
							 ' OR UserFieldText4 like ''%' + @Context + '%''' +
							 ' OR UserFieldText5 like ''%' + @Context + '%''' +
							 ' OR UserFieldText6 like ''%' + @Context + '%''' +
							 ' OR UserFieldText7 like ''%' + @Context + '%''' +
							 ' OR UserFieldText8 like ''%' + @Context + '%''' +
							 ' OR Department like ''%' + @Context + '%''' +
							 ' OR Resolution like ''%' + @Context + '%''' +
							 ' OR PartnerName like ''%' + @Context + '%'')'
		select @Result = @@error if @Result <> 0 goto Err
	end


	select @SQL = substring(@SQL, charindex('AND',@SQL) + 3, len(@SQL))
	select @Result = @@error if @Result <> 0 goto Err

	if @SQL = ''
	begin
		select @SQL = 'select top 0 *,year(DateActivation) as rec_year from dbo.Docs'
	end
	else
	begin
		select @SQL = 'select *, year(DateActivation) as rec_year from dbo.Docs where ' + @SQL + ' order by DateCreation desc, ClassDoc'
	end

	print @SQL
    exec (@SQL)   
	select @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:
	
	return @Result


GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_AGList] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_REP_AGList]
	
as
	declare 
		@Res int,
		@List varchar(4048),
		@One varchar(1024)

	declare @tbl table (AGType varchar(255))

	insert into @tbl(AGType)
	select 
		distinct AGType 
	from dbo.PDXAgentLog 
	where ltrim(rtrim(isnull(AGType,''))) <> ''
	select @Res = @@error if @Res <> 0 goto Err

	select @List = 'ВСЕ/ALL'
	select @Res = @@error if @Res <> 0 goto Err

	while exists (select 1 from @tbl)
	begin
		select top 1
			@One = AGType
		from @tbl 
		order by AGType
		select @Res = @@error if @Res <> 0 goto Err
		
		select @List = @List + ',' + @One
		select @Res = @@error if @Res <> 0 goto Err

		delete from @tbl where AGType = @One
		select @Res = @@error if @Res <> 0 goto Err
	end

	select @List as AGList
	select @Res = @@error if @Res <> 0 goto Err

OK:

	return @Res
Err:
	return @Res
GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_AGLOGInfo] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_REP_AGLOGInfo]
	@AGType varchar(128),
	@DateFrom datetime,
	@DateTo datetime,
	@UserID varchar(255)
	
as
	declare 
	@Res int

	select @UserID = case dbo.PDX_SubstringReturn(@UserID,charindex('<',@UserID),charindex('>',@UserID))
						when ''
							then @UserID
						else '<'+dbo.PDX_SubstringReturn(@UserID,charindex('<',@UserID),charindex('>',@UserID))+'>'
					  end,
		@AGType = case @AGType when 'ВСЕ/ALL' then '' else ltrim(rtrim(@AGType)) end
	select @Res = @@error if @Res <> 0 goto Err
 
	select * from dbo.PDXAgentLog 
	where (AGType = @AGType or @AGType = '')
		and convert(datetime,convert(varchar(100),DateCreation,104),104) between convert(datetime,convert(varchar(100),@DateFrom,104),104) and convert(datetime,convert(varchar(100),@DateTo,104),104)
		and UserID like '%' + @UserID + '%'
	order by convert(datetime,convert(varchar(100),DateCreation,104),104), AgType, UserID
	select @Res = @@error if @Res <> 0 goto Err

OK:

	return @Res
Err:
	return @Res
GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_AllDocByActDoc] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[PDX_REP_AllDocByActDoc]
	@DateS datetime,
	@DateE datetime,
	@DocID varchar(128),
	@ActDoc varchar(255),
	@ClassDoc varchar(255),
	@RecName varchar(255),
	@NameApp varchar(255),
	@NameCr	varchar(255),
	@State int, --1 - все, 2- на согл, 3 - утв, 4 зарег., 5-на подписании
	@Access bit = 1

as

--declare @Result int
--select @Result = 0

	declare @Cls_vorbiden1 varchar(255),
			@Cls_vorbiden2 varchar(255)

	select 
		@Cls_vorbiden1 = dbo.PDX_CLSGet('RIK_CategoryName_SYSZADACHI'),
		@Cls_vorbiden2 = dbo.PDX_CLSGet('RIK_CategoryName_OTHERS_DOG')
	
	select @RecName = case dbo.PDX_SubstringReturn(@RecName,charindex('<',@RecName),charindex('>',@RecName))
						when ''
							then @RecName
						else '<'+dbo.PDX_SubstringReturn(@RecName,charindex('<',@RecName),charindex('>',@RecName))+'>'
					  end,
			@NameApp = case dbo.PDX_SubstringReturn(@NameApp,charindex('<',@NameApp),charindex('>',@NameApp))
						when ''
							then @NameApp
						else '<'+dbo.PDX_SubstringReturn(@NameApp,charindex('<',@NameApp),charindex('>',@NameApp))+'>'
					  end,
			@NameCr = case dbo.PDX_SubstringReturn(@NameCr,charindex('<',@NameCr),charindex('>',@NameCr))
						when ''
							then @NameCr
						else '<'+dbo.PDX_SubstringReturn(@NameCr,charindex('<',@NameCr),charindex('>',@NameCr))+'>'
					  end,
		    @DateS = CONVERT(datetime, CONVERT(varchar(100), @DateS, 104), 104),
		    @DateE = dateadd(SECOND,23*60*60+59*60+59,CONVERT(datetime, CONVERT(varchar(100), @DateE, 104), 104))


	select  case @Access when 1 then 'system_report' else DocID end as DocID,
		D.DocID as strID, 
		case isnull(year(D.DateActivation),1900)
			when 1900
				then D.UserFieldDate3
			else D.DateActivation
		end as DateActivation,
		D.NameCreation,
	 	D.Name,
		D.DateLastModification,
		D.ClassDoc,
		D.ListToReconcile,
		D.ListReconciled,
		D.NameAproval,
		case when isnull(LocationPath,'') like '%+%' then 'ДА' else '' end as isReg,
		ActDoc		
	from dbo.Docs D
	where upper(D.isActive) = 'Y' 
		and isnull(ActDoc,'') like '%' + @ActDoc + '%' 
		and D.ClassDoc like @ClassDoc + '%'
		and D.DateCreation between @DateS and @DateE

		and D.DocID like '%' + @DocID + '%'
		and isnull(D.ListToReconcile,'') like '%' + @RecName + '%'
		and isnull(D.NameAproval,'') like '%' + @NameApp + '%'
		and isnull(D.NameCreation,'') like '%' + @NameCr + '%'

		and isnull(D.StatusDevelopment,'') in (case @State
												when 1 --все
													then isnull(D.StatusDevelopment,'')
												when 2 --на согл (далее добавим еще 2 условия)
													then '1'
												when 3  --утв
													then '4'
												when 4 --зарег
													then '4'
												when 5 --на подпис
													then '3'
												end, 
											case @State when 2 then '2' else '-' end, --на согл
											case when @State in (2,3) then '' else '-' end)
		and isnull(D.LocationPath,'') like '%' + case @State when 4 then '+' else '' end + '%' 
 		and case @State when 3 then 1 else 0 end = case @State when 3 then dbo.PDX_CompareReconcilationList(D.ListToReconcile,D.ListReconciled) else 0 end

		and isnull(D.StatusDevelopment,'') <> '0'
		and isnull(D.StatusCompletion,'') <> '0'
		and isnull(D.StatusArchiv,'') <> '1'
		and not (
				D.ClassDoc = @Cls_vorbiden1
				or D.ClassDoc = @Cls_vorbiden2
				)
	order by 2,1 desc


	--select @Result = @@error if @Result <> 0 goto Err

--	return @Result
--Err:
	
--	return @Result


GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_AllDocByPartner] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE proc [dbo].[PDX_REP_AllDocByPartner]
	@DateS datetime,
	@DateE datetime,
	@DocID varchar(128),
	@ActDoc varchar(255),
	@ClassDoc varchar(255),
	@RecName varchar(255),
	@NameApp varchar(255),
	@NameCr	varchar(255),
	@PartnerName varchar(255),
	@State int, --1 - все, 2- на согл, 3 - утв, 4 зарег., 5-на подписании
	@Access bit = 1

as

--declare @Result int
--select @Result = 0
	declare @cls table (ClassName varchar(256), FieldName varchar(256))
	
	insert into @cls (ClassName, FieldName)
	select DocType, FieldName from dbo.PDXUserSettingDocTypes S 
	where S.DirType = -4

	/*declare @Cls_vorbiden1 varchar(255),
			@Cls_vorbiden2 varchar(255)

	select 
		@Cls_vorbiden1 = dbo.PDX_CLSGet('RIK_CategoryName_SYSZADACHI'),
		@Cls_vorbiden2 = dbo.PDX_CLSGet('RIK_CategoryName_OTHERS_DOG')
	*/
	select @RecName = case dbo.PDX_SubstringReturn(@RecName,charindex('<',@RecName),charindex('>',@RecName))
						when ''
							then @RecName
						else '<'+dbo.PDX_SubstringReturn(@RecName,charindex('<',@RecName),charindex('>',@RecName))+'>'
					  end,
			@NameApp = case dbo.PDX_SubstringReturn(@NameApp,charindex('<',@NameApp),charindex('>',@NameApp))
						when ''
							then @NameApp
						else '<'+dbo.PDX_SubstringReturn(@NameApp,charindex('<',@NameApp),charindex('>',@NameApp))+'>'
					  end,
			@NameCr = case dbo.PDX_SubstringReturn(@NameCr,charindex('<',@NameCr),charindex('>',@NameCr))
						when ''
							then @NameCr
						else '<'+dbo.PDX_SubstringReturn(@NameCr,charindex('<',@NameCr),charindex('>',@NameCr))+'>'
					  end,
		    @DateS = CONVERT(datetime, CONVERT(varchar(100), @DateS, 104), 104),
		    @DateE = dateadd(SECOND,23*60*60+59*60+59,CONVERT(datetime, CONVERT(varchar(100), @DateE, 104), 104)),
		    @PartnerName = ltrim(ISNULL(@PartnerName,''))

    If @PartnerName <> ''
	begin
		select  case @Access when 1 then 'system_report' else DocID end as DocID,
			D.DocID as strID, 
			case isnull(year(D.DateActivation),1900)
				when 1900
					then D.UserFieldDate3
				else D.DateActivation
			end as DateActivation,
			D.NameCreation,
	 		D.Name,
			D.DateCreation,
			D.DateApproved,
			D.ClassDoc,
			D.ListToReconcile,
			D.ListReconciled,
			D.NameAproval,
			case when isnull(D.LocationPath,'') like '%+%' then 'ДА' else '' end as isReg,
			D.ActDoc,			
			case c.FieldName
				when 'PartnerName' then D.PartnerName
				when 'UserFieldText1' then D.UserFieldText1
				when 'UserFieldText2' then D.UserFieldText2
				when 'UserFieldText3' then D.UserFieldText3
				when 'UserFieldText4' then D.UserFieldText4
				when 'UserFieldText5' then D.UserFieldText5
				when 'UserFieldText6' then D.UserFieldText6
				when 'UserFieldText7' then D.UserFieldText7
				when 'UserFieldText8' then D.UserFieldText8
				else '-'
			end as PartnerName,
			D.Currency						
		from dbo.Docs D
		inner join @cls c on c.ClassName = d.ClassDoc
		where upper(D.isActive) = 'Y' 
			and isnull(ActDoc,'') like '%' + @ActDoc + '%' 
			and D.ClassDoc like @ClassDoc + '%'
			and D.DateCreation between @DateS and @DateE

			and D.DocID like '%' + @DocID + '%'
			and isnull(D.ListToReconcile,'') like '%' + @RecName + '%'
			and isnull(D.NameAproval,'') like '%' + @NameApp + '%'
			and isnull(D.NameCreation,'') like '%' + @NameCr + '%'

			and isnull(D.StatusDevelopment,'') in (case @State
													when 1 --все
														then isnull(D.StatusDevelopment,'')
													when 2 --на согл (далее добавим еще 2 условия)
														then '1'
													when 3  --утв
														then '4'
													when 4 --зарег
														then '4'
													when 5 --на подпис
														then '3'
													end, 
												case @State when 2 then '2' else '-' end, --на согл
												case when @State in (2,3) then '' else '-' end)
			and isnull(D.LocationPath,'') like '%' + case @State when 4 then '+' else '' end + '%' 
 			and case @State when 3 then 1 else 0 end = case @State when 3 then dbo.PDX_CompareReconcilationList(D.ListToReconcile,D.ListReconciled) else 0 end

			and isnull(D.StatusDevelopment,'') <> '0'
			and isnull(D.StatusCompletion,'') <> '0'
			and isnull(D.StatusArchiv,'') <> '1'
			
			and case c.FieldName
					when 'PartnerName' then D.PartnerName
					when 'UserFieldText1' then D.UserFieldText1
					when 'UserFieldText2' then D.UserFieldText2
					when 'UserFieldText3' then D.UserFieldText3
					when 'UserFieldText4' then D.UserFieldText4
					when 'UserFieldText5' then D.UserFieldText5
					when 'UserFieldText6' then D.UserFieldText6
					when 'UserFieldText7' then D.UserFieldText7
					when 'UserFieldText8' then D.UserFieldText8
					else '-'
				end = @PartnerName
      
			/*and not (
					D.ClassDoc = @Cls_vorbiden1
					or D.ClassDoc = @Cls_vorbiden2
					)*/
		order by 6,2 desc
	end
	else
	begin
	
		select top 0 '' as DocID,
			'' as strID, 
			'' as DateActivation,
			'' as NameCreation,
	 		'' as Name,
			'1900-01-01' as DateCreation,
			'1900-01-01' as DateApproved,
			'' as ClassDoc,
			'' as ListToReconcile,
			'' as ListReconciled,
			'' as NameAproval,
			'' as isReg,
			'' as ActDoc,
			'' as PartnerName	,
			'' as Currency	
			
	end

	--select @Result = @@error if @Result <> 0 goto Err

--	return @Result
--Err:
	
--	return @Result



GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_AppWithUnCompletedRec] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_REP_AppWithUnCompletedRec]

as

declare @Result int
select @Result = 0

	select 
		DocID as strID, 
		ListToReconcile, 
		ListReconciled, 
		NameCreation, 
		NameAproval,
		case isnull(year(DateActivation),1900)
			when 1900
				then UserFieldDate3
			else DateActivation
		end as DocDate, 
		Name, 
		ClassDoc, 
		isnull(LocationPath,'') as LocationPath
	from dbo.Docs
	where upper(isActive) = 'Y'
		and isnull(StatusDevelopment,'') = '4' --утвержденные
		and isnull(StatusCompletion,'') <> '0' --неотмененные 
		--and ltrim(rtrim(replace(replace(isnull(ListToReconcile,''),'(#$)',''),'(#!)',''))) <> ''
		and ltrim(rtrim(replace(replace(replace(isnull(ListToReconcile,''),'<(#!)>',''),'(#$)',''),'(#!)',''))) <> ''
		and isnull(ListToReconcile,'') like '%<%>%'
		and dbo.PDX_CompareReconcilationList(replace(ListToReconcile,'(#$)',''), ListReconciled) = 0
	order by DocID
	select @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:
	
	return @Result

GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_CheckFiredUser] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_REP_CheckFiredUser]
	@UserID varchar(16)
as

declare @Result int
select @Result = 0

	create table #dcs
		(DocID varchar(255),
		ClassDoc varchar(255),
		UserID varchar(255),
		Descr varchar(512),
		DateEvent datetime,
		DateEventEnd datetime,
		Type int,
		CommentType varchar(16),
		Address varchar(125),
		SpecialInfo varchar(512),
		UserName varchar(64),
		Comment varchar(255))

	select @UserID = ltrim(rtrim(@UserID))
	select @Result = @@error if @Result <> 0 goto Err

/*****UNION**************************************/
	insert into #dcs
		(DocID,ClassDoc,UserID,Descr,DateEvent,DateEventEnd,Type,CommentType,Address,SpecialInfo,UserName,Comment)
	exec dbo. PDX_UNI_DocsToVISA
		@UserID = @UserID,
		@Type = null
	select @Result = @@error if @Result <> 0 goto Err
/*****РАБОЧИЕ ДОКУМЕНТЫ***************************/
	insert into #dcs
		(DocID,ClassDoc,UserID,Descr,DateEvent,DateEventEnd,Type,CommentType,SpecialInfo,UserName,Comment)
	select 
		DocID,
		ClassDoc,
		@UserID,
		cast('<b>' + case len(isnull(D.Name,'')) when 0 then D.Description else D.Name end + '</b>' as varchar(125)) +
				case when len('<b>' + case isnull(len(D.Name),0) when 0 then D.Description else D.Name end + '</b>') > 125 then ' ...' else '' end +
				 + case len(isnull(D.Name,'')+isnull(D.Description,'')) when 0 then '' else '<br>' end,
		DateCreation,
		null,
		110,
		'',isActive,'',''
	from dbo.Docs D
	where ltrim(rtrim(isnull(StatusDevelopment,''))) in ('','1','2','3') 
		and not isnull(StatusCompletion,'') in ('1','0') 
		and NameCreation like '%<'+@UserID+'>%' 
	select @Result = @@error if @Result <> 0 goto Err
/*****АРХИВ**************************************/
	insert into #dcs
		(DocID,ClassDoc,UserID,Descr,DateEvent,DateEventEnd,Type,CommentType,SpecialInfo,UserName,Comment)
	select 
		DocID,
		ClassDoc,
		@UserID,
		cast('<b>' + case len(isnull(D.Name,'')) when 0 then D.Description else D.Name end + '</b>' as varchar(125)) +
				case when len('<b>' + case isnull(len(D.Name),0) when 0 then D.Description else D.Name end + '</b>') > 125 then ' ...' else '' end +
				 + case len(isnull(D.Name,'')+isnull(D.Description,'')) when 0 then '' else '<br>' end,
		DateApproved,
		null,
		120,
		'','','',''
	from dbo.Docs D
	where ltrim(rtrim(isnull(StatusDevelopment,''))) = '4'
		and upper(isnull(isActive,'')) = 'Y'
		and ClassDoc like 'Договоры /%'
		and NameCreation like '%<'+@UserID+'>%' 
		and not LocationPath like '%+%'
	select @Result = @@error if @Result <> 0 goto Err

	update #dcs
		set UserName = '',
			Descr = replace(replace(replace(Descr,'<b>',''),'</b>',''),'<br>','')
	select @Result = @@error if @Result <> 0 goto Err
/*****ЗАМЕЩЕНИЕ И РОЛИ***************************/		
	insert into #dcs
		(DocID,ClassDoc,UserID,Descr,DateEvent,DateEventEnd,Type,CommentType,SpecialInfo,UserName,Comment)
	select
		null,--DocID,
		'',--ClassDoc,
		@UserID,--UserID,
		'ЗАМЕСТИТЕЛЬ пользователя "' + Name + '" <' + UserID + '>;',--Descr,
		DeputyDateFrom,--DateEvent,
		DeputyDateTo,--DateEventEnd,
		130,--Type,
		'',--CommentType,
		'',--SpecialInfo,
		UserID,--UserName,
		''--Comment
	from dbo.Users
	where DeputyID = @UserID
		and convert(datetime,convert(varchar(100),DeputyDateTo,104),104)>=convert(datetime,convert(varchar(100),getdate(),104),104)
	select @Result = @@error if @Result <> 0 goto Err

	insert into #dcs
		(DocID,ClassDoc,UserID,Descr,DateEvent,DateEventEnd,Type,CommentType,SpecialInfo,UserName,Comment)
	select
		null,--DocID,
		'',--ClassDoc,
		@UserID,--UserID,
		'Под ролью данного пользователя работает: "' + Name + '" <' + UserID + '>;',--Descr,
		null,--DateEvent,
		null,--DateEventEnd,
		140,--Type,
		'',--CommentType,
		'',--SpecialInfo,
		UserID,--UserName,
		''--Comment
	from dbo.Users
	where PossibleRoles like '%<' + @UserID + '>%'
	select @Result = @@error if @Result <> 0 goto Err

	insert into #dcs
		(DocID,ClassDoc,UserID,Descr,DateEvent,DateEventEnd,Type,CommentType,SpecialInfo,UserName,Comment)
	select
		null,--DocID,
		'',--ClassDoc,
		@UserID,--UserID,
		'Данный пользователь работает под ролями: "' + PossibleRoles,--Descr,
		null,--DateEvent,
		null,--DateEventEnd,
		140,--Type,
		'',--CommentType,
		'',--SpecialInfo,
		'',--UserName,
		''--Comment
	from dbo.Users
	where UserID = @UserID
		and ltrim(rtrim(isnull(PossibleRoles,''))) <> ''
	select @Result = @@error if @Result <> 0 goto Err
/*****ОТВЕТСТВЕННЫЕ***************************/
	insert into #dcs
		(DocID,ClassDoc,UserID,Descr,DateEvent,DateEventEnd,Type,CommentType,SpecialInfo,UserName,Comment)
	select top 1
		null,--DocID,
		'',--ClassDoc,
		@UserID,--UserID,
		'Пользователь прописан в справочнике: Системные / Ответственные по видам деят-ти',--Descr,
		null,--DateEvent,
		null,--DateEventEnd,
		150,--Type,
		'',--CommentType,
		'',--SpecialInfo,
		'',--UserName,
		''--Comment
	from dbo.PDXBranchSettings
	where Fld2 like '%<' + @UserID + '>%'
		or Fld3 like '%<' + @UserID + '>%'
		or Fld4 like '%<' + @UserID + '>%'
		--or Fld5 like '%<' + @UserID + '>%'
		or Fld6 like '%<' + @UserID + '>%'
		--or Fld7 like '%<' + @UserID + '>%'
		or Fld8 like '%<' + @UserID + '>%'
		or Fld9 like '%<' + @UserID + '>%'
	select @Result = @@error if @Result <> 0 goto Err

	insert into #dcs
		(DocID,ClassDoc,UserID,Descr,DateEvent,DateEventEnd,Type,CommentType,SpecialInfo,UserName,Comment)
	select distinct
		null,--DocID,
		'',--ClassDoc,
		@UserID,--UserID,
		'Данный пользователь является ответственым за делопроизводство подразделения: ' + Name + ' (справочник "Подразделения")',--Descr,
		null,--DateEvent,
		null,--DateEventEnd,
		150,--Type,
		'',--CommentType,
		'',--SpecialInfo,
		'',--UserName,
		''--Comment
	from dbo.Departments
	where LocationPath like '%<' + @UserID + '>%'
	select @Result = @@error if @Result <> 0 goto Err

	insert into #dcs
		(DocID,ClassDoc,UserID,Descr,DateEvent,DateEventEnd,Type,CommentType,SpecialInfo,UserName,Comment)
	select distinct
		null,--DocID,
		'',--ClassDoc,
		@UserID,--UserID,
		'Пользователь прописан в справочнике: ' + D.Name,--Descr,
		null,--DateEvent,
		null,--DateEventEnd,
		150,--Type,
		'',--CommentType,
		'',--SpecialInfo,
		'',--UserName,
		''--Comment
	from dbo.UserDirValues V
	inner join dbo.UserDirectories D on D.KeyField = V.UDKeyField
	where V.Field1 like '%<' + @UserID + '>%'
		or V.Field2 like '%<' + @UserID + '>%'
		or V.Field3 like '%<' + @UserID + '>%'
		or V.Field4 like '%<' + @UserID + '>%'
		or V.Field5 like '%<' + @UserID + '>%'
		or V.Field6 like '%<' + @UserID + '>%'
		or V.Field1 = @UserID
		or V.Field2 = @UserID
		or V.Field3 = @UserID
		or V.Field4 = @UserID
		or V.Field5 = @UserID
		or V.Field6 = @UserID
	select @Result = @@error if @Result <> 0 goto Err

	insert into #dcs
		(DocID,ClassDoc,UserID,Descr,DateEvent,DateEventEnd,Type,CommentType,SpecialInfo,UserName,Comment)
	select distinct
		null,--DocID,
		'',--ClassDoc,
		@UserID,--UserID,
		'Пользователь прописан в справочнике: Системные / Отказ в согласовании',--Descr,
		null,--DateEvent,
		null,--DateEventEnd,
		150,--Type,
		'',--CommentType,
		'',--SpecialInfo,
		'',--UserName,
		''--Comment
	from dbo.PDXDocRefuse
	where UserID like '%<' + @UserID + '>%'
		or UserID = @UserID
	select @Result = @@error if @Result <> 0 goto Err

	insert into #dcs
		(DocID,ClassDoc,UserID,Descr,DateEvent,DateEventEnd,Type,CommentType,SpecialInfo,UserName,Comment)
	select distinct
		null,--DocID,
		'',--ClassDoc,
		@UserID,--UserID,
		'Пользователь прописан в справочнике: Системные / Комитеты',--Descr,
		null,--DateEvent,
		null,--DateEventEnd,
		150,--Type,
		'',--CommentType,
		'',--SpecialInfo,
		'',--UserName,
		''--Comment
	from dbo.PDXKomitet
	where Field1 like '%<' + @UserID + '>%'
		or Field2 like '%<' + @UserID + '>%'
		or Field3 like '%<' + @UserID + '>%'
		or Field4 like '%<' + @UserID + '>%'
		or Field5 like '%<' + @UserID + '>%'
		or Field6 like '%<' + @UserID + '>%'
		or Field7 like '%<' + @UserID + '>%'
		or Field1 = @UserID
		or Field2 = @UserID
		or Field3 = @UserID
		or Field4 = @UserID
		or Field5 = @UserID
		or Field6 = @UserID
		or Field7 = @UserID
	select @Result = @@error if @Result <> 0 goto Err

	insert into #dcs
		(DocID,ClassDoc,UserID,Descr,DateEvent,DateEventEnd,Type,CommentType,SpecialInfo,UserName,Comment)
	select distinct
		null,--DocID,
		'',--ClassDoc,
		@UserID,--UserID,
		'Пользователь прописан в справочнике: Системные / Специальное согласование',--Descr,
		null,--DateEvent,
		null,--DateEventEnd,
		150,--Type,
		'',--CommentType,
		'',--SpecialInfo,
		'',--UserName,
		''--Comment
	from dbo.PDXReconcilationRules
	where UserName like '%<' + @UserID + '>%'
	select @Result = @@error if @Result <> 0 goto Err

	insert into #dcs
		(DocID,ClassDoc,UserID,Descr,DateEvent,DateEventEnd,Type,CommentType,SpecialInfo,UserName,Comment)
	select distinct
		null,--DocID,
		'',--ClassDoc,
		@UserID,--UserID,
		'Пользователь прописан в справочнике: Системные / Тех. поддержка',--Descr,
		null,--DateEvent,
		null,--DateEventEnd,
		150,--Type,
		'',--CommentType,
		'',--SpecialInfo,
		'',--UserName,
		''--Comment
	from dbo.PDXSupport
	where Login like '%<' + @UserID + '>%'
		or Login = @UserID
	select @Result = @@error if @Result <> 0 goto Err

	insert into #dcs
		(DocID,ClassDoc,UserID,Descr,DateEvent,DateEventEnd,Type,CommentType,SpecialInfo,UserName,Comment)
	select distinct
		null,--DocID,
		'',--ClassDoc,
		@UserID,--UserID,
		'Пользователь прописан в справочнике: Системные / Специальный срок согласования',--Descr,
		null,--DateEvent,
		null,--DateEventEnd,
		150,--Type,
		'',--CommentType,
		'',--SpecialInfo,
		'',--UserName,
		''--Comment
	from dbo.PDXTimeBound
	where UserID like '%<' + @UserID + '>%'
		or UserID = @UserID
	select @Result = @@error if @Result <> 0 goto Err

	insert into #dcs
		(DocID,ClassDoc,UserID,Descr,DateEvent,DateEventEnd,Type,CommentType,SpecialInfo,UserName,Comment)
	select distinct
		null,--DocID,
		'',--ClassDoc,
		@UserID,--UserID,
		'Пользователь подписан на рассылки (справочник: Системные / Подписка на рассылку)',--Descr,
		null,--DateEvent,
		null,--DateEventEnd,
		1,--Type,
		'',--CommentType,
		'',--SpecialInfo,
		'',--UserName,
		''--Comment
	from dbo.PDXSubscribe
	where UserID like '%<' + @UserID + '>%'
		or UserID = @UserID
	select @Result = @@error if @Result <> 0 goto Err

	insert into #dcs
		(DocID,ClassDoc,UserID,Descr,DateEvent,DateEventEnd,Type,CommentType,SpecialInfo,UserName,Comment)
	select top 1
		null,--DocID,
		Name,--ClassDoc,
		@UserID,--UserID,
		case when StatusActive = '1' and convert(datetime,convert(varchar(100), DateExpirationSecurity,104),104)>=convert(datetime,convert(varchar(100), getdate(),104),104)
			then 'АКТИВНОЕ подключение. Срок действия до ' + convert(varchar(100), DateExpirationSecurity,104) + '.'
		     when StatusActive = '1' and convert(datetime,convert(varchar(100), DateExpirationSecurity,104),104)<convert(datetime,convert(varchar(100), getdate(),104),104)
			then 'Срок действия ПОДКЛЮЧЕНИЯ истек (' + convert(varchar(100), DateExpirationSecurity,104) + ').'
		     when StatusActive = '-' and convert(datetime,convert(varchar(100), DateExpirationSecurity,104),104)>=convert(datetime,convert(varchar(100), getdate(),104),104)
			then 'Только как роль. Срок действия до ' + convert(varchar(100), DateExpirationSecurity,104) + '.'
		     when StatusActive = '-' and convert(datetime,convert(varchar(100), DateExpirationSecurity,104),104)<convert(datetime,convert(varchar(100), getdate(),104),104)
			then 'Срок действия РОЛИ истек (' + convert(varchar(100), DateExpirationSecurity,104) + ').'
		     else 'Доступ запрещен.' 
		end + 
		case when isnull(Permitions,'') like '%*%' then ' ПОЛЬЗОВАТЕЛЬ(роль) СКРЫТ(а).' else '' end ,--Descr,
		null,--DateEvent,
		DateExpirationSecurity,--DateEventEnd,
		case when StatusActive = '1' and convert(datetime,convert(varchar(100), DateExpirationSecurity,104),104)>=convert(datetime,convert(varchar(100), getdate(),104),104)
			then 0
		     else -1 
		end,--Type,
		'',--CommentType,
		'',--SpecialInfo,
		UserID,--UserName,
		''--Comment
	from dbo.Users
	where UserID = @UserID
	select @Result = @@error if @Result <> 0 goto Err

	select 
		case Type
			when -1 then 'ДОСТУП В СЭД запрещен'
			when 0 then 'ДОСТУП В СЭД'
			when 1 then 'подписка'
			when 10 then 'на согласовании'
			when 20 then 'на рецензии'
			when 30 then 'на подписании' 
			when 40 then 'на утверждении/завершении'
			when 50 then 'на ознакомлении'
			when 60 then 'на контроле'
			when 70 then 'на исполнении'
			when 110 then
				case when upper(isnull(SpecialInfo,'')) = 'Y' then 'рабочие проекты документов' else 'черновые проекты документов (неактивен)' end
			when 120 then 'не сдано в архив'
			when 130 then 'замещение'
			when 140 then 'роль'
			when 150 then 'ответственный'
		end TypeName,
		case Type
			when 130 then 2 --замещение
			when 140 then 3 --роль
			when 150 then 4 --ответственный
			else Type
		end as Type,
		DocID as strID,
		ClassDoc,
		UserID,
		Descr,
		DateEvent,
		DateEventEnd,
		CommentType,
		SpecialInfo,
		UserName,
		Comment
	from #dcs
	ORDER BY 2,1,DateEventEnd,DocID 
	select @Result = @@error if @Result <> 0 goto Err

	drop table #dcs
	return @Result
Err:
	
	drop table #dcs
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_CheckUserName] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_REP_CheckUserName]
	@UserID varchar(16),
	@UserName varchar(255)
as

declare @Result int
select @Result = 0

	select @UserID = ltrim(@UserID),
		@UserName = ltrim(@UserName) --правые пробелы иогут пригодиться
	select @Result = @@error if @Result <> 0 goto Err

	select *,
		case StatusActive
			when '1' then 'активное подключение'
			when '-' then 'только как роль'
			else 'неактивное подключение'
		end as StatusName
	from dbo.Users 
	where isnull(Name,'') like '%' + isnull(@UserName,'') + '%'
		and isnull(UserID,'') like '%' + isnull(@UserID,'') + '%'
	select @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:
	
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_ClearingCertf_Find] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_REP_ClearingCertf_Find]
	@Str varchar(255),
	@CrName varchar(255),
	@DocID varchar(128),
	@Reconcil varchar(255),
	@ActDoc varchar(128),
	@Access bit = 1
as

--declare @Result int
--select @Result = 0

	select case @Access when 1 then 'system_report' else DocID end as DocID,
		DocID as strID, 
		Name, 
		Description, 
		NameCreation, 
		DateActive ,
		ActDoc,
		ListReconciled,
		ListReconciled,
		Department
	from dbo.Docs with (nolock)
	where (Name like '%'+@Str+'%' or Description like '%'+@Str+'%')
		and NameCreation like '%'+@CrName+'%'
		and DocID like '%'+@DocID+'%'
		and ActDoc like '%'+@ActDoc+'%'
		and ListToReconcile like '%'+@Reconcil+'%'
		and ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_CLEARING_C')
		and upper(isnull(isActive,'')) = 'Y'
		and StatusDevelopment <> '0' 
		and isnull(StatusCompletion,'') <> '0'
	order by dateCreation, DocID
	--select @Result = @@error if @Result <> 0 goto Err

--	return @Result
--Err:
	
--	return @Result

GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_COR_CorrespFind] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_REP_COR_CorrespFind]
	@DateF datetime,
	@DateT datetime,
	@ActDoc varchar(255),
	@Code varchar(255),
	@WithChild bit = 0,
	@Type varchar(5), -- [2] - входящ
						--[1] - исх ,
	@Access bit = 1

as

--declare @Result int
--select @Result = 0
   
   select @Code = LTRIM(rtrim(isnull(@Code,'')))
   If @Code = '' or @WithChild=1 
   begin
		select @Code = @Code + '%'
   end

    If @Type = '2'
	begin
		select  case @Access when 1 then 'system_report' else DocID end as DocID,
			DocID as strID, 
			DocIDAdd,
			UserFieldDate3 as DateActivation,
			ActDoc, 
			UserFieldText4, 
			UserFieldText1,
			ltrim(substring(ClassDoc,charindex('-', ClassDoc)+1, len(ClassDoc))) as ClassDoc, 
			Name, 
			DocIDIncoming, 
			PartnerName, 
			UserFieldText5, 
			NameAproval, 
			Resolution, 
			StatusDevelopment,
			case StatusDevelopment
				when '4'
					then '+'
				when '0' 
					then '-'
				else ''
			end as Status,
			NameCreation
		from dbo.Docs 
		where (ActDoc = @ActDoc or @ActDoc = '')
			/*and DocID like dbo.PDX_SubstringReturn(@ActDoc,charindex('<',@ActDoc),charindex('>',@ActDoc)) +
				case dbo.PDX_SubstringReturn(@ActDoc,charindex('<',@ActDoc),charindex('>',@ActDoc))
				when '' then '' else '-' end + '0[2,4]-' + @Code + '-%'*/
			and DocID like '0[2,4]-' + @Code + '-%'
			and convert(datetime,convert(varchar(50),UserFieldDate3,101),121)  between @DateF and @DateT
			and isnull(StatusCompletion,'') <> '0' 
			and upper(isnull(isActive,'')) = 'Y'
			and ClassDoc like 'Корреспонденция / Входящие%' and StatusArchiv<>'1' and ExtInt=' ' 
		order by UserFieldDate3,DocID
	end
	else if @Type = '1'
	begin
		select case @Access when 1 then 'system_report' else DocID end as DocID,
			DocID as strID, 
			DocIDAdd,
			DateActivation, 
			ActDoc, 
			UserFieldText4, 
			UserFieldText1 + case LEN(ltrim(rtrim(isnull(UserFieldText1,'')))) when 0 then '' else CHAR(13)+CHAR(10) end +
				UserFieldText2 +
				case LEN(ltrim(rtrim(isnull(UserFieldText1,'')+isnull(UserFieldText2,'')))) when 0 then '' else CHAR(13)+CHAR(10) end +
				ListToView as UserFieldText1,
			ltrim(substring(ClassDoc,charindex('-', ClassDoc)+1, len(ClassDoc))) as ClassDoc, 
			Name, 
			DocIDIncoming, 
			PartnerName, 
			UserFieldText5, 
			NameAproval, 
			Resolution, 
			StatusDevelopment,
			case StatusDevelopment
				when '4'
					then '+'
				when '0' 
					then '-'
				else ''
			end as Status,
			NameCreation
		from dbo.Docs 
		where (ActDoc = @ActDoc or @ActDoc = '') 
			/*and DocID like dbo.PDX_SubstringReturn(@ActDoc,charindex('<',@ActDoc),charindex('>',@ActDoc)) +
				case dbo.PDX_SubstringReturn(@ActDoc,charindex('<',@ActDoc),charindex('>',@ActDoc))
				when '' then '' else '-' end + '0[1,3]-' + @Code + '-%'*/
		and DocID like '0[1,3]-' + @Code + '-%'
		and convert(datetime,convert(varchar(50),DateActivation,101),121)  between @DateF and @DateT
		and LocationPath like '%+%' 
		and StatusDevelopment = '4' 
		and isnull(StatusCompletion,'') <> '0' 
		and upper(isnull(isActive,'')) = 'Y'
		and ClassDoc like 'Корреспонденция / Исходящие%' and StatusArchiv<>'1' and ExtInt=' ' 
		order by DateActivation,DocID
	end

	--select @Result = @@error if @Result <> 0 goto Err

--	return @Result
--Err:
	
--	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_COR_IshodFind] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

create proc [dbo].[PDX_REP_COR_IshodFind]
	@DocID varchar(128),
	@DA_f datetime,
	@DA_t datetime,
	@ActDoc varchar(128),
	@UFT4 varchar(256),
	@UFT1 varchar(1024),
	@UFT2 varchar(1024),
	@LTV varchar(1024),
	@Corr varchar(96),
	@DInc varchar(128),
	@DPr varchar(128),
	@Name varchar(1024),
	@LTR varchar(1024),
	@Dep varchar(512),
	@Aut varchar(96),
	@NA varchar(96),
	@DPar varchar(128),
	@Resol varchar(256),
	@NCr varchar(128),
	@Aut_c varchar(32),
	@Access bit = 0

as


--declare @Result int
--select @Result = 0
declare @Adept varchar(1024)

    select @Aut_c = ltrim(rtrim(isnull(@Aut_c,''))), @Adept = ''
    
    if @Aut_c <> ''
    begin
		select @Adept = case right(ltrim(rtrim(name)),1) when '/' then LEFT(ltrim(rtrim(name)), LEN(ltrim(rtrim(name)))-1) else Name end
		from Departments
		where DocFlowCode = @Aut_c
    end
    
	select 
		@DocID = ltrim(rtrim(ISNULL(@DocID,''))),
		@DA_f = ISNULL(@DA_f,'1900-01-01'),
		@DA_t = ISNULL(@DA_t,'1900-01-01'),
		@ActDoc = ltrim(rtrim(ISNULL(@ActDoc,''))),
		@UFT4 = ltrim(rtrim(ISNULL(@UFT4,''))),
		@UFT1 = ltrim(rtrim(ISNULL(@UFT1,''))),
		@UFT2 = ltrim(rtrim(ISNULL(@UFT2,''))),
		@LTV = case when ltrim(rtrim(ISNULL(@LTV,''))) like '%<%>%'
				then '<' + dbo.PDX_SubstringReturn(ISNULL(@LTV,''), charindex('<',ISNULL(@LTV,'')), charindex('>', ISNULL(@LTV,''))) + '>'
				else ltrim(rtrim(ISNULL(@LTV,'')))
				end, 
		@Corr = case when ltrim(rtrim(ISNULL(@Corr,''))) like '%<%>%'
				then '<' + dbo.PDX_SubstringReturn(ISNULL(@Corr,''), charindex('<',ISNULL(@Corr,'')), charindex('>', ISNULL(@Corr,''))) + '>'
				else ltrim(rtrim(ISNULL(@Corr,'')))
				end, 
		@DInc = ltrim(rtrim(ISNULL(@DInc,''))),
		@DPr = ltrim(rtrim(ISNULL(@DPr,''))),
		@DPar = ltrim(rtrim(ISNULL(@DPar,''))),		
		@Name = ltrim(rtrim(ISNULL(@Name,''))),		
		@LTR = case when ltrim(rtrim(ISNULL(@LTR,''))) like '%<%>%'
				then '<' + dbo.PDX_SubstringReturn(ISNULL(@LTR,''), charindex('<',ISNULL(@LTR,'')), charindex('>', ISNULL(@LTR,''))) + '>'
				else ltrim(rtrim(ISNULL(@LTR,'')))
				end,
		@Dep = ltrim(rtrim(ISNULL(@Dep,''))),		
		@NA = case when ltrim(rtrim(ISNULL(@NA,''))) like '%<%>%'
				then '<' + dbo.PDX_SubstringReturn(ISNULL(@NA,''), charindex('<',ISNULL(@NA,'')), charindex('>', ISNULL(@NA,''))) + '>'
				else ltrim(rtrim(ISNULL(@NA,'')))
				end,
		@Aut= case when ltrim(rtrim(ISNULL(@Aut,''))) like '%<%>%'
				then '<' + dbo.PDX_SubstringReturn(ISNULL(@Aut,''), charindex('<',ISNULL(@Aut,'')), charindex('>', ISNULL(@Aut,''))) + '>'
				else ltrim(rtrim(ISNULL(@Aut,'')))
				end,
		@Resol = ltrim(rtrim(ISNULL(@Resol,''))),
		@NCr = ltrim(rtrim(ISNULL(@NCr,'')))
		

	select  case @Access when 1 then 'system_report' else DocID end as DocID,
		D.DocID as strID, 
		D.DateActivation,
		D.DocIDadd,
		D.Author,
		D.ActDoc,
		D.UserFieldText4,
		D.PartnerName,
		D.UserFieldText5,
		D.UserFieldText1,
		D.Department,
		D.NameAproval,
		D.DocIdIncoming,
		D.UserFieldDate1,
		D.DocIDPrevious,
		D.UserFieldText2,
		D.Name,
		D.Description,
		D.Resolution,
		D.ListToView,
		D.Correspondent,
		D.DocIDParent,
		D.SecurityLevel,
		D.StatusDevelopment,
		D.NameCreation,
		D.ListToReconcile,
		D.ListReconciled,
		U.Department as UDept
	from dbo.Docs D
	left join dbo.Users U on isnull(D.Author,'') like '%<' + U.UserID + '>%'
	where isnull(D.StatusCompletion,'') <> '0' 
		and isnull(D.StatusDevelopment,'') <> '0' 
		and upper(isnull(D.isActive,'')) = 'Y'
		and D.ClassDoc in (dbo.PDX_CLSGet('RIK_CategoryName_ISHO_VNESH'), dbo.PDX_CLSGet('RIK_CategoryName_ISHO_VNUTR'))
		and D.StatusArchiv<>'1' and D.ExtInt=' ' 
		
		and isnull(D.DocID,'') like '%' + @DocID + '%' --	Рег.номер вх. документа
		and isnull(D.DateActivation, '1900-01-01') between @DA_f and @DA_t --	Дата регистрации 
		and isnull(D.ActDoc,'') like '%' + @ActDoc + '%' --	Вид деятельности
		and isnull(D.UserFieldText4,'') like '%' + @UFT4 + '%' --	Проект
		and isnull(D.UserFieldText1,'') like '%' + @UFT1 + '%' -- 
		and isnull(D.UserFieldText2,'') like '%' + @UFT2 + '%' --	
		and isnull(D.ListToView,'') like '%' + @Corr + '%'	--	
		and isnull(D.Correspondent,'') like '%' + @Corr + '%'	--	Список рассылки
		and isnull(D.DocIdIncoming,'')	like '%' + @DInc + '%' --Исх. номер документа
		and isnull(D.DocIDPrevious,'') like '%' + @DPr + '%' --	На номер
		and isnull(D.DocIDParent,'')	like '%' + @DPar + '%' --Рег. № родит. док-та
		and (isnull(D.Name,'') like '%' + @Name + '%'	--Заголовок
			or isnull(D.Description,'') like '%' + @Name + '%')	--Перечень приложений
		and isnull(D.ListToReconcile,'')	 like '%' + @LTR + '%' --
		and isnull(D.Department,'')	like '%' + @Dep + '%' --Подразделение 
		and isnull(D.Author,'') like '%' + @Aut + '%' -- 		
		and isnull(D.NameAproval,'')	like '%' + @NA + '%' --отправитель
		and isnull(D.Resolution,'') like '%' + @Resol + '%'	--Резолюция
		and isnull(D.NameCreation,'') like '%' + @NCr + '%'	--создатель
		
		and isnull(U.Department,'')	like '%' + @Adept + '%' --Подразделение пользователя
		
		
	order by DateActivation,DocID
	

	--select @Result = @@error if @Result <> 0 goto Err

--	return @Result
--Err:
	
--	return @Result

GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_COR_ISHODocsInfo] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_REP_COR_ISHODocsInfo]
	@DocID varchar(128)

as

declare @Result int
select @Result = 0
   
	select *, Resolution as Resolution1
	from dbo.Docs 
	where DocIDIncoming = @DocID
		and ClassDoc like 'Корреспонденция / Входящие%' 
		and upper(isnull(isActive,'')) = 'Y' 
		and isnull(StatusDevelopment,'') <> '0' 
		and isnull(StatusCompletion,'')<>'0'
	select @Result = @@error if @Result <> 0 goto Err

/*	create table #tbl  
		(DocID varchar(128),
		Resolution varchar(7000))

	create table #tbl1  
		(DocID varchar(128),
		Resolution varchar(1024),
		DateCreation datetime,
		Keyfield int)
	
	declare 
		@DocID1 varchar(128),
		@Resolution varchar(2048),
		@Keyfield int,
		@i int

	insert into #tbl
		(DocID, Resolution)
	select DocID, ''
	from dbo.Docs 
	where DocIDIncoming = @DocID
		and ClassDoc like 'Корреспонденция / Входящие%' 
		and upper(isnull(isActive,'')) = 'Y' 
		and isnull(StatusDevelopment,'') <> '0' 
		and isnull(StatusCompletion,'')<>'0'
	select @Result = @@error if @Result <> 0 goto Err

	insert into #tbl1 
		(DocID,Resolution,DateCreation, KeyField)
	select
		C.DocID,C.Comment,C.DateCreation,C.KeyField
	from dbo.Comments C
	inner join #tbl T on T.DocID = C.DocID 
	where upper(isnull(C.CommentType,'')) = 'RESOLUTION'
	select @Result = @@error if @Result <> 0 goto Err

	select @i = 0, @DocID1 = ''
	while exists (select 1 from #tbl1)
	begin
		select top 1
			@DocID = DocID,
			@KeyField = KeyField,
			@i = case @DocID1 when @DocID then @i+1 else 1 end,
			@Resolution = convert(varchar(100),DateCreation,104) + space(1) + Resolution
		from #tbl1 
		order by DocID, DateCreation desc
		select @Result = @@error if @Result <> 0 goto Err
		
		select @DocID1 = @DocID
		select @Result = @@error if @Result <> 0 goto Err

		update #tbl
		set Resolution = cast(Resolution + case Resolution when '' then '' else '<br>' end + '<b>'+cast(@i as varchar(10)) + '.</b> ' + @Resolution as varchar(7000))
		where DocID = @DocID
		delete from #tbl1 where KeyField = @KeyField
		select @Result = @@error if @Result <> 0 goto Err
	end 

	select D.*, T.Resolution as Resolution1
	from #tbl as T
	inner join dbo.Docs D on D.DocID = T.DocID 
	select @Result = @@error if @Result <> 0 goto Err

	drop table #tbl1
	drop table #tbl*/
	return @Result
Err:
	
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_COR_VhodFind] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

create proc [dbo].[PDX_REP_COR_VhodFind]
	@DocID varchar(128),
	@UFD3_f datetime,
	@UFDT_t datetime,
	@ActDoc varchar(128),
	@UFT4 varchar(256),
	@PN varchar(512),
	@UFT5 varchar(1024),
	@UFT1 varchar(1024),
	@UFT2 varchar(1024),
	@Dep varchar(512),
	@NA varchar(96),
	@DInc varchar(128),
	@DPr varchar(128),
	@Name varchar(1024),
	@Resol varchar(256),
	@Corr varchar(96),
	@DPar varchar(128),
	@NCr varchar(128),
	@Access bit = 0

as

--declare @Result int
--select @Result = 0
	select 
		@DocID = ltrim(rtrim(ISNULL(@DocID,''))),
		@UFD3_f = ISNULL(@UFD3_f,'1900-01-01'),
		@UFDT_t = ISNULL(@UFDT_t,'1900-01-01'),
		@ActDoc = ltrim(rtrim(ISNULL(@ActDoc,''))),
		@UFT4 = ltrim(rtrim(ISNULL(@UFT4,''))),
		@PN = ltrim(rtrim(ISNULL(@PN,''))),
		@UFT5 = ltrim(rtrim(ISNULL(@UFT5,''))),
		@UFT1 = ltrim(rtrim(ISNULL(@UFT1,''))),
		@UFT2 = ltrim(rtrim(ISNULL(@UFT2,''))),
		@Dep = ltrim(rtrim(ISNULL(@Dep,''))),
		@NA = case when ltrim(rtrim(ISNULL(@NA,''))) like '%<%>%'
				then '<' + dbo.PDX_SubstringReturn(ISNULL(@NA,''), charindex('<',ISNULL(@NA,'')), charindex('>', ISNULL(@NA,''))) + '>'
				else ltrim(rtrim(ISNULL(@NA,'')))
				end,
		@DInc = ltrim(rtrim(ISNULL(@DInc,''))),
		@DPr = ltrim(rtrim(ISNULL(@DPr,''))),
		@Name = ltrim(rtrim(ISNULL(@Name,''))),
		@Resol = ltrim(rtrim(ISNULL(@Resol,''))),
		@NCr = ltrim(rtrim(ISNULL(@NCr,''))),
		@Corr = case when ltrim(rtrim(ISNULL(@Corr,''))) like '%<%>%'
				then '<' + dbo.PDX_SubstringReturn(ISNULL(@Corr,''), charindex('<',ISNULL(@Corr,'')), charindex('>', ISNULL(@Corr,''))) + '>'
				else ltrim(rtrim(ISNULL(@Corr,'')))
				end, 
		@DPar = ltrim(rtrim(ISNULL(@DPar,'')))

	select  case @Access when 1 then 'system_report' else DocID end as DocID,
		DocID as strID, 
		UserFieldDate3,
		ActDoc,
		UserFieldText4,
		PartnerName,
		UserFieldText5,
		UserFieldText1,
		Department,
		NameAproval,
		DocIdIncoming,
		UserFieldDate1,
		DocIDPrevious,
		UserFieldText2,
		Name,
		Description,
		Resolution,
		ListToView,
		Correspondent,
		DocIDParent,
		SecurityLevel,
		StatusDevelopment,
		NameCreation
	from dbo.Docs 
	where isnull(StatusCompletion,'') <> '0' 
		and isnull(StatusDevelopment,'') <> '0' 
		and upper(isnull(isActive,'')) = 'Y'
		and ClassDoc in (dbo.PDX_CLSGet('RIK_CategoryName_VHOD_VNESH'))
		and StatusArchiv<>'1' and ExtInt=' ' 
		
		and isnull(DocID,'') like '%' + @DocID + '%' --	Рег.номер вх. документа
		and isnull(UserFieldDate3, '1900-01-01') between @UFD3_f and @UFDT_t --	Дата регистрации 
		and isnull(ActDoc,'') like '%' + @ActDoc + '%' --	Вид деятельности
		and isnull(UserFieldText4,'') like '%' + @UFT4 + '%' --	Проект
		and isnull(PartnerName,'')	 like '%' + @PN + '%' --Отправитель / организация
		and isnull(UserFieldText5,'') like '%' + @UFT5 + '%' -- Отправитель / должностное лицо
		and isnull(UserFieldText1,'') like '%' + @UFT1 + '%' -- Адрес отправителя
		and isnull(Department,'')	like '%' + @Dep + '%' --Подразделение получателя
		and isnull(NameAproval,'')	like '%' + @NA + '%' --Получатель
		and isnull(DocIdIncoming,'')	like '%' + @DInc + '%' --Исх. номер документа
		--UserFieldDate1	Исх. дата
		and isnull(DocIDPrevious,'') like '%' + @DPr + '%' --	На номер
		and isnull(UserFieldText2,'') like '%' + @UFT2 + '%' --	Вид документа
		and (isnull(Name,'') like '%' + @Name + '%'	--Заголовок
			or isnull(Description,'') like '%' + @Name + '%')	--Перечень приложений
		and isnull(Resolution,'') like '%' + @Resol + '%'	--Резолюция
		and isnull(NameCreation,'') like '%' + @NCr + '%'	--создатель
		and (isnull(ListToView,'') like '%' + @Corr + '%'	--	Список ознакомления
			or isnull(Correspondent,'') like '%' + @Corr + '%')	--	Список рассылки
		and isnull(DocIDParent,'')	like '%' + @DPar + '%' --Рег. № родит. док-та
		--and SecurityLevel	Уровень доступа
		--and StatusDevelopment	--
		--and ListToEdit	--
		
		
		
	order by UserFieldDate3,DocID
	

	--select @Result = @@error if @Result <> 0 goto Err

--	return @Result
--Err:
	
--	return @Result

GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_CoropateZadGet] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_REP_CoropateZadGet]
	@DocID varchar(128),
	@ClassDoc varchar(255),
	@DClassDoc varchar(255)
as

declare @Result int
select @Result = 0

	declare @tbl table (DocID varchar(128), Description varchar(1024))
		

	insert into @tbl (DocID,Description)
	select 
		DocID,Description
	from dbo.Docs
	where @DocID = case @DClassDoc 
						when 'Управляющий комитет / Решение'
							then DocID
						when 'Управляющий комитет / Протокол'
							then DocIDParent
						end
	and ClassDoc = 'Управляющий комитет / Решение'
	select @Result = @@error if @Result <> 0 goto Err

	insert into @tbl (DocID,Description)
	select 
		DocID,Description
	from dbo.Docs
	where DocID = @DocID 
		and not exists (select 1 from @tbl where DocID = @DocID)
	select @Result = @@error if @Result <> 0 goto Err
   
	select
		case 
			when upper(isnull(isActive,'')) <> 'Y'
				then 'неактивен'
			when isnull(D.StatusCompletion,'') = '1' and upper(isnull(isActive,'')) = 'Y'
				then 'исполнено'
			when isnull(D.StatusCompletion,'') = '+' and upper(isnull(isActive,'')) = 'Y'
				then 'запрошен статус "исполнено"'
			when isnull(D.StatusCompletion,'') = '-' and upper(isnull(isActive,'')) = 'Y'
				then 'на доработке'
			when not isnull(D.StatusCompletion,'') in ('1','+','-') and upper(isnull(isActive,'')) = 'Y' 
				then 'на исполнении'
		end + 
		case 
			when isnull(D.StatusCompletion,'') <> '1' and upper(isnull(isActive,'')) = 'Y' and 
				convert(datetime,convert(varchar(100),D.DateCompletion,104),104) < convert(datetime,convert(varchar(100),getdate(),104),104)
				then ' (просрочен)' 
			else ''
		end as Status,

		case 
			when upper(isnull(isActive,'')) = 'Y'
				then 1
			when upper(isnull(isActive,'')) <> 'Y' and isnull(D.NameResponsible,'') <> ''
				and isnull(D.NameControl,'') <> ''
				and isnull(len(SUBSTRING(D.Content,1,1)),0) <> 0
				and year(isnull(D.DateCompletion,'1900-01-01')) <> 1900
				then 0
			else -1		
		end as StatusI,

		T.Description as DDescription,
		T.DocID as DDocID,
		D.*,
		D.Content as DContent
	from dbo.Docs D
	inner join @tbl T on T.DocID = D.DocIDParent
	where D.ClassDoc = @ClassDoc
		--and upper(isnull(isActive,'Y')) = 'Y'
		--and isnull(StatusCompletion,'') <> '0'
	order by 2 asc, T.DocID,D.DateCompletion

	select @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:
	
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_CrossContracts] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[PDX_REP_CrossContracts]
	@vDocID varchar(128),
	@nDocID varchar(128),
	@vPN varchar(512),
	@nPN varchar(512),	
	@vUFT8 varchar(512),
	@nUFT8 varchar(512),
	@vStatus int, --0-все, 1 на согл, 2 подписан
	@nStatus int, --0-все, 1 на согл, 2 подписан
	@vDA1 datetime = '1900-01-01',
	@vDA2 datetime = '2100-01-01',
	@vDC1 datetime = '1900-01-01',
	@vDC2 datetime = '2100-01-01',
	@nDA1 datetime = '1900-01-01',
	@nDA2 datetime = '2100-01-01',
	@nDC1 datetime = '1900-01-01',
	@nDC2 datetime = '2100-01-01',
	@EUR money = 1,
	@USD money = 1,
	@CAD money = 1,
	@SEK money = 1
	
	
as
declare 
	@Res int, @vCls varchar(128), @nCls varchar(128), @Cls varchar(128), @oCls varchar(128),@cnt int
	set @Res = 0
	
	/*
	Задаваемые параметры для формирования отчета(f-я "и"):
1) Номер верхнего договора 
2) Номер нижнего договора
3) Поставщик верхний
4) Покупатель верхний
5) Поставщик нижний
6) Покупатель нижний
7) Статус договора (подписан, на согласовании)

	*/
	create table #vtbl (DocID varchar(128), DocIDPrev varchar(128), OI int, Am money, r_Am money, Curr varchar(24), PN varchar(128), UFT8 varchar(128),DA date,DC date)
	create table #ntbl (DocID varchar(128), DocIDPrev varchar(128), OI int, Am money, r_Am money, Curr varchar(24), PN varchar(128), UFT8 varchar(128),DA date,DC date)
	create table #vtmp (DocID varchar(128), DocIDParent varchar(128), UFT7 bit, OI int, Am money, Curr varchar(24))
	create table #ntmp (DocID varchar(128), DocIDParent varchar(128), UFT7 bit, OI int, Am money, Curr varchar(24))
	
	create table #vT (i int identity, cnt int, DIDP varchar(128),OI int,DA date,DC date,
		DocID_1 varchar(128),Am_1 money,Curr_1 varchar(24),rAm_1 money, 
		DocID_2 varchar(128),Am_2 money,Curr_2 varchar(24),rAm_2 money, 
		Am_D money,Curr_D varchar(24), rAm_D money, PN varchar(128), UFT8 varchar(128), Diff money, fcnt int, cnt2 int,isTotal bit default 0)
	create table #nT (i int identity, cnt int, DIDP varchar(128),OI int,DA date,DC date,
		DocID_1 varchar(128),Am_1 money,Curr_1 varchar(24), rAm_1 money, 
		DocID_2 varchar(128),Am_2 money,Curr_2 varchar(24), rAm_2 money, 
		Am_D money,Curr_D varchar(24), rAm_D money, PN varchar(128), UFT8 varchar(128), Diff money, fcnt int, cnt2 int,isTotal bit default 0)
	
	set @vDocID = ltrim(rtrim(ISNULL(@vDocID,'')))
	set @nDocID = ltrim(rtrim(ISNULL(@nDocID,'')))
	set @vPN = ltrim(rtrim(ISNULL(@vPN,'')))
	set @nPN = ltrim(rtrim(ISNULL(@nPN,'')))
	set @vUFT8 = ltrim(rtrim(ISNULL(@vUFT8,'')))
	set @nUFT8 = ltrim(rtrim(ISNULL(@nUFT8,'')))
	set @vCls = dbo.PDX_CLSGrGet('RIK_CategoryName_DOGOVORY_X') + '%'
	set @nCls = dbo.PDX_CLSGet('RIK_CategoryName_OTHERS_DOG')
	set @Cls = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_ORDPAY')
	set @oCls = dbo.PDX_CLSGet('RIK_CategoryName_FIN_ORDPAY')
	
	If @vDocID <> '' or @vPN <> '' or @vUFT8 <> ''
	begin --отбираем верхние договоры по условиям заданным из вне
		insert into #vtbl
			(DocID, Am, Curr, PN,UFT8, r_Am, DA, DC)
		select D.DocID, D.AmountDoc,D.Currency, D.PartnerName, D.UserFieldText8,
				case D.Currency
					when 'EUR' then @EUR
					when 'USD' then @USD
					when 'CAD' then @CAD
					when 'SEK' then @SEK
					else 1
				end * D.AmountDoc,
				D.DateActivation, D.DateCompletion
		from dbo.Docs D
		where D.IsActive = 'Y'
			and d.ClassDoc like @vCls
			and (d.PartnerName = @vPN or @vPN = '')
			and (d.UserFieldText8 = @vUFT8 or @vUFT8 = '')
			and (d.DocID = @vDocID or @vDocID = '')
			and (d.StatusDevelopment is null or d.StatusDevelopment <> '0')
			and (d.StatusCompletion is null or d.StatusCompletion <> '0')
			and CAST(d.DateActivation as date) between @vDA1 and @vDA2
			and CAST(d.DateCompletion as date) between @vDC1 and @vDC2
			
			and (@vStatus = 0 or
				(@vStatus = 1 and d.StatusDevelopment <> '4') or
				(@vStatus = 2 and d.StatusDevelopment = '4')
				)
		select @Res = @@error if @Res <> 0 goto Err
	end
	
	If @nDocID <> '' or @nPN <> ''  or @nUFT8 <> ''
	begin --отбираем нижние договоры по условиям заданным из вне
		insert into #ntbl
			(DocID, DocIDPrev, Am, Curr, PN,UFT8, r_Am, DA, DC)
		select D.DocID, D.DocIDPrevious, D.AmountDoc,D.Currency, D.PartnerName, D.UserFieldText8,
				case D.Currency
					when 'EUR' then @EUR
					when 'USD' then @USD
					when 'CAD' then @CAD
					when 'SEK' then @SEK
					else 1
				end * D.AmountDoc,
				D.DateActivation, D.DateCompletion
		from dbo.Docs D
		where D.IsActive = 'Y'
			and d.ClassDoc = @nCls
			and (d.PartnerName = @nPN or @nPN = '')
			and (d.UserFieldText8 = @nUFT8 or @nUFT8 = '')
			and (d.DocID = @nDocID or @nDocID = '')
			and (d.StatusDevelopment is null or d.StatusDevelopment <> '0')
			and (d.StatusCompletion is null or d.StatusCompletion <> '0')
			and CAST(d.DateActivation as date) between @nDA1 and @nDA2
			and CAST(d.DateCompletion as date) between @nDC1 and @nDC2
			
			and (@nStatus = 0 or
				(@nStatus = 1 and d.StatusDevelopment <> '4') or
				(@nStatus = 2 and d.StatusDevelopment = '4')
				)	
		select @Res = @@error if @Res <> 0 goto Err
	end
	--отбираем верхние договоры, которые привязаны к уже отобранным нижим
	insert into #vtbl
		(DocID, Am, Curr, PN,UFT8, r_Am, DA, DC)
	select distinct
		T.DocIDPrev, D.AmountDoc,D.Currency, D.PartnerName, D.UserFieldText8,
				case D.Currency
					when 'EUR' then @EUR
					when 'USD' then @USD
					when 'CAD' then @CAD
					when 'SEK' then @SEK
					else 1
				end * D.AmountDoc,
				D.DateActivation, D.DateCompletion
	from #ntbl T
	inner join dbo.Docs D on D.DocID = T.DocIDPrev
		and D.ClassDoc like @vCls
	where not exists (select 1 from #vtbl V where V.DocID = T.DocIDPrev)	
	select @Res = @@error if @Res <> 0 goto Err
	--отбираем нижние договоры, которые привязаны к уже отобранным верхним
	insert into #ntbl
		(DocID, Am, Curr, PN,UFT8, r_Am, DA, DC)
	select distinct
		D.DocID, D.AmountDoc,D.Currency, D.PartnerName, D.UserFieldText8,
				case D.Currency
					when 'EUR' then @EUR
					when 'USD' then @USD
					when 'CAD' then @CAD
					when 'SEK' then @SEK
					else 1
				end * D.AmountDoc,
				D.DateActivation, D.DateCompletion
	from #vtbl T
	inner join dbo.Docs D on D.DocIDPrevious = T.DocID
		and D.ClassDoc = @nCls
	where not exists (select 1 from #ntbl N where N.DocID = D.DocID)	
	select @Res = @@error if @Res <> 0 goto Err
	
	--платежи к верхним договорам
	insert into #vtmp
		(DocID, DocIDParent, UFT7, Am, Curr)
	select
		D.DocID, D.DocIDParent, case D.UserFieldText3 when 'да' then 0 else 1 end,
			D.AmountDoc,D.Currency
	from #vtbl T
	inner join dbo.Docs D on D.DocIDParent = T.DocID
		and D.ClassDoc = @Cls
	union
	select
		D.DocID, D.DocIDParent, 1,
			D.AmountDoc,D.Currency
	from #vtbl T
	inner join dbo.Docs D on D.DocIDParent = T.DocID
		and D.ClassDoc = @oCls
	--платежи к нижним договорам	
	insert into #ntmp
		(DocID, DocIDParent, UFT7, Am, Curr)
	select
		D.DocID, D.DocIDParent, case D.UserFieldText3 when 'да' then 0 else 1 end,
			D.AmountDoc,D.Currency
	from #ntbl T
	inner join dbo.Docs D on D.DocIDParent = T.DocID
		and D.ClassDoc = @Cls
	union
	select
		D.DocID, D.DocIDParent, 1,
			D.AmountDoc,D.Currency
	from #ntbl T
	inner join dbo.Docs D on D.DocIDParent = T.DocID
		and D.ClassDoc = @oCls
	
	--рассчитываем индыксы, которые нам потом помогут "скрестить" данные по договорам и платежам
	update V
		set OI = T.OI
	from #vtmp V
	inner join (	
		select ROW_NUMBER() OVER(PARTITION BY DocIDParent,UFT7 ORDER BY DocID) as OI, DocID
		from #vtmp) T on T.DocID = V.DocID
		
	update N
		set OI = T.OI
	from #ntmp N
	inner join (	
		select ROW_NUMBER() OVER(PARTITION BY DocIDParent,UFT7 ORDER BY DocID) as OI, DocID
		from #ntmp) T on T.DocID = N.DocID
		
	--"скрещиваем" нижние договоры и платежи к ним
	insert into #nT
		(DIDP,OI,DocID_1,Am_1,Curr_1, DocID_2, Am_2, Curr_2,  rAm_1,rAm_2)
	select
		isnull(N1.DocIDParent,N2.DocIDParent),isnull(N1.OI,N2.OI),
		N1.DocID,N1.Am,N1.Curr, N2.DocID,N2.Am, N2.Curr,
		
		case N1.Curr
			when 'EUR' then @EUR
			when 'USD' then @USD
			when 'CAD' then @CAD
			when 'SEK' then @SEK
			else 1
		end * N1.Am,
		case N2.Curr
			when 'EUR' then @EUR
			when 'USD' then @USD
			when 'CAD' then @CAD
			when 'SEK' then @SEK
			else 1
		end * N2.Am
	from (select distinct OI, DocIDParent from #ntmp) N
	left join #ntmp N1 on N1.OI = N.OI and N1.DocIDParent = N.DocIDParent and N1.UFT7 = 0	
	left join #ntmp N2 on N2.OI = N.OI and N2.DocIDParent = N.DocIDParent and N2.UFT7 = 1
	order by isnull(N1.DocIDParent,N2.DocIDParent),isnull(N1.OI,N2.OI)
	
	--"скрещиваем" верхние договоры и платежи к ним
	insert into #vT
		(DIDP,OI,DocID_1,Am_1,Curr_1, DocID_2, Am_2, Curr_2,  rAm_1,rAm_2)
	select
		isnull(N1.DocIDParent,N2.DocIDParent),isnull(N1.OI,N2.OI),
		N1.DocID,N1.Am,N1.Curr, N2.DocID,N2.Am, N2.Curr,
		
		case N1.Curr
			when 'EUR' then @EUR
			when 'USD' then @USD
			when 'CAD' then @CAD
			when 'SEK' then @SEK
			else 1
		end * N1.Am,
		case N2.Curr
			when 'EUR' then @EUR
			when 'USD' then @USD
			when 'CAD' then @CAD
			when 'SEK' then @SEK
			else 1
		end * N2.Am	
	from (select distinct OI, DocIDParent from #vtmp) N
	left join #vtmp N1 on N1.OI = N.OI and N1.DocIDParent = N.DocIDParent and N1.UFT7 = 0	
	left join #vtmp N2 on N2.OI = N.OI and N2.DocIDParent = N.DocIDParent and N2.UFT7 = 1
	order by isnull(N1.DocIDParent,N2.DocIDParent),isnull(N1.OI,N2.OI)
	
	update T
		set cnt = X.OI
	from #vT T
	inner join (	
		select
			DIDP, MAX(OI) as OI
		from #vT
		group by DIDP) as X on X.DIDP = T.DIDP
		
	update T
		set cnt = X.OI
	from #nT T
	inner join (	
		select
			DIDP, MAX(OI) as OI
		from #nT
		group by DIDP) as X on X.DIDP = T.DIDP
	--переносим в результ. табл данные по договорам
	update T
		set Am_D = B.Am,
		Curr_D = B.Curr,
		PN = B.PN,
		UFT8 = B.UFT8,
		rAm_D = B.r_Am,
		DA = B.DA,
		DC = B.DC
	from #nT T
	inner join #ntbl B on T.DIDP = B.DocID
	update T
		set Am_D = B.Am,
		Curr_D = B.Curr,
		PN = B.PN,
		UFT8 = B.UFT8,
		rAm_D = B.r_Am,
		DA = B.DA,
		DC = B.DC
	from #vT T
	inner join #vtbl B on T.DIDP = B.DocID
	--переносим в результ. табл данные по нижним договорам, для которых не было платежей
	insert into #nT
		(cnt,DIDP, Am_D, Curr_D, PN,UFT8, rAm_D, DA, DC)
	select
		1,DocID, Am, Curr, PN,UFT8,
		case Curr
			when 'EUR' then @EUR
			when 'USD' then @USD
			when 'CAD' then @CAD
			when 'SEK' then @SEK
			else 1
		end * Am, DA, DC
	from #ntbl T
	where not T.DocID in (select distinct DIDP from #nT)
	--переносим в результ. табл данные по верхним договорам, для которых не было платежей
	insert into #vT
		(cnt,DIDP, Am_D, Curr_D, PN,UFT8, rAm_D, DA, DC)
	select
		1,DocID, Am, Curr, PN,UFT8,
		case Curr
			when 'EUR' then @EUR
			when 'USD' then @USD
			when 'CAD' then @CAD
			when 'SEK' then @SEK
			else 1
		end * Am, DA, DC
	from #vtbl T
	where not T.DocID in (select distinct DIDP from #vT)
	
	--расчет итоговых сумм по договорам - по всем нижним
	;with NDocCurr as (
	select distinct DIDP as DocID, COALESCE(Curr_D,Curr_1,Curr_2) as Curr, cnt
	from #nT
	)
	insert into #nT
		(cnt,DIDP,OI,Am_1,Curr_1, Am_2, Curr_2, Am_D, Curr_D, rAm_D)
	select null,
		DC.DocID, DC.cnt + ROW_NUMBER() OVER (PARTITION BY DC.DocID order by DC.Curr),
		(select SUM(nT1.Am_1) from #nT as nT1 where nt1.DIDP = DC.DocID and nt1.Curr_1 = DC.Curr),
		DC.Curr,
		(select SUM(nT2.Am_2) from #nT as nT2 where nt2.DIDP = DC.DocID and nt2.Curr_2 = DC.Curr),
		DC.Curr,
		(select SUM(nT3.Am) from #ntbl as nT3 where nt3.DocID = DC.DocID and nt3.Curr = DC.Curr),
		DC.Curr,
		(select SUM(nT3.r_Am) from #ntbl as nT3 where nt3.DocID = DC.DocID and nt3.Curr = DC.Curr)
	from NDocCurr DC
	--полная сумма по нижним
	insert into #nT
		(isTotal,DIDP,OI,Am_1,Curr_1, Am_2, Curr_2, Am_D, Curr_D, rAm_D)
	select
		1,'',null,SUM(Am_1),Curr_1,SUM(Am_2),Curr_2,SUM(Am_D),Curr_D,SUM(rAm_D)
	from #nT where cnt is null
	group by Curr_1,Curr_2,Curr_D
	
--расчет итоговых сумм по договорам - по всем верхним
	;with VDocCurr as (
	select distinct DIDP as DocID, COALESCE(Curr_D,Curr_1,Curr_2) as Curr, cnt
	from #vT
	)
	insert into #vT
		(DIDP,OI,Am_1,Curr_1, Am_2, Curr_2, Am_D, Curr_D, rAm_D)
	select
		DC.DocID, DC.cnt + ROW_NUMBER() OVER (PARTITION BY DC.DocID order by DC.Curr),
		(select SUM(vT1.Am_1) from #vT as vT1 where vt1.DIDP = DC.DocID and vt1.Curr_1 = DC.Curr),
		DC.Curr,
		(select SUM(vT2.Am_2) from #vT as vT2 where vt2.DIDP = DC.DocID and vt2.Curr_2 = DC.Curr),
		DC.Curr,
		(select SUM(vT3.Am) from #vtbl as vT3 where vt3.DocID = DC.DocID and vt3.Curr = DC.Curr),
		DC.Curr,
		(select SUM(vT3.r_Am) from #vtbl as vT3 where vt3.DocID = DC.DocID and vt3.Curr = DC.Curr)
	from VDocCurr DC		
	--полная сумма по верхним
	insert into #vT
		(isTotal,DIDP,OI,Am_1,Curr_1, Am_2, Curr_2, Am_D, Curr_D, rAm_D)
	select
		1,'',null,SUM(Am_1),Curr_1,SUM(Am_2),Curr_2,SUM(Am_D),Curr_D,SUM(rAm_D)
	from #vT where cnt is null
	group by Curr_1,Curr_2,Curr_D
	
	--расчет разницы м=ду договорами и платежами
	update #nT
	set Diff = ISNULL(Am_D,0) - ISNULL(Am_1,0) - ISNULL(Am_2,0),
		Curr_D = ISNULL(Curr_D,isnull(Curr_1,Curr_2)),
		Curr_1 = ISNULL(Curr_1,isnull(Curr_D,Curr_2)),
		Curr_2 = ISNULL(Curr_2,isnull(Curr_D,Curr_1))
	where cnt is null
	update #vT
	set Diff = ISNULL(Am_D,0) - ISNULL(Am_1,0) - ISNULL(Am_2,0),
		Curr_D = ISNULL(Curr_D,isnull(Curr_1,Curr_2)),
		Curr_1 = ISNULL(Curr_1,isnull(Curr_D,Curr_2)),
		Curr_2 = ISNULL(Curr_2,isnull(Curr_D,Curr_1))
	where cnt is null
	
	set @cnt = 0
	select @cnt = COUNT(*) from #vT where isTotal = 0
	update #vT set fcnt = @cnt where isTotal = 0
	set @cnt = 0
	select @cnt = COUNT(*) from #nT where isTotal = 0
	update #nT set fcnt = @cnt where isTotal = 0
	
	update T
	set cnt2 = (select MAX(OI) from #nT T1 where T1.DIDP = T.DIDP)
	from #nT T
	
	update T
	set cnt2 = (select MAX(OI) from #vT T1 where T1.DIDP = T.DIDP)
	from #vT T
	
	--итоговый результат верх+низ+их_разница
	
	select
		1 as x,i, cnt,OI, DIDP,isTotal,cnt2,Am_D,Curr_D,rAm_D,DocID_1,Am_1,Curr_1,DocID_2,Am_2,Curr_2, PN,UFT8,DA,DC, Diff, fcnt
	from #vT 
	union
	select 
		2 as x,i, cnt,OI, DIDP,isTotal,cnt2,Am_D,Curr_D,rAm_D,DocID_1,Am_1,Curr_1,DocID_2,Am_2,Curr_2,PN,UFT8,DA,DC,Diff, fcnt
	from #nT
	union
	select
		3 as x,1 as i,null,null,'',null,null,null,'',
		isnull((select SUM(rAm_D) from #vT where isTotal = 1),0) - isnull((select SUM(rAm_D) from #nT where isTotal = 1),0),
		'',null,null,null,null,null,null,null,null,null,null,1

	
	order by 1,6,5,4--1,2

OK:

	
	return @Res
Err:
	return @Res










GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_DepartmentsCode] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_REP_DepartmentsCode]
as

declare @Result int
select @Result = 0

select DocFlowCode, Name,
case charindex('/',Name,charindex('/',Name)+1) 
	when 0 
		then '' 
	else substring(Name,charindex('/',Name)+1,charindex('/',Name,charindex('/',Name)+1)-charindex('/',Name))
end as GrName
from dbo.Departments with (nolock) 
where Name like '%/%'
order by Name

	select @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:
	
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_DepartmentsList] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_REP_DepartmentsList]
as

declare @Result int
select @Result = 0

select 
--replicate('&nbsp;',4*(len(replace(case right(Name,1) when '/' then left(Name,len(Name)-1) else Name end,space(1),'')) - len(replace(replace(case right(Name,1) when '/' then left(Name,len(Name)-1) else Name end,space(1),''),'/','')))) +
--reverse(left(reverse(case right(Name,1) when '/' then '/' + left(Name,len(Name)-1) else Name end),charindex('/',reverse(case right(Name,1) when '/' then '/' + left(Name,len(Name)-1) else Name end))-1)) as Name1, 
--case right(Name,1) when '/' then Name else Name + '/' end as Name,

--Name,
--reverse(left(reverse(case right(Name,1) when '/' then '/' + left(Name,len(Name)-1) else Name end),charindex('/',reverse(case right(Name,1) when '/' then '/' + left(Name,len(Name)-1) else Name end))-1)) as Name1,
/*case 
	when len(replace(Name,' ','')) - len(replace(replace(Name,' ',''),'/','')) <= 1
		then Name
	else
		left(Name,charindex('/',Name, charindex('/', Name) + 1))
end as Name,
case 
	when len(replace(Name,' ','')) - len(replace(replace(Name,' ',''),'/','')) <= 1
		then Name
	else
		substring(Name,charindex('/',Name, charindex('/', Name) + 1) + 1, len(Name))
end as Name1,*/
/*case when ltrim(rtrim(Name)) like '%/' 
	then Name
	else left(Name,len(Name)-charindex('/',reverse(Name) + '/')+1)
end as Name,
reverse(left(reverse(case right(Name,1) when '/' then '/' + left(Name,len(Name)-1) else Name end),charindex('/',reverse(case right(Name,1) when '/' then '/' + left(Name,len(Name)-1) else Name end))-1)) as Name1,
*/
case charindex('/',Name,charindex('/',Name)+1) 
	when 0 
		then '' 
	else substring(Name,charindex('/',Name)+1,charindex('/',Name,charindex('/',Name)+1)-charindex('/',Name))
end as GrName,
'<a href=/ShowDepartment.asp?Department=' + replace(replace(replace(Name,space(1),'+'),'<','%3C'),'>','%3E') + '&l=ru>' + Name + ' </a>' as Name, 
DocFlowCode, DepartmentCode, FullCode, LocationPath,/* ATT_Register, ATT_Controller,*/ NameLastModification, DateLastModification 
from dbo.Departments with (nolock) 
--where right(Name,1) <> '/'
where Name like '%/%'
order by Name

--4*(len(replace(case right(Name,1) when '/' then left(Name,len(Name)-1) else Name end,space(1),'')) - len(replace(replace(case right(Name,1) when '/' then left(Name,len(Name)-1) else Name end,space(1),''),'/',''))),
--replicate('&nbsp;',4*(len(replace(case right(Name,1) when '/' then left(Name,len(Name)-1) else Name end,space(1),'')) - len(replace(replace(case right(Name,1) when '/' then left(Name,len(Name)-1) else Name end,space(1),''),'/','')))) +

	select @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:
	
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_DG_DateCompletion] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

create proc [dbo].[PDX_REP_DG_DateCompletion]
		@Days int,
		@isOver bit,--учитывать просроченные
		@Access bit
as
	declare @Result int

	

	select @Result = 0

	--список утвержденных документов 
 
	select case @Access when 1 then 'system_report' else DocID end as DocID,
		datediff(day,getdate(),D.DateCompletion) as cnt,
		DocIDadd,DocIDIncoming,DocIDParent,DocIDPrevious,Author,Correspondent,  
		Department,Name,Description,LocationURL,LocationPaper,LocationPath,  
		ExtInt,PartnerName,StatusDevelopment,StatusPayment,StatusArchiv,  
		StatusCompletion,StatusDelivery,TypeDoc,ClassDoc,ActDoc,InventoryUnit,  
		PaymentMethod,AmountDoc,QuantityDoc,DateActivation,SecurityLevel,DateCreation,  
		DateCompletion,DateCompleted,DateExpiration,NameCreation,NameAproval,NameApproved,  
		DateApproved,ListToEdit,ListToReconcile,ListReconciled,NameResponsible,NameControl,  
		NameLastModification,DateLastModification,UserFieldText1,UserFieldText2,  
		UserFieldText3,UserFieldText4,UserFieldText5,UserFieldText6,UserFieldText7,  
		UserFieldText8,UserFieldMoney1,UserFieldMoney2,UserFieldDate1,  
		UserFieldDate2,UserFieldDate3,UserFieldDate4,UserFieldDate5,UserFieldDate6,  
		UserFieldDate7,UserFieldDate8,IsActive,DateActive,ExtPassword,DateSigned,  
		Currency,CurrencyRate,Rank,ListToView,Content,
		DocID as strID,
		dbo.REC_DocStatusRead(1,isActive, StatusCompletion, StatusDevelopment,
		ListToReconcile, ListReconciled, LocationPath) as StatusName
	from dbo.Docs D with (nolock) 
	where D.ClassDoc like 'Договоры /%'
		and upper(isnull(D.isActive,'')) = 'Y' --активных
		and isnull(D.StatusCompletion,'') <> '0' --неотмененных
		and D.StatusDevelopment = '4' --утвержденных
		and datediff(day,getdate(),D.DateCompletion) <= @Days
		and datediff(day,getdate(),D.DateCompletion) >= case @isOver when 1 then datediff(day,getdate(),D.DateCompletion) else 0 end
		and Year(isnull(D.DateCompletion,'1900-01-01')) <> 1900
	order by 2,D.DocID
	select @Result = @@error if @Result <> 0 goto Err



	return @Result
Err:
	
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_DG_DogovorAndPartners] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

create proc [dbo].[PDX_REP_DG_DogovorAndPartners]
	@pDID varchar(255),
	@pDateAF datetime,
	@pDateAT datetime,
	@pPrj varchar(255),
	@pPartn varchar(255),
	@pPart2 varchar(255),
	@pAut varchar(255),
	@pDep varchar(255),
	@pResp varchar(255)

as


declare @Res int

declare @Tmp table
	(DocID varchar(128),	
	pDocID varchar(128),
	PartnerName varchar(255),
	Name varchar(255),
	AmountDoc money,
	Currency varchar(50),
	StatusName varchar(128),
	OI bit default 0,
	RootID varchar(128),
	Lev int default 0 
	)
	
insert into @Tmp (DocID, PartnerName,Name,AmountDoc, Currency,pDocID,StatusName,RootID)
select DocID, PartnerName,Name,AmountDoc, Currency,DocIDParent,
dbo.REC_DocStatusRead(1,isActive, StatusCompletion, StatusDevelopment,
	ListToReconcile, ListReconciled, LocationPath) as StatusName,
DocIDParent
from dbo.Docs with (nolock)
where StatusArchiv<>'1' 
	and ExtInt=' ' 
	and upper(isActive) = 'Y'
	and (isnull(DocID,'') like '%' + @pDID + '%' or @pDID = '') 
	and convert(datetime,convert(varchar(50),DateActivation,101),121) between @pDateAF and @pDateAT 
	and (isnull(UserFieldText4,'') like ltrim(rtrim('%' + @pPrj + '%')) or @pPrj = '') 
	and (isnull(UserFieldText8,'') like '%' + @pPartn + '%' or @pPartn = '') 
	and (isnull(PartnerName,'') like '%' + @pPart2 + '%' or isnull(UserFieldText6,'') like '%' + @pPart2 + '%' or @pPart2 = '') 
	and (isnull(NameCreation,'') like '%' + @pAut + '%' or @pAut = '') 
	and (isnull(Department,'') like '%' + @pDep + '%' or @pDep = '') 
	and (isnull(NameResponsible,'') like '%' + @pResp + '%' or @pResp = '') 
	and ClassDoc like 'Договоры / (%'


select @Res = 1
while @Res > 0
begin
	update P
	set
		RootID = X.pDocID,
		Lev = P.Lev + 1
	from @Tmp P
	inner join @Tmp X on P.RootID = X.DocID
	where isnull(X.pDocID,'') <> ''
	select @Res = @@rowcount
end

insert into @Tmp
	(PartnerName)
select distinct PartnerName
from @Tmp

insert into @Tmp
	(PartnerName,AmountDoc,OI, Currency)
select PartnerName, sum(isnull(AmountDoc,0)), 1, case when min(Currency)=max(Currency) then max(Currency) else '[валюта различается]' end
from @Tmp
group by PartnerName

--select * from @Tmp order by DocID
select
	isnull(case when DocID is null and OI = 0 then PartnerName else '' end,'') as Fld1,
	isnull(case when isnull(pDocID,'') <> '' then '' else DocID end,'') as Fld2,
	isnull(case when isnull(pDocID,'') = '' then '' else DocID end,'') as Fld3,
	isnull(cast(AmountDoc as varchar(50)) + ' ' + isnull(Currency,''),'') as Fld4,
	isnull(Name,'') as Fld5,
	isnull(StatusName,'') as StatusName, cast(OI as varchar(10)) as OI,
	replicate('&nbsp', 5*Lev) as step
from @Tmp
order by PartnerName, OI, case when isnull(RootID,'')='' then DocID else RootID end,
case 
		when DocID is null then 1
		when isnull(pDocID,'') = '' then 2
		else 3
	end, 3

--iif({OI} = "1","<b>TOTAL:</b>","<a href=http://paydox-rec.int.rual.ru/showdoc.asp?docid=" & {Fld2} & "&l=ru>" & {Fld2} & "</a>") #WIDTH150 #ASIS #VBSCRIPT
GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_DG_DogovorCount] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
create proc [dbo].[PDX_REP_DG_DogovorCount]
	@ActDoc varchar(250)
as

--declare @Result int
--select @Result = 0

select ActDoc,
case 
	when upper(isActive) = 'N' then 'неактивен'
	when upper(isActive) = 'Y' and isnull(StatusCompletion,'') = '0' then 'отменен'
	when upper(isActive) = 'Y' and isnull(StatusCompletion,'') <> '0' and isnull(StatusDevelopment,'') in ('0') then 'отказано в утверждении'
	when upper(isActive) = 'Y' and isnull(StatusCompletion,'') <> '0' and isnull(StatusDevelopment,'') in ('1','2') then 'на согласовании'
	when upper(isActive) = 'Y' and isnull(StatusCompletion,'') <> '0' and isnull(StatusDevelopment,'') = '3' then 'на утверждении'
	when upper(isActive) = 'Y' and isnull(StatusCompletion,'') <> '0' and isnull(StatusDevelopment,'') = '4' and ListToReconcile <> '(#$)' then 'утвержден'
	when upper(isActive) = 'Y' and isnull(StatusCompletion,'') <> '0' and isnull(StatusDevelopment,'') = '4' and ListToReconcile = '(#$)' then 'утвержден (загрузка архива)'
	else 'неопределено' end as 'Type', count(DocID) as 'Count'
from dbo.Docs with (nolock)
where ClassDoc like 'Договоры / %'
and (ActDoc = @ActDoc or isnull(@ActDoc,'') = '')--'РИК <>'
and upper(isnull(isActive,'N')) = 'Y'
group by case 
	when upper(isActive) = 'N' then 'неактивен'
	when upper(isActive) = 'Y' and isnull(StatusCompletion,'') = '0' then 'отменен'
	when upper(isActive) = 'Y' and isnull(StatusCompletion,'') <> '0' and isnull(StatusDevelopment,'') in ('0') then 'отказано в утверждении'
	when upper(isActive) = 'Y' and isnull(StatusCompletion,'') <> '0' and isnull(StatusDevelopment,'') in ('1','2') then 'на согласовании'
	when upper(isActive) = 'Y' and isnull(StatusCompletion,'') <> '0' and isnull(StatusDevelopment,'') = '3' then 'на утверждении'
	when upper(isActive) = 'Y' and isnull(StatusCompletion,'') <> '0' and isnull(StatusDevelopment,'') = '4' and ListToReconcile <> '(#$)' then 'утвержден'
	when upper(isActive) = 'Y' and isnull(StatusCompletion,'') <> '0' and isnull(StatusDevelopment,'') = '4' and ListToReconcile = '(#$)' then 'утвержден (загрузка архива)'
	else 'неопределено' end,
	ActDoc
order by 1,2
	--select @Result = @@error if @Result <> 0 goto Err

--	return @Result
--Err:
	
--	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_DG_DogovorFind] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE proc [dbo].[PDX_REP_DG_DogovorFind]
	@pDID varchar(128),
	@pDateAF datetime,
	@pDateAT datetime,
	@pPrj varchar(255),
	@pCode varchar(255),
	@pName varchar(255),
	@pIDInc varchar(255),
	@pPartn varchar(255),
	@pPart2 varchar(255),
	@pAppr varchar(96),
	@pApp2 varchar(96),
	@pAut varchar(96),
	@pDep varchar(255),
	@pResp varchar(96),
	@pRec varchar(255),
	@pType varchar(128),
	@pPrev varchar(255) = null,
	@pCurr varchar(255) = null,
	@SHCode varchar(64) = null,
	@pObj varchar(1024) = null,
	@pPerc char(1) = null,
	@Place varchar(1024) = null,
	@Vnutr int = -1, -- -1 = неважно, 1=да, 0=нет
	@pDateCrF datetime = null,
	@pDateCrT datetime = null,	
	@CFO varchar(1024) = null,
	@Access bit = 1,
	@ActDoc varchar(128) = ''

as

--declare @Result int
--select @Result = 0

	set @pDID  = ISNULL(@pDID,'')
	set @pPrj  = ISNULL(@pPrj,'')
	set @pCode  = ISNULL(@pCode,'')
	set @pName  = ISNULL(@pName,'')
	set @pIDInc  = ISNULL(@pIDInc,'')
	set @pPartn  = ISNULL(@pPartn,'')
	set @pPart2  = ISNULL(@pPart2,'')
	set @pAppr  = ISNULL(@pAppr,'')
	set @pApp2  = ISNULL(@pApp2,'')
	set @pAut  = ISNULL(@pAut,'')
	set @pDep  = ISNULL(@pDep,'')
	set @pResp  = ISNULL(@pResp,'')
	set @pRec  = ISNULL(@pRec,'')
	set @pType  = ISNULL(@pType,'')
	set @ActDoc = ISNULL(@ActDoc,'')
	set @CFO = ISNULL(@CFO,'')
	
set @pPrev = isnull(@pPrev,'')
set @pCurr = isnull(@pCurr,'')
set @SHCode = isnull(@SHCode,'')
set @pObj = isnull(@pObj,'')
set @pPerc = ISNULL(@pPerc,'')
set @Place = isnull(@Place,'')
--set @Vnutr = isnull(@Vnutr,-1)

set @pObj = case when @pObj like '%<%>%' then '<' + dbo.PDX_SubstringReturn(@pObj,charindex('<',@pObj), charindex('>',@pObj)) + '>'
			else @pObj
			end

;with X as (
	select DocIDInt,
	ISNULL(REPLACE((
          SELECT DISTINCT case C.Code when '' then '' else '''' + C.Code +';;' end
          FROM dbo.PDXSHCode C
          WHERE C.DocIdInt = D.DocIdInt and C.isDel = 0
          FOR XML PATH('')
          ),';;',CHAR(13)+char(10)),'') as ShCode,
    ISNULL(REPLACE((
          SELECT DISTINCT case C.Place when '' then '' else C.Place +';;' end
          FROM dbo.PDXSHCode C
          WHERE C.DocIdInt = D.DocIdInt and C.isDel = 0
          FOR XML PATH('')
          ),';;',CHAR(13)+char(10)),'') as Place
	from dbo.PDXSHCode D
	where (Code like '%' + @SHCode + '%' and @SHCode <> '')
	or (Place like '%' + @Place + '%' and @Place <> '')
	union 
	select DocIDInt,
	ISNULL(REPLACE((
          SELECT DISTINCT case C.Code when '' then '' else '''' + C.Code +';;' end
          FROM dbo.PDXSHCode C
          WHERE C.DocIdInt = D.DocIdInt and C.isDel = 0
          FOR XML PATH('')
          ),';;',CHAR(13)+char(10)),'') as ShCode,
    ISNULL(REPLACE((
          SELECT DISTINCT case C.Place when '' then '' else C.Place +';;' end
          FROM dbo.PDXSHCode C
          WHERE C.DocIdInt = D.DocIdInt and C.isDel = 0
          FOR XML PATH('')
          ),';;',CHAR(13)+char(10)),'') as Place
	from dbo.Docs D
	where @SHCode = '' and @Place = ''
	and ClassDoc like 'Договоры / (%'
	and upper(isActive) = 'Y'
)
--select * from X
select case @Access when 1 then 'system_report' else D.DocID end as DocID,
D.DocIDadd,D.DocIDIncoming,D.DocIDParent,D.DocIDPrevious,D.Author,D.Correspondent,  
D.Department,D.Name,D.Description,D.LocationURL,D.LocationPaper,D.LocationPath,  
D.ExtInt,D.PartnerName,D.StatusDevelopment,D.StatusPayment,D.StatusArchiv,  
D.StatusCompletion,D.StatusDelivery,D.TypeDoc,D.ClassDoc,D.ActDoc,D.InventoryUnit,  
D.PaymentMethod,D.AmountDoc,D.QuantityDoc,D.DateActivation,D.SecurityLevel,D.DateCreation,  
D.DateCompletion,D.DateCompleted,D.DateExpiration,D.NameCreation,D.NameAproval,D.NameApproved,  
D.DateApproved,D.ListToEdit,D.ListToReconcile,D.ListReconciled,D.NameResponsible,D.NameControl,  
D.NameLastModification,D.DateLastModification,D.UserFieldText1,D.UserFieldText2,  
D.UserFieldText3,D.UserFieldText4,D.UserFieldText5,D.UserFieldText6,D.UserFieldText7,  
D.UserFieldText8,D.UserFieldMoney1,D.UserFieldMoney2,D.UserFieldDate1,  
D.UserFieldDate2,D.UserFieldDate3,D.UserFieldDate4,D.UserFieldDate5,D.UserFieldDate6,  
D.UserFieldDate7,D.UserFieldDate8,D.IsActive,D.DateActive,D.ExtPassword,D.DateSigned,  
D.Currency,D.CurrencyRate,D.Rank,D.ListToView,D.Content,F.CFO,
ISNULL(F.GPPercent,0) as GPPercent,
case 
	when isnull(StatusDevelopment,0) <> '4' and upper(isActive) = 'Y'
		then '0'
	else '1'
end as St, DocID as strID,
dbo.REC_DocStatusRead(1,D.isActive, D.StatusCompletion, D.StatusDevelopment,
	D.ListToReconcile, D.ListReconciled, D.LocationPath) as StatusName,
	X.ShCode, X.Place, isnull(P.PortalID,0) as PortalID
from dbo.Docs D with (nolock)
inner join X on X.DocIDInt = D.DocIDInt
left join [dbo].[DocsCFO] F on F.DocIDInt = D.DocIDInt
left join dbo.Partners P on P.Name = D.PartnerName
where D.isActive = 'Y'
	and (D.DocID like '%' + ltrim(rtrim(@pDID)) + '%' or @pDID = '') 
	and cast(D.DateActivation as date) between @pDateAF and @pDateAT 
	and (D.UserFieldText4 like '%' + @pPrj + '%' or @pPrj = '') 
	and (D.UserFieldText7 like '%' + ltrim(rtrim(@pCode)) +  '%' or @pCode = '') 
	and (D.Name like '%' + @pName + '%' or Description like '%' + @pName + '%' or @pName = '') 
	and (D.DocIdIncoming like '%' + @pIDInc + '%' or @pIDInc = '') 
	and (D.UserFieldText8 like '%' + @pPartn + '%' or @pPartn = '') 
	and (D.PartnerName like '%' + @pPart2 + '%' or UserFieldText6 like '%' + @pPart2 + '%' or @pPart2 = '') 
	and (D.NameAproval like '%' + @pAppr + '%' or @pAppr = '') 
	and (D.UserFieldText5 like '%' + @pApp2 + '%' or @pApp2 = '') 
	and (D.NameCreation like '%' + @pAut + '%' or @pAut = '') 
	and (D.Department like '%' + @pDep + '%' or @pDep = '') 
	and (D.NameResponsible like '%' + @pResp + '%' or @pResp = '') 
	and (D.ListToReconcile like '%' + @pRec + '%' or @pRec = '') 
	and (D.UserFieldText2 like '%' + @pType + '%' or @pType = '') 
	and (D.DocIDPrevious like '%' + @pPrev + '%' or @pPrev = '') 
	and (D.Currency like '%' + @pCurr + '%' or @pCurr = '') 
	and (D.UserFieldText7 like '%' + @pObj + '%' or @pObj = '') 
	and (F.CFO like '%' + @CFO + '%' or @CFO = '') 
	and (case when isnull(P.ActDoc,'') <> '' then 1 else 0 end = @Vnutr or @Vnutr = -1 )
	and (cast(D.DateCreation as date) between @pDateCrF and @pDateCrT or @pDateCrF is null or @pDateCrT is null)
	and (
			--(@pPerc = '0' and (isnull(F.ExistGPPercent,'0') = '0' or (isnull(F.ExistGPPercent,'0') = '1' and ISNULL(F.GPPercent,0)=0)))
			--or (@pPerc = '1' and isnull(F.ExistGPPercent,'0') = '1' and ISNULL(F.GPPercent,0)>0)		
			(@pPerc = '0' and ISNULL(F.GPPercent,0)=0)
			or (@pPerc = '1' and ISNULL(F.GPPercent,0)>0)
			or ltrim(@pPerc) = ''
			)
	and D.ClassDoc like 'Договоры / (%'
	and (D.ActDoc = @ActDoc or @ActDoc = '')
order by D.DateActivation

	--select @Result = @@error if @Result <> 0 goto Err

--	return @Result
--Err:
	
--	return @Result










GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_DG_DogovorFind_v2] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_REP_DG_DogovorFind_v2]
	@pDID varchar(128),
	@pDateAF datetime,
	@pDateAT datetime,
	@pPrj varchar(255),
	@pAut varchar(4096),
	@pActDoc varchar(96),
	/*@pCode varchar(255),
	@pName varchar(255),
	@pIDInc varchar(255),
	@pPartn varchar(255),
	@pPart2 varchar(255),
	@pAppr varchar(96),
	@pApp2 varchar(96),
	@pDep varchar(255),
	@pResp varchar(96),
	@pRec varchar(255),
	@pType varchar(128),
	@pPrev varchar(255) = null,
	@pCurr varchar(255) = null,*/
	@Access bit = 1,
	@pDateTo datetime

as
declare @pYear int
--declare @Result int
--select @Result = 0
/*
select @pDID  = isnull(@pDID,'')
select @pPrj  = isnull(@pPrj,'')
select @pCode  = isnull(@pCode,'')
select @pName  = isnull(@pName,'')
select @pIDInc  = isnull(@pIDInc,'')
select @pPartn  = isnull(@pPartn,'')
select @pPart2  = isnull(@pPart2,'')
select @pAppr  = isnull(@pAppr,'')
select @pApp2  = isnull(@pApp2,'')
select @pAut  = isnull(@pAut,'')
select @pDep  = isnull(@pDep,'')
select @pResp  = isnull(@pResp,'')
select @pRec  = isnull(@pRec,'')

select @pPrev = isnull(@pPrev,'')
select @pCurr = isnull(@pCurr,'')*/

select @pActDoc = ltrim(rtrim(ISNULL(@pActDoc,''))),
@pDID = ltrim(rtrim(ISNULL(@pDID,''))),
@pPrj = ltrim(rtrim(ISNULL(@pPrj,''))),
@pAut = ltrim(rtrim(ISNULL(@pAut,''))),
@pYear = ISNULL(year(@pDateTo),1900)

select case @Access when 1 then 'system_report' else DocID end as DocID,
DocIDadd,DocIDIncoming,DocIDParent,DocIDPrevious,Author,Correspondent,  
Department,Name,Description,LocationURL,LocationPaper,LocationPath,  
ExtInt,PartnerName,StatusDevelopment,StatusPayment,StatusArchiv,  
StatusCompletion,StatusDelivery,TypeDoc,ClassDoc,ActDoc,InventoryUnit,  
PaymentMethod,AmountDoc,QuantityDoc,DateActivation,SecurityLevel,DateCreation,  
DateCompletion,DateCompleted,DateExpiration,NameCreation,NameAproval,NameApproved,  
DateApproved,ListToEdit,ListToReconcile,ListReconciled,NameResponsible,NameControl,  
NameLastModification,DateLastModification,UserFieldText1,UserFieldText2,  
UserFieldText3,UserFieldText4,UserFieldText5,UserFieldText6,UserFieldText7,  
UserFieldText8,UserFieldMoney1,UserFieldMoney2,UserFieldDate1,  
UserFieldDate2,UserFieldDate3,UserFieldDate4,UserFieldDate5,UserFieldDate6,  
UserFieldDate7,UserFieldDate8,IsActive,DateActive,ExtPassword,DateSigned,  
Currency,CurrencyRate,Rank,ListToView,Content,
case 
	when isnull(StatusDevelopment,0) <> '4' and upper(isActive) = 'Y'
		then '0'
	else '1'
end as St, DocID as strID,
dbo.REC_DocStatusRead(1,isActive, StatusCompletion, StatusDevelopment,
	ListToReconcile, ListReconciled, LocationPath) as StatusName
from dbo.Docs with (nolock)
where StatusArchiv<>'1' 
	and ExtInt=' ' 
	and upper(isActive) = 'Y'
	and (ltrim(rtrim(isnull(DocID,''))) like '%' + @pDID + '%' or @pDID = '') 
	and convert(datetime,convert(varchar(50),DateActivation,101),121) between @pDateAF and @pDateAT 
	and (ltrim(rtrim(isnull(UserFieldText4,''))) like '%' + @pPrj + '%' or @pPrj = '') 
	and (ltrim(rtrim(isnull(ActDoc,''))) = @pActDoc or ltrim(rtrim(@pActDoc)) = '') 
	--and (ltrim(rtrim(isnull(UserFieldText7,''))) like '%' + ltrim(rtrim(@pCode)) +  '%' or ltrim(rtrim(@pCode)) = '') 
	--and (ltrim(rtrim(isnull(Name,''))) like '%' + ltrim(rtrim(@pName)) + '%' or ltrim(rtrim(isnull(Description,''))) like '%' + ltrim(rtrim(@pName)) + '%' or ltrim(rtrim(@pName)) = '') 
	--and (ltrim(rtrim(isnull(DocIdIncoming,''))) like '%' + ltrim(rtrim(@pIDInc)) + '%' or ltrim(rtrim(@pIDInc)) = '') 
	--and (ltrim(rtrim(isnull(UserFieldText8,''))) like '%' + ltrim(rtrim(@pPartn)) + '%' or ltrim(rtrim(@pPartn)) = '') 
	--and (ltrim(rtrim(isnull(PartnerName,''))) like '%' + ltrim(rtrim(@pPart2)) + '%' or ltrim(rtrim(isnull(UserFieldText6,''))) like '%' + ltrim(rtrim(@pPart2)) + '%' or ltrim(rtrim(@pPart2)) = '') 
	--and (ltrim(rtrim(isnull(NameAproval,''))) like '%' + ltrim(rtrim(@pAppr)) + '%' or ltrim(rtrim(@pAppr)) = '') 
	--and (ltrim(rtrim(isnull(UserFieldText5,''))) like '%' + ltrim(rtrim(@pApp2)) + '%' or ltrim(rtrim(@pApp2)) = '') 
	
	and (@pAut like '%<' + dbo.PDX_SubstringReturn(NameCreation,CHARINDEX('<', NameCreation), charindex('>', NameCreation)) + '>%' or @pAut = '') 
	
	--and (ltrim(rtrim(isnull(Department,''))) like '%' + ltrim(rtrim(@pDep)) + '%' or ltrim(rtrim(@pDep)) = '') 
	--and (ltrim(rtrim(isnull(NameResponsible,''))) like '%' + ltrim(rtrim(@pResp)) + '%' or ltrim(rtrim(@pResp)) = '') 
	--and (ltrim(rtrim(isnull(ListToReconcile,''))) like '%' + ltrim(rtrim(@pRec)) + '%' or ltrim(rtrim(@pRec)) = '') 
	--and (ltrim(rtrim(isnull(UserFieldText2,''))) like '%' + ltrim(rtrim(@pType)) + '%' or ltrim(rtrim(@pType)) = '') 
	--and (ltrim(rtrim(isnull(DocIDPrevious,''))) like '%' + ltrim(rtrim(@pPrev)) + '%' or ltrim(rtrim(@pPrev)) = '') 
	--and (ltrim(rtrim(isnull(Currency,''))) like '%' + ltrim(rtrim(@pCurr)) + '%' or ltrim(rtrim(@pCurr)) = '') 
	and ClassDoc like 'Договоры / (%'
	
	and (( @pYear <> 1900 and convert(datetime,convert(varchar(50),DateCompletion,101),121) <= @pDateTo
				and isnull(YEAR(DateCompletion),1900) <> 1900) 
		or
		(@pYear = 1900 and isnull(YEAR(DateCompletion),1900) = @pYear))
	
order by dbo.PDX_SubstringReturn(NameCreation,CHARINDEX('<', NameCreation), charindex('>', NameCreation)),DateCompletion

	--select @Result = @@error if @Result <> 0 goto Err

--	return @Result
--Err:
	
--	return @Result

GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_DG_DogovorList] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_REP_DG_DogovorList]
	@Proect varchar(255),
	@ActDoc varchar(255),
	@DateF datetime,
	@DateT datetime,
	@ByDateApp int, --0-по дате регистрации 1-по дате утв,2-по дате сдачи в архив
	@Access bit = 1
as

	declare @Result int
	select @Result = 0

	create table #tbl (DocID varchar(128), DateReg datetime)

	If @ByDateApp in (0,1) 
	begin
		select case @Access when 1 then 'system_report' else DocID end as DocID,
			DocID as strID, 
			Name, 
			UserFieldText8, 
			NameCreation,
			ClassDoc,
			UserFieldText4, 
			PartnerName, 
			ActDoc, 
			NameApproved, 
			AmountDoc, 
			Currency, 
			convert(varchar(100),DateApproved,104) as DateApproved, 
			convert(varchar(100),DateActivation,104) as DateActivation,
			case when isnull(LocationPath,'')='' then 'неопределено' when LocationPath like '%+%' then 'Да' else 'Нет' end as Registered, 
			UserFieldText3, 
			NameResponsible,
			null as DateReg,
			UserFieldText7,
			@ByDateApp as ByDate,
			DateCompletion
	
	
			--,'personal' as DocID
	
		from dbo.Docs
		where StatusArchiv<>'1' 
			and ExtInt=' ' 
			and isnull(StatusDevelopment,'') = '4'  
			and isnull(StatusCompletion,'') <>'0'
			and upper(isActive) = 'Y' 
			and ActDoc like @ActDoc + '%'
			and (UserFieldText4 like @Proect + '%' or @Proect = '')
			and convert(datetime,convert(varchar(50),isnull(case @ByDateApp 
																when 1 
																	then DateApproved 
																else DateActivation 
															end ,case @ByDateApp 
																	when 1 
																		then DateActivation
																	else DateApproved
																end ),101),121)  between @DateF and @DateT
			and ClassDoc like 'Договоры / %'
		order by DateActivation,DocID
		select @Result = @@error if @Result <> 0 goto Err
	end
	else
	begin
		insert into #tbl
			(DocID, DateReg)
		select D.DocID, max(C.DateCreation)
		from dbo.Docs D 
		inner join dbo.Comments C on C.DocID = D.DocID 
			and upper(C.CommentType) = 'HISTORY'
			and (Comment like 'Document registered%'
				or Comment like 'Документ зарегистрирован%')
		where ClassDoc like 'Договоры / %'
			and isnull(LocationPath,'') like '%+%'
			and StatusArchiv<>'1' 
			and ExtInt=' ' 
			and isnull(StatusDevelopment,'') = '4'  
			and isnull(StatusCompletion,'') <>'0'
			and upper(isActive) = 'Y' 
			and ActDoc like @ActDoc + '%'
			and (UserFieldText4 like @Proect + '%' or @Proect = '')
		group by D.DocID
		Having convert(datetime,convert(varchar(50),max(C.DateCreation),104),104) between @DateF and @DateT
		select @Result = @@error if @Result <> 0 goto Err	

		select case @Access when 1 then 'system_report' else D.DocID end as DocID,
			D.DocID as strID, 
			D.Name, 
			D.UserFieldText8, 
			D.NameCreation,
			D.ClassDoc,
			D.UserFieldText4, 
			D.PartnerName, 
			D.ActDoc, 
			D.NameApproved, 
			D.AmountDoc, 
			D.Currency, 
			convert(varchar(100),D.DateApproved,104) as DateApproved, 
			convert(varchar(100),D.DateActivation,104) as DateActivation,
			case when isnull(D.LocationPath,'')='' then 'неопределено' when D.LocationPath like '%+%' then 'Да' else 'Нет' end as Registered, 
			D.UserFieldText3, 
			D.NameResponsible,
			convert(datetime,convert(varchar(50),T.DateReg,104),104) as DateReg,
			UserFieldText7,
			@ByDateApp as ByDate,
			D.DateCompletion
	
			--,'personal' as DocID
	
		from dbo.Docs D 		
		inner join #tbl T on T.DocID = D.DocID
		where D.ClassDoc like 'Договоры / %'			
			and isnull(D.LocationPath,'') like '%+%'
		order by T.DateReg,D.DocID
		select @Result = @@error if @Result <> 0 goto Err
	end

	drop table #tbl
	return @Result
Err:

	drop table #tbl
	return @Result

GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_DG_DogovorSum] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_REP_DG_DogovorSum]

	@Amount money = 0,--Сумма сделки
	@Curr varchar(100) = '',--Валюта сделки
	@USD money = 1,--Курс доллара к рублю
	@EUR money = 1,----Курс евро к рублю
	@CAD money = 1,----Курс канадского доллара к рублю
	@SEK money = 1,----Курс шведской кроны к рублю

	@pDID varchar(128) = null,
	@pDateAF datetime = '1900-01-01',--Дата документа (попадает в интервал дат) 
	@pDateAT datetime = '2050-01-01',--Дата документа (попадает в интервал дат) 
	@pPrj varchar(255) = null,--Проект
	@pName varchar(255) = null,--Заголовок/Предмет 
	@pIDInc varchar(255) = null,--№ договора контрагента
	@pPartn varchar(255) = null,--Контрагент1
	@pPart2 varchar(255) = null,--Контрагент2 (и доп. контрагенты)  
	@pAppr varchar(96) = null,--Подписывающий1
	@pApp2 varchar(96) = null,--Подписывающий2
	@pAut varchar(96) = null,--Отв. за заключ. договора 
	@pDep varchar(255) = null,--Департамент отв. за исп.
	@pResp varchar(96) = null,--Отв. за исп. договора
	@pRec varchar(255) = null,--Список согласующих
	@pType varchar(128) = null,--Вид договора  
	@pPrev varchar(255) = null,--Для работ по договору 
	@pCurr varchar(255) = null,--Валюта договора 
	
	@St tinyint = 0 --0-все, 1-утв
as
declare @Cls varchar(128)

select
	@pDID = ISNULL(@pDID,''),
	@pPrj = ISNULL(@pPrj,''),
	@pName = isnull(@pName,''),
	@pIDInc = isnull(@pIDInc,''),
	@pPartn = isnull(@pPartn,''),
	@pPart2 = isnull(@pPart2,''),  
	@pAppr  = isnull(@pAppr,''),
	@pApp2  = isnull(@pApp2,''),
	@pAut  = isnull(@pAut,''),
	@pDep = isnull(@pDep,''),
	@pResp  = isnull(@pResp,''),
	@pRec  = isnull(@pRec,''),
	@pType = isnull(@pType,''),
	@pPrev  = isnull(@pPrev,''),
	@pCurr = isnull(@pCurr,'')
	
set @Cls = dbo.[PDX_CLSGrGet]('RIK_CategoryName_DOGOVORY_X')

;with DT (DocID,AmountDoc, Currency, DocIDRoot, AmCurr) as (
select  DocID, AmountDoc, Currency, DocID,
AmountDoc * case Currency  --в рубли
				when 'CAD' then @CAD
				when 'EUR' then @EUR
				when 'SEK' then @SEK
				when 'USD' then @USD
				else 1
			end /
			case @Curr  --в нужную валюту
				when 'CAD' then @CAD
				when 'EUR' then @EUR
				when 'SEK' then @SEK
				when 'USD' then @USD
				else 1
			end
from dbo.Docs with (nolock)
where upper(isActive) = 'Y'
	and (ltrim(rtrim(isnull(DocID,''))) like '%' + ltrim(rtrim(@pDID)) + '%' or ltrim(rtrim(@pDID)) = '') 
	and convert(datetime,convert(varchar(50),DateActivation,101),121) between @pDateAF and @pDateAT 
	and (ltrim(rtrim(isnull(UserFieldText4,''))) like ltrim(rtrim('%' + @pPrj + '%')) or ltrim(rtrim(@pPrj)) = '') 
	and (ltrim(rtrim(isnull(Name,''))) like '%' + ltrim(rtrim(@pName)) + '%' or ltrim(rtrim(isnull(Description,''))) like '%' + ltrim(rtrim(@pName)) + '%' or ltrim(rtrim(@pName)) = '') 
	and (ltrim(rtrim(isnull(DocIdIncoming,''))) like '%' + ltrim(rtrim(@pIDInc)) + '%' or ltrim(rtrim(@pIDInc)) = '') 
	and (ltrim(rtrim(isnull(UserFieldText8,''))) like '%' + ltrim(rtrim(@pPartn)) + '%' or ltrim(rtrim(@pPartn)) = '') 
	and (ltrim(rtrim(isnull(PartnerName,''))) like '%' + ltrim(rtrim(@pPart2)) + '%' or ltrim(rtrim(isnull(UserFieldText6,''))) like '%' + ltrim(rtrim(@pPart2)) + '%' or ltrim(rtrim(@pPart2)) = '') 
	and (ltrim(rtrim(isnull(NameAproval,''))) like '%' + ltrim(rtrim(@pAppr)) + '%' or ltrim(rtrim(@pAppr)) = '') 
	and (ltrim(rtrim(isnull(UserFieldText5,''))) like '%' + ltrim(rtrim(@pApp2)) + '%' or ltrim(rtrim(@pApp2)) = '') 
	and (ltrim(rtrim(isnull(NameCreation,''))) like '%' + ltrim(rtrim(@pAut)) + '%' or ltrim(rtrim(@pAut)) = '') 
	and (ltrim(rtrim(isnull(Department,''))) like '%' + ltrim(rtrim(@pDep)) + '%' or ltrim(rtrim(@pDep)) = '') 
	and (ltrim(rtrim(isnull(NameResponsible,''))) like '%' + ltrim(rtrim(@pResp)) + '%' or ltrim(rtrim(@pResp)) = '') 
	and (ltrim(rtrim(isnull(ListToReconcile,''))) like '%' + ltrim(rtrim(@pRec)) + '%' or ltrim(rtrim(@pRec)) = '') 
	and (ltrim(rtrim(isnull(UserFieldText2,''))) like '%' + ltrim(rtrim(@pType)) + '%' or ltrim(rtrim(@pType)) = '') 
	and (ltrim(rtrim(isnull(DocIDPrevious,''))) like '%' + ltrim(rtrim(@pPrev)) + '%' or ltrim(rtrim(@pPrev)) = '') 
	and (ltrim(rtrim(isnull(Currency,''))) like '%' + ltrim(rtrim(@pCurr)) + '%' or ltrim(rtrim(@pCurr)) = '') 
	and ClassDoc like @Cls + '%'
	and ((ISNULL(StatusDevelopment,'') = 4 and @St = 1) or @St = 0)
	and DocIDParent = ''
	
union all

select D.DocID, D.AmountDoc, D.Currency, DT.DocIDRoot,
D.AmountDoc * case D.Currency 
				when 'CAD' then @CAD
				when 'EUR' then @EUR
				when 'SEK' then @SEK
				when 'USD' then @USD
				else 1
			end /
			case @Curr  --в нужную валюту
				when 'CAD' then @CAD
				when 'EUR' then @EUR
				when 'SEK' then @SEK
				when 'USD' then @USD
				else 1
			end
from dbo.Docs D
inner join DT on DT.DocID = D.DocIDParent
where D.ClassDoc like @Cls + '%'
and ((ISNULL(D.StatusDevelopment,'') = 4 and @St = 1) or @St = 0)
)
--select * from dt

select 
D.DocID as strID,D.DocIDIncoming,D.DocIDParent,D.DocIDPrevious,  
D.Department,D.Name,D.Description,D.LocationPath,  
D.PartnerName,D.ClassDoc,D.ActDoc,D.AmountDoc,D.DateActivation,D.DateCreation,  
D.DateCompletion,D.NameCreation,D.NameAproval,D.ListToReconcile,D.ListReconciled,D.NameResponsible,  
D.UserFieldText1,D.UserFieldText2,D.UserFieldText3,D.UserFieldText4,D.UserFieldText5,
D.UserFieldText6,D.UserFieldText7, D.UserFieldText8,D.UserFieldMoney1,D.DateSigned,  
D.Currency,D.Rank,D.DateApproved,D.DateActive,
dbo.REC_DocStatusRead(1,D.isActive, D.StatusCompletion, D.StatusDevelopment,
	D.ListToReconcile, D.ListReconciled, D.LocationPath) as StatusName,
A.AD as Amount,
@Curr as Curr
from (
	select DocIDRoot, SUM(AmCurr) as AD
	from DT
	group by DocIDRoot
	having SUM(AmCurr) >= @Amount) as A
inner join dbo.Docs D on D.DocID = A.DocIDRoot

GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_DG_DogovorWithOutPDFFind] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_REP_DG_DogovorWithOutPDFFind]
	@pDID varchar(128),
	@pDateAF datetime,
	@pDateAT datetime,
	@pPrj varchar(255),
	@pCode varchar(255),
	@pName varchar(255),
	@pIDInc varchar(255),
	@pPartn varchar(255),
	@pPart2 varchar(255),
	@pAppr varchar(96),
	@pApp2 varchar(96),
	@pAut varchar(96),
	@pDep varchar(255),
	@pResp varchar(96),
	@pRec varchar(255),
	@pType varchar(128),
	@pPrev varchar(255) = null,
	@pCurr varchar(255) = null,
	@FileType tinyint = 1, --1=pdf, 0-all
	@Access bit = 1

as

--declare @Result int
--select @Result = 0
/*
select @pDID  = isnull(@pDID,'')
select @pPrj  = isnull(@pPrj,'')
select @pCode  = isnull(@pCode,'')
select @pName  = isnull(@pName,'')
select @pIDInc  = isnull(@pIDInc,'')
select @pPartn  = isnull(@pPartn,'')
select @pPart2  = isnull(@pPart2,'')
select @pAppr  = isnull(@pAppr,'')
select @pApp2  = isnull(@pApp2,'')
select @pAut  = isnull(@pAut,'')
select @pDep  = isnull(@pDep,'')
select @pResp  = isnull(@pResp,'')
select @pRec  = isnull(@pRec,'')
*/
declare @Cls varchar(256)
create table #tbl (DocID varchar(256), withPDF bit default 0)
select @pPrev = isnull(@pPrev,'')
select @pCurr = isnull(@pCurr,'')

set @Cls = dbo.PDX_CLSGrGet('RIK_CategoryName_DOGOVORY_X') 

insert into #tbl (DocID)
select D.DocID
from dbo.Docs D with (nolock)
where D.StatusArchiv<>'1' 
	and D.ExtInt=' ' 
	and upper(D.isActive) = 'Y'
	and D.StatusDevelopment = '4'
	and ISNULL(D.StatusCompletion,'')<>'0'
	and (ltrim(rtrim(isnull(D.DocID,''))) like '%' + ltrim(rtrim(@pDID)) + '%' or ltrim(rtrim(@pDID)) = '') 
	and convert(datetime,convert(varchar(50),D.DateActivation,101),121) between @pDateAF and @pDateAT 
	and (ltrim(rtrim(isnull(D.UserFieldText4,''))) like ltrim(rtrim('%' + @pPrj + '%')) or ltrim(rtrim(@pPrj)) = '') 
	and (ltrim(rtrim(isnull(D.UserFieldText7,''))) like '%' + ltrim(rtrim(@pCode)) +  '%' or ltrim(rtrim(@pCode)) = '') 
	and (ltrim(rtrim(isnull(D.Name,''))) like '%' + ltrim(rtrim(@pName)) + '%' or ltrim(rtrim(isnull(Description,''))) like '%' + ltrim(rtrim(@pName)) + '%' or ltrim(rtrim(@pName)) = '') 
	and (ltrim(rtrim(isnull(D.DocIdIncoming,''))) like '%' + ltrim(rtrim(@pIDInc)) + '%' or ltrim(rtrim(@pIDInc)) = '') 
	and (ltrim(rtrim(isnull(D.UserFieldText8,''))) like '%' + ltrim(rtrim(@pPartn)) + '%' or ltrim(rtrim(@pPartn)) = '') 
	and (ltrim(rtrim(isnull(D.PartnerName,''))) like '%' + ltrim(rtrim(@pPart2)) + '%' or ltrim(rtrim(isnull(D.UserFieldText6,''))) like '%' + ltrim(rtrim(@pPart2)) + '%' or ltrim(rtrim(@pPart2)) = '') 
	and (ltrim(rtrim(isnull(D.NameAproval,''))) like '%' + ltrim(rtrim(@pAppr)) + '%' or ltrim(rtrim(@pAppr)) = '') 
	and (ltrim(rtrim(isnull(D.UserFieldText5,''))) like '%' + ltrim(rtrim(@pApp2)) + '%' or ltrim(rtrim(@pApp2)) = '') 
	and (ltrim(rtrim(isnull(D.NameCreation,''))) like '%' + ltrim(rtrim(@pAut)) + '%' or ltrim(rtrim(@pAut)) = '') 
	and (ltrim(rtrim(isnull(D.Department,''))) like '%' + ltrim(rtrim(@pDep)) + '%' or ltrim(rtrim(@pDep)) = '') 
	and (ltrim(rtrim(isnull(D.NameResponsible,''))) like '%' + ltrim(rtrim(@pResp)) + '%' or ltrim(rtrim(@pResp)) = '') 
	and (ltrim(rtrim(isnull(D.ListToReconcile,''))) like '%' + ltrim(rtrim(@pRec)) + '%' or ltrim(rtrim(@pRec)) = '') 
	and (ltrim(rtrim(isnull(D.UserFieldText2,''))) like '%' + ltrim(rtrim(@pType)) + '%' or ltrim(rtrim(@pType)) = '') 
	and (ltrim(rtrim(isnull(D.DocIDPrevious,''))) like '%' + ltrim(rtrim(@pPrev)) + '%' or ltrim(rtrim(@pPrev)) = '') 
	and (ltrim(rtrim(isnull(D.Currency,''))) like '%' + ltrim(rtrim(@pCurr)) + '%' or ltrim(rtrim(@pCurr)) = '') 
	and D.ClassDoc like @Cls + '%'

update X
set withPDF = case when Y.cnt > 0 then 1 else 0 end
from #tbl X
inner join (
	select T.DocID, SUM(case when (@FileType = 1 and RIGHT(C.FileName,4) = '.pdf') OR @FileType = 0 then 1  else 0 end) as cnt
	from #tbl T
	inner join dbo.Comments C on C.DocID = T.DocID
			and C.CommentType = 'FILE'
			and C.Amount = 0
	group by T.DocID) as Y on Y.DocID = X.DocID
	
delete from #tbl where withPDF = 1

select case @Access when 1 then 'system_report' else D.DocID end as DocID,
	D.DocIDadd,D.DocIDIncoming,D.DocIDParent,D.DocIDPrevious,D.Author,D.Correspondent,  
	D.Department,D.Name,D.Description,D.LocationURL,D.LocationPaper,D.LocationPath,  
	D.ExtInt,D.PartnerName,D.StatusDevelopment,D.StatusPayment,D.StatusArchiv,  
	D.StatusCompletion,D.StatusDelivery,D.TypeDoc,D.ClassDoc,D.ActDoc,D.InventoryUnit,  
	D.PaymentMethod,D.AmountDoc,D.QuantityDoc,D.DateActivation,D.SecurityLevel,D.DateCreation,  
	D.DateCompletion,D.DateCompleted,D.DateExpiration,D.NameCreation,D.NameAproval,D.NameApproved,  
	D.DateApproved,D.ListToEdit,D.ListToReconcile,D.ListReconciled,D.NameResponsible,D.NameControl,  
	D.NameLastModification,D.DateLastModification,D.UserFieldText1,D.UserFieldText2,  
	D.UserFieldText3,D.UserFieldText4,D.UserFieldText5,D.UserFieldText6,D.UserFieldText7,  
	D.UserFieldText8,D.UserFieldMoney1,D.UserFieldMoney2,D.UserFieldDate1,  
	D.UserFieldDate2,D.UserFieldDate3,D.UserFieldDate4,D.UserFieldDate5,D.UserFieldDate6,  
	D.UserFieldDate7,D.UserFieldDate8,D.IsActive,D.DateActive,D.ExtPassword,D.DateSigned,  
	D.Currency,D.CurrencyRate,D.Rank,D.ListToView,D.Content,
case 
	when isnull(D.StatusDevelopment,0) <> '4' and upper(D.isActive) = 'Y'
		then '0'
	else '1'
end as St, D.DocID as strID,
dbo.REC_DocStatusRead(1,D.isActive, D.StatusCompletion, D.StatusDevelopment,
	D.ListToReconcile, D.ListReconciled, D.LocationPath) as StatusName
from #tbl T
inner join dbo.Docs D with (nolock) on D.DocID = T.DocID
order by D.DateActivation

	--select @Result = @@error if @Result <> 0 goto Err

--	return @Result
--Err:
	
--	return @Result


GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_DG_LongRecPeriod] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

create proc [dbo].[PDX_REP_DG_LongRecPeriod]
	@Days int,
	@Access bit = 1

as

declare @Result int
select @Result = 0


	create table #tmp (
		DocID varchar(128),
		DateActive0 datetime,
		DateActive datetime,
		isRec bit,
		DateSuspend datetime,
		DateRec datetime,
		Descr varchar(1024))

	create table #rec (
		KF int identity,
		DocID varchar(128),
		DateCreation datetime,
		UserID varchar(128),
		UserName varchar(128))
	declare @KF int, 
			@UserName varchar(256),		
			@DocID varchar(128),
			@DC datetime

	--ищем карточки созданные более указанного кол-ва дне назад
	insert into #tmp (DocID, DateActive, isRec, DateActive0)
	select
		D.DocID, case year(isnull(D.DateActive,'1900-01-01'))
					when 1900 then D.DateCreation
					else D.DateActive
				end,
		case when D.ListToReconcile like '%(#!)%' then 0 else 1 end,
		D.DateActive
	from dbo.Docs D
	where D.ClassDoc like 'Договоры /%'
		and upper(D.isActive) = 'Y'
		and not isnull(D.StatusDevelopment,'') in ('0','4')
		--and isnull(D.StatusCompletion,'') <> 0
		and dbo.PDX_CompareReconcilationList(D.ListToReconcile,D.ListReconciled) = 0
		and datediff(day,D.DateCreation, getdate()) >= @Days --дата создания точно не больше даты пераой активации
		--так что это доп фильтр
	select @Result = @@error if @Result <> 0 goto Err

	--уточняем их дату активации
	update T
		set DateActive = P.DateActive
	from #tmp T 
	inner join (
		select X.DocID, min(C.DateCreation) as DateActive
		from #tmp X
		inner join dbo.Comments C on C.DocID = X.DocID
			and upper(C.CommentType) = 'SYSTEM'
			and (C.Comment like 'Документ активен%' or C.Comment like 'Document active%')
		group by X.DocID ) as P on P.DocID = T.DocID
	select @Result = @@error if @Result <> 0 goto Err
	--удаляем те, кот нам по дате не подходят
	delete from #tmp where datediff(day,DateActive, getdate()) < @Days
	select @Result = @@error if @Result <> 0 goto Err
	
	--это по доработке
	update T
		set DateSuspend = N.DateCreation,
			Descr = cast(N.UserName + ' [' + N.UserID + '];' as varchar(1024))
	from #tmp T
	inner join (
		select S.DocID, S.DateCreation, S.UserID, S.UserName
		from dbo.Comments S 
		inner join ( 
			select X.DocID, max(DateCreation) as DC
			from #tmp X 
			inner join dbo.Comments C on C.DocID = X.DocID
				and upper(C.CommentType) = 'VISA'
				and upper(C.SpecialInfo) = 'VISASUSPENDING'
			where X.isRec = 0	
			group by X.DocID
					) as P on S.DocID = P.DocID
				and S.DateCreation = P.DC
				and upper(S.CommentType) = 'VISA'
				and upper(S.SpecialInfo) = 'VISASUSPENDING'
				) as N on T.DocID = N.DocID
	where T.isRec = 0	
	select @Result = @@error if @Result <> 0 goto Err

	--по согласованию
	insert into #rec(DocID, DateCreation, UserID, UserName)
	select S.DocID, S.DateCreation, S.UserID, S.UserName
	from dbo.Comments S 
	inner join ( 
		select X.DocID, max(DateCreation) as DC
		from #tmp X 
		inner join dbo.Comments C on C.DocID = X.DocID
			and upper(C.CommentType) = 'VISA'
			and upper(C.SpecialInfo) = 'VISAWAITING'
		where X.isRec = 1
		group by X.DocID
				) as P on S.DocID = P.DocID
			and S.DateCreation = P.DC
			and upper(S.CommentType) = 'VISA'
			and upper(S.SpecialInfo) = 'VISAWAITING'
	select @Result = @@error if @Result <> 0 goto Err

						 
						  
	while exists (select 1 from #rec)
	begin

		select top 1
			@KF = KF,
			@DocID = DocID,
			@UserName = UserName + ' [' + UserID + '];',
			@DC = DateCreation
		from #rec
		order by DocID, UserName
		select @Result = @@error if @Result <> 0 goto Err

		update #tmp
			set DateRec = @DC,
				Descr = cast(isnull(Descr,'') + case len(isnull(Descr,'')) when 0 then '' else char(13)+char(10) end +
						@UserName as varchar(1024))
		where DocID = @DocID
		select @Result = @@error if @Result <> 0 goto Err

		delete from #rec where KF = @KF
		select @Result = @@error if @Result <> 0 goto Err
	end
---
	select
		case @Access when 1 then 'system_report' else T.DocID end as DocID,
		T.DocID as strID,
		T.DateActive0,
		T.DateActive,
		datediff(day,T.DateActive,getdate()) as Cnt0,
		case T.isRec when 1 then 'на согласовании' else 'на доработке' end as isRec,
		case T.isRec when 1 then T.DateRec else T.DateSuspend end as Date,
		datediff(day,case T.isRec when 1 then T.DateRec else T.DateSuspend end,getdate()) as Cnt,
		case T.isRec when 1 then 'текущие согласующие:' else 'отправил на доработку:' end + char(13) + char(10) + T.Descr as descr,
		D.UserFieldText8,
		D.PartnerName,
		D.NameCreation,
		D.Name,
		D.Description,
		D.ClassDoc,
		D.ListToReconcile,
		D.ListReconciled
	from #tmp T
	inner join dbo.Docs D on D.DocID = T.DocID
	order by T.DateActive

	drop table #tmp
	drop table #rec

	return @Result
Err:
	
	drop table #tmp
	drop table #rec

	return @Result

GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_DG_NotRUB] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_REP_DG_NotRUB]
	@MasterName varchar(128),
	@ActDoc varchar(128),
	@Ukr bit = 1,
	@Alsc bit = 1,
	@Frg bit = 1,
	@Side1 varchar(128)=''

as

declare @Result int, @I int
select @Result = 0

	create table #Doc (DocID varchar(128), DocIDParent varchar(128), Currency varchar(50))
	create table #Doc_C (DocID varchar(128), Currency varchar(50), Flag char(1))

	select @MasterName = ltrim(rtrim(isnull(@MasterName,'')))
	select @Result = @@error if @Result <> 0 goto Err
	select @MasterName = case dbo.PDX_SubstringReturn(@MasterName,charindex('<',@MasterName),charindex('>',@MasterName))
						when ''
							then @MasterName
						else '<'+dbo.PDX_SubstringReturn(@MasterName,charindex('<',@MasterName),charindex('>',@MasterName))+'>'
					  end,
			@ActDoc = ltrim(rtrim(isnull(@ActDoc,'')))
	select @Result = @@error if @Result <> 0 goto Err


	INSERT INTO #Doc (DocID,DocIDParent,Currency)
	select D.DocID, case ltrim(rtrim(isnull(D.DocIDParent,''))) when '' then D.DocID else D.DocIDParent end, 
		ltrim(rtrim(isnull(D.Currency,'')))
	from dbo.Docs D
	where D.ClassDoc like 'Договоры /%'
		and isnull(D.isActive,'') = 'Y'
		and isnull(D.StatusDevelopment,'') <> '0'
		and isnull(D.StatusCompletion,'') <> '0'
		and upper(ltrim(rtrim(isnull(D.Currency,'')))) <> 'РУБ'
	select @Result = @@error if @Result <> 0 goto Err

	select @I = 1
	while @I <> 0
	begin
		update D
			set DocIDParent = ltrim(rtrim(isnull(F.DocIDParent,'')))
		from #Doc D
		inner join dbo.Docs F on F.DocID = D.DocIDParent and ltrim(rtrim(isnull(F.DocIDParent,''))) <> ''
		where D.DocID <> D.DocIDParent
		select @I=@@rowcount, @Result = @@error if @Result <> 0 goto Err
	end

	INSERT INTO #Doc_C (DocID, Currency, Flag)
	select
		DocIDParent, 
		max(case when DocIDParent = DocID then Currency else '' end),
		case when min(Currency) <> max(Currency) then '*' else '' end
	from #Doc
	group by DocIDParent
	select @Result = @@error if @Result <> 0 goto Err
	
	select 
		D.DocID,
		D.Author,
		D.DateActivation,
		D.Name,
		D.Description,
		D.UserFieldText8,
		D.PartnerName,
		D.Currency, --т.е. 
		case when ltrim(rtrim(isnull(D.Currency,''))) <> ltrim(rtrim(isnull(C.Currency,''))) and C.Flag = '' 
			then '*' else C.Flag end as CurrFlg,
		D.NameCreation,
		D.Department,
		D.UserFieldText3,
		D.ActDoc
	from #Doc_C C
	inner join dbo.Docs D on D.DocID = C.DocID
		and D.Author like case @MasterName when 'ALL' then D.Author when '' then @MasterName else '%' + @MasterName + '%' end
		and D.ActDoc like '%' + @ActDoc + '%' 
		and ltrim(rtrim(lower(D.UserFieldText3))) = case @Side1 when '' then ltrim(rtrim(lower(D.UserFieldText3))) else @Side1 end
		and not D.ActDoc like case @Ukr when 0 then '%<83%' else '***' end
		and not D.ActDoc like case @Alsc when 0 then '%<106%' else '***' end
		and not D.ActDoc like case @Frg when 0 then '%<076%' else '***' end
	order by D.Author,D.DocID
	select @Result = @@error if @Result <> 0 goto Err
		

	return @Result
Err:
	
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_DG_raspDogovorFind] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_REP_DG_raspDogovorFind]
	@pDID varchar(128),
	@pDateAF datetime,
	@pDateAT datetime,

	@pPartner1 varchar(255),
	@pPartner2 varchar(255),
	
	@pName varchar(255),
	@pActDoc varchar(128),
	@pDIDAdd varchar(255),
	@pUFT7 varchar(128),
	@PartnerFlg bit = 0
as

declare @Result int
select @Result = 0

select @pDID  = isnull(@pDID,''),
	@pPartner1  = isnull(@pPartner1,''),
	@pPartner2  = isnull(@pPartner2,''),
	@pName  = isnull(@pName,''),
	@pActDoc  = isnull(@pActDoc,''),
	@pDIDAdd  = isnull(@pDIDAdd,'')



select *,
case 
	when upper(isnull(isActive,'')) <> 'Y'
		then 'неактивен'
	when isnull(StatusDevelopment,'') = '0'
		then 'отказано в утверждении'
	when isnull(StatusDevelopment,'') = '4'
		then 'утвержден'
	when not isnull(StatusDevelopment,'') in ('4','0') and dbo.PDX_CompareReconcilationList(ListToReconcile,ListReconciled)=0
		then 'на согласовании'
	when not isnull(StatusDevelopment,'') in ('4','0') and dbo.PDX_CompareReconcilationList(ListToReconcile,ListReconciled)=1
		then 'на подписании'
end as Status1,
case 
	when isnull(LocationPath,'') like '%+%'
		then '
зарегистрирован'
	else ''
end as Status2
from dbo.Docs with (nolock)
where StatusArchiv<>'1' 
	and ExtInt=' ' 
	--and upper(isActive) = 'Y'
	and (ltrim(rtrim(isnull(DocID,''))) like '%' + ltrim(rtrim(@pDID)) + '%' or ltrim(rtrim(@pDID)) = '') 
	and convert(datetime,convert(varchar(50),DateActivation,101),121) between @pDateAF and @pDateAT 
	
	and (
		(ltrim(rtrim(isnull(UserFieldText8,''))) like '%' + ltrim(rtrim(@pPartner1)) + '%' or ltrim(rtrim(@pPartner1)) = '') 
		or
		(@PartnerFlg=1 and ltrim(rtrim(isnull(UserFieldText8,''))) like '%' + ltrim(rtrim(@pPartner2)) + '%' or ltrim(rtrim(@pPartner2)) = '')
		)
	and (
		(ltrim(rtrim(isnull(PartnerName,''))) like '%' + ltrim(rtrim(@pPartner2)) + '%' or ltrim(rtrim(isnull(UserFieldText6,''))) like '%' + ltrim(rtrim(@pPartner2)) + '%' or ltrim(rtrim(@pPartner2)) = '') 
		or
		(@PartnerFlg=1 and ltrim(rtrim(isnull(PartnerName,''))) like '%' + ltrim(rtrim(@pPartner1)) + '%' or ltrim(rtrim(isnull(UserFieldText6,''))) like '%' + ltrim(rtrim(@pPartner1)) + '%' or ltrim(rtrim(@pPartner1)) = '')
		)
	and (ltrim(rtrim(isnull(DocIdIncoming,''))) like '%' + ltrim(rtrim(@pDIDAdd)) + '%' or ltrim(rtrim(@pDIDAdd)) = '' or ltrim(rtrim(isnull(DocIDPrevious,''))) like '%' + ltrim(rtrim(@pDIDAdd)) + '%' or ltrim(rtrim(@pDIDAdd)) = '') 
	and (ltrim(rtrim(isnull(ActDoc,''))) like '%' + ltrim(rtrim(@pActDoc)) + '%' or ltrim(rtrim(@pActDoc)) = '') 
	and (ltrim(rtrim(isnull(Name,''))) like '%' + ltrim(rtrim(@pName)) + '%' or ltrim(rtrim(@pName)) = '' or ltrim(rtrim(isnull(Description,''))) like '%' + ltrim(rtrim(@pName)) + '%' or ltrim(rtrim(@pName)) = '') 
	and (ltrim(rtrim(isnull(Description,''))) like '%' + ltrim(rtrim(@pName)) + '%' or ltrim(rtrim(@pName)) = '') 
	and (ltrim(rtrim(isnull(UserFieldText7,''))) like '%' + ltrim(rtrim(@pUFT7)) + '%' or ltrim(rtrim(@pUFT7)) = '') 
	and ClassDoc like 'Договоры / (%'
order by UserFieldText8, PartnerName, DocID

	select @Result = @@error if @Result <> 0 goto Err

return @Result
Err:
	
return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_DG_ResponsibleStatistic] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_REP_DG_ResponsibleStatistic]
	@DS datetime,
	@DE datetime,
	@Type int --1 - отв. за хранение
				--2 - подача на подпись
				--3 - совмещ. 1 и 2
as

declare @Result int
select @Result = 0

	create table  #tbl (UserID varchar(128), cnt int, DT datetime, Type int)

	IF @Type in (1,3) --отв. за хранение
	begin
		insert into #tbl
			(UserID, cnt, DT, Type)
		select C.UserID, count(distinct C.DocID), convert(datetime,convert(varchar(100),C.DateCreation,104),104) as DC, 1  
		from dbo.Comments C 
			inner join dbo.Docs D on D.DocID = C.DocID and D.LocationPath like '%<' + C.UserID + '>%'
				and D.ClassDoc like 'Договоры / %'
		where upper(C.Commenttype) = 'HISTORY'
			and  convert(datetime,convert(varchar(100),C.DateCreation,104),104) between @DS and @DE
		group by C.UserID, convert(datetime,convert(varchar(100),C.DateCreation,104),104)
		select @Result = @@error if @Result <> 0 goto Err
	end
	
	IF @Type in (2,3)-- подача на подпись
	begin
		insert into #tbl
			(UserID, cnt, DT, Type)
		select C.UserID, count(distinct C.DocID), convert(datetime,convert(varchar(100),C.DateCreation,104),104) as DC, 2
		from dbo.Comments C 
			inner join dbo.Docs D on D.DocID = C.DocID and reverse(dbo.PDX_SubstringReturn(reverse(D.ListToReconcile),charindex('>',reverse(D.ListToReconcile)),charindex('<',reverse(D.ListToReconcile)))) = C.UserID 
			and D.ClassDoc like 'Договоры / %'
		where upper(C.Commenttype) = 'VISA'
			and upper(isnull(C.SpecialInfo,'')) in ('VISAOK','VISAOKREFUSE','VISASUSPENDING','VISASUSPENDINGUSER','')
			and convert(datetime,convert(varchar(100),C.DateCreation,104),104) between @DS and @DE
		group by C.UserID, convert(datetime,convert(varchar(100),C.DateCreation,104),104)
		select @Result = @@error if @Result <> 0 goto Err
	end

	--имена пользователей
	update t
		set UserID = isnull(U.Name + ' / ','') + t.UserID
	from #tbl t
	left join dbo.Users U on U.UserID = t.UserID
	select @Result = @@error if @Result <> 0 goto Err

	--результат
	select  --суммарно
		P.UserID as UID, null as DT, sum(P.cnt1) as cnt1, sum(P.cnt2) as cnt2, -1 as OI, P.UserID, 0 as cnt_1, 0 as cnt_2
	from (
		select 
			DT,sum(case Type when 1 then cnt else 0 end) as cnt1, sum(case Type when 2 then cnt else 0 end) as cnt2, UserID
		from #tbl
		group BY UserID, DT) as P
	group by P.UserID
	union
	select --по датам
		'' as UID, DT, sum(case Type when 1 then cnt else 0 end) as cnt1, sum(case Type when 2 then cnt else 0 end) as cnt2, 0 as OI, UserID, sum(case Type when 1 then cnt else 0 end) as cnt_1, sum(case Type when 2 then cnt else 0 end) as cnt_2
	from #tbl
	group BY UserID, DT

	order by 6,5,2
	select @Result = @@error if @Result <> 0 goto Err

	drop table #tbl
	return @Result
Err:
	drop table #tbl	
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_DocsWithoutFiles] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

CREATE proc [dbo].[PDX_REP_DocsWithoutFiles]
	@ClassDoc varchar(255),
	@NCr	varchar(255),
	@Access bit = 1

as

--declare @Result int
--select @Result = 0
	declare @Cls_vorbiden varchar(255)

	select @Cls_vorbiden = dbo.PDX_CLSGet('RIK_CategoryName_OTHERS_DOG')
	
	
	select @NCr = case dbo.PDX_SubstringReturn(@NCr,charindex('<',@NCr),charindex('>',@NCr))
						when ''
							then @NCr
						else '<'+dbo.PDX_SubstringReturn(@NCr,charindex('<',@NCr),charindex('>',@NCr))+'>'
					  end

	select case @Access when 1 then 'system_report' else DocID end as DocID,
		D.DocID as strID,
		D.ClassDoc,
		D.Name,
		D.StatusDevelopment,
		D.DateCreation,
		case isnull(year(D.DateActivation),1900)
			when 1900
				then D.UserFieldDate3
			else D.DateActivation
		end as DateActivation,
		D.NameCreation,
		D.StatusCompletion ,
		dbo.REC_DocStatusRead(1,isActive, StatusCompletion, StatusDevelopment,
		ListToReconcile, ListReconciled, LocationPath) as StatusName
	from dbo.Docs D
	where not exists (select 1 from Comments C where D.DocID = C.DocID and C.CommentType = 'FILE'
				and C.Amount = 0)
	and upper(isnull(D.isActive,'')) = 'Y'
	and isnull(D.StatusDevelopment,'') <> '0'
	and isnull(D.StatusCompletion,'') <> '0'
	and D.NameCreation like '%' + @NCr + '%'
	and D.ClassDoc like @ClassDoc+'%'
	and D.NameCreation <> ''
	and D.ClassDoc <> @Cls_vorbiden
	order by D.ClassDoc, D.DateCreation, D.DocID


	--select @Result = @@error if @Result <> 0 goto Err

--	return @Result
--Err:
	
--	return @Result

GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_DogovorLinks] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
create proc [dbo].[PDX_REP_DogovorLinks]
	@DocID varchar(128)
as

  declare @Result int
  select @Result = 0

	declare @DocIDParent varchar(128),
		@DocIDPrevious varchar(128),
		@NameCreation varchar(255),
		@Name varchar(255),
		@StatusDevelopment char(2),
		@Amount money,
		@Currency varchar(12)

	declare @TmpDoc table
		(DocID varchar(128),
		NameCreation varchar(255),
		Name varchar(1024),
		Comment varchar(255),
		Type int,
		PDAddress varchar(255) default '',
		StatusDevelopment char(2) default '-1',
		Amount money,
		Currency varchar(12),
		Version varchar(64))

		
--1 DocID
--2 previous
--3 parent
--4 next
--5 child
--6 links
--7 ext links

	select 
		@DocIDPrevious = DocIDPrevious,
		@DocIDParent = DocIDParent,
		@NameCreation = NameCreation,
		@Name = Name,
		@StatusDevelopment = StatusDevelopment,
		@Amount = AmountDoc,
		@Currency = Currency
	from dbo.Docs with (nolock)
	where DocID = @DocID 
	select @Result = @@error if @Result <> 0 goto Err

	--docid
	insert into @TmpDoc
		(DocID, Type, NameCreation, Name, StatusDevelopment,Amount,Currency)
	values (@DocID,1, @NameCreation, @Name, @StatusDevelopment,@Amount,@Currency)
	select @Result = @@error if @Result <> 0 goto Err

	--previous
	if isnull(@DocIDPrevious,'') <> ''
	begin
		insert into @TmpDoc
			(DocID, Type, NameCreation, Name, StatusDevelopment,Amount,Currency)
		select DocID, 2, NameCreation, Name, StatusDevelopment,AmountDoc,Currency
		from dbo.Docs with (nolock)
		where DocID = @DocIDPrevious
			and upper(isnull(Isactive,'')) = 'Y'
			and isnull(StatusCompletion,'') <> '0'
			and isnull(StatusDevelopment,'') <> '0'
		select @Result = @@error if @Result <> 0 goto Err
	end 

	--parent
	if isnull(@DocIDParent,'') <> ''
	begin
		insert into @TmpDoc
			(DocID, Type, NameCreation, Name, StatusDevelopment,Amount,Currency)
		select DocID, 3, NameCreation, Name, StatusDevelopment,AmountDoc,Currency
		from dbo.Docs with (nolock)
		where DocID = @DocIDParent
			and upper(isnull(Isactive,'')) = 'Y'
			and isnull(StatusCompletion,'') <> '0'
			and isnull(StatusDevelopment,'') <> '0'
		select @Result = @@error if @Result <> 0 goto Err
	end 

	--next
	insert into @TmpDoc
		(DocID, Type, NameCreation, Name, StatusDevelopment,Amount,Currency)
	select DocID, 4, NameCreation, Name, StatusDevelopment,AmountDoc,Currency
	from dbo.Docs with (nolock)
	where DocIDPrevious = @DocID
		and upper(isnull(Isactive,'')) = 'Y'
		and isnull(StatusCompletion,'') <> '0'
		and isnull(StatusDevelopment,'') <> '0'
	select @Result = @@error if @Result <> 0 goto Err

	--child
	insert into @TmpDoc
		(DocID, Type, NameCreation, Name, StatusDevelopment, Amount,Currency)
	select DocID, 5, NameCreation, Name, StatusDevelopment, AmountDoc,Currency
	from dbo.Docs with (nolock)
	where DocIDParent = @DocID
		and upper(isnull(Isactive,'')) = 'Y'
		and isnull(StatusCompletion,'') <> '0'
		and isnull(StatusDevelopment,'') <> '0'
	select @Result = @@error if @Result <> 0 goto Err

	--links
/*	insert into @TmpDoc
		(DocID, Type, NameCreation, Name, StatusDevelopment, Comment,Amount,Currency)
	select C.Subject, 6, D.NameCreation, isnull(D.Name,'[документ не существует]'), D.StatusDevelopment, C.Comment,D.AmountDoc,D.Currency
	from dbo.Comments C with (nolock)
	left join dbo.Docs D with (nolock) on D.DocID = C.Subject
	where C.DocID = @DocID
		and C.CommentType = 'LINK'
		and upper(isnull(Isactive,'')) = 'Y'
		and isnull(StatusCompletion,'') <> '0'
		and isnull(StatusDevelopment,'') <> '0'
	select @Result = @@error if @Result <> 0 goto Err*/

	insert into @TmpDoc
		(DocID, Type, NameCreation, Name, StatusDevelopment, Comment,Amount,Currency, Version)
	select C.Subject, 6, D.NameCreation, 
	case 
		when upper(isnull(D.Isactive,'')) = 'Y' and isnull(D.StatusCompletion,'') <> '0' and isnull(D.StatusDevelopment,'') <> '0'
			then case ltrim(rtrim(isnull(D.Name,''))) when '' then C.Comment else D.Name end
		when D.DocID is null and C.Subject like 'http://%'
			then C.Comment--'[ССЫЛКА НА ВНЕШНЮЮ СЭД]'
		else
			'некорректная ссылка: документ не существует или отменен'
	end
	, D.StatusDevelopment, 
	case 
		when D.DocID is null and C.Subject like 'http://%'
			then '[ССЫЛКА НА ВНЕШНЮЮ СЭД]'
		else
			C.Comment
	end,D.AmountDoc,D.Currency, C.Version
	from dbo.Comments C with (nolock)
	left join dbo.Docs D with (nolock) on D.DocID = C.Subject
	where C.DocID = @DocID
		and C.CommentType = 'LINK'
		--and upper(isnull(Isactive,'')) = 'Y'
		--and isnull(StatusCompletion,'') <> '0'
		--and isnull(StatusDevelopment,'') <> '0'
	select @Result = @@error if @Result <> 0 goto Err

--подставим название внешней СЭД
	update T
		set --Name = replace(C.FullName,'<br>','') + '<br>' + Name
			Comment = replace(C.FullName,'<br>','') + '<br>' + Comment
	from @TmpDoc T
	inner join dbo.PDXCore C with (nolock) on T.DocID like C.FullPath + '%'
	where T.DocID like 'http://%'
		--and Name = '[ССЫЛКА НА ВНЕШНЮЮ СЭД]'
		and Comment = '[ССЫЛКА НА ВНЕШНЮЮ СЭД]'
	select @Result = @@error if @Result <> 0 goto Err

/*
	--ext links
	insert into @TmpDoc
		(DocID, Type, NameCreation, Name, PDAddress)
	select DocNumber, 7, NameCreation, Comment, PDAddress
	from dbo.PDXLinkToPD with (nolock)
	where DocID = @DocID
	select @Result = @@error if @Result <> 0 goto Err
*/
	select P.*, D.*
	from 
		(select
			DocID as DocID1, Name as Name1, NameCreation as NameCreation1, 1 as [Type2], Type as Type1, isnull(PDAddress,'') as PDAddress1, isnull(StatusDevelopment,'-1') as StatusDevelopment1,
			isnull(Comment,'') as Comment1, 
			case Type 
				when 7
					then '-'
				else
					isnull(convert(varchar(100),Amount,1),'') + space(1) + isnull(Currency,'') 
			end as Amount1, Version as Version1
		from @TmpDoc
		union 
		select 
			case Type
				when 1
					then 'Текущий документ'
				when 2 
					then 'Предшествующий документ'
				when 3
					then 'Родительский документ'
				when 4
					then 'Последующие документы'
				when 5
					then 'Подчиненные документы'
				when 6
					then 'Ссылки'
				when 7
					then 'Ссылки на внешнюю СЭД'
				else 'ошибка'
			end as [DocID1], '' as [Name1],'' as [NameCreation1], 0 as [Type2], Type as Type1, '' as PDAddress1, '-1' as StatusDevelopment1,
			'' as Comment1, '' as Amount1, '' as Version1
		from @TmpDoc
		group by Type) as P
	left join dbo.Docs D on D.DocID = P.DocID1

	order by 5,4,1
	select @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:
	
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_Files_Check] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_REP_Files_Check]
	@DocID varchar(128)

as

declare @Result int,
		@KeyField int,
		@FKeyField int,
		@UKeyField int,
		@FullUserInfo varchar(1024),
		@FullStr varchar(1024),
		@DateApp datetime,
		@DateRec datetime,
		@Status int,
		@StatusName varchar(128),
		@txt1 varchar(64),
		@txt2 varchar(64),
		@txt3 varchar(64),
		@txt4 varchar(64),
		@Err varchar(1024)

select @Result = 0

	declare @Us table
		(KeyField int identity,
		UserID varchar(64),
		UserName varchar(128),
		SpecialInfo varchar(128),
		DateCreation datetime)

	declare @Files table 
		(KeyField int identity,
		Version varchar(64),
		Amount1 money,		
		Amount money,
		DateCreation datetime,
		DateExpired datetime,
		FName varchar(255))

declare @FComm table
(KeyField int,
Comment varchar(1024),
DateCreation datetime)

	declare @Res table
		(KeyField int identity,
		UKeyField int,
		--Version varchar(64),
		--Amount money,
		--FDateCreation datetime,
		--FName varchar(255),
		FKeyField int,

		FL bit default 0,
		FullStr varchar(4096) default '',
		FullUserInfo varchar(4096))


	declare @Res1 table
		(KeyField int,
		FKeyField int,
		FullUserInfo varchar(4096),
		Version varchar(64),
		Amount money,
		FDateCreation datetime,
		FName varchar(255))

	--получаем последнюю дату утверждения документа
	select 
		@DateRec = null,
		@DateApp = DateApproved,
		@Status = cast(dbo.REC_DocStatusRead (2,isActive,StatusCompletion,StatusDevelopment,ListToReconcile,ListReconciled,LocationPath) as int),
		@StatusName = dbo.REC_DocStatusRead (1,isActive,StatusCompletion,StatusDevelopment,ListToReconcile,ListReconciled,LocationPath)
	from dbo.Docs 
	where DocID = @DocID
	select @Result = @@error if @Result <> 0 goto Err

	--получаем список отметок Согласовано/отказано
	insert into @Us
		(UserID, UserName, SpecialInfo,DateCreation)
	select
		UserID, UserName, SpecialInfo, DateCreation
	from dbo.Comments
	where DocID = @DocID
		and upper(isnull(CommentType,'')) = 'VISA'
		and upper(isnull(SpecialInfo,'')) in ('VISAOK', 'VISAOKREFUSE')
	order by DateCreation
	select @Result = @@error if @Result <> 0 goto Err

	--получаем списко всех файлов, в т.ч и старых версий
	insert into @Files
		(Version, Amount1, Amount, DateCreation, FName)
	select Version, Amount, Amount, DateCreation, FileName
	from dbo.Comments C
	where C.DocID = @DocID
		and upper(isnull(CommentType,'')) = 'FILE'
		and ltrim(rtrim(isnull(FileName,''))) <> ''
	select @Result = @@error if @Result <> 0 goto Err

/************************************************************/
	--checkin/checkout
	select @txt1 = 'Файл удален',
		@txt2 = 'Файл документа заменен',
		@txt3 = 'Document file changed',
		@txt4 = 'Delete File'
	select @Result = @@error if @Result <> 0 goto Err

	insert into @FComm (KeyField, Comment, DateCreation)
	select KeyField, ltrim(rtrim(Comment)), DateCreation
	from dbo.Comments C
	where C.DocID = @DocID
		and upper(isnull(CommentType,'')) = 'CHECKINOUT'
	union	
	select KeyField, ltrim(rtrim(Comment)), DateCreation
	from dbo.CommentsFiles 
	where DocID = @DocID
		and upper(isnull(CommentType,'')) = 'CHECKINOUT'
	select @Result = @@error if @Result <> 0 goto Err

	update @FComm
		set Comment = ltrim(rtrim(left(Comment, len(Comment)-2)))
	where Comment like '%' + char(13) + char(10)
	select @Result = @@error if @Result <> 0 goto Err

	delete @Fcomm
	where not(right(ltrim(rtrim(Comment)),len(@txt1)) = @txt1
			or right(ltrim(rtrim(Comment)),len(@txt2)) = @txt2
			or right(ltrim(rtrim(Comment)),len(@txt3)) = @txt3
			or right(ltrim(rtrim(Comment)),len(@txt4)) = @txt4)
	select @Result = @@error if @Result <> 0 goto Err

	update @FComm
		set Comment = ltrim(rtrim(
				case when right(Comment,len(@txt1)) = @txt1
					then left(Comment, len(Comment) - len(@txt1))
				when right(Comment,len(@txt2)) = @txt2
					then left(Comment, len(Comment) - len(@txt2))
				when right(Comment,len(@txt3)) = @txt3
					then left(Comment, len(Comment) - len(@txt3))
				when right(Comment,len(@txt4)) = @txt4
					then left(Comment, len(Comment) - len(@txt4))
				end
					))
	select @Result = @@error if @Result <> 0 goto Err

	update @FComm
		set Comment = ltrim(rtrim(left(Comment, len(Comment)-2)))
	where Comment like '%' + char(13) + char(10)
	select @Result = @@error if @Result <> 0 goto Err

	update @FComm
		set Comment = ltrim(rtrim(left(Comment, len(Comment)-1)))
	where right(Comment,1) = '-'
	select @Result = @@error if @Result <> 0 goto Err

	update F
		set DateExpired = (select min(DateCreation) from @FComm C where F.Version = C.Comment and datediff(second,F.DateCreation,C.DateCreation) > 3)
--(select min(DateCreation) from @FComm C where F.Version = C.Comment and C.DateCreation > F.DateCreation)
--(select min(DateCreation) from @FComm C where F.Version = C.Comment and datediff(second,F.DateCreation,C.DateCreation) > 0)
	from @Files F
	select @Result = @@error if @Result <> 0 goto Err

	If exists(select 1 from @Files where not DateExpired is null group by Version, DateExpired having count(*)>1)
	begin
		select @Err = 'Уважаемые пользователи!<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Система не смогла корректно обработать историю загрузки файлов в данную карточку.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;При наличии вопросов по истории согласования файлов, обращайтесь к Администратору системы.'
		select @Result = @@error if @Result <> 0 goto Err
	end
	else
	begin
		select @Err = ''
		select @Result = @@error if @Result <> 0 goto Err
	end
	select @Result = @@error if @Result <> 0 goto Err

/************************************************************/

	If @Status >= 3  -- от "требует подписания" и выше
	begin
		--нам нужно отцепить версии файлов, которые были прикреплены после последнего согласования	
		select @DateRec = max(DateCreation)
		from @Us
		select @Result = @@error if @Result <> 0 goto Err

		update @Files --помечаем файлы загруженные после последнего согласующего
			set Amount = -100
		where /*Amount = 0 
			and */DateCreation > @DateRec
		select @Result = @@error if @Result <> 0 goto Err

		update F -- помечаем предыдущие от архивных версии файлов как основные
			set Amount = 0
		from @Files F 
		inner join (
			select L.Version, max(L.DateCreation) as DateCreation --находим файлы (по названию и дате), которые были действительны перед загружеными сканами
			from @Files F
			inner join @Files L on L.Version = F.Version
				and L.Amount <> -100
				and L.DateCreation < F.DateCreation
			where F.Amount = -100
			group by L.Version) as K on K.Version = F.Version
		and K.DateCreation = F.DateCreation
		and F.Amount <> -100
		select @Result = @@error if @Result <> 0 goto Err
	
		--ахивные версии файлов удаляем из рассмотрения
		delete from @Files where Amount = -100 
		select @Result = @@error if @Result <> 0 goto Err
	end	
	
/*
	--если после утверждения карточки уже был загружен архив пробуем его отсечь
	If  year(isnull(@DateApp,'1900-01-01')) <> 1900
	begin
		update @Files --помечаем файлы загруженные после утверждения
			set Amount = -100
		where Amount = 0 
			and DateCreation > @DateApp
		select @Result = @@error if @Result <> 0 goto Err
			
		update F -- помечаем предыдущие от архивных версии файлов как основные
			set Amount = 0
		from @Files F 
		inner join (
			select L.Version, max(L.DateCreation) as DateCreation --находим файлы (по названию и дате), которые были действительны перед загружеными сканами
			from @Files F
			inner join @Files L on L.Version = F.Version
				and L.Amount <> -100
				and L.DateCreation < F.DateCreation
			where F.Amount = -100
			group by L.Version) as K on K.Version = F.Version
		and K.DateCreation = F.DateCreation
		and F.Amount <> -100
		select @Result = @@error if @Result <> 0 goto Err
	
		--ахивные версии файлов удаляем из рассмотрения
		delete from @Files where Amount = -100 
		select @Result = @@error if @Result <> 0 goto Err
	end
*/
	--получаем список соответствий кто-что согласовал
	insert into @Res
		(UKeyField, FKeyField)
	select 
		U.KeyField, F.KeyField
	from (
		select
			U.KeyField, F.Version, max(F.DateCreation) as DateCreation
		from @Us U
		inner join @Files F on U.DateCreation  between F.DateCreation and isnull(F.DateExpired,getdate())--F.DateCreation <= U.DateCreation 
		group by U.KeyField, F.Version
		) as P
	inner join @Us U on U.KeyField = P.KeyField
	inner join @Files F on F.Version = P.Version and F.DateCreation = P.DateCreation
	select @Result = @@error if @Result <> 0 goto Err

	--пытамся понять кто согласовывал одинаковые пакеты документов (для группировки)
	--для этого собираем в одну строку Ид файлов согласованных одним юзером,
	-- чтобы потом сравнив строки понять кто согласовывал одинаковые пакеты документов
	while exists (select 1 from @Res where FL = 0)
	begin
		select top 1 @FKeyField = FKeyField,
			@KeyField = KeyField,
			@UKeyField = UKeyField
		from @Res 
		where FL = 0
		order by FKeyField
		select @Result = @@error if @Result <> 0 goto Err

		update @Res
			set FullStr = FullStr + '_' + cast(@FKeyField as varchar(1000))
		where UKeyField = @UKeyField
		select @Result = @@error if @Result <> 0 goto Err

		update @Res
			set FL = 1
		where KeyField = @KeyField
		select @Result = @@error if @Result <> 0 goto Err
--select * from @Res order by UKeyField,FKeyField
	end	

	--собираем информацию по пользователям , которые согласовали одинаковые пакеты документов
	-- информацию в записываем в каждую строку таблицы "кто-что соглаосвал", чтобы потом применитьгруппировку для получения окончательного результата
	while exists (select 1 from @Res where FL = 1)
	begin 
		select top 1
			@FullStr = FullStr,
			@KeyField = KeyField,
			@UKeyField = UKeyField,
			@FKeyField = FKeyField
		from @Res
		where FL = 1
		order by UKeyField
		select @Result = @@error if @Result <> 0 goto Err

		select @FullUserInfo = UserName + ' - ' + case SpecialInfo when 'VISAOKREFUSE' then '<font color=red>ОТКАЗ</font>' when 'VISAOK' then 'СОГЛ.' else 'ошибка' end + ' - ' + convert(varchar(100), DateCreation,121) 
		from @Us 
		where KeyField = @UKeyField
		select @Result = @@error if @Result <> 0 goto Err

		update @Res set FullUserInfo = isnull(FullUserInfo,'') + case isnull(FullUserInfo,'') when '' then '' else '<br>' end + @FullUserInfo where FullStr = @FullStr
		select @Result = @@error if @Result <> 0 goto Err		 

		update @Res set FL = 0 where UKeyField = @UKeyField and FullStr = @FullStr
		select @Result = @@error if @Result <> 0 goto Err

	end
	select @Result = @@error if @Result <> 0 goto Err

--select distinct FullUserInfo,FKeyField  from @Res

	--"догуружаем" информацию о файлах 
	insert into @Res1
		(KeyField,FullUserInfo,
		Version,Amount,FDateCreation,FName, FKeyField)
	select
		min(U.UKeyField),U.FullUserInfo,
		F.Version,F.Amount,F.DateCreation,F.FName, F.KeyField
	from @Res U
	inner join @Files F on F.KeyField = U.FKeyField
	group by U.FullUserInfo,F.Version,F.Amount,F.DateCreation,F.FName,F.KeyField
	select @Result = @@error if @Result <> 0 goto Err

	--получаем результата 
	select R1.KeyField,R2.KeyField,isnull(R1.KeyField,R2.KeyField) as KeyField,
		isnull(R1.FullUserInfo,R2.FullUserInfo) as FullUserInfo,
		isnull(R1.Version,'') as Version, R1.FDateCreation as FDateCreation, R1.Amount as Amount, isnull(R1.FName,'') as FName,
		isnull(R2.Version,'') as a_Version, R2.FDateCreation as a_FDateCreation, R2.Amount as a_Amount, isnull(R2.FName,'') as a_FName,
		R1.FKeyField as FKeyField, R2.FKeyField as a_FKeyField,
		R2.Amount1 as a_Amount1,
		isnull(@DateApp,'1900-01-01') as DateApp,
		isnull(@DateRec,'1900-01-01') as DateRec,
		@StatusName as StatusName, @Err as ErrTxt
	from @Res1 R1
	full outer join (select
						min(U.UKeyField) as KeyField,U.FullUserInfo,
						F.Version,F.Amount1,F.Amount,F.DateCreation as FDateCreation,F.FName, F.KeyField as FKeyField
					from @Res U
					inner join @Files F on F.Amount = 0
					group by U.FullUserInfo,F.Version,F.Amount1,F.Amount,F.DateCreation,F.FName,F.KeyField) R2 on 
				R1.KeyField = R2.KeyField
				--and R1.FDateCreation = R2.FDateCreation
				and R1.Version = R2.Version

	order by isnull(R1.KeyField,R2.KeyField), isnull(R1.Version,R2.Version)
	--order by isnull(R1.FullUserInfo,R2.FullUsgoerInfo)
	select @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:
	
	return @Result


GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_FILEStatistic] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
create proc [dbo].[PDX_REP_FILEStatistic]
	@DS datetime,
	@DE datetime
as

declare @Result int
select @Result = 0

create table #tbl
(DocID varchar(128), Name varchar(128), LocationPath varchar(128), DateRec datetime) 


	insert into #tbl 
		(DocID, DateRec, Name, LocationPath)
	select d.docid, isnull(d.dateapproved, d.datecreation),/*max(c.datecreation),*/ d.Name, d.LocationPath
	from docs d
		--inner join comments c on c.docid = d.docid and c.commenttype = 'VISA' and c.specialinfo in ('VISAOK','VISAOKREFUSE')
	where d.statusdevelopment = '4'
	and isnull(d.statuscompletion,'')<>'0'
	and isnull(d.isActive,'') = 'Y'
	and d.classdoc like 'Договоры / %'
	and isnull(d.dateapproved, d.datecreation) between @DS and @DE
	--group by d.docid, d.Name, d.LocationPath
	select @Result = @@error if @Result <> 0 goto Err
	--select * from #tbl
	
	select * from #tbl t
	where not exists (select 1 from comments c where t.docid = c.docid
		and c.commenttype= 'file'
		and c.datecreation > t.daterec
		and (
		rtrim(isnull(c.filename,'')) like '%.tif' or
		rtrim(isnull(c.filename,'')) like '%.tiff' or
		rtrim(isnull(c.filename,'')) like '%.pdf' 
	))
	order by DateRec
	select @Result = @@error if @Result <> 0 goto Err

	drop table #tbl
	return @Result
Err:
	drop table #tbl	
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_GetResolutionList] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE procedure [dbo].[PDX_REP_GetResolutionList]
	@UserID				varchar(16),
	@ActDoc				varchar(64),
	@Author				varchar(128),
	@DateFrom			datetime,
	@DateTo				datetime,
	@doMainOnly			bit,
	@doProcessed		int,
	@ProcessedMark		varchar(50),
	@UFT4				varchar(1024) = null,
	@result				int	output
as

declare
	@pActDoc		varchar(64),
	@pAuthor		varchar(128),
	@pDateFrom		datetime,
	@pDateTo		datetime,
	@pDoMain		bit,
	@pDoProcessed	int,
	@userActDoc		varchar(4096),
	@err_msg		varchar(1024)

declare @tmp_prj table (ClassDoc varchar(128), UFT varchar(100))
	
	set @result = 0

	insert into @tmp_prj (ClassDoc)
	select Name from dbo.DocTypes
	
	update P
		set UFT = U.FieldName
	from @tmp_prj P
	inner join dbo.PDXUserSettingDocTypes U on U.DocType = P.ClassDoc
		and U.DirType = 35
	
	set @UFT4 = rtrim(ISNULL(@UFT4,''))
	
	if (@ActDoc IS NULL or rtrim(ltrim(@ActDoc)) = '')
	begin
		select
			@userActDoc = u.ActDoc
		from dbo.Users u
		where u.UserID = @UserID 
		
		if (@@ROWCOUNT = 0) 
		begin
			set @err_msg = 'Текущий пользователь не идентифицирован'
			goto ErrHandler
		end
		
		-- check possibility to work with all activities
		if (CHARINDEX('"ALL"',@userActDoc,1) > 0)
		begin	
			set @pActDoc = NULL
--			print 'ALL: ' + CHARINDEX('"ALL"', @userActDoc,0)
		end
		else
		begin
			-- check if user has no access to activites
			if (LEN(@userActDoc) = 0)
				set @pActDoc = '#NONE#' -- lock access to resolutions
			else
				set @pActDoc = @userActDoc
		end
	end
	else
		set @pActDoc = @ActDoc

	print @pActDoc

	if (@Author IS NULL or rtrim(ltrim(@Author)) = '')
		set @pAuthor = NULL
	else
	begin 
		select 
			@pAuthor = '<' + u.UserID + '>'
		from dbo.Users u
		where @Author like '%<' + u.UserID + '>%'
		
		if (@@ROWCOUNT = 0)
		begin
			set @err_msg = 'Указанный автор не обнаружен'
			goto ErrHandler
		end
	end

	if (@DateFrom IS NULL)
		set @pDateFrom = '2000-01-01'
	else
		set @pDateFrom = @DateFrom

	if (@DateTo IS NULL)
		set @pDateTo = DATEADD(dd,1,GETDATE())
	else
		set @pDateTo = @DateTo

	if (@doMainOnly IS NULL)
		set @pDoMain = 0
	else
		set @pDoMain = @doMainOnly

	if (@doProcessed IS NULL)
		set @pDoProcessed = 0
	else
		set @pDoProcessed = @doProcessed

	-- new resolutions select
	if @pDoProcessed = 0
	begin
		select
			d.DocID							as strID,
			d.DateActivation				as docDate,
			d.Name							as docName,
			d.Description					as docDescr,
			c.UserName						as resAuthor,
			'<B>' + convert(varchar,c.DateCreation,104) + ' '
				+ convert(varchar,DATEPART(hh,c.DateCreation)) + ':'
				+ CONVERT(varchar,DATEPART(mi,c.DateCreation)) + ' ' + c.UserName + ':</B> ' + CHAR(13) + CHAR(10) + c.Comment as resData,
			c.SpecialInfo					as resSpecial,
			c.DateCreation					as resDate,
			ISNULL(c.RIK_CommentType,'')	as resRIKCommentType,
			c.KeyField						as resKeyField,
			''								as taskID,
			'1900-01-01 00:00:00.000'		as taskDate,
			''								as taskData,
			case P.UFT
				when 'UserFieldText4'
					then D.UserFieldText4
				when 'UserFieldText5'
					then D.UserFieldText5
				else ''
			end								as docUFT4
		from dbo.Comments c
			inner join dbo.Docs d on (d.DocIDInt = c.DocIDInt)
			inner join @tmp_prj P on P.ClassDoc = d.ClassDoc
		where	c.CommentType = 'RESOLUTION'
			and c.FileName IS NULL
			and CHARINDEX(d.ActDoc,ISNULL(@pActDoc,d.ActDoc)) > 0 
			and ISNULL(c.SpecialInfo,'') = case @pDoMain
									when 1 then 'MAIN'
									else ISNULL(c.SpecialInfo,'')
								end
			and ISNULL(c.RIK_CommentType,'') = ''
			and ISNULL(@pAuthor,'<'+c.UserID+'>') like '%<'+c.UserID+'>%'
			and c.DateCreation between @pDateFrom and @pDateTo
			and (case P.UFT
					when 'UserFieldText4'
						then D.UserFieldText4
					when 'UserFieldText5'
						then D.UserFieldText5
					else @UFT4
				end = @UFT4 or @UFT4 = '')
		order by d.DateActivation, c.DateCreation
	end
	
	-- only processed
	if @doProcessed = 2
	begin
		select
			d.DocID							as strID,
			d.DateActivation				as docDate,
			d.Name							as docName,
			d.Description					as docDescr,
			c.UserName						as resAuthor,
			'<B>' + convert(varchar,c.DateCreation,104) + ' '
				+ convert(varchar,DATEPART(hh,c.DateCreation)) + ':'
				+ CONVERT(varchar,DATEPART(mi,c.DateCreation)) + ' ' + c.UserName + ':</B> ' + CHAR(13) + CHAR(10) + c.Comment as resData,
			c.SpecialInfo					as resSpecial,
			c.DateCreation					as resDate,
			ISNULL(c.RIK_CommentType,'')	as resRIKCommentType,
			c.KeyField						as resKeyField,
			t.DocID							as taskID,
			t.DateCompletion				as taskDate,
			'<B>Ответственный: ' + t.NameResponsible + ' Срок: ' + convert(varchar,t.DateCompletion,104) + '</B>'+ CHAR(13) + CHAR(10) + t.Description as taskData,
			case P.UFT
				when 'UserFieldText4'
					then D.UserFieldText4
				when 'UserFieldText5'
					then D.UserFieldText5
				else ''
			end								as docUFT4
		from dbo.Comments c
			inner join dbo.Docs d on (d.DocIDInt = c.DocIDInt)
			inner join @tmp_prj P on P.ClassDoc = d.ClassDoc
			inner join dbo.Docs t on (t.UserFieldText8 = CONVERT(varchar,c.KeyField))
		where	c.CommentType = 'RESOLUTION'
			and c.FileName IS NULL
			and t.ClassDoc = 'Задачи'
			and CHARINDEX(d.ActDoc,ISNULL(@pActDoc,d.ActDoc)) > 0 
			and ISNULL(c.SpecialInfo,'') = case @pDoMain
									when 1 then 'MAIN'
									else ISNULL(c.SpecialInfo,'')
								end
			and charindex(@ProcessedMark,ISNULL(c.RIK_CommentType,'')) > 0
			and ISNULL(@pAuthor,'<'+c.UserID+'>') like '%<'+c.UserID+'>%'
			and c.DateCreation between @pDateFrom and @pDateTo
			and (case P.UFT
					when 'UserFieldText4'
						then D.UserFieldText4
					when 'UserFieldText5'
						then D.UserFieldText5
					else @UFT4
				end = @UFT4 or @UFT4 = '')
		order by d.DateActivation, c.DateCreation
	end
	
	-- full set of processed and unprocessed resolutions
	if @doProcessed = 1
	begin	
		select
			d.DocID							as strID,
			d.DateActivation				as docDate,
			d.Name							as docName,
			d.Description					as docDescr,
			c.UserName						as resAuthor,
			'<B>' + convert(varchar,c.DateCreation,104) + ' '
				+ convert(varchar,DATEPART(hh,c.DateCreation)) + ':'
				+ CONVERT(varchar,DATEPART(mi,c.DateCreation)) + ' ' + c.UserName + ':</B> ' + CHAR(13) + CHAR(10) + c.Comment as resData,
			c.SpecialInfo					as resSpecial,
			c.DateCreation					as resDate,
			ISNULL(c.RIK_CommentType,'')	as resRIKCommentType,
			c.KeyField						as resKeyField,
			t.DocID							as taskID,
			t.DateCompletion				as taskDate,
			'<B>Ответственный: ' + t.NameResponsible + ' Срок: ' + convert(varchar,t.DateCompletion,104) + '</B>'+ CHAR(13) + CHAR(10) + t.Description as taskData,
			case P.UFT
				when 'UserFieldText4'
					then D.UserFieldText4
				when 'UserFieldText5'
					then D.UserFieldText5
				else ''
			end								as docUFT4
		from dbo.Comments c
			inner join dbo.Docs d on (d.DocIDInt = c.DocIDInt)
			inner join @tmp_prj P on P.ClassDoc = d.ClassDoc
			left join dbo.Docs t on (t.UserFieldText8 = CONVERT(varchar,c.KeyField)
										and charindex(@ProcessedMark,ISNULL(c.RIK_CommentType,'')) > 0
										and t.ClassDoc = 'Задачи')
		where	c.CommentType = 'RESOLUTION'
			and c.FileName IS NULL
			and d.IsActive = 'Y'
			and CHARINDEX(d.ActDoc,ISNULL(@pActDoc,d.ActDoc)) > 0 
			and ISNULL(c.SpecialInfo,'') = case @pDoMain
									when 1 then 'MAIN'
									else ISNULL(c.SpecialInfo,'')
								end
			and ISNULL(@pAuthor,'<'+c.UserID+'>') like '%<'+c.UserID+'>%'
			and c.DateCreation between @pDateFrom and @pDateTo
			and (case P.UFT
					when 'UserFieldText4'
						then D.UserFieldText4
					when 'UserFieldText5'
						then D.UserFieldText5
					else @UFT4
				end = @UFT4 or @UFT4 = '')
		order by d.DateActivation, c.DateCreation
	end
	
	return
ErrHandler:
	RAISERROR(@err_msg,16,1);
	
	set @result = 1
	return



GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_IKDocsByIM] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
create proc [dbo].[PDX_REP_IKDocsByIM]
	@DocID varchar(128),
	@ClassDoc varchar(255)
as

  declare @Result int
  select @Result = 0
	
	declare @UserFieldText7 varchar(1024)

	--получаем ИМ	
	select 
		@UserFieldText7 = UserFieldText7
	from dbo.Docs
	where DocID = @DocID 
		and ClassDoc = @ClassDoc
	select @Result = @@error if @Result <> 0 goto Err

	exec @Result = dbo.PDX_REP_IKDocsByIMList
		@IMList = @UserFieldText7
	if @Result <> 0 goto Err
	

	return @Result
Err:
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_IKDocsByIMList] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
create proc [dbo].[PDX_REP_IKDocsByIMList]
	@IMList varchar(1024)
as

  declare @Result int
  select @Result = 0
	
	declare @SQLStatement varchar(4000),
			@Flg bit

	create table #tblIM 
		(CodeIM varchar(1024),
		Descr varchar(256),
		Flg bit default 0 )

	create table #tmpIMDocs
		(DocID varchar(128),
		DateActivation datetime,
		PartnerName varchar(255),
		Amount varchar(255),
		State varchar(255),
		UserFieldText7 varchar(1024),
		NameCreation varchar(128),
		NameResponsible varchar(128),
		Name varchar(255),
		CodeIM varchar(1024),
		OrderIndex int)

	select @IMList = ltrim(rtrim(isnull(@IMList,''))) 
	select @Result = @@error if @Result <> 0 goto Err

	select @IMList = replace(@IMList,char(13)+char(10),space(1))
	select @Result = @@error if @Result <> 0 goto Err

	while isnull(charindex(space(2),@IMList),0) > 0
	begin
		select @IMList = replace(@IMList, space(2), space(1))
		select @Result = @@error if @Result <> 0 goto Err
	end
	select @Result = @@error if @Result <> 0 goto Err

	select @IMList = ltrim(rtrim(@IMList)) 
	select @Result = @@error if @Result <> 0 goto Err

	if @IMList <> ''
	begin
		--разбиваем их по одному
		select @SQLStatement = 'insert into #tblIM(CodeIM) values(''' + replace(@IMList, space(1),''') insert into #tblIM(CodeIM) values(''') + ''')'
		select @Result = @@error if @Result <> 0 goto Err
		print @SQLStatement
		exec (@SQLStatement)
		select @Result = @@error if @Result <> 0 goto Err

		update I
		set
			CodeIM = ltrim(rtrim(I.CodeIM)),
			Descr = U.Descr,
			Flg = 1
		from #tblIM I
		inner join dbo.UserDir_IM U on ltrim(rtrim(U.Code)) = ltrim(rtrim(I.CodeIM))
		select @Result = @@error if @Result <> 0 goto Err

		insert into #tmpIMDocs
			(DocID,
			DateActivation,
			PartnerName,
			Amount,
			State,
			UserFieldText7,
			NameCreation,
			NameResponsible,
			Name,
			CodeIM,
			OrderIndex)
		select 
			D.DocID,
			case isnull(year(D.DateActivation),1900) when 1900 then D.UserFieldText3 else D.DateActivation end,
			D.PartnerName,
			cast(D.AmountDoc as varchar(100)) + space(1) + D.Currency,
			case D.StatusDevelopment when 4 then 'Да' else '' end as State,
			D.UserFieldText7,
			D.NameCreation,
			D.NameResponsible,
			D.Name,
			ltrim(rtrim(I.CodeIM)) + ' - ' + case isnull(I.Descr,'') when '' then 'НЕОПРЕДЕЛЕНО' else isnull(I.Descr,'') end,
			1
		from dbo.Docs D
		inner join #tblIM I on D.UserFieldText7 like '%' + ltrim(rtrim(I.CodeIM)) + '%' and I.Flg = 1
		--space(1) + replace(D.UserFieldText7, char(13)+char(10),space(1)) + space(1) like '% ' + ltrim(rtrim(I.CodeIM)) + ' %'
		where Upper(D.isActive) = 'Y'
			and isnull(D.StatusDevelopment,0) <> 0
			and isnull(D.StatusCompletion,'') <> '0'
			and D.ClassDoc like 'Договоры / %'
		select @Result = @@error if @Result <> 0 goto Err
	end

	insert into #tmpIMDocs
		(DocID,
		CodeIM,
		OrderIndex)
	select distinct
		'',
		CodeIM,
		0
	from #tmpIMDocs
	select @Result = @@error if @Result <> 0 goto Err

	select @Flg = isnull((select top 1 1 from #tblIM where Flg = 0),0)
	select @Result = @@error if @Result <> 0 goto Err

	select 
		DocID,
		DateActivation,
		PartnerName,
		Amount,
		State,
		UserFieldText7,
		NameCreation,
		NameResponsible,
		Name,
		CodeIM,
		@Flg as isErr
	from #tmpIMDocs
	order by CodeIM,OrderIndex
	select @Result = @@error if @Result <> 0 goto Err
	

	drop table #tmpIMDocs
	drop table #tblIM
	return @Result
Err:
	drop table #tmpIMDocs
	drop table #tblIM
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_IKInfo] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
create proc [dbo].[PDX_REP_IKInfo]
	@IMNumber varchar(50),
	@IKV_Class varchar(128),
	@IKR_Class varchar(128),
	@IKK_Class varchar(128)
as

  declare @Result int
  select @Result = 0
	
	declare @DocID varchar(128),
			@Info varchar(4096),
			@ClassDoc varchar(128)

	declare @res table
		(DocID varchar(128),
		Descr varchar(1024),
		Res varchar(4096),
		NameCreation varchar(128),
		Status varchar(64),
		ClassDoc varchar(128),
		Flg bit default 0,
		UserFieldText7 varchar(1024),
		DateActivation datetime)

	select @IMNumber = ltrim(rtrim(isnull(@IMNumber,'')))

	if @IMNumber <> '' 
	begin
		insert into @res(DocID, Descr, NameCreation, Status, ClassDoc, UserFieldText7, DateActivation)
		select DocID, Description, NameCreation, 
			case isnull(StatusCompletion,'') when 1 then 'исполнено' else 'исполняется' end, 
			ClassDoc, UserFieldText7, DateActivation
		from dbo.Docs 
		where UserFieldText7 like '%' + ltrim(rtrim(@IMNumber)) + '%'
			and ClassDoc in (@IKV_Class, @IKK_Class)
			and upper(isnull(isActive,'')) = 'Y'
			and isnull(StatusDevelopment,'') <> '0'
			and isnull(StatusCompletion,'') <> '0'
		order by ClassDoc,DocID
		select @Result = @@error if @Result <> 0 goto Err


		while exists (select 1 from @res where Flg = 0)
		begin
			select top 1
				@DocID = DocID,
				@ClassDoc = ClassDoc,
				@Info = ''
			from @res 
			where Flg = 0
			select @Result = @@error if @Result <> 0 goto Err

			If @ClassDoc = @IKV_Class 
			begin --получаем реения по вопросу

				select @Info = cast((@Info + case len(@Info) when 0 then '' else '<BR>' end +  'Решение [' + DocID + ']. Статус [' + case isnull(StatusCompletion,'') when 1 then 'исполнено' else 'исполняется' end + '] - ' + cast(Content as varchar(4096))) as varchar(4096))
				from dbo.Docs
				where DocIDPrevious = @DocID 
					and ClassDoc = @IKR_Class
					and upper(isnull(isActive,'')) = 'Y'
					and isnull(StatusDevelopment,'') <> '0'
					and isnull(StatusCompletion,'') <> '0'
				--order by DateCreation
				select @Result = @@error if @Result <> 0 goto Err
			end
			else if @ClassDoc = @IKK_Class
			begin

				select @Info = cast(@Info + case len(@Info) when 0 then '' else '<BR>' end + UserName + ': ' + Comment as varchar(4096))
				from dbo.Comments
				where DocID = @DocID 
					and CommentType = 'HISTORY'
				--order by DateCreation
				select @Result = @@error if @Result <> 0 goto Err
			end
			
			update @res
				set Res = @Info,
					Flg = 1
			where DocID = @DocID
			select @Result = @@error if @Result <> 0 goto Err

		end
		select @Result = @@error if @Result <> 0 goto Err
	end

	select 
		DocID, 
		Status, 
		replace(UserFieldText7, char(13) + char(10), '<BR>') as IMCode, 
		DateActivation, 
		replace(Descr,char(13)+char(10),'<BR>') as Descr, 
		replace(Res,char(13)+char(10),'<BR>') as Res, 
		NameCreation 
	from @res
	order by DateActivation
	select @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_IncomingDocs] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_REP_IncomingDocs]
	@DF datetime,
	@DT datetime,
	@ClassDoc varchar(128),
	@UserID varchar(16)

as

	declare @Result int
	select @Result = 0

	select @ClassDoc = ltrim(rtrim(isnull(@ClassDoc,''))),
			@DF = isnull(@DF,getdate()),
			@DT = isnull(@DT,getdate())

	select D.* from dbo.Docs D with (nolock)
	inner join (
	select DocID, max(DateCreation) as DateCreation from dbo.Comments with (nolock)
	where convert(datetime,convert(varchar(100),DateCreation,104),104) between
	convert(datetime,convert(varchar(100),@DF,104),104) and
	convert(datetime,convert(varchar(100),@DT,104),104)
	and (
		(UserID = @UserID and upper(CommentType) not in ('NOTIFICATION','RESOLUTION')) or 
		(Comment like '%<' + @UserID + '>%' and upper(CommentType) in('NOTIFICATION','RESOLUTION')))
	and upper(CommentType) in ('APROVAL',
								'NOTIFICATION',
								'RESOLUTION',
								'REVIEW',
								'VIEWED',
								'VISA')
	group by DocID) as C on C.DocID = D.DocID
	where D.ClassDoc like @ClassDoc + '%'
	order by C.DateCreation desc, D.DocID 

	select @Result = @@error if @Result <> 0 goto Err
	return @Result
Err:
	
	drop table #tbl_res
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_KBPDocsByBP] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
create proc [dbo].[PDX_REP_KBPDocsByBP]
	@DocID varchar(128)
as

declare @Result int
select @Result = 0

declare @BPName varchar(255),
@BPDept varchar(255)

select @BPName = Name,
@BPDept = Department
from dbo.Docs where DocID = @DocID
select @Result = @@error if @Result <> 0 goto Err

select D.*, C.UserName, C.RIK_CommentType, C.Comment, @BPName as BPName, @BPDept as BPDept
from dbo.Comments C
inner join dbo.Docs D on D.DocID = C.DocID
	and isnull(D.isActive ,'') = 'Y'
	and isnull(D.StatusDevelopment,'')<>'0'
	and isnull(D.StatusCompletion,'')<>'0'
where C.CommentType = 'LINK'
and C.Subject = @DocID
/*order by case C.RIK_CommentType
			when 'RIK_LINK_OUT'
				then 1
			when 'RIK_LINK_IN'
				then 2
			else 3
		end, D.DocID*/
order by D.DateActivation, D.DocID

select @Result = @@error if @Result <> 0 goto Err

OK:
	return @Result
Err:
	
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_MOBFind] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE proc [dbo].[PDX_REP_MOBFind]
	@DocID varchar(128),
	@ActDoc varchar(128),
	@UFD3_f date,
	@UFD3_t date,
	@Department varchar(1024),
	@Author varchar(128),
	--@UFT1 varchar(1024),
	@LTR varchar(128),
	@NameAproval varchar(128),
	@UFT7 varchar(1024),
	@CrName varchar(128),
	@Access bit = 1
as

--declare @Result int
--select @Result = 0
	declare @Cls varchar(128)
	
	set @Cls = dbo.PDX_CLSGet('RIK_CategoryName_OTHERS_MOB')
	set @UFD3_f = ISNULL(@UFD3_f,'1900-01-01')
	set @UFD3_t = ISNULL(@UFD3_t,'2500-01-01')
	set @DocID = ltrim(ISNULL(@DocID,''))
	set @ActDoc = ltrim(ISNULL(@ActDoc,''))
	set @Department = ltrim(ISNULL(@Department,''))
	set @Author = case when @Author like '%<%>%'
					then '<'+dbo.PDX_SubstringReturn(@Author, charindex('<',@Author), charindex('>',@Author))+'>'
					else ltrim(ISNULL(@Author,''))
				end
	--set @UFT1 = ltrim(ISNULL(@UFT1,''))
	set @LTR = case when @LTR like '%<%>%'
					then '<'+dbo.PDX_SubstringReturn(@LTR, charindex('<',@LTR), charindex('>',@LTR))+'>'
					else ltrim(ISNULL(@LTR,''))
				end
	set @NameAproval = case when @NameAproval like '%<%>%'
					then '<'+dbo.PDX_SubstringReturn(@NameAproval, charindex('<',@NameAproval), charindex('>',@NameAproval))+'>'
					else ltrim(ISNULL(@NameAproval,''))
				end
	set @UFT7 = ltrim(ISNULL(@UFT7,''))
	set @CrName = case when @CrName like '%<%>%'
					then '<'+dbo.PDX_SubstringReturn(@CrName, charindex('<',@CrName), charindex('>',@CrName))+'>'
					else ltrim(ISNULL(@CrName,''))
				end
	
	
	select case @Access when 1 then 'system_report' else DocID end as DocID,
		DocID as strID, 
		ActDoc,
		UserFieldDate3,
		Department,
		Author,
		UserFieldText1,
		ListToReconcile,
		NameAproval,
		UserFieldText7,
		NameCreation
	from dbo.Docs with (nolock)
	where NameCreation like '%'+@CrName+'%'
		and UserFieldDate3 between @UFD3_f and @UFD3_t
		and DocID like '%'+@DocID+'%'
		and ActDoc like '%'+@ActDoc+'%'
		--and UserFieldText1 like '%'+@UFT1+'%'
		and UserFieldText7 like '%'+@UFT7+'%'
		and Department like '%'+@Department+'%'
		and Author like '%'+@Author+'%'
		and NameAproval like '%'+@NameAproval+'%'
		and ListToReconcile like '%'+@LTR+'%'
		and ClassDoc = @Cls
		and upper(isnull(isActive,'')) = 'Y'
		and StatusDevelopment <> '0' 
		and isnull(StatusCompletion,'') <> '0'
	order by dateCreation, DocID
	--select @Result = @@error if @Result <> 0 goto Err

--	return @Result
--Err:
	
--	return @Result


GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_Notification] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_REP_Notification]
	@pDateAF datetime,
	@pDateAT datetime,
	@pUserID varchar(128),
	@pDocID varchar(128) = null,
	@Access bit = 1
as

declare @Result int
select @Result = 0
	
	If @pUserID <> ''
	begin
		select @pUserID = case dbo.PDX_SubstringReturn(@pUserID,charindex('<',@pUserID),charindex('>',@pUserID))
							when ''
								then @pUserID
							else '<'+dbo.PDX_SubstringReturn(@pUserID,charindex('<',@pUserID),charindex('>',@pUserID))+'>'
						  end,
			@pDocID = ltrim(rtrim(isnull(@pDocID,'')))
	
		select case @Access when 1 then 'system_report' else DocID end as DocID,
		DocID as strID,DateCreation,CommentType, replace(Comment,char(13)+char(10),' ') as Comment, UserId,UserName
		from Comments 
		where convert(datetime,convert(varchar(100),DateCreation,104),104) between 
				convert(datetime,convert(varchar(100),@pDateAF,104),104) and convert(datetime,convert(varchar(100),@pDateAT,104),104)
			and upper(CommentType) = upper('NOTIFICATION')
			and Comment like '%' + @pUserID + '%'
			and DocID like '%' + @pDocID + '%'
		select @Result = @@error if @Result <> 0 goto Err

	end

	return @Result
Err:
	
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_NotReconciledInTime] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

CREATE proc [dbo].[PDX_REP_NotReconciledInTime]
	@ClassDoc varchar(255),
	@NCr	varchar(255),
	@NApp	varchar(255),
	@NRec	varchar(255),
	@Access bit = 1

as

	declare @Cls_vorbiden varchar(255)

	select @Cls_vorbiden = dbo.PDX_CLSGet('RIK_CategoryName_OTHERS_DOG')

	select @NCr = case dbo.PDX_SubstringReturn(@NCr,charindex('<',@NCr),charindex('>',@NCr))
						when ''
							then @NCr
						else '<'+dbo.PDX_SubstringReturn(@NCr,charindex('<',@NCr),charindex('>',@NCr))+'>'
					  end,
			@NApp = case dbo.PDX_SubstringReturn(@NApp,charindex('<',@NApp),charindex('>',@NApp))
						when ''
							then @NApp
						else '<'+dbo.PDX_SubstringReturn(@NApp,charindex('<',@NApp),charindex('>',@NApp))+'>'
					  end,
			@NRec = case dbo.PDX_SubstringReturn(@NRec,charindex('<',@NRec),charindex('>',@NRec))
						when ''
							then @NRec
						else '<'+dbo.PDX_SubstringReturn(@NRec,charindex('<',@NRec),charindex('>',@NRec))+'>'
					  end

--declare @Result int
--select @Result = 0
	Select  case @Access when 1 then 'system_report' else D.DocID end as DocID,
		D.ClassDoc,
		D.DocID as strID,
		D.Name,
		'"'+C.UserName+'" <' + C.UserID + '>;' as CurrReconciled, 
		C.DateEvent,
		C.DateEventEnd, 
		D.NameCreation,
		D.NameAproval,
		D.Description,
		datediff(day,C.DateEventEnd,getdate()) as CC
	from dbo.Docs D
	inner Join dbo.Comments C ON D.DocID = C.DocID and C.CommentType='VISA' and C.SpecialInfo='VISAWAITING' 
		and C.DateEventEnd<GetDate() 
	where D.IsActive='Y' 
		and D.NameCreation like '%' + @NCr + '%'
		and D.NameAproval like '%' + @NApp + '%'
		and '"'+C.UserName+'" <' + C.UserID + '>;' like  '%' + @NRec + '%'
		and D.ClassDoc like @ClassDoc +'%'
		and isnull(D.StatusCompletion,'') <> '0'
		and isnull(D.StatusDevelopment,'') <> '0'

		and not isnull(D.ListReconciled,'') like '%' + case @NRec when '' then '???' else @NRec end + '%'
		
		and D.ClassDoc <> @Cls_vorbiden
	order by D.DocID


	--select @Result = @@error if @Result <> 0 goto Err

--	return @Result
--Err:
	
--	return @Result

GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_NZFind] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*drop  proc [dbo].[PDX_REP_NZFind]
go*/

CREATE proc [dbo].[PDX_REP_NZFind]
	@Str varchar(255),
	@CrName varchar(255),
	@DocID varchar(128),
	@Reconcil varchar(255),
	@ActDoc varchar(128),
	@Dept varchar(255),
	@UFT4 varchar(255),
	@NApr varchar(255),
	@DateF datetime,
	@DateT datetime,
	@Access bit = 1
as

--declare @Result int
--select @Result = 0
declare @ClassDoc varchar(255)

set @ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_OTHERS_N_Z')
-- DocID = Рег.номер
-- ActDoc = Вид деятельности
-- UserFieldDate3 = Рег. дата
-- Description = Содержание документа
-- UserFieldText4 = Проект
-- NameCreation = Создатель документа
-- Department = Подразделение
-- ListToReconcile = Лист согласование
-- NameAproval = Утверждающий
-- ListToView = Список ознакомления
-- Correspondent = Список рассылки
-- SecurityLevel = Уровень доступа

	select @CrName = case when @CrName like '%<%>%'	
							then '<' + dbo.PDX_SubstringReturn(@CrName, CHARINDEX('<',@CrName), charindex('>',@CrName)) + '>'
						else isnull(@CrName,'')
					end,
	@NApr = case when @NApr like '%<%>%'	
							then '<' + dbo.PDX_SubstringReturn(@CrName, CHARINDEX('<',@NApr), charindex('>',@NApr)) + '>'
						else isnull(@NApr,'')
					end,
	@DateT = ISNULL(@DateT,'1900-01-01'),
	@DateF = ISNULL(@DateF,'1900-01-01')				
					
	select case @Access when 1 then 'system_report' else DocID end as DocID,
		DocID as strID, 
		Name, 
		Description, 
		NameCreation, 
		DateActive ,
		ActDoc,
		Department,
		UserFieldText4,
		ListToReconcile,
		ListReconciled,
		NameAproval
	from dbo.Docs with (nolock)
	where Description like '%'+@Str+'%'
		and NameCreation like '%'+@CrName+'%'
		and DocID like '%'+@DocID+'%'
		and ActDoc like '%'+@ActDoc+'%'
		and Department like '%'+@Dept+'%'
		and UserFieldText4 like '%'+@UFT4+'%'
		and NameAproval like '%'+@NApr+'%'
		and ListToReconcile like '%'+@Reconcil+'%'
		and ClassDoc = @ClassDoc
		and upper(isnull(isActive,'')) = 'Y'
		and StatusDevelopment <> '0' 
		and isnull(StatusCompletion,'') <> '0'
		and UserFieldDate3 between @DateF and @DateT
	order by dateCreation, DocID
	--select @Result = @@error if @Result <> 0 goto Err

--	return @Result
--Err:
	
--	return @Result


GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_OTH_DogovorFind] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_REP_OTH_DogovorFind]
	@pDID varchar(128),
	@pDID_add varchar(128),
	@pDateAF datetime,
	@pDateAT datetime,
	@pPrj varchar(255),
	@pCode varchar(255),
	@pName varchar(255),
	@pIDInc varchar(255),
	@pPartn varchar(255),
	@pPart2 varchar(255),
	@pAppr varchar(96),
	@pApp2 varchar(96),
	@pAut varchar(96),
	@pDep varchar(255),
	@pResp varchar(96),
	@pRec varchar(255),
	@pType varchar(128),
	@pPrev varchar(255) = null,
	@pCurr varchar(255) = null,
	@pRAppr varchar(255)

as

--declare @Result int
--select @Result = 0
/*
select @pDID  = isnull(@pDID,'')
select @pPrj  = isnull(@pPrj,'')
select @pCode  = isnull(@pCode,'')
select @pName  = isnull(@pName,'')
select @pIDInc  = isnull(@pIDInc,'')
select @pPartn  = isnull(@pPartn,'')
select @pPart2  = isnull(@pPart2,'')
select @pAppr  = isnull(@pAppr,'')
select @pApp2  = isnull(@pApp2,'')
select @pAut  = isnull(@pAut,'')
select @pDep  = isnull(@pDep,'')
select @pResp  = isnull(@pResp,'')
select @pRec  = isnull(@pRec,'')
*/
select @pPrev = isnull(@pPrev,'')
select @pCurr = isnull(@pCurr,'')


select DocID as DocID,
case isnull(DocID_AddNumber,'') when '' then DocID else DocID_AddNumber end as DocID_AddNumber,
DocIDadd,DocIDIncoming,DocIDParent,DocIDPrevious,Author,Correspondent,  
Department,Name,Description,LocationURL,LocationPaper,LocationPath,  
ExtInt,PartnerName,StatusDevelopment,StatusPayment,StatusArchiv,  
StatusCompletion,StatusDelivery,TypeDoc,ClassDoc,ActDoc,InventoryUnit,  
PaymentMethod,AmountDoc,QuantityDoc,DateActivation,SecurityLevel,DateCreation,  
DateCompletion,DateCompleted,DateExpiration,NameCreation,NameAproval,NameApproved,  
DateApproved,ListToEdit,ListToReconcile,ListReconciled,NameResponsible,NameControl,  
NameLastModification,DateLastModification,UserFieldText1,UserFieldText2,  
UserFieldText3,UserFieldText4,UserFieldText5,UserFieldText6,UserFieldText7,  
UserFieldText8,UserFieldMoney1,UserFieldMoney2,UserFieldDate1,  
UserFieldDate2,UserFieldDate3,UserFieldDate4,UserFieldDate5,UserFieldDate6,  
UserFieldDate7,UserFieldDate8,IsActive,DateActive,ExtPassword,DateSigned,  
Currency,CurrencyRate,Rank,ListToView,Content,
case 
	when isnull(StatusDevelopment,0) <> '4' and upper(isActive) = 'Y'
		then '0'
	else '1'
end as St, DocID as strID,
dbo.REC_DocStatusRead(1,isActive, StatusCompletion, StatusDevelopment,
	ListToReconcile, ListReconciled, LocationPath) as StatusName
from dbo.Docs with (nolock)
where StatusArchiv<>'1' 
	and ExtInt=' ' 
	and upper(isActive) = 'Y'
	and (ltrim(rtrim(isnull(DocID,''))) like '%' + ltrim(rtrim(@pDID)) + '%' or ltrim(rtrim(@pDID)) = '') 
	and (ltrim(rtrim(isnull(DocID_AddNumber,''))) like '%' + ltrim(rtrim(@pDID_add)) + '%' or ltrim(rtrim(@pDID_add)) = '') 
	and convert(datetime,convert(varchar(50),DateActivation,101),121) between @pDateAF and @pDateAT 
	and (ltrim(rtrim(isnull(UserFieldText4,''))) like ltrim(rtrim('%' + @pPrj + '%')) or ltrim(rtrim(@pPrj)) = '') 
	and (ltrim(rtrim(isnull(UserFieldText7,''))) like '%' + ltrim(rtrim(@pCode)) +  '%' or ltrim(rtrim(@pCode)) = '') 
	and (ltrim(rtrim(isnull(Name,''))) like '%' + ltrim(rtrim(@pName)) + '%' or ltrim(rtrim(isnull(Description,''))) like '%' + ltrim(rtrim(@pName)) + '%' or ltrim(rtrim(@pName)) = '') 
	and (ltrim(rtrim(isnull(DocIdIncoming,''))) like '%' + ltrim(rtrim(@pIDInc)) + '%' or ltrim(rtrim(@pIDInc)) = '') 
	and (ltrim(rtrim(isnull(UserFieldText8,''))) like '%' + ltrim(rtrim(@pPartn)) + '%' or ltrim(rtrim(@pPartn)) = '') 
	and (ltrim(rtrim(isnull(PartnerName,''))) like '%' + ltrim(rtrim(@pPart2)) + '%' or ltrim(rtrim(isnull(UserFieldText6,''))) like '%' + ltrim(rtrim(@pPart2)) + '%' or ltrim(rtrim(@pPart2)) = '') 
	and (ltrim(rtrim(isnull(UserFieldText7,''))) like '%' + ltrim(rtrim(@pAppr)) + '%' or ltrim(rtrim(@pAppr)) = '') 
	and (ltrim(rtrim(isnull(UserFieldText5,''))) like '%' + ltrim(rtrim(@pApp2)) + '%' or ltrim(rtrim(@pApp2)) = '') 
	and (ltrim(rtrim(isnull(NameCreation,''))) like '%' + ltrim(rtrim(@pAut)) + '%' or ltrim(rtrim(@pAut)) = '') 
	and (ltrim(rtrim(isnull(Department,''))) like '%' + ltrim(rtrim(@pDep)) + '%' or ltrim(rtrim(@pDep)) = '') 
	and (ltrim(rtrim(isnull(NameResponsible,''))) like '%' + ltrim(rtrim(@pResp)) + '%' or ltrim(rtrim(@pResp)) = '') 
	and (ltrim(rtrim(isnull(ListToReconcile,''))) like '%' + ltrim(rtrim(@pRec)) + '%' or ltrim(rtrim(@pRec)) = '') 
	and (ltrim(rtrim(isnull(UserFieldText2,''))) like '%' + ltrim(rtrim(@pType)) + '%' or ltrim(rtrim(@pType)) = '') 
	and (ltrim(rtrim(isnull(DocIDPrevious,''))) like '%' + ltrim(rtrim(@pPrev)) + '%' or ltrim(rtrim(@pPrev)) = '') 
	and (ltrim(rtrim(isnull(Currency,''))) like '%' + ltrim(rtrim(@pCurr)) + '%' or ltrim(rtrim(@pCurr)) = '') 
	and (ltrim(rtrim(isnull(NameAproval,''))) like '%' + ltrim(rtrim(@pRAppr)) + '%' or ltrim(rtrim(@pRAppr)) = '') 
	and ClassDoc = 'Прочие / Договоры'
order by DateActivation

	--select @Result = @@error if @Result <> 0 goto Err

--	return @Result
--Err:
	
--	return @Result


GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_OTH_TRIPFind] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[PDX_REP_OTH_TRIPFind]
	@pDID varchar(128), --DocID, --Номер документа
	@pActDoc varchar(128),--ActDoc, --Вид деятельности
	@pDep varchar(255),--Department, --Подразделение
	@pUFT2 varchar(255), --UserFieldText2, --Место назначения (страна, населенный пункт)-
	@pAut varchar(255),  --Author, --ФИО командируемого
	@pDescr varchar(255),--Description, --Цель командировки по бухгалтерскому учету-
	@pUFT4 varchar(1024),--UserFieldText4, --Пункт назначения (наименование Организации)-
	@pUFT6 varchar(1024),--UserFieldText6, --Вид командировки
	@pUFT5 varchar(1024),--UserFieldText5, --Цель командировки по управленческому учету-
	@pUFT8 varchar(1024),--UserFieldText8, --Командировка за счет средств
	@pUFT7 varchar(1024),--UserFieldText7, --Основание Командировки-
	@pUFT3 varchar(1024),--UserFieldText3, --ЦФО
	@NCr varchar(96),
	@pUFD1_1 datetime,--UserFieldDate1, --Дата начала командировки
	@pUFD1_2 datetime,
	@pUFD2_1 datetime,--UserFieldDate2, --Дата окончания командировки
	@pUFD2_2 datetime,
	@pUFD3_1 datetime,--UserFieldDate4, --Срок предоставления отчета о командировке
	@pUFD3_2 datetime,
	
	@AVIA tinyint = 2,
	@VISA tinyint = 2,
	@HOTEL tinyint = 2,
	@VIP tinyint = 2,
	@INSURE tinyint = 2,
	@TRANSFER tinyint = 2,
	@Access bit = 1

as

declare @Cls varchar(128)

set @pDID = isnull(@pDID,'')
set @pActDoc = isnull(@pActDoc,'')
set @pDep = isnull(@pDep,'')
set @pUFT2 = isnull(@pUFT2,'')
set @pAut = isnull(@pAut,'')
set @NCr = isnull(@NCr,'')
set @pDescr = isnull(@pDescr,'')
set @pUFD1_1 = isnull(@pUFD1_1,'1900-01-01')
set @pUFD1_1 = case YEAR(@pUFD1_1) when 1900 then '1900-01-01' else @pUFD1_1 end
set @pUFD1_2 = isnull(@pUFD1_2,'1900-01-01')
set @pUFD1_2 = case YEAR(@pUFD1_2) when 1900 then '1900-01-01' else @pUFD1_2 end
set @pUFD2_1 = isnull(@pUFD2_1,'1900-01-01')
set @pUFD2_1 = case YEAR(@pUFD2_1) when 1900 then '1900-01-01' else @pUFD2_1 end
set @pUFD2_2 = isnull(@pUFD2_2,'1900-01-01')
set @pUFD2_2 = case YEAR(@pUFD2_2) when 1900 then '1900-01-01' else @pUFD2_2 end
set @pUFD3_1 = isnull(@pUFD3_1,'1900-01-01')
set @pUFD3_1 = case YEAR(@pUFD3_1) when 1900 then '1900-01-01' else @pUFD3_1 end
set @pUFD3_2 = isnull(@pUFD3_2,'1900-01-01')
set @pUFD3_2 = case YEAR(@pUFD3_2) when 1900 then '1900-01-01' else @pUFD3_2 end


set @pUFT4 = isnull(@pUFT4,'')
set @pUFT5 = isnull(@pUFT5,'')
set @pUFT6 = isnull(@pUFT6,'')
set @pUFT8 = isnull(@pUFT8,'')
set @pUFT7 = isnull(@pUFT7,'')
set @pUFT3 = isnull(@pUFT3,'')

set @AVIA = isnull(@AVIA,2)
set @VISA = isnull(@VISA,2)
set @HOTEL = isnull(@HOTEL,2)
set @VIP = isnull(@VIP,2)
set @INSURE = isnull(@INSURE,2)
set @TRANSFER = isnull(@TRANSFER,2)
	
	
select @NCr = case 
				when @NCr like '%<%>%'
					then dbo.PDX_SubstringReturn(@NCr, CHARINDEX('<',@NCr), charindex('>', @NCr))
				else @NCr
			  end,
		@pAut = case 
				when @pAut like '%<%>%'
					then dbo.PDX_SubstringReturn(@pAut, CHARINDEX('<',@pAut), charindex('>', @pAut))
				else @pAut
			  end

set @Cls = dbo.PDX_CLSGet('RIK_CategoryName_OTHERS_TRP')

select case @Access when 1 then 'system_report' else D.DocID end as DocID,
	D.ActDoc,
	D.Department,
	D.Author,
	D.UserFieldText2,
	D.UserFieldText4,
	D.UserFieldText6,
	D.UserFieldText5,
	D.Description,
	D.UserFieldText8,
	D.UserFieldText7,
	D.UserFieldDate1,
	D.UserFieldDate2,
	D.UserFieldDate4,
	D.UserFieldText3,
	D.UserFieldText1,
	D.ListToReconcile,
	D.NameAproval,
	D.ListToView,
	D.Correspondent,
	D.NameCreation,
	D.SecurityLevel,
	D.DateLastModification,
	case 
		when isnull(D.StatusDevelopment,0) <> '4' and upper(D.isActive) = 'Y'
			then '0'
		else '1'
	end as St, D.DocID as strID,
	dbo.REC_DocStatusRead(1,D.isActive, D.StatusCompletion, D.StatusDevelopment,
		D.ListToReconcile, D.ListReconciled, D.LocationPath) as StatusName,
		
		case T.AVIA when 0 then 'НЕТ' when 1 then 'ДА' else '--' end as AVIA,
		case T.VISA when 0 then 'НЕТ' when 1 then 'ДА' else '--' end as VISA,
		case T.HOTEL when 0 then 'НЕТ' when 1 then 'ДА' else '--' end as HOTEL,
		case T.VIP when 0 then 'НЕТ' when 1 then 'ДА' else '--' end as VIP,
		case T.INSURE when 0 then 'НЕТ' when 1 then 'ДА' else '--' end as INSURE,
		case T.TRANSFER when 0 then 'НЕТ' when 1 then 'ДА' else '--' end as TRANSFER
from dbo.Docs D with (nolock)
left join dbo.PDXTrip T on T.DocIDInt = D.DocIDInt
where D.isActive = 'Y'
	and (D.DocID like '%' + @pDID + '%' or @pDID = '') 
	and (D.ActDoc like '%' + @pActDoc + '%' or @pActDoc = '') 
	and (D.Description like '%' + @pDescr + '%' or @pDescr = '') 
	and (D.UserFieldText2 like '%' + @pUFT2 + '%' or @pUFT2 = '') 
	and (D.Department like '%' + @pDep + '%' or @pDep = '') 
	and (D.Author like '%' + @pAut + '%' or @pAut = '') 
	and (D.NameCreation like '%' + @Ncr + '%' or @NCr = '') 
	
	
	and (D.UserFieldText4 like '%' + @pUFT4 + '%' or @pUFT4 = '') 
	--and (D.UserFieldText6 like '%' + @pUFT6 + '%' or @pUFT6 = '')
	and (D.UserFieldText6 = @pUFT6 or @pUFT6 = '') 
	and (D.UserFieldText5 like '%' + @pUFT5 + '%' or @pUFT5 = '') 
	--and (D.UserFieldText8 like '%' + @pUFT8 + '%' or @pUFT8 = '')
	and (D.UserFieldText8 = @pUFT8 or @pUFT8 = '')  
	and (D.UserFieldText7 like '%' + @pUFT7 + '%' or @pUFT7 = '') 
	--and (D.UserFieldText3 like '%' + @pUFT3 + '%' or @pUFT3 = '') 
	and (D.UserFieldText3 = @pUFT3 or @pUFT3 = '') 
	
	and D.UserFieldDate1 between @pUFD1_1 and @pUFD1_2
	and D.UserFieldDate2 between @pUFD2_1 and @pUFD2_2
	and D.UserFieldDate4 between @pUFD3_1 and @pUFD3_2
	
	and (T.AVIA = @AVIA or @AVIA = 2)
	and (T.VISA = @VISA or @VISA = 2)
	and (T.HOTEL = @HOTEL or @HOTEL = 2)
	and (T.VIP = @VIP or @VIP = 2)
	and (T.INSURE = @INSURE or @INSURE = 2)
	and (T.TRANSFER = @TRANSFER or @TRANSFER = 2)
	
	and D.ClassDoc = @Cls
order by D.DateActivation

	--select @Result = @@error if @Result <> 0 goto Err

--	return @Result
--Err:
	
--	return @Result


GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_PAYCOR_Find] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[PDX_REP_PAYCOR_Find] --БАЗОВЫЙ ПЛАН ПЛАТЕЖЕЙ (детальный)
	@DID varchar(128),
	@UFD3f datetime,
	@UFD3t datetime,
	@UFT7 varchar(64),
	@Currency varchar(64),
	@UFT8 varchar(512),
	@UFT2 varchar(512),
	@PN varchar(512),
	@UFT4 varchar(512),
	@UFT3 varchar(512),
	@UFT5 varchar(512),
	@Name varchar(128),
	@DIDPar varchar(128),
	@DIDPrev varchar(128),
	@UFT6 varchar(512),
	@NCr varchar(96),
	@State int, --1 - все, кроме отмен, 2- на согл, 3 - треб утв, 4 утв, 5 - отмен
	@Access bit = 1
as
	declare @Result int
	set @Result = 0

	select @UFT2 = ltrim(rtrim(ISNULL(@UFT2,''))),
		@UFT3 = ltrim(rtrim(ISNULL(@UFT3,''))),
		@UFT4 = ltrim(rtrim(ISNULL(@UFT4,''))),
		@UFT5 = ltrim(rtrim(ISNULL(@UFT5,''))),
		@UFT6 = ltrim(rtrim(ISNULL(@UFT6,''))),
		@UFT7 = ltrim(rtrim(ISNULL(@UFT7,''))),
		@UFT8 = ltrim(rtrim(ISNULL(@UFT8,''))),
		@Currency = ltrim(rtrim(ISNULL(@Currency,''))),
		@PN = ltrim(rtrim(ISNULL(@PN,''))),
		@Name = ltrim(rtrim(ISNULL(@Name,''))),
		@DIDPar = ltrim(rtrim(ISNULL(@DIDPar,''))),
		@DIDPrev = ltrim(rtrim(ISNULL(@DIDPrev,''))),
		@NCr = case when ISNULL(@NCr,'') like '%<%>%' 
					then dbo.PDX_SubstringReturn(ISNULL(@NCr,''), CHARINDEX('<',ISNULL(@NCr,'')), charindex('>',ISNULL(@NCr,'')))
					else ltrim(rtrim(ISNULL(@NCr,''))) end
	select @Result = @@error if @Result <> 0 goto Err
 
	select 
		case @Access when 1 then 'system_report' else DocID end as DocID,
		DocID as strID, 
		UserFieldDate3, --Рег. дата
		Currency, --Валюта
		UserFieldText8, --Бизнес единица
		NameAproval, --Фин. Менеджер
		UserFieldText2, --Исх. ЦФО
		UserFieldText3, --Треб. ЦФО
		PartnerName, --Отправитель\Получатель
		UserFieldText4, --Проект
		UserFieldText5, --Исх. статья расходов
		UserFieldText7, --Треб. статья расходов
		Name, --Назначение
		AmountDoc, --Сумма
		DocIDParent, --Оплата по договору №
		DocIDPrevious, --№ договора с Заказчиком
		UserFieldText6, --Счет
		Description, --Основание
		NameCreation, --Заявитель
		UserFieldText1, --Наименование листа согласования
		ListToReconcile, --Лист согласования
		Correspondent, --Список рассылки
		ListToEdit , --Список имеющих право редактирования д-та 
		dbo.REC_DocStatusRead(1,isActive,StatusCompletion,StatusDevelopment,
			ListToReconcile, ListReconciled, LocationPath) as Status
	from dbo.Docs
	where ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_FIN_CORPAY')
		and UPPER(ISNULL(IsActive,'')) = 'Y'
		and (DocID like '%' + @DID + '%' or @DID = '')
		and UserFieldDate3 between @UFD3f and @UFD3t
		and (UserFieldText7 = @UFT7 or @UFT7 = '')
		and (Currency = @Currency or @Currency = '')
		and (UserFieldText8 = @UFT8 or @UFT8 = '')
		and (UserFieldText2 = @UFT2 or @UFT2 = '')
		and (PartnerName = @PN or @PN = '')
		and (UserFieldText4 = @UFT4 or @UFT4 = '')
		and (UserFieldText3 = @UFT3 or @UFT3 = '')
		and (UserFieldText5 = @UFT5 or @UFT5 = '')
		and (Name like '%' + @Name +'%' or Description like '%' + @Name + '%')
		and (DocIDParent = @DIDPar or @DIDPar = '')
		and (DocIDPrevious = @DIDPrev or @DIDPrev = '')
		and (UserFieldText6 = @UFT6 or @UFT6 = '')
		and (NameCreation like '%<' + @NCr + '>%' or @NCr = '')
		and StatusDevelopment = case @State when 4 then '4' else StatusDevelopment end
		and StatusDevelopment <> case when @State in (2,4) then '4' else '-' end
		and dbo.PDX_CompareReconcilationList(listToReconcile, ListReconciled) = case @State when 3 then 1 else dbo.PDX_CompareReconcilationList(listToReconcile, ListReconciled) end
		and isnull(StatusCompletion,'') = case @State when 5 then '0' else isnull(StatusCompletion,'') end
		and isnull(StatusCompletion,'') <> case @State when 5 then '%^&*^(*' else '0' end
	order by UserFieldDate3, DocID
	select @Result = @@error if @Result <> 0 goto Err	
	
	return @Result
Err:

	drop table #cfo
	drop table #rescfo
	return @Result


GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_PAYCORn_Find] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[PDX_REP_PAYCORn_Find] --БАЗОВЫЙ ПЛАН ПЛАТЕЖЕЙ (детальный)
	@DID varchar(128),
	@UFD3f datetime,
	@UFD3t datetime,
	@UFT7 varchar(64),
	@Currency varchar(64),
	@UFT8 varchar(512),
	@UFT2 varchar(512),
	@PN varchar(512),
	@UFT4 varchar(512),
	@UFT3 varchar(512),
	@UFT5 varchar(512),
	@Name varchar(128),
	@DIDPar varchar(128),
	@DIDPrev varchar(128),
	@UFT6 varchar(512),
	@NCr varchar(96),
	@State int, --1 - все, кроме отмен, 2- на согл, 3 - треб утв, 4 утв, 5 - отмен
	@Access bit = 1
as
	declare @Result int, @Cls varchar(128)
	set @Result = 0

	set @Cls = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_CORPAY')
	select @UFT2 = ltrim(rtrim(ISNULL(@UFT2,''))),
		@UFT3 = ltrim(rtrim(ISNULL(@UFT3,''))),
		@UFT4 = ltrim(rtrim(ISNULL(@UFT4,''))),
		@UFT5 = ltrim(rtrim(ISNULL(@UFT5,''))),
		@UFT6 = ltrim(rtrim(ISNULL(@UFT6,''))),
		@UFT7 = ltrim(rtrim(ISNULL(@UFT7,''))),
		@UFT8 = ltrim(rtrim(ISNULL(@UFT8,''))),
		@Currency = ltrim(rtrim(ISNULL(@Currency,''))),
		@PN = ltrim(rtrim(ISNULL(@PN,''))),
		@Name = ltrim(rtrim(ISNULL(@Name,''))),
		@DIDPar = ltrim(rtrim(ISNULL(@DIDPar,''))),
		@DIDPrev = ltrim(rtrim(ISNULL(@DIDPrev,''))),
		@NCr = case when ISNULL(@NCr,'') like '%<%>%' 
					then dbo.PDX_SubstringReturn(ISNULL(@NCr,''), CHARINDEX('<',ISNULL(@NCr,'')), charindex('>',ISNULL(@NCr,'')))
					else ltrim(rtrim(ISNULL(@NCr,''))) end
	select @Result = @@error if @Result <> 0 goto Err
 
	create table #treeRes (Code varchar(128))
	
	if @UFT4 like '<%>%'
	begin		
		-- и еще раз достраиваем нижние уровни
		;with treeResFirst2 (KeyField, ParentKeyField, code, descr)
		as
		(
			-- сами узелки
			select T1.KeyField, T1.ParentKeyField, cast(T1.Code as varchar(max)), cast(T1.descr as varchar(max))
			from UserDir_ISR T1
			where '<'+Code+'>'=LEFT(@UFT4, charindex('>',@UFT4))
			-- нижние
			union all
			select	I.KeyField, I.ParentKeyField,
					cast(I.Code as varchar(max)) as Code,
					cast(I.descr as varchar(max))
			from UserDir_ISR I 
				inner join treeResFirst2 T on T.KeyField = I.ParentKeyField
			
			
		)
		
			insert into #treeRes (Code)
			select '<' + Code + '>'
			from treeResFirst2
	end
	
	if not exists (select 1 from #treeRes)
	begin
		if @UFT4 <> ''
		begin
			insert into #treeRes (Code) values (@UFT4)
		end
		else
		begin
			insert into #treeRes (Code) values ('')
		end
	end
	
	select 
		case @Access when 1 then 'system_report' else D.DocID end as DocID,
		D.DocID as strID, 
		D.UserFieldDate3, --Рег. дата
		D.Currency, --Валюта
		D.UserFieldText8, --Бизнес единица
		D.NameAproval, --Фин. Менеджер
		D.UserFieldText2, --Исх. ЦФО
		D.UserFieldText3, --Треб. ЦФО
		D.PartnerName, --Отправитель\Получатель
		D.UserFieldText4, --Код ИСР
		D.UserFieldText5, --Исх. статья расходов
		D.UserFieldText7, --Треб. статья расходов
		D.Name, --Назначение
		D.AmountDoc, --Сумма
		D.DocIDParent, --Оплата по договору №
		D.DocIDPrevious, --№ договора с Заказчиком
		D.UserFieldText6, --Счет
		D.Description, --Основание
		D.NameCreation, --Заявитель
		D.UserFieldText1, --Наименование листа согласования
		D.ListToReconcile, --Лист согласования
		D.Correspondent, --Список рассылки
		D.ListToEdit , --Список имеющих право редактирования д-та 
		dbo.REC_DocStatusRead(1,D.isActive,D.StatusCompletion,D.StatusDevelopment,
			D.ListToReconcile, D.ListReconciled, D.LocationPath) as Status
	from dbo.Docs D
	inner join #treeRes R on D.UserFieldText4 like R.Code + '%'
	where D.ClassDoc = @Cls
		and UPPER(ISNULL(D.IsActive,'')) = 'Y'
		and (D.DocID like '%' + @DID + '%' or @DID = '')
		and D.UserFieldDate3 between @UFD3f and @UFD3t
		and (D.UserFieldText7 = @UFT7 or @UFT7 = '')
		and (D.Currency = @Currency or @Currency = '')
		and (D.UserFieldText8 = @UFT8 or @UFT8 = '')
		and (D.UserFieldText2 = @UFT2 or @UFT2 = '')
		and (D.PartnerName = @PN or @PN = '')
		--and (UserFieldText4 = @UFT4 or @UFT4 = '')
		and (D.UserFieldText3 = @UFT3 or @UFT3 = '')
		and (D.UserFieldText5 = @UFT5 or @UFT5 = '')
		and (D.Name like '%' + @Name +'%' or D.Description like '%' + @Name + '%')
		and (D.DocIDParent = @DIDPar or @DIDPar = '')
		and (D.DocIDPrevious = @DIDPrev or @DIDPrev = '')
		and (D.UserFieldText6 = @UFT6 or @UFT6 = '')
		and (D.NameCreation like '%<' + @NCr + '>%' or @NCr = '')
		and D.StatusDevelopment = case @State when 4 then '4' else D.StatusDevelopment end
		and D.StatusDevelopment <> case when @State in (2,3) then '4' else '-' end
		and dbo.PDX_CompareReconcilationList(D.listToReconcile, D.ListReconciled) = case @State when 3 then 1 else dbo.PDX_CompareReconcilationList(D.listToReconcile, D.ListReconciled) end
		and isnull(D.StatusCompletion,'') = case @State when 5 then '0' else isnull(D.StatusCompletion,'') end
		and isnull(D.StatusCompletion,'') <> case @State when 5 then '%^&*^(*' else '0' end
	order by D.UserFieldDate3, D.DocID
	select @Result = @@error if @Result <> 0 goto Err	
	
	drop table #treeRes
	return @Result
Err:
	return @Result


GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_PAYCORn2_Find] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_REP_PAYCORn2_Find] --БАЗОВЫЙ ПЛАН ПЛАТЕЖЕЙ (детальный)
	@DID varchar(128),
	@UFD3f datetime,
	@UFD3t datetime,
	@UFT7 varchar(64),
	@Currency varchar(64),
	@UFT8 varchar(512),
	@UFT2 varchar(512),
	@PN varchar(512),
	@UFT4 varchar(512),
	@UFT3 varchar(512),
	@UFT5 varchar(512),
	@Name varchar(128),
	@DIDPar varchar(128),
	@DIDPrev varchar(128),
	@UFT6 varchar(512),
	@NCr varchar(96),
	@State int, --1 - все, кроме отмен, 2- на согл, 3 - треб утв, 4 утв, 5 - отмен
	@Access bit = 1
as
	declare @Result int
	set @Result = 0

	create table #REP1
	(	DocID varchar(128),
		strID varchar(128),
		UserFieldDate3 datetime,
		Currency varchar(12),
		UserFieldText8 varchar(1024),
		NameAproval varchar(96),
		UserFieldText2 varchar(1024),
		UserFieldText3 varchar(1024),
		PartnerName varchar(512),
		UserFieldText4 varchar(1024),
		UserFieldText5 varchar(1024),
		UserFieldText7 varchar(1024),
		Name varchar(256), 
		AmountDoc money,
		DocIDParent varchar(128),
		DocIDPrevious varchar(128),
		UserFieldText6 varchar(1024),
		Description varchar(1024),
		NameCreation varchar(96),
		UserFieldText1 varchar(1024),
		ListToReconcile varchar(1024),
		Correspondent varchar(1024), 
		ListToEdit varchar(1024),
		Status varchar(256))

		insert into #REP1
		exec PayDoxOP.[dbo].[PDX_REP_PAYCORn_Find] --БАЗОВЫЙ ПЛАН ПЛАТЕЖЕЙ (детальный)
			@DID = @DID,
			@UFD3f = @UFD3f,
			@UFD3t = @UFD3t,
			@UFT7 = @UFT7,
			@Currency = @Currency,
			@UFT8 = @UFT8,
			@UFT2 = @UFT2,
			@PN = @PN,
			@UFT4 = @UFT4,
			@UFT3 = @UFT3,
			@UFT5 = @UFT5,
			@Name = @Name,
			@DIDPar = @DIDPar,
			@DIDPrev = @DIDPrev,
			@UFT6 = @UFT6,
			@NCr = @NCr,
			@State = @State,
			@Access = @Access

 
	drop table #REP1
	select @Result = @@error if @Result <> 0 goto Err	
	
	return @Result
Err:
	return @Result


GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_PAYDetails] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[PDX_REP_PAYDetails] 
    @DateFrom datetime,--a.	Начальная дата платежей
    @DateTo datetime,--b.	Конечная дата платежей
    @UFT8 varchar(1024),--c.	Бизнес-единица
    @UFT2 varchar(1024),--d.	ЦФО  
    @UserID varchar(96)  
    --@Access bit = 1
as
	declare @Result int, @Cls varchar(128), @ClsGr varchar(128)
	set @Result = 0

	--declare @CFO table (name varchar(256))
	create table #res1
		(DocID varchar(128),
		bDocID varchar(256),
		Amount money,
		Currency varchar(32),
		Date datetime,
		DocIDParent varchar(128),
		PartnerName varchar(512),
		NameCreation varchar(128),
		DateApproved datetime,
		DateRegister datetime,
		StatusDG varchar(128))
	
	create table #res2
		(DocID varchar(128),
		DateRegister datetime)
			
	select @UFT2 = ltrim(rtrim(ISNULL(@UFT2,''))),
		@UFT8 = ltrim(rtrim(ISNULL(@UFT8,'')))	,
		@UserID = ltrim(rtrim(ISNULL(@UserID,'')))					
	select @Result = @@error if @Result <> 0 goto Err
 
	set @Cls = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_ORDPAY')
	set @ClsGr = dbo.PDX_CLSGrGet('RIK_CategoryName_DOGOVORY_X')
	
    /*if @UserID <> ''
    begin
		If (select top 1 
				case when ReadSecurityLevel = 10 and WriteSecurityLevel = 10 
				then 1 else 0 end 
			from Users where UserID = @UserID) = 1
		begin
			insert into @CFO (name)
			select name from dbo.PDX_pay_CFO
			select @Result = @@error if @Result <> 0 goto Err
		end
		else
		begin
			insert into @CFO (name)
			select name from dbo.PDX_pay_CFO
			where Manager like '%<' + @UserID + '>%'
			select @Result = @@error if @Result <> 0 goto Err
		end
    end */
--select * from @CFO
	insert into #res1
		(DocID,
		bDocID,
		Amount,
		Currency,
		Date,
		DocIDParent,
		PartnerName,
		NameCreation,
		DateApproved,
		DateRegister,
		StatusDG)
	select 
		--case @Access when 1 then 'system_report' else D.DocID end as DocID,
		D.DocID as strID,
		P.bDocID,
		P.Amount,
		D.Currency,
		P.Date,
		D.DocIDParent,
		C.PartnerName,
		C.NameCreation,
		case when ltrim(REPLACE(REPLACE(isnull(C.ListToReconcile,''), '(#!)',''), '(#$)','')) = ''
				and isnull(C.NameApproved,'') <> ''
				and C.StatusDevelopment = '4'
			then ISNULL(C.DateApproved, C.DateActivation) --это по архивным карточкам
			else C.DateApproved
		end,
		case when ltrim(REPLACE(REPLACE(isnull(C.ListToReconcile,''), '(#!)',''), '(#$)','')) = ''
				and isnull(C.NameApproved,'') <> ''
				and C.StatusDevelopment = '4'
			then ISNULL(C.DateApproved, C.DateActivation) --это по архивным карточкам
			else null
		end,
		dbo.REC_DocStatusRead(1, C.IsActive, C.StatusCompletion, C.StatusDevelopment,
		C.ListToReconcile, C.ListReconciled, C.LocationPath) as St
	from dbo.Docs D
	--inner join @CFO F on F.name = D.UserFieldText2
	inner join dbo.PayDetails P on P.TransferGUID = D.TransferGUID
		and P.Date between @DateFrom and @DateTo
	inner join dbo.Docs C on C.DocID = D.DocIDParent
		and C.ClassDoc like @ClsGr + '%'
	where D.ClassDoc = @Cls
		and UPPER(ISNULL(D.IsActive,'')) = 'Y'
		and (D.UserFieldText8 = @UFT8 or @UFT8 = '')
		and (D.UserFieldText2 = @UFT2 or @UFT2 = '')
		and (D.StatusDevelopment <> '0' or D.StatusDevelopment is null)
		and (D.StatusCompletion <> '0' or D.StatusCompletion is null)
	select @Result = @@error if @Result <> 0 goto Err	
	
	insert into #res2 (DocID, DateRegister)
	select C.DocID, max(C.DateCreation) as DC
	from (select distinct DocIDParent as DocID from #res1) R
	inner join dbo.Comments C on C.DocID = R.DocID
		and C.CommentType = 'HISTORY'
		and (C.Comment like 'Document registered%'
				or C.Comment like 'Документ зарегистрирован%')
	group by C.DocID
	select @Result = @@error if @Result <> 0 goto Err
	
	update R1
		set DateRegister = R2.DateRegister
	from #res1 R1
	inner join #res2  R2 on R1.DocIDParent = R2. DocID
	select @Result = @@error if @Result <> 0 goto Err
	
	update #res1
	set Date = CONVERT(datetime, CONVERT(varchar(100), Date, 104), 104),
		DateRegister = CONVERT(datetime, CONVERT(varchar(100), DateRegister, 104), 104),
		DateApproved = CONVERT(datetime, CONVERT(varchar(100), DateApproved, 104), 104)
	select @Result = @@error if @Result <> 0 goto Err
	
	--нас интересуют платежи, где оригиналы предоставили после проведения платежа
	delete from #res1
	where DateRegister < Date
	and not DateRegister is null
	select @Result = @@error if @Result <> 0 goto Err
	
	select DocID as strID,
		bDocID,
		replace(cast(Amount as varchar(1000)),'.',',') as Amount,
		Currency,
		Date,
		DocIDParent,
		PartnerName,
		NameCreation,
		DateApproved,
		DATEADD(day,7,DateApproved) as DateRegisterPlan,
		DateRegister,
		StatusDG,
		case when not (DateApproved is null or DateRegister is null)
			then DATEDIFF(day,DATEADD(day,7,DateApproved), DateRegister)
			else null end as Diff
	from #res1
	order by DocIDParent, DocID
	select @Result = @@error if @Result <> 0 goto Err
		
	return @Result
Err:

	return @Result









GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_PAYORD_Find] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[PDX_REP_PAYORD_Find] --ПОИСК заявок по основным реквизитам (казначейство)
	@DID varchar(128),
	@DAf datetime,
	@DAt datetime,
	@DSf datetime,
	@DSt datetime,
	@UFT7 varchar(64),
	@Currency varchar(64),
	@UFT8 varchar(512),
	@UFT2 varchar(512),
	@PN varchar(512),
	@UFT4 varchar(512),
	@UFT5 varchar(512),
	@Name varchar(128),
	@DIDPar varchar(128),
	@DIDPrev varchar(128),
	@UFT6 varchar(512),
	@NCr varchar(96),
	@State int, --1 - все, кроме отмен, 2- на согл, 3 - треб утв, 4 утв, 5 - отмен
	@Access bit = 1
as
	declare @Result int, @Cls varchar(128)
	set @Result = 0

-- DocID  Рег. номер
-- UserFieldText7  Наличный расчет
-- Currency  Валюта
-- UserFieldText8  Бизнес единица
-- NameAproval  Заявитель
-- UserFieldText2  ЦФО
-- PartnerName  Отправитель\Получатель
-- UserFieldText4  Код ИСР
-- UserFieldText5  Статья расходов
-- Name  Назначение
-- AmountDoc  Сумма (общая)
-- DocIDParent  Оплата по договору №
-- DocIDPrevious  № договора с Заказчиком
-- UserFieldText6  Счет
-- Description  Основание
-- NameCreation  Автор
-- DateSigned  Дата оплаты
-- UserFieldText1  Наименование листа согласования
-- ListToReconcile  Лист согласования
-- Correspondent  Список рассылки


	set @Cls = dbo.PDX_CLSGet('RIK_CategoryName_FIN_ORDPAY')
	
	select @UFT2 = ltrim(rtrim(ISNULL(@UFT2,''))),
		@UFT4 = ltrim(rtrim(ISNULL(@UFT4,''))),
		@UFT5 = ltrim(rtrim(ISNULL(@UFT5,''))),
		@UFT6 = ltrim(rtrim(ISNULL(@UFT6,''))),
		@UFT7 = ltrim(rtrim(ISNULL(@UFT7,''))),
		@UFT8 = ltrim(rtrim(ISNULL(@UFT8,''))),
		@Currency = ltrim(rtrim(ISNULL(@Currency,''))),
		@PN = ltrim(rtrim(ISNULL(@PN,''))),
		@Name = ltrim(rtrim(ISNULL(@Name,''))),
		@DIDPar = ltrim(rtrim(ISNULL(@DIDPar,''))),
		@DIDPrev = ltrim(rtrim(ISNULL(@DIDPrev,''))),
		@NCr = case when ISNULL(@NCr,'') like '%<%>%' 
					then dbo.PDX_SubstringReturn(ISNULL(@NCr,''), CHARINDEX('<',ISNULL(@NCr,'')), charindex('>',ISNULL(@NCr,'')))
					else ltrim(rtrim(ISNULL(@NCr,''))) end,
		@DAt = dateadd(MILLISECOND,-1,DATEADD(DAY, 1, @DAt)),
		@DSt = dateadd(MILLISECOND,-1,DATEADD(DAY, 1, @DSt))
	select @Result = @@error if @Result <> 0 goto Err
 
	select 
		case @Access when 1 then 'system_report' else DocID end as DocID,
		DocID as strID, 
		DateActivation, --Рег. дата
		DateSigned, -- дата оплаты
		UserFieldText7, --Наличный расчет
		Currency, --Валюта
		UserFieldText8, --Бизнес единица
		NameAproval, --Фин. Менеджер
		UserFieldText2, --ЦФО
		PartnerName, --Отправитель\Получатель
		UserFieldText4, --Код ИСР
		case	
			when charindex('<',UserFieldText5)> 0
				then LEFT(UserFieldText5, CHARINDEX('<',UserFieldText5)-1)
			else UserFieldText5
		end as UserFieldText5, --Статья расходов
		dbo.PDX_SubstringReturn(UserFieldText5, CHARINDEX('<',UserFieldText5), charindex('>',UserFieldText5)) as UFT5,
		Name, --Назначение
		AmountDoc, --Сумма
		DocIDParent, --Оплата по договору №
		DocIDPrevious, --№ договора с Заказчиком
		UserFieldText6, --Счет
		Description, --Основание
		NameCreation, --Заявитель
		UserFieldText1, --Наименование листа согласования
		ListToReconcile, --Лист согласования
		Correspondent, --Список рассылки
		ListToEdit, --Список имеющих право редактирования д-та 
		dbo.REC_DocStatusRead(1,isActive,StatusCompletion,StatusDevelopment,
			ListToReconcile, ListReconciled, LocationPath) as Status
	from dbo.Docs
	where ClassDoc = @Cls
		and UPPER(ISNULL(IsActive,'')) = 'Y'
		and (DocID like '%' + @DID + '%' or @DID = '')
		and DateActivation between @DAf and @DAt
		and isnull(DateSigned,'1900-01-01') between @DSf and @DSt
		and (UserFieldText7 = @UFT7 or @UFT7 = '')
		and (Currency = @Currency or @Currency = '')
		and (UserFieldText8 = @UFT8 or @UFT8 = '')
		and (UserFieldText2 = @UFT2 or @UFT2 = '')
		and (PartnerName = @PN or @PN = '')
		and (UserFieldText4 = @UFT4 or @UFT4 = '')
		and (UserFieldText5 = @UFT5 or @UFT5 = '')
		and (Name like '%' + @Name +'%' or Description like '%' + @Name + '%')
		and (DocIDParent = @DIDPar or @DIDPar = '')
		and (DocIDPrevious = @DIDPrev or @DIDPrev = '')
		and (UserFieldText6 = @UFT6 or @UFT6 = '')
		and (NameCreation like '%<' + @NCr + '>%' or @NCr = '')
		and isnull(StatusDevelopment,'') = case @State when 4 then '4' else StatusDevelopment end
		and isnull(StatusDevelopment,'') <> case when @State in (2,3) then '4' else '-' end
		and dbo.PDX_CompareReconcilationList(listToReconcile, ListReconciled) = case @State when 3 then 1 else dbo.PDX_CompareReconcilationList(listToReconcile, ListReconciled) end
		and isnull(StatusCompletion,'') = case @State when 5 then '0' else isnull(StatusCompletion,'') end
		and isnull(StatusCompletion,'') <> case @State when 5 then '%^&*^(*' else '0' end
	order by DateActivation, DocID
	select @Result = @@error if @Result <> 0 goto Err	
	
	return @Result
Err:

	return @Result



GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_PAYORDn_Find] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_REP_PAYORDn_Find] --ПОИСК плановых заявок по основным реквизитам (казначейство)
	@DID varchar(128),
	@DAf datetime,
	@DAt datetime,
	@DSf datetime,
	@DSt datetime,
	@UFT7 varchar(64),
	@Currency varchar(64),
	@UFT8 varchar(512),
	@UFT2 varchar(512),
	@PN varchar(512),
	@UFT4 varchar(512),
	@UFT5 varchar(512),
	@Name varchar(128),
	@DIDPar varchar(128),
	@DIDPrev varchar(128),
	@UFT6 varchar(512),
	@NCr varchar(96),
	@State int, --1 - все, кроме отмен, 2- на согл, 3 - треб утв, 4 утв, 5 - отмен
	@UFM2 tinyint = 2 , --2-все, 1-да, 0-нет
	@Access bit = 1
as
	declare @Result int, @Cls varchar(128)
	set @Result = 0

-- DocID  Рег. номер
-- UserFieldText7  Наличный расчет
-- Currency  Валюта
-- UserFieldText8  Бизнес единица
-- NameAproval  Заявитель
-- UserFieldText2  ЦФО
-- PartnerName  Отправитель\Получатель
-- UserFieldText4  Код ИСР
-- UserFieldText5  Статья расходов
-- Name  Назначение
-- AmountDoc  Сумма (общая)
-- DocIDParent  Оплата по договору №
-- DocIDPrevious  № договора с Заказчиком
-- UserFieldText6  Счет
-- Description  Основание
-- NameCreation  Автор
-- DateSigned  Дата оплаты
-- UserFieldText1  Наименование листа согласования
-- ListToReconcile  Лист согласования
-- Correspondent  Список рассылки


	set @Cls = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_ORDPAY')
	
	select @UFT2 = ltrim(rtrim(ISNULL(@UFT2,''))),
		@UFT4 = ltrim(rtrim(ISNULL(@UFT4,''))),
		@UFT5 = ltrim(rtrim(ISNULL(@UFT5,''))),
		@UFT6 = ltrim(rtrim(ISNULL(@UFT6,''))),
		@UFT7 = ltrim(rtrim(ISNULL(@UFT7,''))),
		@UFT8 = ltrim(rtrim(ISNULL(@UFT8,''))),
		@Currency = ltrim(rtrim(ISNULL(@Currency,''))),
		@PN = ltrim(rtrim(ISNULL(@PN,''))),
		@Name = ltrim(rtrim(ISNULL(@Name,''))),
		@DID = ltrim(rtrim(ISNULL(@DID,''))),
		@DIDPar = ltrim(rtrim(ISNULL(@DIDPar,''))),
		@DIDPrev = ltrim(rtrim(ISNULL(@DIDPrev,''))),
		@NCr = case when ISNULL(@NCr,'') like '%<%>%' 
					then dbo.PDX_SubstringReturn(ISNULL(@NCr,''), CHARINDEX('<',ISNULL(@NCr,'')), charindex('>',ISNULL(@NCr,'')))
					else ltrim(rtrim(ISNULL(@NCr,''))) end,
		@DAt = dateadd(MILLISECOND,-1,DATEADD(DAY, 1, @DAt)),
		@DSt = dateadd(MILLISECOND,-1,DATEADD(DAY, 1, @DSt))
	select @Result = @@error if @Result <> 0 goto Err
 
	create table #treeRes (Code varchar(128))
	
	if @UFT4 like '<%>%'
	begin		
		-- и еще раз достраиваем нижние уровни
		;with treeResFirst2 (KeyField, ParentKeyField, code, descr)
		as
		(
			-- сами узелки
			select T1.KeyField, T1.ParentKeyField, cast(T1.Code as varchar(max)), cast(T1.descr as varchar(max))
			from UserDir_ISR T1
			where '<'+Code+'>'=LEFT(@UFT4, charindex('>',@UFT4))
			-- нижние
			union all
			select	I.KeyField, I.ParentKeyField,
					cast(I.Code as varchar(max)) as Code,
					cast(I.descr as varchar(max))
			from UserDir_ISR I 
				inner join treeResFirst2 T on T.KeyField = I.ParentKeyField
			
			
		)
		
			insert into #treeRes (Code)
			select '<' + Code + '>'
			from treeResFirst2
	end
	
	if not exists (select 1 from #treeRes)
	begin
		if @UFT4 <> ''
		begin
			insert into #treeRes (Code) values (@UFT4)
		end
		else
		begin
			insert into #treeRes (Code) values ('')
		end
	end
	 
	select 
		case @Access when 1 then 'system_report' else DocID end as DocID,
		D.DocID as strID, 
		D.DateActivation, --Рег. дата
		D.DateSigned, -- дата оплаты
		D.UserFieldText7, --Наличный расчет
		D.Currency, --Валюта
		D.UserFieldText8, --Бизнес единица
		D.NameAproval, --Фин. Менеджер
		D.UserFieldText2, --ЦФО
		D.PartnerName, --Отправитель\Получатель
		D.UserFieldText4, --Код ИСР
		case	
			when charindex('<',D.UserFieldText5)> 0
				then LEFT(D.UserFieldText5, CHARINDEX('<',D.UserFieldText5)-1)
			else D.UserFieldText5
		end as UserFieldText5, --Статья расходов
		dbo.PDX_SubstringReturn(D.UserFieldText5, CHARINDEX('<',D.UserFieldText5), charindex('>',D.UserFieldText5)) as UFT5,
		D.Name, --Назначение
		D.AmountDoc, --Сумма
		D.DocIDParent, --Оплата по договору №
		D.DocIDPrevious, --№ договора с Заказчиком
		D.UserFieldText6, --Счет
		D.Description, --Основание
		D.NameCreation, --Заявитель
		D.UserFieldText1, --Наименование листа согласования
		D.ListToReconcile, --Лист согласования
		D.Correspondent, --Список рассылки
		D.ListToEdit, --Список имеющих право редактирования д-та 
		dbo.REC_DocStatusRead(1,D.isActive,D.StatusCompletion,D.StatusDevelopment,
			D.ListToReconcile, D.ListReconciled, D.LocationPath) as Status,
		D.UserFieldMoney2 as UFM2
	from dbo.Docs D
	inner join #treeRes R on D.UserFieldText4 like R.Code + '%'
	where D.ClassDoc = @Cls
		and UPPER(ISNULL(D.IsActive,'')) = 'Y'
		and (D.DocID like '%' + @DID + '%' or @DID = '')
		and D.DateActivation between @DAf and @DAt
		and isnull(D.DateSigned,'1900-02-02') between @DSf and @DSt
		and (D.UserFieldText7 = @UFT7 or @UFT7 = '')
		and (D.Currency = @Currency or @Currency = '')
		and (D.UserFieldText8 = @UFT8 or @UFT8 = '')
		and (D.UserFieldText2 = @UFT2 or @UFT2 = '')
		and (D.PartnerName = @PN or @PN = '')
		--and (UserFieldText4 = @UFT4 or @UFT4 = '')
		and (D.UserFieldText5 = @UFT5 or @UFT5 = '')
		and (D.Name like '%' + @Name +'%' or Description like '%' + @Name + '%')
		and (D.DocIDParent = @DIDPar or @DIDPar = '')
		and (D.DocIDPrevious = @DIDPrev or @DIDPrev = '')
		and (D.UserFieldText6 = @UFT6 or @UFT6 = '')
		and (D.NameCreation like '%<' + @NCr + '>%' or @NCr = '')
		and isnull(D.StatusDevelopment,'') = case @State when 4 then '4' else StatusDevelopment end
		and isnull(D.StatusDevelopment,'') <> case when @State in (2,3) then '4' else '-' end
		and dbo.PDX_CompareReconcilationList(D.listToReconcile, D.ListReconciled) = case @State when 3 then 1 else dbo.PDX_CompareReconcilationList(listToReconcile, ListReconciled) end
		and isnull(D.StatusCompletion,'') = case @State when 5 then '0' else isnull(D.StatusCompletion,'') end
		and isnull(D.StatusCompletion,'') <> case @State when 5 then '%^&*^(*' else '0' end
		and (D.UserFieldMoney2 = @UFM2 or @UFM2 = 2)
	order by D.DateActivation, D.DocID
	select @Result = @@error if @Result <> 0 goto Err	

	drop table #treeRes
	return @Result
Err:

	return @Result






GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_PAYPLN_currdetails_Get] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[PDX_REP_PAYPLN_currdetails_Get] --БАЗОВЫЙ ПЛАН ПЛАТЕЖЕЙ (детальный)
	@CFO varchar(128),
	@FName varchar(256),
	@Date datetime,
	@USD money,
	@EUR money,
	@CAD money
as
	declare @Result int
	set @Result = 0

    create table #cfo (KeyField int identity,
						Code varchar(64), 
						AmountDoc money, 
						DT int,
						PName varchar(512),
						UName varchar(96),
						DName varchar(256),
						Descr varchar(1024),
						UFT8 varchar(512),
						DocID varchar(128),
						UFD3 datetime,
    Curr varchar(100), AmountCurr money, AccType varchar(255))
    
    create table #rescfo (
		KeyField int,  
		Code varchar(64),
		GrName varchar(256),
		GrCode int,
		UFT5 varchar(512), 
		Lev int)
		
	declare @ClassName varchar(128),  @Cnt int, @Lev int,
			@SQLStr varchar(7000), @Month varchar(2),
			@Val varchar(255)
	declare @Digital table (Val varchar(255), TP int, OI int identity, Dig int)
	
	select @ClassName = dbo.PDX_CLSGet('RIK_CategoryName_FIN_PLNPAY'),
		@Month = case when MONTH(@Date) <10 then '0' else '' end + CAST(MONTH(@Date) as varchar(2)),
		@CFO = ltrim(rtrim(ISNULL(@CFO,''))),
		@FName = ltrim(rtrim(ISNULL(@FName,'')))
	select @Result = @@error if @Result <> 0 goto Err
	
	insert into #rescfo
		(Code, GrName, UFT5, Lev, KeyField)
	select Code, GrName, Name, 1,
		cast(case when Code like '%.%' then LEFT(Code, charindex('.',Code)-1) else Code end as int) * 10
	from dbo.PDX_pay_PRiZ
	select @Result = @@error if @Result <> 0 goto Err
	
	update R
		set GrCode = X.KF
	from #rescfo R
	inner join (select min(KeyField)-1 as KF, GrName from #rescfo group by GrName) as X
		on X.GrName = R.GrName
	select @Result = @@error if @Result <> 0 goto Err
	
	--получаем данные по каждой заявке, в дальнейшем будем делать заявку еще одним уровнем Статей (чтобы алгоритм был тот же, что и сгруппированом отчете)
	insert into #cfo
		(Code, AmountDoc, DT, PName, UName, DName, Descr, UFT8, DocID, UFD3, Curr, AmountCurr, AccType)
	select 
		dbo.PDX_SubstringReturn(D.UserFieldText5, CHARINDEX('<',D.UserFieldText5), charindex('>',D.UserFieldText5)) as Code, --Статья расходов
		isnull(
			case upper(D.Currency)
			when 'USD'
				then isnull(@USD,0)
			when 'EUR'
				then isnull(@EUR,0)
			when 'CAD'
				then isnull(@CAD,0) 
			else 1 --РУБ
		end * isnull(D.AmountDoc,0),0) as Amount,		--Сумма		
		DAY(D.UserFieldDate1),
		D.PartnerName, D.NameCreation, D.Name, D.Description, D.UserFieldText8, D.DocID, D.UserFieldDate3,
		
		cast(D.Currency as varchar(100)),
		D.AmountDoc,
		cast(isnull(A.Descr,'') as varchar(255))
	from dbo.Docs D
	left join dbo.PDX_pay_Accounts A on A.Name = D.UserFieldText6
	where D.ClassDoc = @ClassName
		and UPPER(ISNULL(D.IsActive,'')) = 'Y'	
		and (ISNULL(D.StatusDevelopment,'') ='4' or
			dbo.PDX_CompareReconcilationList(D.ListToReconcile, D.ListReconciled) = 1)
		and ISNULL(D.StatusCompletion,'') <>'0'
		and month(D.UserFieldDate1) = month(@Date)
		and year(D.UserFieldDate1) = year(@Date)
		and (D.UserFieldText2 = @CFO or @CFO = '')
		and (D.UserFieldText8 = @FName or @FName = '')
	--group by UserFieldText5, DAY(UserFieldDate1)
	select @Result = @@error if @Result <> 0 goto Err
	
	--изменяем Code заявок, чтобы из превратить в еще один уровень Статей
	select @Cnt = len(cast(MAX(KeyField) as varchar(100))) from #cfo
	select @Result = @@error if @Result <> 0 goto Err
	
	update #cfo
		set Code = Code + '.' + isnull(replicate('0', @Cnt-len(cast(KeyField as varchar(100)))),'') + cast(KeyField as varchar(100))
	select @Result = @@error if @Result <> 0 goto Err
	
	--а теперь добавдяем эти коды в таблицу со статьями
	insert into #rescfo
		(Code, GrName, GrCode, UFT5, Lev, KeyField)
	select distinct
		C.Code, R.GrName, R.GrCode, 'Заявка на денежные средства №' + C.DocID + ' от ' + convert(varchar(100), C.UFD3, 104),
		1, cast(case when C.Code like '%.%' then LEFT(C.Code, charindex('.',C.Code)-1) else C.Code end as int)*10
	from #cfo C
	inner join #rescfo R on C.Code like R.Code + '.%'
	select @Result = @@error if @Result <> 0 goto Err
	
	--далее следуем алгоритму обобщенной процедуры
	--разбиваем Стьи по уровням, чтоьы потом суммы считать
	select @Cnt = 1, @Lev = 1
	while @Cnt <> 0
	begin
		update R
			set Lev = Lev +
					case when exists (select 1 from #rescfo X where R.Code like X.Code + '.%' and X.Lev = @Lev)
						then 1
						else 0 end
		from #rescfo R
		where R.Lev = @Lev
		select @Cnt = @@ROWCOUNT, @Result = @@error if @Result <> 0 goto Err
		
		if @Cnt > 0 set @Lev = @Lev + 1
	end
	
	/**************/
	delete from @Digital
	select @Result = @@error if @Result <> 0 goto Err

	insert into @Digital (Val, TP) values ('РУБ', 0)
	select @Result = @@error if @Result <> 0 goto Err
	insert into @Digital (Val, TP) values ('USD', 0)
	select @Result = @@error if @Result <> 0 goto Err
	insert into @Digital (Val, TP) values ('EUR', 0)
	select @Result = @@error if @Result <> 0 goto Err
	insert into @Digital (Val, TP) values ('CAD', 0)
	select @Result = @@error if @Result <> 0 goto Err
	
	insert into @Digital (Val, TP) values ('ИТОГО, РУБ', 1)
	select @Result = @@error if @Result <> 0 goto Err
		
	insert into @Digital (Val, TP)
	select distinct Descr, 2 from dbo.PDX_pay_Accounts
	order by Descr
	--select distinct AccType, 2 from #cfo
	--order by AccType
	select @Result = @@error if @Result <> 0 goto Err
		
	insert into @Digital (Val, TP, Dig)
	select distinct cast(dt as varchar(100)), 3, DT from #cfo
	order by DT
	select @Result = @@error if @Result <> 0 goto Err
	
	update @Digital 
	set Val = '???'
	where isnull(Val,'') = ''
	select @Result = @@error if @Result <> 0 goto Err
	/**************/

	--**********************************
	insert into #cfo --это группы
		(Code, AmountDoc, DT, Curr, AmountCurr, AccType)
	select 'G' + cast(GrCode as varchar(100)), 
			sum(isnull(C.AmountDoc,0)), C.DT, C.Curr, SUM(ISNULL(C.AmountCurr,0)), C.AccType
	from #cfo C
	inner join #rescfo R on R.Code = C.Code
	group by R.GrCode, C.DT, C.Curr, C.AccType
	union all
	select '-', sum(isnull(C.AmountDoc,0)), C.DT, C.Curr, SUM(ISNULL(C.AmountCurr,0)), C.AccType
	from #cfo C
	group by C.DT, C.Curr, C.AccType
	select @Result = @@error if @Result <> 0 goto Err
	
	insert into #rescfo
		(Code, UFT5, Lev, KeyField)
	select distinct
		'G' + cast(GrCode as varchar(100)), GrName, 0, GrCode
	from #rescfo
	select @Result = @@error if @Result <> 0 goto Err

	insert into #rescfo
		(Code, UFT5, Lev, KeyField)
	values ('-', 'ИТОГО', 0, 999999)
	select @Result = @@error if @Result <> 0 goto Err
--**********************************

	insert into #cfo --это "группирующие"(суммы) узлы
		(Code, AmountDoc, DT, Curr, AmountCurr, AccType)
	select X.Code, sum(isnull(C.AmountDoc,0)), C.DT, C.Curr, SUM(ISNULL(C.AmountCurr,0)), C.AccType
	from #cfo C
	inner join #rescfo R on C.Code = R.Code
		and R.Lev > 1
	inner join #rescfo X on C.Code like X.Code + '.%' 
		and X.Lev < R.Lev
	group by X.Code, C.DT, C.Curr, C.AccType
	select @Result = @@error if @Result <> 0 goto Err
		
	--а теперь в цикле собираем запрос, который все перевернет в столбцы
	select @SQLStr = 'R.Lev,R.KeyField, R.Code as dc, ' +
		'case when C.DocID is null then R.Code else '''' end as Code, R.UFT5 as Name, '+
		'C.UFT8, C.PName, C.UName, C.DName, C.Descr, -1 as UFM2, '''' as FS, '''' as FSC, '''' as UFT4'
	select @Result = @@error if @Result <> 0 goto Err
	while exists (select 1 from @Digital)
	begin
		select top 1
			@Cnt = TP,
			@Val = Val
		from @Digital
		order by OI
		select @Result = @@error if @Result <> 0 goto Err
				
		select @SQLStr = @SQLStr + 
						case @Cnt 
							when 3
								then ', sum(case C.DT when ' + @Val + ' then isnull(C.AmountDoc,0) else 0 end) as [' + case when CAST(@Val as int) < 10 then '0' else '' end  + CAST(@Val as varchar(10)) + '.' + @Month + ']'
							when 1
								then ', sum(isnull(C.AmountDoc,0)) as [(1)' + @Val + ']'
							when 2
								then ', sum(case C.AccType when ''' + @Val + ''' then isnull(C.AmountDoc,0) else 0 end) as [(2)' + @Val + ']'
							when 0
								then ', sum(case C.Curr when ''' + @Val + ''' then isnull(C.AmountCurr,0) else 0 end) as [(1)' + @Val + ']'
						end
		select @Result = @@error if @Result <> 0 goto Err
		
		delete from @Digital where val = @Val
		select @Result = @@error if @Result <> 0 goto Err
	end
	
	select @SQLStr = 'select ' + @SQLStr + 
			' from #rescfo R ' +
			' left join #cfo C on C.Code = R.Code ' +
			' group by R.Code, R.UFT5, R.KeyField, R.Lev, C.DocID, C.UFT8, C.PName, C.UName, C.DName, C.Descr' +
			' order by 2,3'
	select @Result = @@error if @Result <> 0 goto Err

	exec (@SQLStr)
	select @Result = @@error if @Result <> 0 goto Err	

	drop table #cfo
	drop table #rescfo
	return @Result
Err:

	drop table #cfo
	drop table #rescfo
	return @Result




GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_PAYPLN_currency_Get] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE proc [dbo].[PDX_REP_PAYPLN_currency_Get] --БАЗОВЫЙ ПЛАН ПЛАТЕЖЕЙ
	@CFO varchar(128),
	@FName varchar(256),
	@Date datetime,
	@USD money,
	@EUR money,
	@CAD money
as
	declare @Result int
	set @Result = 0

    create table #cfo (Code varchar(64), AmountDoc money, DT int,
    Curr varchar(100), AmountCurr money, AccType varchar(255))
    
    create table #rescfo (
		KeyField int,  
		Code varchar(64),
		GrName varchar(256),
		GrCode int,
		UFT5 varchar(512), 
		Lev int)
		
	declare @ClassName varchar(128),  @Cnt int, @Lev int,
			@SQLStr varchar(7000), @Month varchar(2),
			@Val varchar(255)
	declare @Digital table (Val varchar(255), TP int, OI int identity, Dig int)
	
	select @ClassName = dbo.PDX_CLSGet('RIK_CategoryName_FIN_PLNPAY'),
		@Month = case when MONTH(@Date) <10 then '0' else '' end + CAST(MONTH(@Date) as varchar(2)),
		@CFO = ltrim(rtrim(ISNULL(@CFO,''))),
		@FName = ltrim(rtrim(ISNULL(@FName,'')))
	select @Result = @@error if @Result <> 0 goto Err
	
	insert into #rescfo
		(Code, GrName, UFT5, Lev, KeyField)
	select Code, GrName, Name, 1,
		cast(case when Code like '%.%' then LEFT(Code, charindex('.',Code)-1) else Code end as int) * 10
	from dbo.PDX_pay_PRiZ
	select @Result = @@error if @Result <> 0 goto Err
	
	update R
		set GrCode = X.KF
	from #rescfo R
	inner join (select min(KeyField)-1 as KF, GrName from #rescfo group by GrName) as X
		on X.GrName = R.GrName
	select @Result = @@error if @Result <> 0 goto Err
	
	select @Cnt = 1, @Lev = 1
	while @Cnt <> 0
	begin
		update R
			set Lev = Lev +
					case when exists (select 1 from #rescfo X where R.Code like X.Code + '.%' and X.Lev = @Lev)
						then 1
						else 0 end
		from #rescfo R
		where R.Lev = @Lev
		select @Cnt = @@ROWCOUNT, @Result = @@error if @Result <> 0 goto Err
		
		if @Cnt > 0 set @Lev = @Lev + 1
	end

	insert into #cfo
		(Code, AmountDoc, DT, Curr, AmountCurr, AccType)
	select 
		dbo.PDX_SubstringReturn(D.UserFieldText5, CHARINDEX('<',D.UserFieldText5), charindex('>',D.UserFieldText5)) as Code, --Статья расходов
		sum(isnull(
			case upper(D.Currency)
			when 'USD'
				then isnull(@USD,0)
			when 'EUR'
				then isnull(@EUR,0)
			when 'CAD'
				then isnull(@CAD,0) 
			else 1 --РУБ
		end * isnull(D.AmountDoc,0),0)) as Amount,		--Сумма		
		DAY(D.UserFieldDate1),
		
		cast(D.Currency as varchar(100)),
		sum(D.AmountDoc),
		cast(isnull(A.Descr,'') as varchar(255))
	from dbo.Docs D
	left join dbo.PDX_pay_Accounts A on A.Name = D.UserFieldText6
	where D.ClassDoc = @ClassName
		and UPPER(ISNULL(D.IsActive,'')) = 'Y'	
		and (ISNULL(D.StatusDevelopment,'') ='4' or
			dbo.PDX_CompareReconcilationList(D.ListToReconcile, D.ListReconciled) = 1)
		and ISNULL(D.StatusCompletion,'') <>'0'
		and month(D.UserFieldDate1) = month(@Date)
		and year(D.UserFieldDate1) = year(@Date)
		and (D.UserFieldText2 = @CFO or @CFO = '')
		and (D.UserFieldText8 = @FName or @FName = '')
	group by D.UserFieldText5, DAY(D.UserFieldDate1), cast(D.Currency as varchar(100)),
	D.AmountDoc, cast(isnull(A.Descr,'') as varchar(255))
	select @Result = @@error if @Result <> 0 goto Err

	/**************/
	delete from @Digital
	select @Result = @@error if @Result <> 0 goto Err

	insert into @Digital (Val, TP) values ('РУБ', 0)
	select @Result = @@error if @Result <> 0 goto Err
	insert into @Digital (Val, TP) values ('USD', 0)
	select @Result = @@error if @Result <> 0 goto Err
	insert into @Digital (Val, TP) values ('EUR', 0)
	select @Result = @@error if @Result <> 0 goto Err
	insert into @Digital (Val, TP) values ('CAD', 0)
	select @Result = @@error if @Result <> 0 goto Err
	
	insert into @Digital (Val, TP) values ('ИТОГО', 1)
	select @Result = @@error if @Result <> 0 goto Err
		
	insert into @Digital (Val, TP)
	select distinct Descr, 2 from dbo.PDX_pay_Accounts
	order by Descr
	--select distinct AccType, 2 from #cfo
	--order by AccType
	select @Result = @@error if @Result <> 0 goto Err
		
	insert into @Digital (Val, TP, Dig)
	select distinct cast(dt as varchar(100)), 3, DT from #cfo
	order by DT
	select @Result = @@error if @Result <> 0 goto Err
	
	update @Digital 
	set Val = '???'
	where isnull(Val,'') = ''
	select @Result = @@error if @Result <> 0 goto Err
	/**************/
		
	--**********************************
		
	insert into #cfo --это группы
		(Code, AmountDoc, DT, Curr, AmountCurr, AccType)
	select 'G' + cast(GrCode as varchar(100)), 
			sum(isnull(C.AmountDoc,0)), C.DT, C.Curr, SUM(ISNULL(C.AmountCurr,0)), C.AccType
	from #cfo C
	inner join #rescfo R on R.Code = C.Code
	group by R. GrCode, C.DT, C.Curr, C.AccType
	select @Result = @@error if @Result <> 0 goto Err
	
	insert into #rescfo
		(Code, UFT5, Lev, KeyField)
	select distinct
		'G' + cast(GrCode as varchar(100)), GrName, 0, GrCode
	from #rescfo
	select @Result = @@error if @Result <> 0 goto Err

	insert into #cfo --это ИТОГО
		(Code, AmountDoc, DT, Curr, AmountCurr, AccType)
	select '-', sum(isnull(C.AmountDoc,0)), C.DT, C.Curr, SUM(ISNULL(C.AmountCurr,0)), C.AccType
	from #cfo C
	where not Code like 'G%'
	group by C.DT, C.Curr, C.AccType
	select @Result = @@error if @Result <> 0 goto Err
	insert into #rescfo
		(Code, UFT5, Lev, KeyField)
	values ('-', 'ИТОГО', 0, 999999)
	select @Result = @@error if @Result <> 0 goto Err
--**********************************

	insert into #cfo --это группирующие узлы
		(Code, AmountDoc, DT, Curr, AmountCurr, AccType)
	select X.Code, sum(isnull(C.AmountDoc,0)), C.DT, C.Curr, SUM(ISNULL(C.AmountCurr,0)), C.AccType
	from #cfo C
	inner join #rescfo R on C.Code = R.Code
		and R.Lev > 1
	inner join #rescfo X on C.Code like X.Code + '.%' 
		and X.Lev < R.Lev
	group by X.Code, C.DT, C.Curr, C.AccType
	select @Result = @@error if @Result <> 0 goto Err
		
	select @SQLStr = 'R.Lev,R.KeyField, R.Code, R.UFT5 as Name'
	select @Result = @@error if @Result <> 0 goto Err
	
	while exists (select 1 from @Digital)
	begin
		select top 1
			@Cnt = TP,
			@Val = Val
		from @Digital
		order by OI
		select @Result = @@error if @Result <> 0 goto Err
		
		select @SQLStr = @SQLStr + 
						case @Cnt 
							when 3
								then ', sum(case C.DT when ' + @Val + ' then isnull(C.AmountDoc,0) else 0 end) as [' + case when CAST(@Val as int) < 10 then '0' else '' end  + CAST(@Val as varchar(10)) + '.' + @Month + ']'
							when 1
								then ', sum(isnull(C.AmountDoc,0)) as [(1)' + @Val + ']'
							when 2
								then ', sum(case C.AccType when ''' + @Val + ''' then isnull(C.AmountDoc,0) else 0 end) as [(2)' + @Val + ']'
							when 0
								then ', sum(case C.Curr when ''' + @Val + ''' then isnull(C.AmountCurr,0) else 0 end) as [(1)' + @Val + ']'
						end
		select @Result = @@error if @Result <> 0 goto Err
		
		delete from @Digital where val = @Val
		select @Result = @@error if @Result <> 0 goto Err
	end
	
	--select @SQLStr = @SQLStr + ', sum(isnull(C.AmountDoc,0)) as [ИТОГО]'
	--select @Result = @@error if @Result <> 0 goto Err
		
	select @SQLStr = 'select ' + @SQLStr + 
			' from #rescfo R ' +
			' left join #cfo C on C.Code = R.Code ' +
			' group by R.Code, R.UFT5, R.KeyField, R.Lev' +
			' order by 2,3'
	select @Result = @@error if @Result <> 0 goto Err
print @SQLStr		
	exec (@SQLStr)
	select @Result = @@error if @Result <> 0 goto Err	

	drop table #cfo
	drop table #rescfo
	return @Result
Err:

	drop table #cfo
	drop table #rescfo
	return @Result



GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_PAYPLN_details_Get] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[PDX_REP_PAYPLN_details_Get] --БАЗОВЫЙ ПЛАН ПЛАТЕЖЕЙ (детальный)
	@CFO varchar(128),
	@Date datetime,
	@USD money,
	@EUR money,
	@CAD money
as
	declare @Result int
	set @Result = 0

    create table #cfo (KeyField int identity,
						Code varchar(64), 
						AmountDoc money, 
						DT int,
						PName varchar(512),
						DName varchar(256),
						Descr varchar(1024),
						UFT8 varchar(512),
						DocID varchar(128),
						UFD3 datetime)
    
    create table #rescfo (
		KeyField int,  
		Code varchar(64),
		UFT5 varchar(512), 
		Lev int)
		
	declare @ClassName varchar(128),  @Cnt int, @Lev int,
			@SQLStr varchar(7000), @Month varchar(2)
	declare @Digital table (Dig int)
	
	select @ClassName = dbo.PDX_CLSGet('RIK_CategoryName_FIN_PLNPAY'),
		@Month = case when MONTH(@Date) <10 then '0' else '' end + CAST(MONTH(@Date) as varchar(2)),
		@CFO = ltrim(rtrim(ISNULL(@CFO,'')))
	select @Result = @@error if @Result <> 0 goto Err
	
	insert into #rescfo
		(Code, UFT5, Lev, KeyField)
	select Code, Name, 1,
		cast(case when Code like '%.%' then LEFT(Code, charindex('.',Code)-1) else Code end as int)
	from dbo.PDX_pay_PRiZ
	select @Result = @@error if @Result <> 0 goto Err
	
	--получаем данные по каждой заявке, в дальнейшем будем делать заявку еще одним уровнем Статей (чтобы алгоритм был тот же, что и сгруппированом отчете)
	insert into #cfo
		(Code, AmountDoc, DT, PName, DName, Descr, UFT8, DocID, UFD3)
	select 
		dbo.PDX_SubstringReturn(UserFieldText5, CHARINDEX('<',UserFieldText5), charindex('>',UserFieldText5)) as Code, --Статья расходов
		isnull(
			case upper(Currency)
			when 'USD'
				then isnull(@USD,0)
			when 'EUR'
				then isnull(@EUR,0)
			when 'CAD'
				then isnull(@CAD,0) 
			else 1 --РУБ
		end * isnull(AmountDoc,0),0) as Amount,		--Сумма		
		DAY(UserFieldDate1),
		PartnerName, Name, Description, UserFieldText8, DocID, UserFieldDate3
	from dbo.Docs
	where ClassDoc = @ClassName
		and UPPER(ISNULL(IsActive,'')) = 'Y'	
		and (ISNULL(StatusDevelopment,'') ='4' or
			dbo.PDX_CompareReconcilationList(ListToReconcile, ListReconciled) = 1)
		and ISNULL(StatusCompletion,'') <>'0'
		and month(UserFieldDate1) = month(@Date)
		and year(UserFieldDate1) = year(@Date)
		and (UserFieldText2 = @CFO or @CFO = '')
	--group by UserFieldText5, DAY(UserFieldDate1)
	select @Result = @@error if @Result <> 0 goto Err
	
	--изменяем Code заявок, чтобы из превратить в еще один уровень Статей
	select @Cnt = len(cast(MAX(KeyField) as varchar(100))) from #cfo
	select @Result = @@error if @Result <> 0 goto Err
	
	update #cfo
		set Code = Code + '.' + isnull(replicate('0', @Cnt-len(cast(KeyField as varchar(100)))),'') + cast(KeyField as varchar(100))
	select @Result = @@error if @Result <> 0 goto Err
	
	--а теперь добавдяем эти коды в таблицу со статьями
	insert into #rescfo
		(Code, UFT5, Lev, KeyField)
	select
		Code, 'Заявка на денежные средства №' + DocID + ' от ' + convert(varchar(100), UFD3, 104),
		1, cast(case when Code like '%.%' then LEFT(Code, charindex('.',Code)-1) else Code end as int)
	from #cfo
	select @Result = @@error if @Result <> 0 goto Err
	
	--далее следуем алгоритму обобщенной процедуры
	--разбиваем Стьи по уровням, чтоьы потом суммы считать
	select @Cnt = 1, @Lev = 1
	while @Cnt <> 0
	begin
		update R
			set Lev = Lev +
					case when exists (select 1 from #rescfo X where R.Code like X.Code + '.%' and X.Lev = @Lev)
						then 1
						else 0 end
		from #rescfo R
		where R.Lev = @Lev
		select @Cnt = @@ROWCOUNT, @Result = @@error if @Result <> 0 goto Err
		
		if @Cnt > 0 set @Lev = @Lev + 1
	end
	
	--**********************************
	insert into #cfo --это добавляем ИТОГО
		(Code, AmountDoc, DT)
	select '-', sum(isnull(C.AmountDoc,0)), C.DT
	from #cfo C
	group by C.DT
	select @Result = @@error if @Result <> 0 goto Err
	insert into #rescfo
		(Code, UFT5, Lev, KeyField)
	values ('-', 'ИТОГО', 0, 999999)
	select @Result = @@error if @Result <> 0 goto Err
--**********************************

	insert into #cfo --это "группирующие"(суммы) узлы
		(Code, AmountDoc, DT)
	select X.Code, sum(isnull(C.AmountDoc,0)), C.DT
	from #cfo C
	inner join #rescfo R on C.Code = R.Code
		and R.Lev > 1
	inner join #rescfo X on C.Code like X.Code + '.%' 
		and X.Lev < R.Lev
	group by X.Code, C.DT
	select @Result = @@error if @Result <> 0 goto Err
	
	--теперь готовимся дни месяца "переворачивать" из строк в столбцы
	--выяснем сколько у нас есть дней с суммами
	insert into @Digital (Dig)
	select distinct dt from #cfo
	select @Result = @@error if @Result <> 0 goto Err
	
	--а теперь в цикле собираем запрос, который все перевернет в столбцы
	select @SQLStr = 'R.Lev,R.KeyField, R.Code as dc, ' +
		'case when C.DocID is null then R.Code else '''' end as Code, R.UFT5 as Name, '+
		'C.UFT8, C.PName, C.DName, C.Descr, -1 as UFM2, '''' as FS, '''' as FSC, '''' as UFT4'
	select @Result = @@error if @Result <> 0 goto Err
	while exists (select 1 from @Digital)
	begin
		select top 1
			@Cnt = Dig
		from @Digital
		order by Dig
		select @Result = @@error if @Result <> 0 goto Err
		
		select @SQLStr = @SQLStr + ', sum(case C.DT when ' + CAST(@Cnt as varchar(10)) + ' then isnull(C.AmountDoc,0) else 0 end) as [' + case when @Cnt < 10 then '0' else '' end  + CAST(@Cnt as varchar(10)) + '.' + @Month + ']'
		select @Result = @@error if @Result <> 0 goto Err
		
		delete from @Digital where Dig = @Cnt
		select @Result = @@error if @Result <> 0 goto Err
	end
	
	select @SQLStr = @SQLStr + ', sum(isnull(C.AmountDoc,0)) as [ИТОГО]'
	select @Result = @@error if @Result <> 0 goto Err

	select @SQLStr = 'select ' + @SQLStr + 
			' from #rescfo R ' +
			' left join #cfo C on C.Code = R.Code ' +
			' group by R.Code, R.UFT5, R.KeyField, R.Lev, C.DocID, C.UFT8, C.PName, C.DName, C.Descr' +
			' order by 2,3'
	select @Result = @@error if @Result <> 0 goto Err
		
	exec (@SQLStr)
	select @Result = @@error if @Result <> 0 goto Err	

	drop table #cfo
	drop table #rescfo
	return @Result
Err:

	drop table #cfo
	drop table #rescfo
	return @Result



GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_PAYPLN_Find] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[PDX_REP_PAYPLN_Find] --БАЗОВЫЙ ПЛАН ПЛАТЕЖЕЙ (детальный)
	@DID varchar(128),
	@UFD3f datetime,
	@UFD3t datetime,
	@UFD1f datetime,
	@UFD1t datetime,
	@UFT7 varchar(64),
	@Currency varchar(64),
	@UFT8 varchar(512),
	@UFT2 varchar(512),
	@PN varchar(512),
	@UFT4 varchar(512),
	@UFT3 varchar(512),
	@UFT5 varchar(512),
	@Name varchar(128),
	@DIDPar varchar(128),
	@DIDPrev varchar(128),
	@UFT6 varchar(512),
	@NCr varchar(96),
	@State int, --1 - все, кроме отмен, 2- на согл, 3 - треб утв, 4 утв, 5 - отмен
	@Access bit = 1
as
	declare @Result int
	set @Result = 0

	select @UFT2 = ltrim(rtrim(ISNULL(@UFT2,''))),
		@UFT3 = ltrim(rtrim(ISNULL(@UFT3,''))),
		@UFT4 = ltrim(rtrim(ISNULL(@UFT4,''))),
		@UFT5 = ltrim(rtrim(ISNULL(@UFT5,''))),
		@UFT6 = ltrim(rtrim(ISNULL(@UFT6,''))),
		@UFT7 = ltrim(rtrim(ISNULL(@UFT7,''))),
		@UFT8 = ltrim(rtrim(ISNULL(@UFT8,''))),
		@Currency = ltrim(rtrim(ISNULL(@Currency,''))),
		@PN = ltrim(rtrim(ISNULL(@PN,''))),
		@Name = ltrim(rtrim(ISNULL(@Name,''))),
		@DIDPar = ltrim(rtrim(ISNULL(@DIDPar,''))),
		@DIDPrev = ltrim(rtrim(ISNULL(@DIDPrev,''))),
		@NCr = case when ISNULL(@NCr,'') like '%<%>%' 
					then dbo.PDX_SubstringReturn(ISNULL(@NCr,''), CHARINDEX('<',ISNULL(@NCr,'')), charindex('>',ISNULL(@NCr,'')))
					else ltrim(rtrim(ISNULL(@NCr,''))) end
	select @Result = @@error if @Result <> 0 goto Err
 
	select 
		case @Access when 1 then 'system_report' else DocID end as DocID,
		DocID as strID, 
		UserFieldDate3, --Рег. дата
		UserFieldDate1, --Плановая дата оплаты
		UserFieldText7, --Наличный расчет
		Currency, --Валюта
		UserFieldText8, --Бизнес единица
		NameAproval, --Фин. Менеджер
		UserFieldText2, --ЦФО
		PartnerName, --Отправитель\Получатель
		UserFieldText4, --Проект
		UserFieldText3, --Направление
		UserFieldText5, --Статья расходов
		Name, --Назначение
		AmountDoc, --Сумма
		DocIDParent, --Оплата по договору №
		DocIDPrevious, --№ договора с Заказчиком
		UserFieldText6, --Счет
		Description, --Основание
		NameCreation, --Заявитель
		UserFieldText1, --Наименование листа согласования
		ListToReconcile, --Лист согласования
		Correspondent, --Список рассылки
		ListToEdit, --Список имеющих право редактирования д-та 
		dbo.REC_DocStatusRead(1,isActive,StatusCompletion,StatusDevelopment,
			ListToReconcile, ListReconciled, LocationPath) as Status
	from dbo.Docs
	where ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_FIN_PLNPAY')
		and UPPER(ISNULL(IsActive,'')) = 'Y'
		and (DocID like '%' + @DID + '%' or @DID = '')
		and UserFieldDate3 between @UFD3f and @UFD3t
		and UserFieldDate1 between @UFD1f and @UFD1t
		and (UserFieldText7 = @UFT7 or @UFT7 = '')
		and (Currency = @Currency or @Currency = '')
		and (UserFieldText8 = @UFT8 or @UFT8 = '')
		and (UserFieldText2 = @UFT2 or @UFT2 = '')
		and (PartnerName = @PN or @PN = '')
		and (UserFieldText4 = @UFT4 or @UFT4 = '')
		and (UserFieldText3 = @UFT3 or @UFT3 = '')
		and (UserFieldText5 = @UFT5 or @UFT5 = '')
		and (Name like '%' + @Name +'%' or Description like '%' + @Name + '%')
		and (DocIDParent = @DIDPar or @DIDPar = '')
		and (DocIDPrevious = @DIDPrev or @DIDPrev = '')
		and (UserFieldText6 = @UFT6 or @UFT6 = '')
		and (NameCreation like '%<' + @NCr + '>%' or @NCr = '')
		and isnull(StatusDevelopment,'') = case @State when 4 then '4' else StatusDevelopment end
		and isnull(StatusDevelopment,'') <> case when @State in (2,4) then '4' else '-' end
		and dbo.PDX_CompareReconcilationList(listToReconcile, ListReconciled) = case @State when 3 then 1 else dbo.PDX_CompareReconcilationList(listToReconcile, ListReconciled) end
		and isnull(StatusCompletion,'') = case @State when 5 then '0' else isnull(StatusCompletion,'') end
		and isnull(StatusCompletion,'') <> case @State when 5 then '%^&*^(*' else '0' end
	order by UserFieldDate3, DocID
	select @Result = @@error if @Result <> 0 goto Err	
	
	return @Result
Err:

	drop table #cfo
	drop table #rescfo
	return @Result


GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_PAYPLN_Get] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_REP_PAYPLN_Get] --БАЗОВЫЙ ПЛАН ПЛАТЕЖЕЙ
	@CFO varchar(128),
	@Date datetime,
	@USD money,
	@EUR money,
	@CAD money
as
	declare @Result int
	set @Result = 0

    create table #cfo (Code varchar(64), AmountDoc money, DT int)
    
    create table #rescfo (
		KeyField int,  
		Code varchar(64),
		UFT5 varchar(512), 
		Lev int)
		
	declare @ClassName varchar(128),  @Cnt int, @Lev int,
			@SQLStr varchar(7000), @Month varchar(2)
	declare @Digital table (Dig int)
	
	select @ClassName = dbo.PDX_CLSGet('RIK_CategoryName_FIN_PLNPAY'),
		@Month = case when MONTH(@Date) <10 then '0' else '' end + CAST(MONTH(@Date) as varchar(2)),
		@CFO = ltrim(rtrim(ISNULL(@CFO,'')))
	select @Result = @@error if @Result <> 0 goto Err
	
	insert into #rescfo
		(Code, UFT5, Lev, KeyField)
	select Code, Name, 1,
		cast(case when Code like '%.%' then LEFT(Code, charindex('.',Code)-1) else Code end as int)
	from dbo.PDX_pay_PRiZ
	select @Result = @@error if @Result <> 0 goto Err
	
	select @Cnt = 1, @Lev = 1
	while @Cnt <> 0
	begin
		update R
			set Lev = Lev +
					case when exists (select 1 from #rescfo X where R.Code like X.Code + '.%' and X.Lev = @Lev)
						then 1
						else 0 end
		from #rescfo R
		where R.Lev = @Lev
		select @Cnt = @@ROWCOUNT, @Result = @@error if @Result <> 0 goto Err
		
		if @Cnt > 0 set @Lev = @Lev + 1
	end
	
	insert into #cfo
		(Code, AmountDoc, DT)
	select 
		dbo.PDX_SubstringReturn(UserFieldText5, CHARINDEX('<',UserFieldText5), charindex('>',UserFieldText5)) as Code, --Статья расходов
		sum(isnull(
			case upper(Currency)
			when 'USD'
				then isnull(@USD,0)
			when 'EUR'
				then isnull(@EUR,0)
			when 'CAD'
				then isnull(@CAD,0) 
			else 1 --РУБ
		end * isnull(AmountDoc,0),0)) as Amount,		--Сумма		
		DAY(UserFieldDate1)
	from dbo.Docs
	where ClassDoc = @ClassName
		and UPPER(ISNULL(IsActive,'')) = 'Y'	
		and (ISNULL(StatusDevelopment,'') ='4' or
			dbo.PDX_CompareReconcilationList(ListToReconcile, ListReconciled) = 1)
		and ISNULL(StatusCompletion,'') <>'0'
		and month(UserFieldDate1) = month(@Date)
		and year(UserFieldDate1) = year(@Date)
		and (UserFieldText2 = @CFO or @CFO = '')
	group by UserFieldText5, DAY(UserFieldDate1)
	select @Result = @@error if @Result <> 0 goto Err
	
	--**********************************
	insert into #cfo --это ИТОГО
		(Code, AmountDoc, DT)
	select '-', sum(isnull(C.AmountDoc,0)), C.DT
	from #cfo C
	group by C.DT
	select @Result = @@error if @Result <> 0 goto Err
	insert into #rescfo
		(Code, UFT5, Lev, KeyField)
	values ('-', 'ИТОГО', 0, 999999)
	select @Result = @@error if @Result <> 0 goto Err
--**********************************

	insert into #cfo --это группирующие узлы
		(Code, AmountDoc, DT)
	select X.Code, sum(isnull(C.AmountDoc,0)), C.DT
	from #cfo C
	inner join #rescfo R on C.Code = R.Code
		and R.Lev > 1
	inner join #rescfo X on C.Code like X.Code + '.%' 
		and X.Lev < R.Lev
	group by X.Code, C.DT
	select @Result = @@error if @Result <> 0 goto Err
		
	insert into @Digital (Dig)
	select distinct dt from #cfo
	select @Result = @@error if @Result <> 0 goto Err
	
	select @SQLStr = 'R.Lev,R.KeyField, R.Code, R.UFT5 as Name'
	select @Result = @@error if @Result <> 0 goto Err
	while exists (select 1 from @Digital)
	begin
		select top 1
			@Cnt = Dig
		from @Digital
		order by Dig
		select @Result = @@error if @Result <> 0 goto Err
		
		select @SQLStr = @SQLStr + ', sum(case C.DT when ' + CAST(@Cnt as varchar(10)) + ' then isnull(C.AmountDoc,0) else 0 end) as [' + case when @Cnt < 10 then '0' else '' end  + CAST(@Cnt as varchar(10)) + '.' + @Month + ']'
		select @Result = @@error if @Result <> 0 goto Err
		
		delete from @Digital where Dig = @Cnt
		select @Result = @@error if @Result <> 0 goto Err
	end
	
	select @SQLStr = @SQLStr + ', sum(isnull(C.AmountDoc,0)) as [ИТОГО]'
	select @Result = @@error if @Result <> 0 goto Err
		
	select @SQLStr = 'select ' + @SQLStr + 
			' from #rescfo R ' +
			' left join #cfo C on C.Code = R.Code ' +
			' group by R.Code, R.UFT5, R.KeyField, R.Lev' +
			' order by 2,3'
	select @Result = @@error if @Result <> 0 goto Err
		
	exec (@SQLStr)
	select @Result = @@error if @Result <> 0 goto Err	

	drop table #cfo
	drop table #rescfo
	return @Result
Err:

	drop table #cfo
	drop table #rescfo
	return @Result

GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_PAYPLNBUDG_Find] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE proc [dbo].[PDX_REP_PAYPLNBUDG_Find] --поиск полановых бюджетов

	@DocID	varchar(128),--Рег. номер
	@UFD3f datetime,
	@UFD3t datetime,--	Рег. дата
	@UFT7 varchar(64),--	Год плана
	@Currency varchar(64),--	Валюта
	@UFT8 varchar(512),--	Бизнес единица
	@NApr varchar(96),--	Фин. Менеджер
	@UFT2 varchar(512),--	ЦФО
	@UFT6 varchar(512),--	Корректирующий бюджет
	@NCr varchar(96),--	Заявитель
	@PN [varchar](128),-- Отправитель/Получатель 
	@Intrn [char](1),--Внутр.обороты
	@Obj [varchar](1024),--Объект
	@Item [varchar](1024),--Статья расходов
	@Name [varchar](256),--Назначение
	@PayCID [varchar](128),--Оплата по договору №
	@CustomerCID [varchar](128),--№ договора с заказчиком
	@Account [varchar](1024),--Счет
	
	@State int, --1 - все, кроме отмен, 2- на согл, 3 - треб утв, 4 утв, 5 - отмен
	@Access bit = 1
as

	select 
		@DocID = ltrim(rtrim(ISNULL(@DocID,''))),
		@UFT2 = ltrim(rtrim(ISNULL(@UFT2,''))),
		@UFT6 = ltrim(rtrim(ISNULL(@UFT6,''))),
		@UFT7 = ltrim(rtrim(ISNULL(@UFT7,''))),
		@UFT8 = ltrim(rtrim(ISNULL(@UFT8,''))),
		@Currency = ltrim(rtrim(ISNULL(@Currency,''))),
		@PN = ltrim(rtrim(ISNULL(@PN,''))),
		@Name = ltrim(rtrim(ISNULL(@Name,''))),
		@Account = ltrim(rtrim(ISNULL(@Account,''))),
		@PayCID = ltrim(rtrim(ISNULL(@PayCID,''))),
		@CustomerCID = ltrim(rtrim(ISNULL(@CustomerCID,''))),
		@Item = case when ISNULL(@Item,'') like '%<%>%' 
					then '<' + dbo.PDX_SubstringReturn(ISNULL(@Item,''), CHARINDEX('<',ISNULL(@Item,'')), charindex('>',ISNULL(@Item,''))) + '>'
					else ltrim(rtrim(ISNULL(@Item,''))) end,
		@NCr = case when ISNULL(@NCr,'') like '%<%>%' 
					then '<' + dbo.PDX_SubstringReturn(ISNULL(@NCr,''), CHARINDEX('<',ISNULL(@NCr,'')), charindex('>',ISNULL(@NCr,''))) + '>'
					else ltrim(rtrim(ISNULL(@NCr,''))) end,
		@NApr = case when ISNULL(@NApr,'') like '%<%>%' 
					then '<' + dbo.PDX_SubstringReturn(ISNULL(@NApr,''), CHARINDEX('<',ISNULL(@NApr,'')), charindex('>',ISNULL(@NApr,''))) + '>'
					else ltrim(rtrim(ISNULL(@NApr,''))) end
	
	create table #treeRes (Code varchar(128))
	
	if @Obj like '<%>%'
	begin		
		-- и еще раз достраиваем нижние уровни
		;with treeResFirst2 (KeyField, ParentKeyField, code, descr)
		as
		(
			-- сами узелки
			select T1.KeyField, T1.ParentKeyField, cast(T1.Code as varchar(max)), cast(T1.descr as varchar(max))
			from UserDir_ISR T1
			where '<'+Code+'>'=LEFT(@Obj, charindex('>',@Obj))
			-- нижние
			union all
			select	I.KeyField, I.ParentKeyField,
					cast(I.Code as varchar(max)) as Code,
					cast(I.descr as varchar(max))
			from UserDir_ISR I 
				inner join treeResFirst2 T on T.KeyField = I.ParentKeyField
			
			
		)
		
			insert into #treeRes (Code)
			select '<' + Code + '>'
			from treeResFirst2
	end
	
	if not exists (select 1 from #treeRes)
	begin
		if @Obj <> ''
		begin
			insert into #treeRes (Code) values (@Obj)
		end
		else
		begin
			insert into #treeRes (Code) values ('')
		end
	end
	
 
	select distinct
		case @Access when 1 then 'system_report' else DocID end as DocID,
		D.DocID as strID, 
		D.UserFieldDate3,--	Рег. дата
		D.UserFieldText7,--	Год плана
		D.Currency,--	Валюта
		D.UserFieldText8,--	Бизнес единица
		D.NameAproval,--	Фин. Менеджер
		D.UserFieldText2,--	ЦФО
		D.UserFieldText6,--	Корректирующий бюджет
		D.NameCreation,--	Заявитель
		D.UserFieldText1,--	Наименование листа согласования
		D.ListToReconcile,--	Лист согласования
		D.Correspondent,--	Список рассылки
		D.ListToEdit,--	Список имеющих право редактирования д-та
		dbo.REC_DocStatusRead(1,D.isActive,D.StatusCompletion,D.StatusDevelopment,
			D.ListToReconcile, D.ListReconciled, D.LocationPath) as Status,
		S.FinStatus as FS, S.Comment as FSC
	from dbo.Docs D
	inner join [dbo].[DocsPLNTBL] P on P.DocIDInt = D.DocIDInt
	inner join #treeRes R on P.Obj like R.Code + '%'
	left join dbo.PayStatusDetails S on S.DocIDInt = D.DocIDInt
	where D.ClassDoc = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_PLNTBL')
		and UPPER(ISNULL(D.IsActive,'')) = 'Y'
		and (D.DocID like '%' + @DocID + '%' or @DocID = '')
		and D.UserFieldDate3 between @UFD3f and @UFD3t		
		and (D.UserFieldText7 = @UFT7 or @UFT7 = '')		
		and (D.Currency = @Currency or @Currency = '')
		and (D.UserFieldText8 = @UFT8 or @UFT8 = '')
		and (D.UserFieldText2 = @UFT2 or @UFT2 = '')
		and (D.NameAproval like '%' + @NApr + '%' or @NApr = '')
		and (NameCreation like '%' + @NCr + '%' or @NCr = '')
		
		
		and (P.PN like '%' + @PN + '%' or @PN = '')
		and (P.Intrn = @Intrn or @Intrn = '')		
		and (P.Item like '%' + @Item + '%' or @Item = '')
		and (P.Name like '%' + @Name + '%')
		and (P.PayCID = @PayCID or @PayCID = '')
		and (P.CustomerCID = @CustomerCID or @CustomerCID = '')
		and (P.Account = @Account or @Account = '')	
		
		
		and isnull(D.StatusDevelopment,'') = case @State when 4 then '4' else D.StatusDevelopment end
		and isnull(D.StatusDevelopment,'') <> case when @State in (2,4) then '4' else '-' end
		and dbo.PDX_CompareReconcilationList(D.listToReconcile, D.ListReconciled) = case @State when 3 then 1 else dbo.PDX_CompareReconcilationList(D.listToReconcile, D.ListReconciled) end
		and isnull(D.StatusCompletion,'') = case @State when 5 then '0' else isnull(D.StatusCompletion,'') end
		and isnull(D.StatusCompletion,'') <> case @State when 5 then '%^&*^(*' else '0' end
	order by D.UserFieldDate3, D.DocID



GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_PAYPLNn_currdetails_Get] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROC [dbo].[PDX_REP_PAYPLNn_currdetails_Get] --БАЗОВЫЙ ПЛАН ПЛАТЕЖЕЙ (детальный)
	@CFO varchar(128),
	@FName varchar(256),
	@Date datetime,
	@UFM2 tinyint = 2 , --2-все, 1-да, 0-нет
	@RTR bit = 0, --0-руб, 1-тыс руб
	@USD money,
	@EUR money,
	@JPY money
as
	declare @Result int, @RTR2 varchar(10)
	set @Result = 0

	set @RTR2 = case @RTR when 0 then '' else '/1000' end
	
    create table #cfo (KeyField int identity,
						Code varchar(64), 
						AmountDoc money, 
						DT int,
						PName varchar(512),
						UName varchar(96),
						DName varchar(256),
						Descr varchar(1024),
						UFT8 varchar(512),
						DocID varchar(128),
						UFD3 datetime,
    Curr varchar(100), AmountCurr money, AccType varchar(255), UFM2 money, FS varchar(60), FSC varchar(4000), UFT4 varchar(1024))
    
    create table #items (Code varchar(64), Name varchar(256), Expens tinyint, GrName varchar(256), InActive bit, SetID int, ParentID int)
    create table #rescfo (
		KeyField int,  
		Code varchar(64),
		GrName varchar(256),
		GrCode int,
		UFT5 varchar(512), 
		Lev int,
		InActive bit,
		KF int,
		PKF int,
		HaveAm bit default 0,
		flg bit default 0)
		
	declare @ClassName varchar(128),  @Cnt int, @Lev int,
			@SQLStr varchar(7000), @Month varchar(2),
			@Val varchar(255)
	declare @Digital table (Val varchar(255), TP int, OI int identity, Dig int)
	
	select @ClassName = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_PLNPAY'),
		@Month = case when MONTH(@Date) <10 then '0' else '' end + CAST(MONTH(@Date) as varchar(2)),
		@CFO = ltrim(rtrim(ISNULL(@CFO,''))),
		@FName = ltrim(rtrim(ISNULL(@FName,'')))
	select @Result = @@error if @Result <> 0 goto Err
		
	If YEAR(@Date) <= 2015 
	begin
		insert into #items (Code, Name, Expens, GrName, InActive, SetID, ParentID)
		select Code, Name, Expens, GrName, InActive, SetID, ParentID
		from dbo.PDX_pay_Items		
	end	
	else
	begin
		insert into #items (Code, Name, Expens, GrName, InActive, SetID, ParentID)
		select Code, Name, Expens, GrName, InActive, SetID, ParentID
		from dbo.PDX_pay_Items2016		
	end	
	
	insert into #rescfo
		(Code, GrName, UFT5, Lev, KeyField, InActive, KF, PKF)
	select Code, GrName, Name, 1,
		cast(replace(case when Code like '%.%' then LEFT(Code, charindex('.',Code)-1) else Code end,'н','') as int) * 10,
		InActive, SetID, ParentID
	from #items
	select @Result = @@error if @Result <> 0 goto Err
	
	while exists (select 1 from #rescfo p
					inner join #rescfo c on c.PKF = p.KF and c.InActive = 0
				where p.InActive = 1)
	begin
		update c
			set InActive = 1
		from #rescfo p
		inner join #rescfo c on c.PKF = p.KF and c.InActive = 0
		where p.InActive = 1
	end
		
	update R
		set GrCode = X.KF
	from #rescfo R
	inner join (select min(KeyField)-1 as KF, GrName from #rescfo group by GrName) as X
		on X.GrName = R.GrName
	select @Result = @@error if @Result <> 0 goto Err
	
	--получаем данные по каждой заявке, в дальнейшем будем делать заявку еще одним уровнем Статей (чтобы алгоритм был тот же, что и сгруппированом отчете)
	insert into #cfo
		(Code, AmountDoc, DT, PName, UName, DName, Descr, UFT8, DocID, UFD3, Curr, AmountCurr, AccType, UFM2, FS, FSC, UFT4)
	select 
		dbo.PDX_SubstringReturn(D.UserFieldText5, CHARINDEX('<',D.UserFieldText5), charindex('>',D.UserFieldText5)) as Code, --Статья расходов
		isnull(
			case upper(D.Currency)
			when 'USD'
				then isnull(@USD,0)
			when 'EUR'
				then isnull(@EUR,0)
			when 'JPY'
				then isnull(@JPY,0) 
			else 1 --РУБ
		end * isnull(D.AmountDoc,0),0) * case I.Expens when 1 then -1 else 1 end as Amount,		--Сумма		
		DAY(D.UserFieldDate1),
		D.PartnerName, D.NameCreation, D.Name, D.Description, D.UserFieldText8, D.DocID, D.UserFieldDate3,
		
		cast(D.Currency as varchar(100)),
		D.AmountDoc * case I.Expens when 1 then -1 else 1 end as Amount,
		cast(isnull(A.Descr,'') as varchar(255)),
		D.UserFieldMoney2,
		S.FinStatus, S.Comment,
		D.UserFieldText4
	from dbo.Docs D
	inner join #items I on D.UserFieldText5 like '%<' + I.Code + '>%'
	left join dbo.PDX_pay_Accounts A on A.Name = D.UserFieldText6
	left join dbo.PayStatusDetails S on S.DocIDInt = D.DocIDInt
	where D.ClassDoc = @ClassName
		and UPPER(ISNULL(D.IsActive,'')) = 'Y'	
		and (ISNULL(D.StatusDevelopment,'') ='4' or
			dbo.PDX_CompareReconcilationList(D.ListToReconcile, D.ListReconciled) = 1)
		and ISNULL(D.StatusCompletion,'') <>'0'
		and month(D.UserFieldDate1) = month(@Date)
		and year(D.UserFieldDate1) = year(@Date)
		and (D.UserFieldText2 = @CFO or @CFO = '')
		and (D.UserFieldText8 = @FName or @FName = '')
		and (D.UserFieldMoney2 = @UFM2 or @UFM2 = 2)
	--group by UserFieldText5, DAY(UserFieldDate1)
	select @Result = @@error if @Result <> 0 goto Err
	
	--изменяем Code заявок, чтобы из превратить в еще один уровень Статей
	select @Cnt = len(cast(MAX(KeyField) as varchar(100))) from #cfo
	select @Result = @@error if @Result <> 0 goto Err
	
	update #cfo
		set Code = Code + '.' + isnull(replicate('0', @Cnt-len(cast(KeyField as varchar(100)))),'') + cast(KeyField as varchar(100))
	select @Result = @@error if @Result <> 0 goto Err
/***********************************/
--проверяем нет ли доков на неактивных статьях
   update RC
	set HaveAm = 1
   from #rescfo RC
   inner join (select distinct Code from #cfo where isnull(AmountDoc,0) <> 0) as X on X.Code = RC.Code
   
   if exists (select 1 from #rescfo	where InActive = 1 and HaveAm = 1)
   begin
	  update #rescfo
		set InActive = 0,
		flg = 1	
	  where InActive = 1 and HaveAm = 1
	  
	  while exists (select top 1 1 from #rescfo c 
					inner join #rescfo p on p.KF = c.PKF and p.InActive = 1
					where c.InActive = 0 and c.HaveAm = 1)
	  begin
		update p
			set InActive = 0, HaveAm = 1, flg = 1
		from #rescfo c 
		inner join #rescfo p on p.KF = c.PKF and p.InActive = 1
		where c.InActive = 0 and c.HaveAm = 1 and flg = 1
	  end
	  
   end
   
   delete from #rescfo where InActive = 1
/**************************************/	
	--а теперь добавдяем эти коды в таблицу со статьями
	insert into #rescfo
		(Code, GrName, GrCode, UFT5, Lev, KeyField)
	select distinct
		C.Code, R.GrName, R.GrCode, 'Заявка на денежные средства №' + C.DocID + ' от ' + convert(varchar(100), C.UFD3, 104),
		1, cast(case when C.Code like '%.%' then LEFT(C.Code, charindex('.',C.Code)-1) else C.Code end as int)*10
	from #cfo C
	inner join #rescfo R on C.Code like R.Code + '.%'
	select @Result = @@error if @Result <> 0 goto Err
	
	--далее следуем алгоритму обобщенной процедуры
	--разбиваем Стьи по уровням, чтоьы потом суммы считать
	select @Cnt = 1, @Lev = 1
	while @Cnt <> 0
	begin
		update R
			set Lev = Lev +
					case when exists (select 1 from #rescfo X where R.Code like X.Code + '.%' and X.Lev = @Lev)
						then 1
						else 0 end
		from #rescfo R
		where R.Lev = @Lev
		select @Cnt = @@ROWCOUNT, @Result = @@error if @Result <> 0 goto Err
		
		if @Cnt > 0 set @Lev = @Lev + 1
	end
	
	/**************/
	delete from @Digital
	select @Result = @@error if @Result <> 0 goto Err

	insert into @Digital (Val, TP) values ('РУБ', 0)
	select @Result = @@error if @Result <> 0 goto Err
	insert into @Digital (Val, TP) values ('USD', 0)
	select @Result = @@error if @Result <> 0 goto Err
	insert into @Digital (Val, TP) values ('EUR', 0)
	select @Result = @@error if @Result <> 0 goto Err
	insert into @Digital (Val, TP) values ('JPY', 0)
	select @Result = @@error if @Result <> 0 goto Err
	
	insert into @Digital (Val, TP) values ('ИТОГО, РУБ', 1)
	select @Result = @@error if @Result <> 0 goto Err
		
	insert into @Digital (Val, TP)
	select distinct Descr, 2 from dbo.PDX_pay_Accounts
	order by Descr
	--select distinct AccType, 2 from #cfo
	--order by AccType
	select @Result = @@error if @Result <> 0 goto Err
		
	insert into @Digital (Val, TP, Dig)
	select distinct cast(dt as varchar(100)), 3, DT from #cfo
	order by DT
	select @Result = @@error if @Result <> 0 goto Err
	
	update @Digital 
	set Val = '???'
	where isnull(Val,'') = ''
	select @Result = @@error if @Result <> 0 goto Err
	/**************/

	--**********************************
	insert into #cfo --это группы
		(Code, AmountDoc, DT, Curr, AmountCurr, AccType)
	select 'G' + cast(GrCode as varchar(100)), 
			sum(isnull(C.AmountDoc,0)), C.DT, C.Curr, SUM(ISNULL(C.AmountCurr,0)), C.AccType
	from #cfo C
	inner join #rescfo R on R.Code = C.Code
	group by R.GrCode, C.DT, C.Curr, C.AccType
	union all
	select '-', sum(isnull(C.AmountDoc,0)), C.DT, C.Curr, SUM(ISNULL(C.AmountCurr,0)), C.AccType
	from #cfo C
	group by C.DT, C.Curr, C.AccType
	select @Result = @@error if @Result <> 0 goto Err
	
	insert into #rescfo
		(Code, UFT5, Lev, KeyField)
	select distinct
		'G' + cast(GrCode as varchar(100)), GrName, 0, GrCode
	from #rescfo
	select @Result = @@error if @Result <> 0 goto Err

	insert into #rescfo
		(Code, UFT5, Lev, KeyField)
	values ('-', 'ИТОГО', 0, 999999)
	select @Result = @@error if @Result <> 0 goto Err
--**********************************

	insert into #cfo --это "группирующие"(суммы) узлы
		(Code, AmountDoc, DT, Curr, AmountCurr, AccType)
	select X.Code, sum(isnull(C.AmountDoc,0)), C.DT, C.Curr, SUM(ISNULL(C.AmountCurr,0)), C.AccType
	from #cfo C
	inner join #rescfo R on C.Code = R.Code
		and R.Lev > 1
	inner join #rescfo X on C.Code like X.Code + '.%' 
		and X.Lev < R.Lev
	group by X.Code, C.DT, C.Curr, C.AccType
	select @Result = @@error if @Result <> 0 goto Err
		
	--а теперь в цикле собираем запрос, который все перевернет в столбцы
	select @SQLStr = 'R.Lev,R.KeyField, R.Code as dc, ' +
		'case when C.DocID is null then R.Code else '''' end as Code, R.UFT5 as Name, '+
		'C.UFT8, C.PName, C.UName, C.DName, C.Descr, C.UFM2, C.FS, C.FSC, C.UFT4'
	select @Result = @@error if @Result <> 0 goto Err
	while exists (select 1 from @Digital)
	begin
		select top 1
			@Cnt = TP,
			@Val = Val
		from @Digital
		order by OI
		select @Result = @@error if @Result <> 0 goto Err
				
		select @SQLStr = @SQLStr + 
						case @Cnt 
							when 3
								then ', sum(case C.DT when ' + @Val + ' then isnull(C.AmountDoc,0) else 0 end)' + @RTR2 + ' as [(3)' + case when CAST(@Val as int) < 10 then '0' else '' end  + CAST(@Val as varchar(10)) + '.' + @Month + ']'
							when 1
								then ', sum(isnull(C.AmountDoc,0))' + @RTR2 + ' as [(1)' + @Val + ']'
							when 2
								then ', sum(case C.AccType when ''' + @Val + ''' then isnull(C.AmountDoc,0) else 0 end)' + @RTR2 + ' as [(2)' + @Val + ']'
							when 0
								then ', sum(case C.Curr when ''' + @Val + ''' then isnull(C.AmountCurr,0) else 0 end)' + case when @Val like '%РУБ%' then @RTR2 else '' end + ' as [(1)' + @Val + ']'
						end
		select @Result = @@error if @Result <> 0 goto Err
		
		delete from @Digital where val = @Val
		select @Result = @@error if @Result <> 0 goto Err
	end
	
	select @SQLStr = 'select ' + @SQLStr + 
			' from #rescfo R ' +
			' left join #cfo C on C.Code = R.Code ' +
			' group by R.Code, R.UFT5, R.KeyField, R.Lev, C.DocID, C.UFT8, C.PName, C.UName, C.DName, C.Descr,C.UFM2, C.FS, C.FSC, C.UFT4' +
			' order by 2,3'
	select @Result = @@error if @Result <> 0 goto Err

	exec (@SQLStr)
	select @Result = @@error if @Result <> 0 goto Err	

	drop table #cfo
	drop table #rescfo
	return @Result
Err:

	drop table #cfo
	drop table #rescfo
	return @Result











GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_PAYPLNn_currency_Get] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_REP_PAYPLNn_currency_Get] --БАЗОВЫЙ ПЛАН ПЛАТЕЖЕЙ (по валютам и счетам)
	@CFO varchar(128),
	@FName varchar(256),
	@Date datetime,
	@UFM2 tinyint = 2 , --2-все, 1-да, 0-нет
	@RTR bit = 0, --0-руб, 1-тыс руб
	@USD money,
	@EUR money,
	@JPY money
as
	declare @Result int, @RTR2 varchar(10)
	set @Result = 0

	set @RTR2 = case @RTR when 0 then '' else '/1000' end
	
    create table #cfo (Code varchar(64), AmountDoc money, DT int,
    Curr varchar(100), AmountCurr money, AccType varchar(255))
    
    create table #items (Code varchar(64), Name varchar(256), Expens tinyint, GrName varchar(256), InActive bit, SetID int, ParentID int)
    
    create table #rescfo (
		KeyField int,  
		Code varchar(64),
		GrName varchar(256),
		GrCode int,
		UFT5 varchar(512), 
		Lev int)
		
	declare @ClassName varchar(128),  @Cnt int, @Lev int,
			@SQLStr varchar(7000), @Month varchar(2),
			@Val varchar(255)
	declare @Digital table (Val varchar(255), TP int, OI int identity, Dig int)
	
	select @ClassName = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_PLNPAY'),
		@Month = case when MONTH(@Date) <10 then '0' else '' end + CAST(MONTH(@Date) as varchar(2)),
		@CFO = ltrim(rtrim(ISNULL(@CFO,''))),
		@FName = ltrim(rtrim(ISNULL(@FName,'')))
	select @Result = @@error if @Result <> 0 goto Err
	
	If YEAR(@Date) <= 2015 
	begin
		insert into #items (Code, Name, Expens, GrName, InActive, SetID, ParentID)
		select Code, Name, Expens, GrName, InActive, SetID, ParentID
		from dbo.PDX_pay_Items		
	end	
	else
	begin
		insert into #items (Code, Name, Expens, GrName, InActive, SetID, ParentID)
		select Code, Name, Expens, GrName, InActive, SetID, ParentID
		from dbo.PDX_pay_Items2016		
	end	
	
	insert into #rescfo
		(Code, GrName, UFT5, Lev, KeyField)
	select Code, GrName, Name, 1,	
		cast(replace(case when Code like '%.%' then LEFT(Code, charindex('.',Code)-1) else Code end,'н','') as int)* 10
	from #items
	select @Result = @@error if @Result <> 0 goto Err
	
	update R
		set GrCode = X.KF
	from #rescfo R
	inner join (select min(KeyField)-1 as KF, GrName from #rescfo group by GrName) as X
		on X.GrName = R.GrName
	select @Result = @@error if @Result <> 0 goto Err
	
	select @Cnt = 1, @Lev = 1
	while @Cnt <> 0
	begin
		update R
			set Lev = Lev +
					case when exists (select 1 from #rescfo X where R.Code like X.Code + '.%' and X.Lev = @Lev)
						then 1
						else 0 end
		from #rescfo R
		where R.Lev = @Lev
		select @Cnt = @@ROWCOUNT, @Result = @@error if @Result <> 0 goto Err
		
		if @Cnt > 0 set @Lev = @Lev + 1
	end

	insert into #cfo
		(Code, AmountDoc, DT, Curr, AmountCurr, AccType)
	select 
		dbo.PDX_SubstringReturn(D.UserFieldText5, CHARINDEX('<',D.UserFieldText5), charindex('>',D.UserFieldText5)) as Code, --Статья расходов
		sum(isnull(
			case upper(D.Currency)
			when 'USD'
				then isnull(@USD,0)
			when 'EUR'
				then isnull(@EUR,0)
			when 'JPY'
				then isnull(@JPY,0) 
			else 1 --РУБ
		end * isnull(D.AmountDoc,0),0) * case I.Expens when 1 then -1 else 1 end) as Amount,		--Сумма		
		DAY(D.UserFieldDate1),
		
		cast(D.Currency as varchar(100)),
		sum(D.AmountDoc * case I.Expens when 1 then -1 else 1 end),
		cast(isnull(A.Descr,'') as varchar(255))
	from dbo.Docs D
	inner join #items I on D.UserFieldText5 like '%<' + I.Code + '>%'
	left join dbo.PDX_pay_Accounts A on A.Name = D.UserFieldText6
	where D.ClassDoc = @ClassName
		and UPPER(ISNULL(D.IsActive,'')) = 'Y'	
		and (ISNULL(D.StatusDevelopment,'') ='4' or
			dbo.PDX_CompareReconcilationList(D.ListToReconcile, D.ListReconciled) = 1)
		and ISNULL(D.StatusCompletion,'') <>'0'
		and month(D.UserFieldDate1) = month(@Date)
		and year(D.UserFieldDate1) = year(@Date)
		and (D.UserFieldText2 = @CFO or @CFO = '')
		and (D.UserFieldText8 = @FName or @FName = '')
		and (D.UserFieldMoney2 = @UFM2 or @UFM2 = 2)
	group by D.UserFieldText5, DAY(D.UserFieldDate1), cast(D.Currency as varchar(100)),
	/*D.AmountDoc,*/ cast(isnull(A.Descr,'') as varchar(255))
	select @Result = @@error if @Result <> 0 goto Err

	/**************/
	delete from @Digital
	select @Result = @@error if @Result <> 0 goto Err

	insert into @Digital (Val, TP) values ('РУБ', 0)
	select @Result = @@error if @Result <> 0 goto Err
	insert into @Digital (Val, TP) values ('USD', 0)
	select @Result = @@error if @Result <> 0 goto Err
	insert into @Digital (Val, TP) values ('EUR', 0)
	select @Result = @@error if @Result <> 0 goto Err
	insert into @Digital (Val, TP) values ('JPY', 0)
	select @Result = @@error if @Result <> 0 goto Err
	
	insert into @Digital (Val, TP) values ('ИТОГО, РУБ', 1)
	select @Result = @@error if @Result <> 0 goto Err
		
	insert into @Digital (Val, TP)
	select distinct Descr, 2 from dbo.PDX_pay_Accounts
	order by Descr
	--select distinct AccType, 2 from #cfo
	--order by AccType
	select @Result = @@error if @Result <> 0 goto Err
		
	insert into @Digital (Val, TP, Dig)
	select distinct cast(dt as varchar(100)), 3, DT from #cfo
	order by DT
	select @Result = @@error if @Result <> 0 goto Err
	
	update @Digital 
	set Val = '???'
	where isnull(Val,'') = ''
	select @Result = @@error if @Result <> 0 goto Err
	/**************/
		
	--**********************************
		
	insert into #cfo --это группы
		(Code, AmountDoc, DT, Curr, AmountCurr, AccType)
	select 'G' + cast(GrCode as varchar(100)), 
			sum(isnull(C.AmountDoc,0)), C.DT, C.Curr, SUM(ISNULL(C.AmountCurr,0)), C.AccType
	from #cfo C
	inner join #rescfo R on R.Code = C.Code
	group by R. GrCode, C.DT, C.Curr, C.AccType
	select @Result = @@error if @Result <> 0 goto Err
	
	insert into #rescfo
		(Code, UFT5, Lev, KeyField)
	select distinct
		'G' + cast(GrCode as varchar(100)), GrName, 0, GrCode
	from #rescfo
	select @Result = @@error if @Result <> 0 goto Err

	insert into #cfo --это ИТОГО
		(Code, AmountDoc, DT, Curr, AmountCurr, AccType)
	select '-', sum(isnull(C.AmountDoc,0)), C.DT, C.Curr, SUM(ISNULL(C.AmountCurr,0)), C.AccType
	from #cfo C
	where not Code like 'G%'
	group by C.DT, C.Curr, C.AccType
	select @Result = @@error if @Result <> 0 goto Err
	insert into #rescfo
		(Code, UFT5, Lev, KeyField)
	values ('-', 'ИТОГО', 0, 999999)
	select @Result = @@error if @Result <> 0 goto Err
--**********************************

	insert into #cfo --это группирующие узлы
		(Code, AmountDoc, DT, Curr, AmountCurr, AccType)
	select X.Code, sum(isnull(C.AmountDoc,0)), C.DT, C.Curr, SUM(ISNULL(C.AmountCurr,0)), C.AccType
	from #cfo C
	inner join #rescfo R on C.Code = R.Code
		and R.Lev > 1
	inner join #rescfo X on C.Code like X.Code + '.%' 
		and X.Lev < R.Lev
	group by X.Code, C.DT, C.Curr, C.AccType
	select @Result = @@error if @Result <> 0 goto Err
		
	select @SQLStr = 'R.Lev,R.KeyField, R.Code, R.UFT5 as Name'
	select @Result = @@error if @Result <> 0 goto Err
	
	while exists (select 1 from @Digital)
	begin
		select top 1
			@Cnt = TP,
			@Val = Val
		from @Digital
		order by OI
		select @Result = @@error if @Result <> 0 goto Err
		
		select @SQLStr = @SQLStr + 
						case @Cnt 
							when 3
								then ', sum(case C.DT when ' + @Val + ' then isnull(C.AmountDoc,0) else 0 end)' + @RTR2 + ' as [' + case when CAST(@Val as int) < 10 then '0' else '' end  + CAST(@Val as varchar(10)) + '.' + @Month + ']'
							when 1
								then ', sum(isnull(C.AmountDoc,0))' + @RTR2 + ' as [(1)' + @Val + ']'
							when 2
								then ', sum(case C.AccType when ''' + @Val + ''' then isnull(C.AmountDoc,0) else 0 end)' + @RTR2 + ' as [(2)' + @Val + ']'
							when 0
								then ', sum(case C.Curr when ''' + @Val + ''' then isnull(C.AmountCurr,0) else 0 end)' + case when @Val like '%РУБ%' then @RTR2 else '' end + ' as [(1)' + @Val + ']'
						end
		select @Result = @@error if @Result <> 0 goto Err
		
		delete from @Digital where val = @Val
		select @Result = @@error if @Result <> 0 goto Err
	end
	
	--select @SQLStr = @SQLStr + ', sum(isnull(C.AmountDoc,0)) as [ИТОГО]'
	--select @Result = @@error if @Result <> 0 goto Err
		
	select @SQLStr = 'select ' + @SQLStr + 
			' from #rescfo R ' +
			' left join #cfo C on C.Code = R.Code ' +
			' group by R.Code, R.UFT5, R.KeyField, R.Lev' +
			' order by 2,3'
	select @Result = @@error if @Result <> 0 goto Err
print @SQLStr		
	exec (@SQLStr)
	select @Result = @@error if @Result <> 0 goto Err	

	drop table #cfo
	drop table #rescfo
	return @Result
Err:

	drop table #cfo
	drop table #rescfo
	return @Result





GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_PAYPLNn_details_Get] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_REP_PAYPLNn_details_Get] --БАЗОВЫЙ ПЛАН ПЛАТЕЖЕЙ (детальный)
	@CFO varchar(128),
	@Date datetime,
	@UFM2 tinyint = 2 , --2-все, 1-да, 0-нет
	@RTR bit = 0, --0-руб, 1-тыс руб
	@USD money,
	@EUR money,
	@CAD money
as
	declare @Result int, @RTR2 varchar(10)
	set @Result = 0

	set @RTR2 = case @RTR when 0 then '' else '/1000' end
	
    create table #cfo (KeyField int identity,
						Code varchar(64), 
						AmountDoc money, 
						DT int,
						PName varchar(512),
						DName varchar(256),
						Descr varchar(1024),
						UFT8 varchar(512),
						DocID varchar(128),
						UFD3 datetime,
						UFM2 money, FS varchar(60), FSC varchar(4000), UFT4 varchar(1024))
    
    create table #rescfo (
		KeyField int,  
		Code varchar(64),
		UFT5 varchar(512), 
		Lev int)
	
    create table #items (Code varchar(64), Name varchar(256), Expens tinyint, GrName varchar(256), InActive bit, SetID int, ParentID int)
    
	declare @ClassName varchar(128),  @Cnt int, @Lev int,
			@SQLStr varchar(7000), @Month varchar(2)
	declare @Digital table (Dig int)
	
	select @ClassName = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_PLNPAY'),
		@Month = case when MONTH(@Date) <10 then '0' else '' end + CAST(MONTH(@Date) as varchar(2)),
		@CFO = ltrim(rtrim(ISNULL(@CFO,'')))
	select @Result = @@error if @Result <> 0 goto Err
	
	If YEAR(@Date) <= 2015 
	begin
		insert into #items (Code, Name, Expens, GrName, InActive, SetID, ParentID)
		select Code, Name, Expens, GrName, InActive, SetID, ParentID
		from dbo.PDX_pay_Items		
	end	
	else
	begin
		insert into #items (Code, Name, Expens, GrName, InActive, SetID, ParentID)
		select Code, Name, Expens, GrName, InActive, SetID, ParentID
		from dbo.PDX_pay_Items2016		
	end	
	
	insert into #rescfo
		(Code, UFT5, Lev, KeyField)
	select Code, Name, 1,
		cast(replace(case when Code like '%.%' then LEFT(Code, charindex('.',Code)-1) else Code end,'н','') as int)
	from #items
	select @Result = @@error if @Result <> 0 goto Err
	
	--получаем данные по каждой заявке, в дальнейшем будем делать заявку еще одним уровнем Статей (чтобы алгоритм был тот же, что и сгруппированом отчете)
	insert into #cfo
		(Code, AmountDoc, DT, PName, DName, Descr, UFT8, DocID, UFD3, UFM2, FS, FSC,UFT4)
	select 
		dbo.PDX_SubstringReturn(UserFieldText5, CHARINDEX('<',UserFieldText5), charindex('>',UserFieldText5)) as Code, --Статья расходов
		isnull(
			case upper(Currency)
			when 'USD'
				then isnull(@USD,0)
			when 'EUR'
				then isnull(@EUR,0)
			when 'CAD'
				then isnull(@CAD,0) 
			else 1 --РУБ
		end * isnull(AmountDoc,0),0) * case I.Expens when 1 then -1 else 1 end as Amount,		--Сумма		
		DAY(UserFieldDate1),
		PartnerName, D.Name, Description, UserFieldText8, DocID, UserFieldDate3, UserFieldMoney2,
		S.FinStatus,S.Comment,
		D.UserFieldText4
	from dbo.Docs D
	inner join #items I on D.UserFieldText5 like '%<' + I.Code + '>%'
	left join dbo.PayStatusDetails S on S.DocIDInt = D.DocIDInt
	where ClassDoc = @ClassName
		and UPPER(ISNULL(IsActive,'')) = 'Y'	
		and (ISNULL(StatusDevelopment,'') ='4' or
			dbo.PDX_CompareReconcilationList(ListToReconcile, ListReconciled) = 1)
		and ISNULL(StatusCompletion,'') <>'0'
		and month(UserFieldDate1) = month(@Date)
		and year(UserFieldDate1) = year(@Date)
		and (UserFieldText2 = @CFO or @CFO = '')
		and (UserFieldMoney2 = @UFM2 or @UFM2 = 2)
	--group by UserFieldText5, DAY(UserFieldDate1)
	select @Result = @@error if @Result <> 0 goto Err
	
	--изменяем Code заявок, чтобы из превратить в еще один уровень Статей
	select @Cnt = len(cast(MAX(KeyField) as varchar(100))) from #cfo
	select @Result = @@error if @Result <> 0 goto Err
	
	update #cfo
		set Code = Code + '.' + isnull(replicate('0', @Cnt-len(cast(KeyField as varchar(100)))),'') + cast(KeyField as varchar(100))
	select @Result = @@error if @Result <> 0 goto Err
	
	--а теперь добавдяем эти коды в таблицу со статьями
	insert into #rescfo
		(Code, UFT5, Lev, KeyField)
	select
		Code, 'Заявка на денежные средства №' + DocID + ' от ' + convert(varchar(100), UFD3, 104),
		1, cast(case when Code like '%.%' then LEFT(Code, charindex('.',Code)-1) else Code end as int)
	from #cfo
	select @Result = @@error if @Result <> 0 goto Err
	
	--далее следуем алгоритму обобщенной процедуры
	--разбиваем Стьи по уровням, чтоьы потом суммы считать
	select @Cnt = 1, @Lev = 1
	while @Cnt <> 0
	begin
		update R
			set Lev = Lev +
					case when exists (select 1 from #rescfo X where R.Code like X.Code + '.%' and X.Lev = @Lev)
						then 1
						else 0 end
		from #rescfo R
		where R.Lev = @Lev
		select @Cnt = @@ROWCOUNT, @Result = @@error if @Result <> 0 goto Err
		
		if @Cnt > 0 set @Lev = @Lev + 1
	end
	
	--**********************************
	insert into #cfo --это добавляем ИТОГО
		(Code, AmountDoc, DT)
	select '-', sum(isnull(C.AmountDoc,0)), C.DT
	from #cfo C
	group by C.DT
	select @Result = @@error if @Result <> 0 goto Err
	insert into #rescfo
		(Code, UFT5, Lev, KeyField)
	values ('-', 'ИТОГО', 0, 999999)
	select @Result = @@error if @Result <> 0 goto Err
--**********************************

	insert into #cfo --это "группирующие"(суммы) узлы
		(Code, AmountDoc, DT)
	select X.Code, sum(isnull(C.AmountDoc,0)), C.DT
	from #cfo C
	inner join #rescfo R on C.Code = R.Code
		and R.Lev > 1
	inner join #rescfo X on C.Code like X.Code + '.%' 
		and X.Lev < R.Lev
	group by X.Code, C.DT
	select @Result = @@error if @Result <> 0 goto Err
	
	--теперь готовимся дни месяца "переворачивать" из строк в столбцы
	--выяснем сколько у нас есть дней с суммами
	insert into @Digital (Dig)
	select distinct dt from #cfo
	select @Result = @@error if @Result <> 0 goto Err
	
	--а теперь в цикле собираем запрос, который все перевернет в столбцы
	select @SQLStr = 'R.Lev,R.KeyField, R.Code as dc, ' +
		'case when C.DocID is null then R.Code else '''' end as Code, R.UFT5 as Name, '+
		'C.UFT8, C.PName, C.DName, C.Descr, C.UFM2, C.FS, C.FSC, C.UFT4'
	select @Result = @@error if @Result <> 0 goto Err
	while exists (select 1 from @Digital)
	begin
		select top 1
			@Cnt = Dig
		from @Digital
		order by Dig
		select @Result = @@error if @Result <> 0 goto Err
		
		select @SQLStr = @SQLStr + ', sum(case C.DT when ' + CAST(@Cnt as varchar(10)) + ' then isnull(C.AmountDoc,0) else 0 end)' + @RTR2 + ' as [' + case when @Cnt < 10 then '0' else '' end  + CAST(@Cnt as varchar(10)) + '.' + @Month + ']'
		select @Result = @@error if @Result <> 0 goto Err
		
		delete from @Digital where Dig = @Cnt
		select @Result = @@error if @Result <> 0 goto Err
	end
	
	select @SQLStr = @SQLStr + ', sum(isnull(C.AmountDoc,0))' + @RTR2 + ' as [ИТОГО]'
	select @Result = @@error if @Result <> 0 goto Err

	select @SQLStr = 'select ' + @SQLStr + 
			' from #rescfo R ' +
			' left join #cfo C on C.Code = R.Code ' +
			' group by R.Code, R.UFT5, R.KeyField, R.Lev, C.DocID, C.UFT8, C.PName, C.DName, C.Descr, C.UFM2, C.FS, C.FSC, C.UFT4' +
			' order by 2,3'
	select @Result = @@error if @Result <> 0 goto Err
		
	exec (@SQLStr)
	select @Result = @@error if @Result <> 0 goto Err	

	drop table #cfo
	drop table #rescfo
	return @Result
Err:

	drop table #cfo
	drop table #rescfo
	return @Result




GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_PAYPLNn_details2_Get] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_REP_PAYPLNn_details2_Get] --БАЗОВЫЙ ПЛАН ПЛАТЕЖЕЙ (детальный)
	@CFO varchar(128),
	@Date datetime,
	@UFM2 tinyint = 2 , --2-все, 1-да, 0-нет
	@RTR bit = 0, --0-руб, 1-тыс руб
	@USD money,
	@EUR money,
	@CAD money,
	@Article varchar(1024)
as
	declare @Result int, @RTR2 varchar(10)
	set @Result = 0

	set @RTR2 = case @RTR when 0 then '' else '/1000' end
	
    create table #cfo (KeyField int identity,
						Code varchar(64), 
						AmountDoc money, 
						DT int,
						PName varchar(512),
						DName varchar(256),
						Descr varchar(1024),
						UFT8 varchar(512),
						UFT4 varchar(1024),
						DocID varchar(128),
						UFD3 datetime,
						UFM2 money, FS varchar(60), FSC varchar(4000))
    
    create table #items (Code varchar(64), Name varchar(256), Expens tinyint, GrName varchar(256), InActive bit, SetID int, ParentID int)
    create table #rescfo (
		KeyField int,  
		Code varchar(64),
		UFT5 varchar(512), 
		Lev int,
		flg bit default 0,
		Id int identity,
		Code1 varchar(64))
		
	declare @ClassName varchar(128),  @Cnt int, @Lev int,
			@SQLStr varchar(7000), @Month varchar(2)
	declare @Digital table (Dig int)
	
	select @ClassName = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_PLNPAY'),
		@Month = case when MONTH(@Date) <10 then '0' else '' end + CAST(MONTH(@Date) as varchar(2)),
		@CFO = ltrim(rtrim(ISNULL(@CFO,'')))
	select @Result = @@error if @Result <> 0 goto Err
	
	If YEAR(@Date) <= 2015 
	begin
		insert into #items (Code, Name, Expens, GrName, InActive, SetID, ParentID)
		select Code, Name, Expens, GrName, InActive, SetID, ParentID
		from dbo.PDX_pay_Items		
	end	
	else
	begin
		insert into #items (Code, Name, Expens, GrName, InActive, SetID, ParentID)
		select Code, Name, Expens, GrName, InActive, SetID, ParentID
		from dbo.PDX_pay_Items2016		
	end	
	
	insert into #rescfo
		(Code, UFT5, Lev, KeyField)
	select Code, Name, 1,
		cast(replace(case when Code like '%.%' then LEFT(Code, charindex('.',Code)-1) else Code end,'н','') as int)
	from #items
	where (@Article like '%<' + Code + '>%' or @Article = '')
	select @Result = @@error if @Result <> 0 goto Err
	
	--получаем данные по каждой заявке, в дальнейшем будем делать заявку еще одним уровнем Статей (чтобы алгоритм был тот же, что и сгруппированом отчете)
	insert into #cfo
		(Code, AmountDoc, DT, PName, DName, Descr, UFT8, DocID, UFD3, Uft4, UFM2, FS, FSC)
	select 
		dbo.PDX_SubstringReturn(UserFieldText5, CHARINDEX('<',UserFieldText5), charindex('>',UserFieldText5)) as Code, --Статья расходов
		isnull(
			case upper(Currency)
			when 'USD'
				then isnull(@USD,0)
			when 'EUR'
				then isnull(@EUR,0)
			when 'CAD'
				then isnull(@CAD,0) 
			else 1 --РУБ
		end * isnull(AmountDoc,0),0) * case I.Expens when 1 then -1 else 1 end as Amount,		--Сумма		
		DAY(UserFieldDate1),
		PartnerName, D.Name, Description, UserFieldText8, DocID, UserFieldDate3, UserFieldText4,
		UserFieldMoney2, S.FinStatus,S.Comment
	from dbo.Docs D
	inner join #items I on D.UserFieldText5 like '%<' + I.Code + '>%'
	left join dbo.PayStatusDetails S on S.DocIDInt = D.DocIDInt
	where ClassDoc = @ClassName
		and UPPER(ISNULL(IsActive,'')) = 'Y'	
		and (ISNULL(StatusDevelopment,'') ='4' or
			dbo.PDX_CompareReconcilationList(ListToReconcile, ListReconciled) = 1)
		and ISNULL(StatusCompletion,'') <>'0'
		and month(UserFieldDate1) = month(@Date)
		and year(UserFieldDate1) = year(@Date)
		and (UserFieldText2 = @CFO or @CFO = '')
		and (UserFieldText5 = @Article or @Article = '')
		and (D.UserFieldMoney2 = @UFM2 or @UFM2 = 2)
	--group by UserFieldText5, DAY(UserFieldDate1)
	select @Result = @@error if @Result <> 0 goto Err

--коды ИСР задействованные в отобранных карточках "приравниваем к цфо"
	insert into #rescfo
		(Code, UFT5, Lev, KeyField, flg, Code1)
	select Code, UFT4, 1,
		cast(case when Code like '%.%' then LEFT(Code, charindex('.',Code)-1) else Code end as int),
		1, Code
	from #cfo
	group by UFT4, Code
	select @Result = @@error if @Result <> 0 goto Err

	select @Cnt = len(cast(MAX(Id) as varchar(100))) from #rescfo
	select @Result = @@error if @Result <> 0 goto Err
	
	update #rescfo
	set Code = Code + '.' + isnull(replicate('0', @Cnt-len(cast(Id as varchar(100)))),'') + cast(Id as varchar(100)) 
	where flg = 1
	

	--изменяем Code заявок, чтобы из превратить в еще один уровень Статей
	select @Cnt = len(cast(MAX(KeyField) as varchar(100))) from #cfo
	select @Result = @@error if @Result <> 0 goto Err
	
	update C
		set Code = R.Code + '.' + isnull(replicate('0', @Cnt-len(cast(C.KeyField as varchar(100)))),'') + cast(C.KeyField as varchar(100))
	from #cfo C
	inner join #rescfo R on R.UFT5 = C.UFT4
		and C.Code = R.Code1
	select @Result = @@error if @Result <> 0 goto Err

	--а теперь добавдяем эти коды в таблицу со статьями
	insert into #rescfo
		(Code, UFT5, Lev, KeyField)
	select
		Code, 'Заявка на денежные средства №' + DocID + ' от ' + convert(varchar(100), UFD3, 104),
		1, cast(case when Code like '%.%' then LEFT(Code, charindex('.',Code)-1) else Code end as int)
	from #cfo
	select @Result = @@error if @Result <> 0 goto Err
	
	--далее следуем алгоритму обобщенной процедуры
	--разбиваем Стьи по уровням, чтоьы потом суммы считать
	select @Cnt = 1, @Lev = 1
	while @Cnt <> 0
	begin
		update R
			set Lev = Lev +
					case when exists (select 1 from #rescfo X where R.Code like X.Code + '.%' and X.Lev = @Lev)
						then 1
						else 0 end
		from #rescfo R
		where R.Lev = @Lev
		select @Cnt = @@ROWCOUNT, @Result = @@error if @Result <> 0 goto Err
		
		if @Cnt > 0 set @Lev = @Lev + 1
	end
	
	--**********************************
	insert into #cfo --это добавляем ИТОГО
		(Code, AmountDoc, DT)
	select '-', sum(isnull(C.AmountDoc,0)), C.DT
	from #cfo C
	group by C.DT
	select @Result = @@error if @Result <> 0 goto Err
	insert into #rescfo
		(Code, UFT5, Lev, KeyField)
	values ('-', 'ИТОГО', 0, 999999)
	select @Result = @@error if @Result <> 0 goto Err
--**********************************

	insert into #cfo --это "группирующие"(суммы) узлы
		(Code, AmountDoc, DT)
	select X.Code, sum(isnull(C.AmountDoc,0)), C.DT
	from #cfo C
	inner join #rescfo R on C.Code = R.Code
		and R.Lev > 1
	inner join #rescfo X on C.Code like X.Code + '.%' 
		and X.Lev < R.Lev
	group by X.Code, C.DT
	select @Result = @@error if @Result <> 0 goto Err
	
	--теперь готовимся дни месяца "переворачивать" из строк в столбцы
	--выяснем сколько у нас есть дней с суммами
	insert into @Digital (Dig)
	select distinct dt from #cfo
	select @Result = @@error if @Result <> 0 goto Err
	
	--а теперь в цикле собираем запрос, который все перевернет в столбцы
	select @SQLStr = 'R.Lev,R.KeyField, R.Code as dc, ' +
		'case when C.DocID is null then R.Code else '''' end as Code, R.flg, R.UFT5 as Name, '+
		'C.UFT8, C.PName, C.DName, C.Descr, C.UFM2, C.FS, C.FSC'
	select @Result = @@error if @Result <> 0 goto Err
	while exists (select 1 from @Digital)
	begin
		select top 1
			@Cnt = Dig
		from @Digital
		order by Dig
		select @Result = @@error if @Result <> 0 goto Err
		
		select @SQLStr = @SQLStr + ', sum(case C.DT when ' + CAST(@Cnt as varchar(10)) + ' then isnull(C.AmountDoc,0) else 0 end)' + @RTR2 + ' as [' + case when @Cnt < 10 then '0' else '' end  + CAST(@Cnt as varchar(10)) + '.' + @Month + ']'
		select @Result = @@error if @Result <> 0 goto Err
		
		delete from @Digital where Dig = @Cnt
		select @Result = @@error if @Result <> 0 goto Err
	end
	
	select @SQLStr = @SQLStr + ', sum(isnull(C.AmountDoc,0))' + @RTR2 + ' as [ИТОГО]'
	select @Result = @@error if @Result <> 0 goto Err

	select @SQLStr = 'select ' + @SQLStr + 
			' from #rescfo R ' +
			' left join #cfo C on C.Code = R.Code ' +
			' group by R.flg,R.Code, R.UFT5, R.KeyField, R.Lev, C.DocID, C.UFT8, C.PName, C.DName, C.Descr, C.UFM2, C.FS, C.FSC' +
			' order by 2,3'
	select @Result = @@error if @Result <> 0 goto Err
		
	exec (@SQLStr)
	select @Result = @@error if @Result <> 0 goto Err	

	drop table #cfo
	drop table #rescfo
	return @Result
Err:

	drop table #cfo
	drop table #rescfo
	return @Result




GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_PAYPLNn_Find] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE proc [dbo].[PDX_REP_PAYPLNn_Find] --ПОИСК плановых заявок по основным реквизитам (казначейство)
	@DID varchar(128),
	@UFD3f datetime,
	@UFD3t datetime,
	@UFD1f datetime,
	@UFD1t datetime,
	@UFT7 varchar(64),
	@Currency varchar(64),
	@UFT8 varchar(512),
	@UFT2 varchar(512),
	@PN varchar(512),
	@UFT4 varchar(512),
	@UFT5 varchar(512),
	@Name varchar(128),
	@DIDPar varchar(128),
	@DIDPrev varchar(128),
	@UFT6 varchar(512),
	@NCr varchar(96),
	@State int, --1 - все, кроме отмен, 2- на согл, 3 - треб утв, 4 утв, 5 - отмен
	@UFM2 tinyint = 2 , --2-все, 1-да, 0-нет
	@Access bit = 1
as
	declare @Result int, @Cls varchar(128)
	set @Result = 0

	set @Cls= dbo.PDX_CLSGet('RIK_CategoryName_KAZ_PLNPAY')
	select @UFT2 = ltrim(rtrim(ISNULL(@UFT2,''))),
		@UFT4 = ltrim(rtrim(ISNULL(@UFT4,''))),
		@UFT5 = ltrim(rtrim(ISNULL(@UFT5,''))),
		@UFT6 = ltrim(rtrim(ISNULL(@UFT6,''))),
		@UFT7 = ltrim(rtrim(ISNULL(@UFT7,''))),
		@UFT8 = ltrim(rtrim(ISNULL(@UFT8,''))),
		@Currency = ltrim(rtrim(ISNULL(@Currency,''))),
		@PN = ltrim(rtrim(ISNULL(@PN,''))),
		@Name = ltrim(rtrim(ISNULL(@Name,''))),
		@DIDPar = ltrim(rtrim(ISNULL(@DIDPar,''))),
		@DIDPrev = ltrim(rtrim(ISNULL(@DIDPrev,''))),
		@NCr = case when ISNULL(@NCr,'') like '%<%>%' 
					then dbo.PDX_SubstringReturn(ISNULL(@NCr,''), CHARINDEX('<',ISNULL(@NCr,'')), charindex('>',ISNULL(@NCr,'')))
					else ltrim(rtrim(ISNULL(@NCr,''))) end
	select @Result = @@error if @Result <> 0 goto Err
 
	create table #treeRes (Code varchar(128))
	
	if @UFT4 like '<%>%'
	begin		
		-- и еще раз достраиваем нижние уровни
		;with treeResFirst2 (KeyField, ParentKeyField, code, descr)
		as
		(
			-- сами узелки
			select T1.KeyField, T1.ParentKeyField, cast(T1.Code as varchar(max)), cast(T1.descr as varchar(max))
			from UserDir_ISR T1
			where '<'+Code+'>'=LEFT(@UFT4, charindex('>',@UFT4))
			-- нижние
			union all
			select	I.KeyField, I.ParentKeyField,
					cast(I.Code as varchar(max)) as Code,
					cast(I.descr as varchar(max))
			from UserDir_ISR I 
				inner join treeResFirst2 T on T.KeyField = I.ParentKeyField
			
			
		)
		
			insert into #treeRes (Code)
			select '<' + Code + '>'
			from treeResFirst2
	end
	
	if not exists (select 1 from #treeRes)
	begin
		if @UFT4 <> ''
		begin
			insert into #treeRes (Code) values (@UFT4)
		end
		else
		begin
			insert into #treeRes (Code) values ('')
		end
	end
	
	select 
		case @Access when 1 then 'system_report' else D.DocID end as DocID,
		D.DocID as strID, 
		D.UserFieldDate3, --Рег. дата
		D.UserFieldDate1, --Плановая дата оплаты
		D.UserFieldText7, --Наличный расчет
		D.Currency, --Валюта
		D.UserFieldText8, --Бизнес единица
		D.NameAproval, --Фин. Менеджер
		D.UserFieldText2, --ЦФО
		D.PartnerName, --Отправитель\Получатель
		D.UserFieldText4, --Код ИСР
		D.UserFieldText5, --Статья расходов
		D.Name, --Назначение
		D.AmountDoc, --Сумма
		D.DocIDParent, --Оплата по договору №
		D.DocIDPrevious, --№ договора с Заказчиком
		D.UserFieldText6, --Счет
		D.Description, --Основание
		D.NameCreation, --Заявитель
		D.UserFieldText1, --Наименование листа согласования
		D.ListToReconcile, --Лист согласования
		D.Correspondent, --Список рассылки
		D.ListToEdit, --Список имеющих право редактирования д-та 
		dbo.REC_DocStatusRead(1,D.isActive,D.StatusCompletion,D.StatusDevelopment,
			D.ListToReconcile, D.ListReconciled, D.LocationPath) as Status,
		D.UserFieldMoney2 as UFM2,
		S.FinStatus as FS, S.Comment as FSC
	from dbo.Docs D
	inner join #treeRes R on D.UserFieldText4 like R.Code + '%'
	left join dbo.PayStatusDetails S on S.DocIDInt = D.DocIDInt
	where D.ClassDoc = @Cls
		and UPPER(ISNULL(D.IsActive,'')) = 'Y'
		and (D.DocID like '%' + @DID + '%' or @DID = '')
		and D.UserFieldDate3 between @UFD3f and @UFD3t
		and D.UserFieldDate1 between @UFD1f and @UFD1t
		and (D.UserFieldText7 = @UFT7 or @UFT7 = '')
		and (D.Currency = @Currency or @Currency = '')
		and (D.UserFieldText8 = @UFT8 or @UFT8 = '')
		and (D.UserFieldText2 = @UFT2 or @UFT2 = '')
		and (D.PartnerName = @PN or @PN = '')
		--and (D.UserFieldText4 = @UFT4 or @UFT4 = '')
		and (D.UserFieldText5 = @UFT5 or @UFT5 = '')
		and (D.Name like '%' + @Name +'%' or D.Description like '%' + @Name + '%')
		and (D.DocIDParent = @DIDPar or @DIDPar = '')
		and (D.DocIDPrevious = @DIDPrev or @DIDPrev = '')
		and (D.UserFieldText6 = @UFT6 or @UFT6 = '')
		and (D.NameCreation like '%<' + @NCr + '>%' or @NCr = '')
		and isnull(D.StatusDevelopment,'') = case @State when 4 then '4' else D.StatusDevelopment end
		and isnull(D.StatusDevelopment,'') <> case when @State in (2,3) then '4' else '-' end
		and dbo.PDX_CompareReconcilationList(D.listToReconcile, D.ListReconciled) = case @State when 3 then 1 else dbo.PDX_CompareReconcilationList(D.listToReconcile, D.ListReconciled) end
		and isnull(D.StatusCompletion,'') = case @State when 5 then '0' else isnull(D.StatusCompletion,'') end
		and isnull(D.StatusCompletion,'') <> case @State when 5 then '%^&*^(*' else '0' end
		and (D.UserFieldMoney2 = @UFM2 or @UFM2 = 2)
	order by D.UserFieldDate3, D.DocID
	select @Result = @@error if @Result <> 0 goto Err	
	
	return @Result
Err:

	return @Result




GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_PAYPLNn_Get] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE proc [dbo].[PDX_REP_PAYPLNn_Get] --БАЗОВЫЙ ПЛАН ПЛАТЕЖЕЙ
	@CFO varchar(128),
	@Date datetime,
	@UFM2 tinyint = 2 , --2-все, 1-да, 0-нет
	@RTR bit = 0, --0-руб, 1-тыс руб
	@USD money,
	@EUR money,
	@CAD money
as
	declare @Result int, @RTR2 varchar(10)
	set @Result = 0

	set @RTR2 = case @RTR when 0 then '' else '/1000' end
	
    create table #cfo (Code varchar(64), AmountDoc money, DT int)
    
    create table #items (Code varchar(64), Name varchar(256), Expens tinyint, GrName varchar(256), InActive bit, SetID int, ParentID int)
    
    create table #rescfo (
		KeyField int,  
		Code varchar(64),
		UFT5 varchar(512), 
		Lev int)
	
	
	declare @ClassName varchar(128),  @Cnt int, @Lev int,
			@SQLStr varchar(7000), @Month varchar(2)
	declare @Digital table (Dig int)
	
	select @ClassName = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_PLNPAY'),
		@Month = case when MONTH(@Date) <10 then '0' else '' end + CAST(MONTH(@Date) as varchar(2)),
		@CFO = ltrim(rtrim(ISNULL(@CFO,'')))
	select @Result = @@error if @Result <> 0 goto Err
	
	If YEAR(@Date) <= 2015 
	begin
		insert into #items (Code, Name, Expens, GrName, InActive, SetID, ParentID)
		select Code, Name, Expens, GrName, InActive, SetID, ParentID
		from dbo.PDX_pay_Items		
	end	
	else
	begin
		insert into #items (Code, Name, Expens, GrName, InActive, SetID, ParentID)
		select Code, Name, Expens, GrName, InActive, SetID, ParentID
		from dbo.PDX_pay_Items2016		
	end	
	
	insert into #rescfo
		(Code, UFT5, Lev, KeyField)
	select Code, Name, 1,
		cast(replace(case when Code like '%.%' then LEFT(Code, charindex('.',Code)-1) else Code end,'н','') as int)
	from #items
	select @Result = @@error if @Result <> 0 goto Err
	
	select @Cnt = 1, @Lev = 1
	while @Cnt <> 0
	begin
		update R
			set Lev = Lev +
					case when exists (select 1 from #rescfo X where R.Code like X.Code + '.%' and X.Lev = @Lev)
						then 1
						else 0 end
		from #rescfo R
		where R.Lev = @Lev
		select @Cnt = @@ROWCOUNT, @Result = @@error if @Result <> 0 goto Err
		
		if @Cnt > 0 set @Lev = @Lev + 1
	end
	
	insert into #cfo
		(Code, AmountDoc, DT)
	select 
		dbo.PDX_SubstringReturn(D.UserFieldText5, CHARINDEX('<',D.UserFieldText5), charindex('>',D.UserFieldText5)) as Code, --Статья расходов
		sum(isnull(
			case upper(D.Currency)
			when 'USD'
				then isnull(@USD,0)
			when 'EUR'
				then isnull(@EUR,0)
			when 'CAD'
				then isnull(@CAD,0) 
			else 1 --РУБ
		end * isnull(D.AmountDoc,0),0)) * case I.Expens when 1 then -1 else 1 end as Amount,		--Сумма		
		DAY(D.UserFieldDate1)
	from dbo.Docs D
	inner join #items I on D.UserFieldText5 like '%<' + I.Code + '>%'
	where D.ClassDoc = @ClassName
		and UPPER(ISNULL(D.IsActive,'')) = 'Y'	
		and (ISNULL(D.StatusDevelopment,'') ='4' or
			dbo.PDX_CompareReconcilationList(D.ListToReconcile, D.ListReconciled) = 1)
		and ISNULL(D.StatusCompletion,'') <>'0'
		and month(D.UserFieldDate1) = month(@Date)
		and year(D.UserFieldDate1) = year(@Date)
		and (D.UserFieldText2 = @CFO or @CFO = '')
		and (D.UserFieldMoney2 = @UFM2 or @UFM2 = 2)
	group by D.UserFieldText5, DAY(D.UserFieldDate1),I.Expens
	select @Result = @@error if @Result <> 0 goto Err
	
	--**********************************
	insert into #cfo --это ИТОГО
		(Code, AmountDoc, DT)
	select '-', sum(isnull(C.AmountDoc,0)), C.DT
	from #cfo C
	group by C.DT
	select @Result = @@error if @Result <> 0 goto Err
	insert into #rescfo
		(Code, UFT5, Lev, KeyField)
	values ('-', 'ИТОГО', 0, 999999)
	select @Result = @@error if @Result <> 0 goto Err
--**********************************

	insert into #cfo --это группирующие узлы
		(Code, AmountDoc, DT)
	select X.Code, sum(isnull(C.AmountDoc,0)), C.DT
	from #cfo C
	inner join #rescfo R on C.Code = R.Code
		and R.Lev > 1
	inner join #rescfo X on C.Code like X.Code + '.%' 
		and X.Lev < R.Lev
	group by X.Code, C.DT
	select @Result = @@error if @Result <> 0 goto Err
		
	insert into @Digital (Dig)
	select distinct dt from #cfo
	select @Result = @@error if @Result <> 0 goto Err
	
	select @SQLStr = 'R.Lev,R.KeyField, R.Code, R.UFT5 as Name'
	select @Result = @@error if @Result <> 0 goto Err
	while exists (select 1 from @Digital)
	begin
		select top 1
			@Cnt = Dig
		from @Digital
		order by Dig
		select @Result = @@error if @Result <> 0 goto Err
		
		select @SQLStr = @SQLStr + ', sum(case C.DT when ' + CAST(@Cnt as varchar(10)) + ' then isnull(C.AmountDoc,0) else 0 end)' + @RTR2 + ' as [' + case when @Cnt < 10 then '0' else '' end  + CAST(@Cnt as varchar(10)) + '.' + @Month + ']'
		select @Result = @@error if @Result <> 0 goto Err
		
		delete from @Digital where Dig = @Cnt
		select @Result = @@error if @Result <> 0 goto Err
	end
	
	select @SQLStr = @SQLStr + ', sum(isnull(C.AmountDoc,0))' + @RTR2 + ' as [ИТОГО]'
	select @Result = @@error if @Result <> 0 goto Err
		
	select @SQLStr = 'select ' + @SQLStr + 
			' from #rescfo R ' +
			' left join #cfo C on C.Code = R.Code ' +
			' group by R.Code, R.UFT5, R.KeyField, R.Lev' +
			' order by 2,3'
	select @Result = @@error if @Result <> 0 goto Err
		
	exec (@SQLStr)
	select @Result = @@error if @Result <> 0 goto Err	

	drop table #cfo
	drop table #rescfo
	return @Result
Err:

	drop table #cfo
	drop table #rescfo
	return @Result



GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_PAYPLNn2_currdetails_Get] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROC [dbo].[PDX_REP_PAYPLNn2_currdetails_Get] --БАЗОВЫЙ ПЛАН ПЛАТЕЖЕЙ (детальный)
	@CFO varchar(128),
	@FName varchar(256),
	@Date datetime,
	@UFM2 tinyint = 2 , --2-все, 1-да, 0-нет
	@RTR bit = 0, --0-руб, 1-тыс руб
	@USD money,
	@EUR money,
	@JPY money
as
	declare @Result int, @RTR2 varchar(10)
	set @Result = 0

	set @RTR2 = case @RTR when 0 then '' else '/1000' end
	
    create table #items (Code varchar(64), Name varchar(256), Expens tinyint, GrName varchar(256), InActive bit, SetID int, ParentID int)
    create table #cfo (KeyField int identity,
						Code varchar(64), 
						AmountDoc money, 
						DT int,
						PName varchar(512),
						UName varchar(96),
						DName varchar(256),
						Descr varchar(1024),
						UFT8 varchar(512),
						DocID varchar(128),
						UFD3 datetime,
    Curr varchar(100), AmountCurr money, AccType varchar(255), UFM2 money, FS varchar(60), FSC varchar(4000), UFT4 varchar(1024))
    
    create table #rescfo (
		KeyField int,  
		Code varchar(64),
		GrName varchar(256),
		GrCode int,
		UFT5 varchar(512), 
		Lev int)
		
	declare @ClassName varchar(128),  @Cnt int, @Lev int,
			@SQLStr varchar(7000), @Month varchar(2),
			@Val varchar(255)
	declare @Digital table (Val varchar(255), TP int, OI int identity, Dig int)
	
	select @ClassName = PayDoxOP.dbo.PDX_CLSGet('RIK_CategoryName_KAZ_PLNPAY'),
		@Month = case when MONTH(@Date) <10 then '0' else '' end + CAST(MONTH(@Date) as varchar(2)),
		@CFO = ltrim(rtrim(ISNULL(@CFO,''))),
		@FName = ltrim(rtrim(ISNULL(@FName,'')))
	select @Result = @@error if @Result <> 0 goto Err
	
	If YEAR(@Date) <= 2015 
	begin
		insert into #items (Code, Name, Expens, GrName, InActive, SetID, ParentID)
		select Code, Name, Expens, GrName, InActive, SetID, ParentID
		from PayDoxOP.dbo.PDX_pay_Items		
	end	
	else
	begin
		insert into #items (Code, Name, Expens, GrName, InActive, SetID, ParentID)
		select Code, Name, Expens, GrName, InActive, SetID, ParentID
		from PayDoxOP.dbo.PDX_pay_Items2016		
	end	
		
	insert into #rescfo
		(Code, GrName, UFT5, Lev, KeyField)
	select Code, GrName, Name, 1,
		cast(replace(case when Code like '%.%' then LEFT(Code, charindex('.',Code)-1) else Code end,'н','') as int) * 10
	from #items
	select @Result = @@error if @Result <> 0 goto Err
	
	update R
		set GrCode = X.KF
	from #rescfo R
	inner join (select min(KeyField)-1 as KF, GrName from #rescfo group by GrName) as X
		on X.GrName = R.GrName
	select @Result = @@error if @Result <> 0 goto Err
	
	--получаем данные по каждой заявке, в дальнейшем будем делать заявку еще одним уровнем Статей (чтобы алгоритм был тот же, что и сгруппированом отчете)
	insert into #cfo
		(Code, AmountDoc, DT, PName, UName, DName, Descr, UFT8, DocID, UFD3, Curr, AmountCurr, AccType, UFM2, FS,FSC, UFT4)
	select 
		PayDoxOP.dbo.PDX_SubstringReturn(D.UserFieldText5, CHARINDEX('<',D.UserFieldText5), charindex('>',D.UserFieldText5)) as Code, --Статья расходов
		isnull(
			case upper(D.Currency)
			when 'USD'
				then isnull(@USD,0)
			when 'EUR'
				then isnull(@EUR,0)
			when 'JPY'
				then isnull(@JPY,0) 
			else 1 --РУБ
		end * isnull(D.AmountDoc,0),0) * case I.Expens when 1 then -1 else 1 end as Amount,		--Сумма		
		DAY(D.UserFieldDate1),
		D.PartnerName, D.NameCreation, D.Name, D.Description, D.UserFieldText8, D.DocID, D.UserFieldDate3,
		
		cast(D.Currency as varchar(100)),
		D.AmountDoc * case I.Expens when 1 then -1 else 1 end as Amount,
		cast(isnull(A.Descr,'') as varchar(255)),
		D.UserFieldMoney2,
		S.FinStatus, S.Comment,
		D.UserFieldText4
	from PayDoxOP.dbo.Docs D
	inner join #items I on D.UserFieldText5 like '%<' + I.Code + '>%'
	left join PayDoxOP.dbo.PDX_pay_Accounts A on A.Name = D.UserFieldText6
	left join PayDoxOP.dbo.PayStatusDetails S on S.DocIDInt = D.DocIDInt
	where D.ClassDoc = @ClassName
		and UPPER(ISNULL(D.IsActive,'')) = 'Y'	
		and (ISNULL(D.StatusDevelopment,'') ='4' or
			dbo.PDX_CompareReconcilationList(D.ListToReconcile, D.ListReconciled) = 1)
		and ISNULL(D.StatusCompletion,'') <>'0'
		and month(D.UserFieldDate1) = month(@Date)
		and year(D.UserFieldDate1) = year(@Date)
		and (D.UserFieldText2 = @CFO or @CFO = '')
		and (D.UserFieldText8 = @FName or @FName = '')
		and (D.UserFieldMoney2 = @UFM2 or @UFM2 = 2)
	
	select @Result = @@error if @Result <> 0 goto Err
	
	--изменяем Code заявок, чтобы из превратить в еще один уровень Статей
	select @Cnt = len(cast(MAX(KeyField) as varchar(100))) from #cfo
	select @Result = @@error if @Result <> 0 goto Err
	
	update #cfo
		set Code = Code + '.' + isnull(replicate('0', @Cnt-len(cast(KeyField as varchar(100)))),'') + cast(KeyField as varchar(100))
	select @Result = @@error if @Result <> 0 goto Err
	
	--а теперь добавдяем эти коды в таблицу со статьями
	insert into #rescfo
		(Code, GrName, GrCode, UFT5, Lev, KeyField)
	select distinct
		C.Code, R.GrName, R.GrCode, 'Заявка на денежные средства №' + C.DocID + ' от ' + convert(varchar(100), C.UFD3, 104),
		1, cast(case when C.Code like '%.%' then LEFT(C.Code, charindex('.',C.Code)-1) else C.Code end as int)*10
	from #cfo C
	inner join #rescfo R on C.Code like R.Code + '.%'
	select @Result = @@error if @Result <> 0 goto Err
	
	--далее следуем алгоритму обобщенной процедуры
	--разбиваем Стьи по уровням, чтоьы потом суммы считать
	select @Cnt = 1, @Lev = 1
	while @Cnt <> 0
	begin
		update R
			set Lev = Lev +
					case when exists (select 1 from #rescfo X where R.Code like X.Code + '.%' and X.Lev = @Lev)
						then 1
						else 0 end
		from #rescfo R
		where R.Lev = @Lev
		select @Cnt = @@ROWCOUNT, @Result = @@error if @Result <> 0 goto Err
		
		if @Cnt > 0 set @Lev = @Lev + 1
	end
	
	/**************/
	delete from @Digital
	select @Result = @@error if @Result <> 0 goto Err

	insert into @Digital (Val, TP) values ('РУБ', 0)
	select @Result = @@error if @Result <> 0 goto Err
	insert into @Digital (Val, TP) values ('USD', 0)
	select @Result = @@error if @Result <> 0 goto Err
	insert into @Digital (Val, TP) values ('EUR', 0)
	select @Result = @@error if @Result <> 0 goto Err
	insert into @Digital (Val, TP) values ('JPY', 0)
	select @Result = @@error if @Result <> 0 goto Err
	
	insert into @Digital (Val, TP) values ('ИТОГО, РУБ', 1)
	select @Result = @@error if @Result <> 0 goto Err
		
	insert into @Digital (Val, TP)
	select distinct Descr, 2 from PayDoxOP.dbo.PDX_pay_Accounts
	order by Descr
	--select distinct AccType, 2 from #cfo
	--order by AccType
	select @Result = @@error if @Result <> 0 goto Err
		
	insert into @Digital (Val, TP, Dig)
	select distinct cast(dt as varchar(100)), 3, DT from #cfo
	order by DT
	select @Result = @@error if @Result <> 0 goto Err
	
	update @Digital 
	set Val = '???'
	where isnull(Val,'') = ''
	select @Result = @@error if @Result <> 0 goto Err
	/**************/

	--**********************************
	insert into #cfo --это группы
		(Code, AmountDoc, DT, Curr, AmountCurr, AccType)
	select 'G' + cast(GrCode as varchar(100)), 
			sum(isnull(C.AmountDoc,0)), C.DT, C.Curr, SUM(ISNULL(C.AmountCurr,0)), C.AccType
	from #cfo C
	inner join #rescfo R on R.Code = C.Code
	group by R.GrCode, C.DT, C.Curr, C.AccType
	union all
	select '-', sum(isnull(C.AmountDoc,0)), C.DT, C.Curr, SUM(ISNULL(C.AmountCurr,0)), C.AccType
	from #cfo C
	group by C.DT, C.Curr, C.AccType
	select @Result = @@error if @Result <> 0 goto Err
	
	insert into #rescfo
		(Code, UFT5, Lev, KeyField)
	select distinct
		'G' + cast(GrCode as varchar(100)), GrName, 0, GrCode
	from #rescfo
	select @Result = @@error if @Result <> 0 goto Err

	insert into #rescfo
		(Code, UFT5, Lev, KeyField)
	values ('-', 'ИТОГО', 0, 999999)
	select @Result = @@error if @Result <> 0 goto Err
--**********************************

	insert into #cfo --это "группирующие"(суммы) узлы
		(Code, AmountDoc, DT, Curr, AmountCurr, AccType)
	select X.Code, sum(isnull(C.AmountDoc,0)), C.DT, C.Curr, SUM(ISNULL(C.AmountCurr,0)), C.AccType
	from #cfo C
	inner join #rescfo R on C.Code = R.Code
		and R.Lev > 1
	inner join #rescfo X on C.Code like X.Code + '.%' 
		and X.Lev < R.Lev
	group by X.Code, C.DT, C.Curr, C.AccType
	select @Result = @@error if @Result <> 0 goto Err
		
	--а теперь в цикле собираем запрос, который все перевернет в столбцы
	select @SQLStr = 'R.Lev,R.KeyField, R.Code as dc, ' +
		'case when C.DocID is null then R.Code else '''' end as Code, R.UFT5 as Name, '+
		'C.UFT8, C.PName, C.UName, C.DName, C.Descr, C.UFM2, C.FS, C.FSC, C.UFT4'
	select @Result = @@error if @Result <> 0 goto Err
	while exists (select 1 from @Digital)
	begin
		select top 1
			@Cnt = TP,
			@Val = Val
		from @Digital
		order by OI
		select @Result = @@error if @Result <> 0 goto Err
				
		select @SQLStr = @SQLStr + 
						case @Cnt 
							when 3
								then ', sum(case C.DT when ' + @Val + ' then isnull(C.AmountDoc,0) else 0 end)' + @RTR2 + ' as [(3)' + case when CAST(@Val as int) < 10 then '0' else '' end  + CAST(@Val as varchar(10)) + '.' + @Month + ']'
							when 1
								then ', sum(isnull(C.AmountDoc,0))' + @RTR2 + ' as [(1)' + @Val + ']'
							when 2
								then ', sum(case C.AccType when ''' + @Val + ''' then isnull(C.AmountDoc,0) else 0 end)' + @RTR2 + ' as [(2)' + @Val + ']'
							when 0
								then ', sum(case C.Curr when ''' + @Val + ''' then isnull(C.AmountCurr,0) else 0 end)' + case when @Val like '%РУБ%' then @RTR2 else '' end + ' as [(1)' + @Val + ']'
						end
		select @Result = @@error if @Result <> 0 goto Err
		
		delete from @Digital where val = @Val
		select @Result = @@error if @Result <> 0 goto Err
	end
	
	select @SQLStr = 'select ' + @SQLStr + 
			' from #rescfo R ' +
			' left join #cfo C on C.Code = R.Code ' +
			' group by R.Code, R.UFT5, R.KeyField, R.Lev, C.DocID, C.UFT8, C.PName, C.UName, C.DName, C.Descr, C.UFM2, C.FS, C.FSC, C.UFT4' +
			' order by 2,3'
	select @Result = @@error if @Result <> 0 goto Err

	exec (@SQLStr)
	select @Result = @@error if @Result <> 0 goto Err	

	drop table #cfo
	drop table #rescfo
	return @Result
Err:

	drop table #cfo
	drop table #rescfo
	return @Result











GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_PAYPLNn2_currency_Get] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_REP_PAYPLNn2_currency_Get] --БАЗОВЫЙ ПЛАН ПЛАТЕЖЕЙ (по валютам и счетам)
	@CFO varchar(128),
	@FName varchar(256),
	@Date datetime,
	@UFM2 tinyint = 2 , --2-все, 1-да, 0-нет
	@RTR bit = 0, --0-руб, 1-тыс руб
	@USD money,
	@EUR money,
	@JPY money
as
	declare @Result int, @RTR2 varchar(10)
	set @Result = 0

	set @RTR2 = case @RTR when 0 then '' else '/1000' end
	
    create table #cfo (Code varchar(64), AmountDoc money, DT int,
    Curr varchar(100), AmountCurr money, AccType varchar(255))
    
    create table #items (Code varchar(64), Name varchar(256), Expens tinyint, GrName varchar(256), InActive bit, SetID int, ParentID int)
    
    create table #rescfo (
		KeyField int,  
		Code varchar(64),
		GrName varchar(256),
		GrCode int,
		UFT5 varchar(512), 
		Lev int)
		
	declare @ClassName varchar(128),  @Cnt int, @Lev int,
			@SQLStr varchar(7000), @Month varchar(2),
			@Val varchar(255)
	declare @Digital table (Val varchar(255), TP int, OI int identity, Dig int)
	
	select @ClassName = PayDoxOP.dbo.PDX_CLSGet('RIK_CategoryName_KAZ_PLNPAY'),
		@Month = case when MONTH(@Date) <10 then '0' else '' end + CAST(MONTH(@Date) as varchar(2)),
		@CFO = ltrim(rtrim(ISNULL(@CFO,''))),
		@FName = ltrim(rtrim(ISNULL(@FName,'')))
	select @Result = @@error if @Result <> 0 goto Err

	
	If YEAR(@Date) <= 2015 
	begin
		insert into #items (Code, Name, Expens, GrName, InActive, SetID, ParentID)
		select Code, Name, Expens, GrName, InActive, SetID, ParentID
		from PayDoxOP.dbo.PDX_pay_Items		
	end	
	else
	begin
		insert into #items (Code, Name, Expens, GrName, InActive, SetID, ParentID)
		select Code, Name, Expens, GrName, InActive, SetID, ParentID
		from PayDoxOP.dbo.PDX_pay_Items2016		
	end
		
	insert into #rescfo
		(Code, GrName, UFT5, Lev, KeyField)
	select Code, GrName, Name, 1,
		cast(replace(case when Code like '%.%' then LEFT(Code, charindex('.',Code)-1) else Code end,'н','') as int) * 10
	from #items
	select @Result = @@error if @Result <> 0 goto Err
	
	update R
		set GrCode = X.KF
	from #rescfo R
	inner join (select min(KeyField)-1 as KF, GrName from #rescfo group by GrName) as X
		on X.GrName = R.GrName
	select @Result = @@error if @Result <> 0 goto Err
	
	select @Cnt = 1, @Lev = 1
	while @Cnt <> 0
	begin
		update R
			set Lev = Lev +
					case when exists (select 1 from #rescfo X where R.Code like X.Code + '.%' and X.Lev = @Lev)
						then 1
						else 0 end
		from #rescfo R
		where R.Lev = @Lev
		select @Cnt = @@ROWCOUNT, @Result = @@error if @Result <> 0 goto Err
		
		if @Cnt > 0 set @Lev = @Lev + 1
	end

	insert into #cfo
		(Code, AmountDoc, DT, Curr, AmountCurr, AccType)
	select 
		PayDoxOP.dbo.PDX_SubstringReturn(D.UserFieldText5, CHARINDEX('<',D.UserFieldText5), charindex('>',D.UserFieldText5)) as Code, --Статья расходов
		sum(isnull(
			case upper(D.Currency)
			when 'USD'
				then isnull(@USD,0)
			when 'EUR'
				then isnull(@EUR,0)
			when 'JPY'
				then isnull(@JPY,0) 
			else 1 --РУБ
		end * isnull(D.AmountDoc,0),0) * case I.Expens when 1 then -1 else 1 end) as Amount,		--Сумма		
		DAY(D.UserFieldDate1),
		
		cast(D.Currency as varchar(100)),
		sum(D.AmountDoc * case I.Expens when 1 then -1 else 1 end),
		cast(isnull(A.Descr,'') as varchar(255))
	from PayDoxOP.dbo.Docs D
	inner join #items I on D.UserFieldText5 like '%<' + I.Code + '>%'
	left join PayDoxOP.dbo.PDX_pay_Accounts A on A.Name = D.UserFieldText6
	where D.ClassDoc = @ClassName
		and UPPER(ISNULL(D.IsActive,'')) = 'Y'	
		and (ISNULL(D.StatusDevelopment,'') ='4' or
			dbo.PDX_CompareReconcilationList(D.ListToReconcile, D.ListReconciled) = 1)
		and ISNULL(D.StatusCompletion,'') <>'0'
		and month(D.UserFieldDate1) = month(@Date)
		and year(D.UserFieldDate1) = year(@Date)
		and (D.UserFieldText2 = @CFO or @CFO = '')
		and (D.UserFieldText8 = @FName or @FName = '')
		and (D.UserFieldMoney2 = @UFM2 or @UFM2 = 2)
	group by D.UserFieldText5, DAY(D.UserFieldDate1), cast(D.Currency as varchar(100)),
	/*D.AmountDoc,*/ cast(isnull(A.Descr,'') as varchar(255))
	select @Result = @@error if @Result <> 0 goto Err

	
	/**************/
	delete from @Digital
	select @Result = @@error if @Result <> 0 goto Err

	insert into @Digital (Val, TP) values ('РУБ', 0)
	select @Result = @@error if @Result <> 0 goto Err
	insert into @Digital (Val, TP) values ('USD', 0)
	select @Result = @@error if @Result <> 0 goto Err
	insert into @Digital (Val, TP) values ('EUR', 0)
	select @Result = @@error if @Result <> 0 goto Err
	insert into @Digital (Val, TP) values ('JPY', 0)
	select @Result = @@error if @Result <> 0 goto Err
	
	insert into @Digital (Val, TP) values ('ИТОГО, РУБ', 1)
	select @Result = @@error if @Result <> 0 goto Err
		
	insert into @Digital (Val, TP)
	select distinct Descr, 2 from PayDoxOP.dbo.PDX_pay_Accounts
	order by Descr
	--select distinct AccType, 2 from #cfo
	--order by AccType
	select @Result = @@error if @Result <> 0 goto Err
		
	insert into @Digital (Val, TP, Dig)
	select distinct cast(dt as varchar(100)), 3, DT from #cfo
	order by DT
	select @Result = @@error if @Result <> 0 goto Err
	
	update @Digital 
	set Val = '???'
	where isnull(Val,'') = ''
	select @Result = @@error if @Result <> 0 goto Err
	/**************/
		
	--**********************************
		
	insert into #cfo --это группы
		(Code, AmountDoc, DT, Curr, AmountCurr, AccType)
	select 'G' + cast(GrCode as varchar(100)), 
			sum(isnull(C.AmountDoc,0)), C.DT, C.Curr, SUM(ISNULL(C.AmountCurr,0)), C.AccType
	from #cfo C
	inner join #rescfo R on R.Code = C.Code
	group by R. GrCode, C.DT, C.Curr, C.AccType
	select @Result = @@error if @Result <> 0 goto Err
	
	insert into #rescfo
		(Code, UFT5, Lev, KeyField)
	select distinct
		'G' + cast(GrCode as varchar(100)), GrName, 0, GrCode
	from #rescfo
	select @Result = @@error if @Result <> 0 goto Err

	insert into #cfo --это ИТОГО
		(Code, AmountDoc, DT, Curr, AmountCurr, AccType)
	select '-', sum(isnull(C.AmountDoc,0)), C.DT, C.Curr, SUM(ISNULL(C.AmountCurr,0)), C.AccType
	from #cfo C
	where not Code like 'G%'
	group by C.DT, C.Curr, C.AccType
	select @Result = @@error if @Result <> 0 goto Err
	insert into #rescfo
		(Code, UFT5, Lev, KeyField)
	values ('-', 'ИТОГО', 0, 999999)
	select @Result = @@error if @Result <> 0 goto Err
--**********************************

	insert into #cfo --это группирующие узлы
		(Code, AmountDoc, DT, Curr, AmountCurr, AccType)
	select X.Code, sum(isnull(C.AmountDoc,0)), C.DT, C.Curr, SUM(ISNULL(C.AmountCurr,0)), C.AccType
	from #cfo C
	inner join #rescfo R on C.Code = R.Code
		and R.Lev > 1
	inner join #rescfo X on C.Code like X.Code + '.%' 
		and X.Lev < R.Lev
	group by X.Code, C.DT, C.Curr, C.AccType
	select @Result = @@error if @Result <> 0 goto Err
		
	select @SQLStr = 'R.Lev,R.KeyField, R.Code, R.UFT5 as Name'
	select @Result = @@error if @Result <> 0 goto Err
	
	while exists (select 1 from @Digital)
	begin
		select top 1
			@Cnt = TP,
			@Val = Val
		from @Digital
		order by OI
		select @Result = @@error if @Result <> 0 goto Err
		
		select @SQLStr = @SQLStr + 
						case @Cnt 
							when 3
								then ', sum(case C.DT when ' + @Val + ' then isnull(C.AmountDoc,0) else 0 end)' + @RTR2 + ' as [' + case when CAST(@Val as int) < 10 then '0' else '' end  + CAST(@Val as varchar(10)) + '.' + @Month + ']'
							when 1
								then ', sum(isnull(C.AmountDoc,0))' + @RTR2 + ' as [(1)' + @Val + ']'
							when 2
								then ', sum(case C.AccType when ''' + @Val + ''' then isnull(C.AmountDoc,0) else 0 end)' + @RTR2 + ' as [(2)' + @Val + ']'
							when 0
								then ', sum(case C.Curr when ''' + @Val + ''' then isnull(C.AmountCurr,0) else 0 end)' + case when @Val like '%РУБ%' then @RTR2 else '' end + ' as [(1)' + @Val + ']'
						end
		select @Result = @@error if @Result <> 0 goto Err
		
		delete from @Digital where val = @Val
		select @Result = @@error if @Result <> 0 goto Err
	end
	
	--select @SQLStr = @SQLStr + ', sum(isnull(C.AmountDoc,0)) as [ИТОГО]'
	--select @Result = @@error if @Result <> 0 goto Err
		
	select @SQLStr = 'select ' + @SQLStr + 
			' from #rescfo R ' +
			' left join #cfo C on C.Code = R.Code ' +
			' group by R.Code, R.UFT5, R.KeyField, R.Lev' +
			' order by 2,3'
	select @Result = @@error if @Result <> 0 goto Err
print @SQLStr		
	exec (@SQLStr)
	select @Result = @@error if @Result <> 0 goto Err	

	drop table #cfo
	drop table #rescfo
	return @Result
Err:

	drop table #cfo
	drop table #rescfo
	return @Result






GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_PAYPLNn2_details_Get] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[PDX_REP_PAYPLNn2_details_Get] --БАЗОВЫЙ ПЛАН ПЛАТЕЖЕЙ (детальный)
	@CFO varchar(128),
	@Date datetime,
	@UFM2 tinyint = 2 , --2-все, 1-да, 0-нет
	@RTR bit = 0, --0-руб, 1-тыс руб
	@USD money,
	@EUR money,
	@CAD money
as
	declare @Result int, @RTR2 varchar(10)
	set @Result = 0

	set @RTR2 = case @RTR when 0 then '' else '/1000' end
	
    create table #cfo (KeyField int identity,
						Code varchar(64), 
						AmountDoc money, 
						DT int,
						PName varchar(512),
						DName varchar(256),
						Descr varchar(1024),
						UFT8 varchar(512),
						DocID varchar(128),
						UFD3 datetime,
						UFM2 money, FS varchar(60), FSC varchar(4000), UFT4 varchar(1024))
    
    create table #rescfo (
		KeyField int,  
		Code varchar(64),
		UFT5 varchar(512), 
		Lev int)
		
    create table #items (Code varchar(64), Name varchar(256), Expens tinyint, GrName varchar(256), InActive bit, SetID int, ParentID int)
	declare @ClassName varchar(128),  @Cnt int, @Lev int,
			@SQLStr varchar(7000), @Month varchar(2)
	declare @Digital table (Dig int)
	
	select @ClassName = PayDoxOP.dbo.PDX_CLSGet('RIK_CategoryName_KAZ_PLNPAY'),
		@Month = case when MONTH(@Date) <10 then '0' else '' end + CAST(MONTH(@Date) as varchar(2)),
		@CFO = ltrim(rtrim(ISNULL(@CFO,'')))
	select @Result = @@error if @Result <> 0 goto Err
	
	If YEAR(@Date) <= 2015 
	begin
		insert into #items (Code, Name, Expens, GrName, InActive, SetID, ParentID)
		select Code, Name, Expens, GrName, InActive, SetID, ParentID
		from PayDoxOP.dbo.PDX_pay_Items		
	end	
	else
	begin
		insert into #items (Code, Name, Expens, GrName, InActive, SetID, ParentID)
		select Code, Name, Expens, GrName, InActive, SetID, ParentID
		from PayDoxOP.dbo.PDX_pay_Items2016		
	end	
		
	insert into #rescfo
		(Code, UFT5, Lev, KeyField)
	select Code, Name, 1,
		cast(replace(case when Code like '%.%' then LEFT(Code, charindex('.',Code)-1) else Code end,'н','') as int)
	from #items
	select @Result = @@error if @Result <> 0 goto Err
	
	--получаем данные по каждой заявке, в дальнейшем будем делать заявку еще одним уровнем Статей (чтобы алгоритм был тот же, что и сгруппированом отчете)
	insert into #cfo
		(Code, AmountDoc, DT, PName, DName, Descr, UFT8, DocID, UFD3, UFM2, FS, FSC, UFT4)
	select 
		PayDoxOP.dbo.PDX_SubstringReturn(UserFieldText5, CHARINDEX('<',UserFieldText5), charindex('>',UserFieldText5)) as Code, --Статья расходов
		isnull(
			case upper(Currency)
			when 'USD'
				then isnull(@USD,0)
			when 'EUR'
				then isnull(@EUR,0)
			when 'CAD'
				then isnull(@CAD,0) 
			else 1 --РУБ
		end * isnull(AmountDoc,0),0) * case I.Expens when 1 then -1 else 1 end as Amount,		--Сумма		
		DAY(UserFieldDate1),
		PartnerName, D.Name, Description, UserFieldText8, DocID, UserFieldDate3, UserFieldMoney2,
		S.FinStatus, s.Comment,
		D.UserFieldText4
	from PayDoxOP.dbo.Docs D
	inner join #items I on D.UserFieldText5 like '%<' + I.Code + '>%'
	left join PayDoxOP.dbo.PayStatusDetails S on S.DocIDInt = D.DocIDInt
	where ClassDoc = @ClassName
		and UPPER(ISNULL(IsActive,'')) = 'Y'	
		and (ISNULL(StatusDevelopment,'') ='4' or
			dbo.PDX_CompareReconcilationList(ListToReconcile, ListReconciled) = 1)
		and ISNULL(StatusCompletion,'') <>'0'
		and month(UserFieldDate1) = month(@Date)
		and year(UserFieldDate1) = year(@Date)
		and (UserFieldText2 = @CFO or @CFO = '')
		and (D.UserFieldMoney2 = @UFM2 or @UFM2 = 2)
	
	select @Result = @@error if @Result <> 0 goto Err
	
	--изменяем Code заявок, чтобы из превратить в еще один уровень Статей
	select @Cnt = len(cast(MAX(KeyField) as varchar(100))) from #cfo
	select @Result = @@error if @Result <> 0 goto Err
	
	update #cfo
		set Code = Code + '.' + isnull(replicate('0', @Cnt-len(cast(KeyField as varchar(100)))),'') + cast(KeyField as varchar(100))
	select @Result = @@error if @Result <> 0 goto Err
	
	--а теперь добавдяем эти коды в таблицу со статьями
	insert into #rescfo
		(Code, UFT5, Lev, KeyField)
	select
		Code, 'Заявка на денежные средства №' + DocID + ' от ' + convert(varchar(100), UFD3, 104),
		1, cast(case when Code like '%.%' then LEFT(Code, charindex('.',Code)-1) else Code end as int)
	from #cfo
	select @Result = @@error if @Result <> 0 goto Err
	
	--далее следуем алгоритму обобщенной процедуры
	--разбиваем Стьи по уровням, чтоьы потом суммы считать
	select @Cnt = 1, @Lev = 1
	while @Cnt <> 0
	begin
		update R
			set Lev = Lev +
					case when exists (select 1 from #rescfo X where R.Code like X.Code + '.%' and X.Lev = @Lev)
						then 1
						else 0 end
		from #rescfo R
		where R.Lev = @Lev
		select @Cnt = @@ROWCOUNT, @Result = @@error if @Result <> 0 goto Err
		
		if @Cnt > 0 set @Lev = @Lev + 1
	end
	
	--**********************************
	insert into #cfo --это добавляем ИТОГО
		(Code, AmountDoc, DT)
	select '-', sum(isnull(C.AmountDoc,0)), C.DT
	from #cfo C
	group by C.DT
	select @Result = @@error if @Result <> 0 goto Err
	insert into #rescfo
		(Code, UFT5, Lev, KeyField)
	values ('-', 'ИТОГО', 0, 999999)
	select @Result = @@error if @Result <> 0 goto Err
--**********************************

	insert into #cfo --это "группирующие"(суммы) узлы
		(Code, AmountDoc, DT)
	select X.Code, sum(isnull(C.AmountDoc,0)), C.DT
	from #cfo C
	inner join #rescfo R on C.Code = R.Code
		and R.Lev > 1
	inner join #rescfo X on C.Code like X.Code + '.%' 
		and X.Lev < R.Lev
	group by X.Code, C.DT
	select @Result = @@error if @Result <> 0 goto Err
	
	--теперь готовимся дни месяца "переворачивать" из строк в столбцы
	--выяснем сколько у нас есть дней с суммами
	insert into @Digital (Dig)
	select distinct dt from #cfo
	select @Result = @@error if @Result <> 0 goto Err
	
	--а теперь в цикле собираем запрос, который все перевернет в столбцы
	select @SQLStr = 'R.Lev,R.KeyField, R.Code as dc, ' +
		'case when C.DocID is null then R.Code else '''' end as Code, R.UFT5 as Name, '+
		'C.UFT8, C.PName, C.DName, C.Descr, C.UFM2, C.FS, C.FSC, C.UFT4'
	select @Result = @@error if @Result <> 0 goto Err
	while exists (select 1 from @Digital)
	begin
		select top 1
			@Cnt = Dig
		from @Digital
		order by Dig
		select @Result = @@error if @Result <> 0 goto Err
		
		select @SQLStr = @SQLStr + ', sum(case C.DT when ' + CAST(@Cnt as varchar(10)) + ' then isnull(C.AmountDoc,0) else 0 end)' + @RTR2 + ' as [' + case when @Cnt < 10 then '0' else '' end  + CAST(@Cnt as varchar(10)) + '.' + @Month + ']'
		select @Result = @@error if @Result <> 0 goto Err
		
		delete from @Digital where Dig = @Cnt
		select @Result = @@error if @Result <> 0 goto Err
	end
	
	select @SQLStr = @SQLStr + ', sum(isnull(C.AmountDoc,0))' + @RTR2 + ' as [ИТОГО]'
	select @Result = @@error if @Result <> 0 goto Err

	select @SQLStr = 'select ' + @SQLStr + 
			' from #rescfo R ' +
			' left join #cfo C on C.Code = R.Code ' +
			' group by R.Code, R.UFT5, R.KeyField, R.Lev, C.DocID, C.UFT8, C.PName, C.DName, C.Descr, C.UFM2, C.FS, C.FSC, C.UFT4' +
			' order by 2,3'
	select @Result = @@error if @Result <> 0 goto Err
		
	exec (@SQLStr)
	select @Result = @@error if @Result <> 0 goto Err	

	drop table #cfo
	drop table #rescfo
	return @Result
Err:

	drop table #cfo
	drop table #rescfo
	return @Result






GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_PAYPLNn2_details2_Get] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_REP_PAYPLNn2_details2_Get] --БАЗОВЫЙ ПЛАН ПЛАТЕЖЕЙ (детальный)
	@CFO varchar(128),
	@Date datetime,
	@UFM2 tinyint = 2 , --2-все, 1-да, 0-нет
	@RTR bit = 0, --0-руб, 1-тыс руб
	@USD money,
	@EUR money,
	@CAD money,
	@Article varchar(1024)
as
	declare @Result int, @RTR2 varchar(10)
	set @Result = 0

	set @RTR2 = case @RTR when 0 then '' else '/1000' end
	
    create table #cfo (KeyField int identity,
						Code varchar(64), 
						AmountDoc money, 
						DT int,
						PName varchar(512),
						DName varchar(256),
						Descr varchar(1024),
						UFT8 varchar(512),
						UFT4 varchar(1024),
						DocID varchar(128),
						UFD3 datetime,
						UFM2 money, FS varchar(60), FSC varchar(4000))
    
    create table #items (Code varchar(64), Name varchar(256), Expens tinyint, GrName varchar(256), InActive bit, SetID int, ParentID int)
    create table #rescfo (
		KeyField int,  
		Code varchar(64),
		UFT5 varchar(512), 
		Lev int,
		flg bit default 0,
		Id int identity,
		Code1 varchar(64))
		
	declare @ClassName varchar(128),  @Cnt int, @Lev int,
			@SQLStr varchar(7000), @Month varchar(2)
	declare @Digital table (Dig int)
	
	select @ClassName = PayDoxOP.dbo.PDX_CLSGet('RIK_CategoryName_KAZ_PLNPAY'),
		@Month = case when MONTH(@Date) <10 then '0' else '' end + CAST(MONTH(@Date) as varchar(2)),
		@CFO = ltrim(rtrim(ISNULL(@CFO,'')))
	select @Result = @@error if @Result <> 0 goto Err

	If YEAR(@Date) <= 2015 
	begin
		insert into #items (Code, Name, Expens, GrName, InActive, SetID, ParentID)
		select Code, Name, Expens, GrName, InActive, SetID, ParentID
		from PayDoxOP.dbo.PDX_pay_Items		
	end	
	else
	begin
		insert into #items (Code, Name, Expens, GrName, InActive, SetID, ParentID)
		select Code, Name, Expens, GrName, InActive, SetID, ParentID
		from PayDoxOP.dbo.PDX_pay_Items2016		
	end
		
	insert into #rescfo
		(Code, UFT5, Lev, KeyField)
	select Code, Name, 1,
		cast(replace(case when Code like '%.%' then LEFT(Code, charindex('.',Code)-1) else Code end,'н','') as int)
	from #items
	where (@Article like '%<' + Code + '>%' or @Article = '')
	select @Result = @@error if @Result <> 0 goto Err
	
	--получаем данные по каждой заявке, в дальнейшем будем делать заявку еще одним уровнем Статей (чтобы алгоритм был тот же, что и сгруппированом отчете)
	insert into #cfo
		(Code, AmountDoc, DT, PName, DName, Descr, UFT8, DocID, UFD3, Uft4, UFM2, FS, FSC)
	select 
		PayDoxOP.dbo.PDX_SubstringReturn(UserFieldText5, CHARINDEX('<',UserFieldText5), charindex('>',UserFieldText5)) as Code, --Статья расходов
		isnull(
			case upper(Currency)
			when 'USD'
				then isnull(@USD,0)
			when 'EUR'
				then isnull(@EUR,0)
			when 'CAD'
				then isnull(@CAD,0) 
			else 1 --РУБ
		end * isnull(AmountDoc,0),0) * case I.Expens when 1 then -1 else 1 end as Amount,		--Сумма		
		DAY(UserFieldDate1),
		PartnerName, D.Name, Description, UserFieldText8, DocID, UserFieldDate3, UserFieldText4,
		UserFieldMoney2, S.FinStatus,S.Comment
	from PayDoxOP.dbo.Docs D
	inner join #items I on D.UserFieldText5 like '%<' + I.Code + '>%'
	left join PayDoxOP.dbo.PayStatusDetails S on S.DocIDInt = D.DocIDInt
	where ClassDoc = @ClassName
		and UPPER(ISNULL(IsActive,'')) = 'Y'	
		and (ISNULL(StatusDevelopment,'') ='4' or
			dbo.PDX_CompareReconcilationList(ListToReconcile, ListReconciled) = 1)
		and ISNULL(StatusCompletion,'') <>'0'
		and month(UserFieldDate1) = month(@Date)
		and year(UserFieldDate1) = year(@Date)
		and (UserFieldText2 = @CFO or @CFO = '')
		and (UserFieldText5 = @Article or @Article = '')
		and (D.UserFieldMoney2 = @UFM2 or @UFM2 = 2)
	
	select @Result = @@error if @Result <> 0 goto Err

--коды ИСР задействованные в отобранных карточках "приравниваем к цфо"
	insert into #rescfo
		(Code, UFT5, Lev, KeyField, flg, Code1)
	select Code, UFT4, 1,
		cast(case when Code like '%.%' then LEFT(Code, charindex('.',Code)-1) else Code end as int),
		1, Code
	from #cfo
	group by UFT4, Code
	select @Result = @@error if @Result <> 0 goto Err

	select @Cnt = len(cast(MAX(Id) as varchar(100))) from #rescfo
	select @Result = @@error if @Result <> 0 goto Err
	
	update #rescfo
	set Code = Code + '.' + isnull(replicate('0', @Cnt-len(cast(Id as varchar(100)))),'') + cast(Id as varchar(100)) 
	where flg = 1
	

	--изменяем Code заявок, чтобы из превратить в еще один уровень Статей
	select @Cnt = len(cast(MAX(KeyField) as varchar(100))) from #cfo
	select @Result = @@error if @Result <> 0 goto Err
	
	update C
		set Code = R.Code + '.' + isnull(replicate('0', @Cnt-len(cast(C.KeyField as varchar(100)))),'') + cast(C.KeyField as varchar(100))
	from #cfo C
	inner join #rescfo R on R.UFT5 = C.UFT4
		and C.Code = R.Code1
	select @Result = @@error if @Result <> 0 goto Err

	--а теперь добавдяем эти коды в таблицу со статьями
	insert into #rescfo
		(Code, UFT5, Lev, KeyField)
	select
		Code, 'Заявка на денежные средства №' + DocID + ' от ' + convert(varchar(100), UFD3, 104),
		1, cast(case when Code like '%.%' then LEFT(Code, charindex('.',Code)-1) else Code end as int)
	from #cfo
	select @Result = @@error if @Result <> 0 goto Err
	
	--далее следуем алгоритму обобщенной процедуры
	--разбиваем Стьи по уровням, чтоьы потом суммы считать
	select @Cnt = 1, @Lev = 1
	while @Cnt <> 0
	begin
		update R
			set Lev = Lev +
					case when exists (select 1 from #rescfo X where R.Code like X.Code + '.%' and X.Lev = @Lev)
						then 1
						else 0 end
		from #rescfo R
		where R.Lev = @Lev
		select @Cnt = @@ROWCOUNT, @Result = @@error if @Result <> 0 goto Err
		
		if @Cnt > 0 set @Lev = @Lev + 1
	end
	
	--**********************************
	insert into #cfo --это добавляем ИТОГО
		(Code, AmountDoc, DT)
	select '-', sum(isnull(C.AmountDoc,0)), C.DT
	from #cfo C
	group by C.DT
	select @Result = @@error if @Result <> 0 goto Err
	insert into #rescfo
		(Code, UFT5, Lev, KeyField)
	values ('-', 'ИТОГО', 0, 999999)
	select @Result = @@error if @Result <> 0 goto Err
--**********************************

	insert into #cfo --это "группирующие"(суммы) узлы
		(Code, AmountDoc, DT)
	select X.Code, sum(isnull(C.AmountDoc,0)), C.DT
	from #cfo C
	inner join #rescfo R on C.Code = R.Code
		and R.Lev > 1
	inner join #rescfo X on C.Code like X.Code + '.%' 
		and X.Lev < R.Lev
	group by X.Code, C.DT
	select @Result = @@error if @Result <> 0 goto Err
	
	--теперь готовимся дни месяца "переворачивать" из строк в столбцы
	--выяснем сколько у нас есть дней с суммами
	insert into @Digital (Dig)
	select distinct dt from #cfo
	select @Result = @@error if @Result <> 0 goto Err
	
	--а теперь в цикле собираем запрос, который все перевернет в столбцы
	select @SQLStr = 'R.Lev,R.KeyField, R.Code as dc, ' +
		'case when C.DocID is null then R.Code else '''' end as Code, R.flg, R.UFT5 as Name, '+
		'C.UFT8, C.PName, C.DName, C.Descr, C.UFM2, C.FS, C.FSC'
	select @Result = @@error if @Result <> 0 goto Err
	while exists (select 1 from @Digital)
	begin
		select top 1
			@Cnt = Dig
		from @Digital
		order by Dig
		select @Result = @@error if @Result <> 0 goto Err
		
		select @SQLStr = @SQLStr + ', sum(case C.DT when ' + CAST(@Cnt as varchar(10)) + ' then isnull(C.AmountDoc,0) else 0 end)' + @RTR2 + ' as [' + case when @Cnt < 10 then '0' else '' end  + CAST(@Cnt as varchar(10)) + '.' + @Month + ']'
		select @Result = @@error if @Result <> 0 goto Err
		
		delete from @Digital where Dig = @Cnt
		select @Result = @@error if @Result <> 0 goto Err
	end
	
	select @SQLStr = @SQLStr + ', sum(isnull(C.AmountDoc,0))' + @RTR2 + ' as [ИТОГО]'
	select @Result = @@error if @Result <> 0 goto Err

	select @SQLStr = 'select ' + @SQLStr + 
			' from #rescfo R ' +
			' left join #cfo C on C.Code = R.Code ' +
			' group by R.flg,R.Code, R.UFT5, R.KeyField, R.Lev, C.DocID, C.UFT8, C.PName, C.DName, C.Descr, C.UFM2, C.FS, C.FSC' +
			' order by 2,3'
	select @Result = @@error if @Result <> 0 goto Err
		
	exec (@SQLStr)
	select @Result = @@error if @Result <> 0 goto Err	

	drop table #cfo
	drop table #rescfo
	return @Result
Err:

	drop table #cfo
	drop table #rescfo
	return @Result






GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_PAYPLNn2_Find] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_REP_PAYPLNn2_Find] --ПОИСК плановых заявок по основным реквизитам (казначейство)
	@DID varchar(128),
	@UFD3f datetime,
	@UFD3t datetime,
	@UFD1f datetime,
	@UFD1t datetime,
	@UFT7 varchar(64),
	@Currency varchar(64),
	@UFT8 varchar(512),
	@UFT2 varchar(512),
	@PN varchar(512),
	@UFT4 varchar(512),
	@UFT5 varchar(512),
	@Name varchar(128),
	@DIDPar varchar(128),
	@DIDPrev varchar(128),
	@UFT6 varchar(512),
	@NCr varchar(96),
	@State int, --1 - все, кроме отмен, 2- на согл, 3 - треб утв, 4 утв, 5 - отмен
	@UFM2 tinyint = 2 , --2-все, 1-да, 0-нет
	@Access bit = 1
as
	declare @Result int
	set @Result = 0

	create table #REP2
	(
		DocID varchar(128),
		strID varchar(128), 
		UserFieldDate3 varchar(1024),
		UserFieldDate1 datetime,
		UserFieldText7 varchar(1024),
		Currency varchar(12),
		UserFieldText8 varchar(1024),
		NameAproval varchar(96),
		UserFieldText2 varchar(1024), 
		PartnerName varchar(256), 
		UserFieldText4 varchar(1024),
		UserFieldText5 varchar(1024),
		Name varchar(256), 
		AmountDoc money, 
		DocIDParent varchar(128), 
		DocIDPrevious varchar(128), 
		UserFieldText6 varchar(1024),
		Description varchar(1024),
		NameCreation varchar(96), 
		UserFieldText1 varchar(1024), 
		ListToReconcile varchar(1024), 
		Correspondent varchar(1024),
		ListToEdit varchar(1024), 
		Status varchar(256),
		UFM2 money,
		FS varchar(60),
		FSC varchar(4000))
	
	insert into #REP2
	exec PayDoxOP.[dbo].[PDX_REP_PAYPLNn_Find] --ПОИСК плановых заявок по основным реквизитам (казначейство)
		@DID = @DID,
		@UFD3f = @UFD3f,
		@UFD3t = @UFD3t,
		@UFD1f = @UFD1f,
		@UFD1t = @UFD1t,
		@UFT7 = @UFT7,
		@Currency = @Currency,
		@UFT8 = @UFT8,
		@UFT2 = @UFT2,
		@PN = @PN,
		@UFT4 = @UFT4,
		@UFT5 = @UFT5,
		@Name = @Name,
		@DIDPar = @DIDPar,
		@DIDPrev = @DIDPrev,
		@UFT6 = @UFT6,
		@NCr = @NCr,
		@State = @State, --1 - все, кроме отмен, 2- на согл, 3 - треб утв, 4 утв, 5 - отмен
		@UFM2 = @UFM2,
		@Access= @Access
 
		
	select 
		* from #REP2
	order by UserFieldDate3, strID
	select @Result = @@error if @Result <> 0 goto Err	
	
	drop table #REP2
	select @Result = @@error if @Result <> 0 goto Err	
	
	return @Result
Err:

	return @Result




GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_PAYPLNn2_Get] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_REP_PAYPLNn2_Get] --БАЗОВЫЙ ПЛАН ПЛАТЕЖЕЙ
	@CFO varchar(128),
	@Date datetime,
	@UFM2 tinyint = 2 , --2-все, 1-да, 0-нет
	@RTR bit = 0, --0-руб, 1-тыс руб
	@USD money,
	@EUR money,
	@CAD money
as
	declare @Result int, @RTR2 varchar(10)
	set @Result = 0

    create table #items (Code varchar(64), Name varchar(256), Expens tinyint, GrName varchar(256), InActive bit, SetID int, ParentID int)
	set @RTR2 = case @RTR when 0 then '' else '/1000' end
	
    create table #cfo (Code varchar(64), AmountDoc money, DT int)
    create table #cfo1 (Code varchar(64), AmountDoc money, DT int)
    
    create table #rescfo (
		KeyField int,  
		Code varchar(64),
		UFT5 varchar(512), 
		Lev int)
		
	declare @ClassName varchar(128),  @Cnt int, @Lev int,
			@SQLStr varchar(7000), @Month varchar(2)
	declare @Digital table (Dig int)
	
	select @ClassName = PayDoxOP.dbo.PDX_CLSGet('RIK_CategoryName_KAZ_PLNPAY'),
		@Month = case when MONTH(@Date) <10 then '0' else '' end + CAST(MONTH(@Date) as varchar(2)),
		@CFO = ltrim(rtrim(ISNULL(@CFO,'')))
	select @Result = @@error if @Result <> 0 goto Err
	
	If YEAR(@Date) <= 2015 
	begin
		insert into #items (Code, Name, Expens, GrName, InActive, SetID, ParentID)
		select Code, Name, Expens, GrName, InActive, SetID, ParentID
		from PayDoxOP.dbo.PDX_pay_Items		
	end	
	else
	begin
		insert into #items (Code, Name, Expens, GrName, InActive, SetID, ParentID)
		select Code, Name, Expens, GrName, InActive, SetID, ParentID
		from PayDoxOP.dbo.PDX_pay_Items2016		
	end
	
	insert into #rescfo
		(Code, UFT5, Lev, KeyField)
	select Code, Name, 1,
		cast(replace(case when Code like '%.%' then LEFT(Code, charindex('.',Code)-1) else Code end,'н','') as int)
	from #items
	select @Result = @@error if @Result <> 0 goto Err
	
	select @Cnt = 1, @Lev = 1
	while @Cnt <> 0
	begin
		update R
			set Lev = Lev +
					case when exists (select 1 from #rescfo X where R.Code like X.Code + '.%' and X.Lev = @Lev)
						then 1
						else 0 end
		from #rescfo R
		where R.Lev = @Lev
		select @Cnt = @@ROWCOUNT, @Result = @@error if @Result <> 0 goto Err
		
		if @Cnt > 0 set @Lev = @Lev + 1
	end
	
	insert into #cfo1
		(Code, AmountDoc, DT)
	select 
		PayDoxOP.dbo.PDX_SubstringReturn(D.UserFieldText5, CHARINDEX('<',D.UserFieldText5), charindex('>',D.UserFieldText5)) as Code, --Статья расходов
		sum(isnull(
			case upper(D.Currency)
			when 'USD'
				then isnull(@USD,0)
			when 'EUR'
				then isnull(@EUR,0)
			when 'CAD'
				then isnull(@CAD,0) 
			else 1 --РУБ
		end * isnull(D.AmountDoc,0),0)) * case I.Expens when 1 then -1 else 1 end as Amount,		--Сумма		
		DAY(D.UserFieldDate1)
	from PayDoxOP.dbo.Docs D
	inner join #items I on D.UserFieldText5 like '%<' + I.Code + '>%'
	where D.ClassDoc = @ClassName
		and UPPER(ISNULL(D.IsActive,'')) = 'Y'	
		and (ISNULL(D.StatusDevelopment,'') ='4' or
			dbo.PDX_CompareReconcilationList(D.ListToReconcile, D.ListReconciled) = 1)
		and ISNULL(D.StatusCompletion,'') <>'0'
		and month(D.UserFieldDate1) = month(@Date)
		and year(D.UserFieldDate1) = year(@Date)
		and (D.UserFieldText2 = @CFO or @CFO = '')
		and (D.UserFieldMoney2 = @UFM2 or @UFM2 = 2)
	group by D.UserFieldText5, DAY(D.UserFieldDate1),I.Expens
	select @Result = @@error if @Result <> 0 goto Err
	
	
	insert into #cfo
		(Code, AmountDoc, DT)
	select
		Code, SUM(AmountDoc), DT
	from #cfo1
	group by Code, DT
	select @Result = @@error if @Result <> 0 goto Err
	--**********************************
	insert into #cfo --это ИТОГО
		(Code, AmountDoc, DT)
	select '-', sum(isnull(C.AmountDoc,0)), C.DT
	from #cfo C
	group by C.DT
	select @Result = @@error if @Result <> 0 goto Err
	insert into #rescfo
		(Code, UFT5, Lev, KeyField)
	values ('-', 'ИТОГО', 0, 999999)
	select @Result = @@error if @Result <> 0 goto Err
--**********************************

	insert into #cfo --это группирующие узлы
		(Code, AmountDoc, DT)
	select X.Code, sum(isnull(C.AmountDoc,0)), C.DT
	from #cfo C
	inner join #rescfo R on C.Code = R.Code
		and R.Lev > 1
	inner join #rescfo X on C.Code like X.Code + '.%' 
		and X.Lev < R.Lev
	group by X.Code, C.DT
	select @Result = @@error if @Result <> 0 goto Err
		
	insert into @Digital (Dig)
	select distinct dt from #cfo
	select @Result = @@error if @Result <> 0 goto Err
	
	select @SQLStr = 'R.Lev,R.KeyField, R.Code, R.UFT5 as Name'
	select @Result = @@error if @Result <> 0 goto Err
	while exists (select 1 from @Digital)
	begin
		select top 1
			@Cnt = Dig
		from @Digital
		order by Dig
		select @Result = @@error if @Result <> 0 goto Err
		
		select @SQLStr = @SQLStr + ', sum(case C.DT when ' + CAST(@Cnt as varchar(10)) + ' then isnull(C.AmountDoc,0) else 0 end)' + @RTR2 + ' as [' + case when @Cnt < 10 then '0' else '' end  + CAST(@Cnt as varchar(10)) + '.' + @Month + ']'
		select @Result = @@error if @Result <> 0 goto Err
		
		delete from @Digital where Dig = @Cnt
		select @Result = @@error if @Result <> 0 goto Err
	end
	
	select @SQLStr = @SQLStr + ', sum(isnull(C.AmountDoc,0))' + @RTR2 + ' as [ИТОГО]'
	select @Result = @@error if @Result <> 0 goto Err
		
	select @SQLStr = 'select ' + @SQLStr + 
			' from #rescfo R ' +
			' left join #cfo C on C.Code = R.Code ' +
			' group by R.Code, R.UFT5, R.KeyField, R.Lev' +
			' order by 2,3'
	select @Result = @@error if @Result <> 0 goto Err
		
	exec (@SQLStr)
	select @Result = @@error if @Result <> 0 goto Err	

	drop table #cfo
	drop table #rescfo
	return @Result
Err:

	drop table #cfo
	drop table #rescfo
	return @Result




GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_PR_ProtocolFind] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_REP_PR_ProtocolFind]
	@DateA1 datetime,
	@DateA2 datetime,
	@ActDoc varchar(100),
	@UFT5 varchar(255),
	@UFD11 datetime,
	@UFD12 datetime,
	@UFT4 varchar(255),
	@Name varchar(255),
	@NameApproval varchar(255),
	@NameControl varchar(255),
	@ListToReconcile varchar(255),
	@DocID varchar(255),
	@Access bit = 1
as

--declare @Result int
--select @Result = 0

	select @ActDoc = ltrim(rtrim(@ActDoc)),
		@UFT5 = ltrim(rtrim(@UFT5)),
		@UFT4 = ltrim(rtrim(@UFT4)),
		@Name = ltrim(rtrim(@Name)),
		@NameApproval = ltrim(rtrim(@NameApproval)),
		@NameControl = ltrim(rtrim(@NameControl)),
		@ListToReconcile = ltrim(rtrim(@ListToReconcile)),
		@DocID = ltrim(rtrim(@DocID))

	select  case @Access when 1 then 'system_report' else DocID end as DocID,
		DocID as strID,
		DateActivation,
		ActDoc,
		UserFieldDate3,DateActivation,
		UserFieldText4,
		UserFieldText5,
		UserFieldDate1,
		Name,
		NameAproval,
		NameControl,
		ListToReconcile,
		ListReconciled,
		ListToView,
		Correspondent,
		ClassDoc,
		StatusDevelopment,
		Namecreation,
		dbo.REC_DocStatusRead(1,isActive, StatusCompletion, StatusDevelopment,
		ListToReconcile, ListReconciled, LocationPath) as StatusName
	from dbo.Docs whth (nolock)
	where ClassDoc like 'Протоколы / %'
	and upper(isnull(isActive,'')) = 'Y'--активен
	and isnull(StatusCompletion,'') <> '0'
	and isnull(StatusArchiv,'') <> '1'
	and (ActDoc like '%' + @ActDoc + '%' or @ActDoc = '')
	and (UserFieldText4 like '%' + @UFT4 + '%' or @UFT4 = '')
	and (UserFieldDate3 between convert(datetime,convert(varchar(10),@DateA1,121),121) and convert(datetime,convert(varchar(10),@DateA2,121),121))
	
	and (UserFieldText5 like '%' + @UFT5 + '%' or @UFT5 = '')
	and (UserFieldDate1 between convert(datetime,convert(varchar(10),@UFD11,121),121) and convert(datetime,convert(varchar(10),@UFD12,121),121))
	
	and (Name like '%' + @Name + '%' or Description like '%' + @Name + '%' or @Name = '')
	and (NameAproval like '%' + @NameApproval + '%' or @NameApproval = '')
	and (NameControl like '%' + @NameControl + '%' or @NameControl = '')
	and (ListToReconcile like '%' + @ListToReconcile + '%' or ListToView like '%' + @ListToReconcile + '%' or @ListToReconcile = '')
	and (DocID like '%' + @DocID + '%' or @DocID = '')
	order by ClassDoc,DocID
	--select @Result = @@error if @Result <> 0 goto Err

--	return @Result
--Err:
	
--	return @Result

GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_RD_MissedNumRD] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
create proc [dbo].[PDX_REP_RD_MissedNumRD]
	@ActDoc varchar(255),
	@Year int,
	@Type int --1 - Приказы, 2- распоряжения
as

--declare @Result int
--select @Result = 0
	declare @Tbl table
	(DocID varchar(255),
	Prefix varchar(255),
	Number varchar(255))

	declare @Prefix varchar(255), @maxN int, @iCount int
	declare @TblPref table (Prefix varchar(255), maxN int)
	declare @Res table (Prefix varchar(255), Ind int)
	declare @Res1 table (Prefix varchar(255), Ind int, DocID varchar(255), isOrig int default 1)
	declare @LET varchar(10)

	If @Year >= 2008 
	begin

		select @LET = case @Type when 1 then 'П' when 2 then 'Р' else '' end
		If @LET = '' 
		begin
			select 'ошибка. обратитесь к администратору СЭД' as Prefix, '' as Ind, 1 as isOrig
			goto OK
		end

		--получаем префикс РД для выбранного ВД
/*		select top 1 
			@Prefix = Field6
		from dbo.UserDirValues with (nolock) where UDKeyField = 48 
			and Field1 = case when @ActDoc like '%<>%' then ltrim(rtrim(replace(@ActDoc,'<>',''))) else dbo.PDX_SubstringReturn(@ActDoc, charindex('<',@ActDoc), charindex('>',@ActDoc)) end
*/
		
		if @ActDoc like '%<>%'
		begin			
			select 
			  @Prefix = Fld4
			from dbo.PDXBranchSettings
			where Fld1 = ltrim(rtrim(replace(@ActDoc,'<>','')))

		end
        else if exists (select 1 from dbo.PDXBranchSettings where Fld1 = dbo.PDX_SubstringReturn(@ActDoc,charindex('<',@ActDoc),charindex('>',@ActDoc)))
		begin
			select 
			  @Prefix = Fld4
			from dbo.PDXBranchSettings
			where Fld1 = dbo.PDX_SubstringReturn(@ActDoc,charindex('<',@ActDoc),charindex('>',@ActDoc))
		end
		else
		begin
			select 
			  @Prefix = Fld4
			from dbo.PDXBranchSettings
			where Fld1 = left(dbo.PDX_SubstringReturn(@ActDoc,charindex('<',@ActDoc),charindex('>',@ActDoc)),2)
		end

		--получаем список номеров
		insert into @Tbl 
			(DocID, Prefix)
		select
			DocID,
			isnull(rtrim(ltrim(@Prefix)),'')
		from dbo.Docs with (nolock)
		where ClassDoc like case @Type when 1 then 'Распорядительные док-ты / Приказы%' when 2 then 'Распорядительные док-ты / Распоряжения' else '' end
			and upper(isnull(isActive,'')) = 'Y'
			and isnull(StatusDevelopment,'') = '4'
			and LocationPath like '%+%'
			and year(DateActivation) = @Year
			and (ActDoc = @ActDoc)
			and isnull(StatusCompletion,'') <> '0'

		--выделяем индексы
		update @Tbl 
			set Number = replace(dbo.PDX_SubstringReturn(DocID+'-', charindex('-' + @LET,DocID+'-'), charindex('-',DocID+'-',charindex('-' + @LET,DocID+'-')+1)),@LET,'')

		--если где-то не удалось выделить счетчик, в результате должны показать ошибку
		insert into @Res1 (Prefix, DocID)
		select 'ошибка', DocID
		from @Tbl 
		where isnumeric(Number) <> 1

		--удаляем "ошибочные" записи
		delete from @Tbl 
		where isnumeric(Number) <> 1

--select * from @Tbl order by Prefix,cast(Number as int)
		insert into @TblPref (Prefix, maxN)
		select Prefix, max(cast(Number as int))
		from @Tbl group by Prefix
--select * from @TblPref
		--формируем полные списки индексов по префиксам
		while exists (select 1 from @TblPref)
		begin
			select top 1 
				@Prefix = Prefix,
				@maxN = maxN
			from @TblPref
				
			select @iCount = 1
			while @iCount <= @maxN
			begin
				insert into @Res (Prefix, Ind)
				values (@Prefix, @iCount)
				select @iCount = @iCount + 1
			end 
			delete from @TblPref where Prefix = @Prefix
		end
		
		--выводим пропущенные вообще
		insert into @Res1 (Prefix, Ind)
		select distinct R.Prefix, R.Ind
		from @Res R
		left join @Tbl T on T.Prefix = R.Prefix and R.Ind = cast(T.Number as int)
		where T.Number is null

		--есть доп. номера, но нет основных
		insert into @Res1 (Prefix, Ind, isOrig)
		select distinct R.Prefix, R.Ind, 0
		from @Res R 
		inner join @Tbl X on X.Prefix = R.Prefix and R.Ind = cast(X.Number as int)
		where not exists (select 1 from @Tbl T where T.Prefix = R.Prefix and R.Ind = cast(T.Number as int)
							and T.DocID = R.Prefix + '-' + right(cast(@Year as varchar(4)),2) + '-' + @LET +isnull(replicate('0',len(T.Number)-len(R.Ind)),'') + cast(R.Ind as varchar(10))   
				)
			

		select 
		Prefix, isnull(DocID,Ind) as Ind, isOrig
		from @Res1
		order by Prefix,DocID,cast(Ind as int)

	end
	else
	begin
		select 'данные не могут быть расчитаны (другой формат номера)' as Prefix, '' as Ind, 1 as isOrig
	end

OK:
	--select @Result = @@error if @Result <> 0 goto Err

--	return
--Err:
	
--	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_RD_RDFind] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
create proc [dbo].[PDX_REP_RD_RDFind]
	@DID varchar(128),
	@DateAF datetime,
	@DateAT datetime,
	@Name varchar(255),
	@IDInc varchar(255),
	@Appr varchar(255),
	@Aut varchar(255),
	@Dep varchar(255),
	@Resp varchar(255),
	@Rec varchar(255),
	@Contr varchar(255),
	@Access bit = 1
	
as

--declare @Result int
--select @Result = 0

	select  case @Access when 1 then 'system_report' else DocID end as DocID,
		DocID as strID,
		NameCreation,
		NameResponsible,
		NameControl,
		LocationPath,
		Name,
		StatusDevelopment,
		StatusCompletion,
 		ListToReconcile,
		Listreconciled,
		DateActivation,
		UserFieldDate1,
		DocIdIncoming,
		DocIdParent,
		Department,
		NameAproval,
		ClassDoc,
		dbo.REC_DocStatusRead(1,isActive, StatusCompletion, StatusDevelopment,
		ListToReconcile, ListReconciled, LocationPath) as StatusName
	from dbo.Docs
	where ClassDoc like 'Распорядительные док-ты / %'
		and upper(isnull(isActive,'')) = 'Y'
		and isnull(StatusDevelopment,'') <> '0'
		and isnull(StatusCompletion,'')<> '0'
		and isnull(DocID,'') like '%'+@DID+'%'
		and convert(datetime,convert(varchar(50),DateActivation,101),121) between @DateAF and @DateAT 
		and isnull(Name,'') like '%'+@Name+'%'
		and isnull(DocIdIncoming,'') like '%'+@IDInc+'%'
		and isnull(NameAproval,'') like '%'+@Appr+'%'
		and isnull(NameCreation,'') like '%'+@Aut+'%'
		and isnull(Department,'') like '%'+@Dep+'%'
		and isnull(NameResponsible,'') like '%'+@Resp+'%'
		and isnull(ListToReconcile,'') like '%'+@Rec+'%'
		and isnull(NameControl,'') like '%'+@Contr+'%'
	order by DateActivation, DocID
	--select @Result = @@error if @Result <> 0 goto Err

--	return @Result
--Err:
	
--	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_RD_Reestr] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
create proc [dbo].[PDX_REP_RD_Reestr]
	@ActDoc varchar(255),
	@DateF datetime,
	@DateT datetime,
	@Type int, --1- приказы, 2-распоряжения,
	@Access bit = 1
as

--declare @Result int
--select @Result = 0

	select  case @Access when 1 then 'system_report' else DocID end as DocID,
		DocID as strID, 
		DocIDAdd, 
		DateActivation, 
		ActDoc, 
		UserFieldText4, 
		substring(ClassDoc,charindex('/', ClassDoc)+1, len(ClassDoc)) as ClassDoc, 
		Name, 
		1 as SecurityLevel, 
		NameAproval,
		NameCreation
	from dbo.Docs
	where ActDoc like @ActDoc + '%' 
	and convert(datetime,convert(varchar(50),DateActivation,101),121)  between @DateF and @DateT
	and isnull(LocationPath,'') like '%+%'
	and isnull(StatusDevelopment,'') = '4' 
	and isnull(StatusCompletion,'') <> '0' 
	and upper(isnull(isActive,'')) = 'Y'
	and ClassDoc like case @Type when 1 then 'Распорядительные док-ты / Приказы%' when 2 then 'Распорядительные док-ты / Распоряжения' else '' end
	and StatusArchiv<>'1' and ExtInt=' ' 
	and Year(@DateF) >=2008
	order by DateActivation,DocID
	--select @Result = @@error if @Result <> 0 goto Err

--	return @Result
--Err:
	
--	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_RECCount] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

CREATE proc [dbo].[PDX_REP_RECCount]
	@Count int,
	@DateStart datetime,
	@DateEnd datetime
as

declare @Result int
select @Result = 0

	declare @Cls_vorbiden varchar(255)

	select @Cls_vorbiden = dbo.PDX_CLSGet('RIK_CategoryName_OTHERS_DOG')

	select 
		C.DocID as StrID, 
		C.UserName + '<' + C.UserID + '>' as UserName, 
		D.NameCreation, count(*) as Qnt, 
		D.ClassDoc
	from dbo.Comments C with (nolock)
	inner join dbo.Docs D on D.DocID = C.DocID
		and D.DocID <> @Cls_vorbiden
	where convert(datetime,convert(varchar(50),C.DateCreation,104),104) between @DateStart and @DateEnd 
		and C.CommentType = 'VISA' 
		and SpecialInfo = 'VISASUSPENDING'
	group by C.DocID, C.UserName + '<' + C.UserID + '>', D.NameCreation, D.ClassDoc
	having count(*) >= @Count
	order by 1,4
	select @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:
	
	return @Result

GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_ReconcileDocs] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

CREATE proc [dbo].[PDX_REP_ReconcileDocs]
	@NameCreation varchar(250) = null,
	@NameAproval varchar(250) = null,
	@NameReconcile varchar(250) = null,
	@ClassDoc varchar(250) = null
as

--declare @Result int
--select @Result = 0
select @NameCreation = ltrim(rtrim(isnull(@NameCreation,'')))
select @NameAproval = ltrim(rtrim(isnull(@NameAproval,'')))
select @NameReconcile = ltrim(rtrim(isnull(@NameReconcile,'')))
select @ClassDoc = ltrim(rtrim(isnull(@ClassDoc,'')))

if isnull(charindex('>',@NameCreation),0) > isnull(charindex('<',@NameCreation),0)
begin
	select @NameCreation = dbo.PDX_SubstringReturn(@NameCreation,charindex('<',@NameCreation),charindex('>',@NameCreation))/* + '>%'*/
end
if isnull(charindex('>',@NameAproval),0) > isnull(charindex('<',@NameAproval),0)
begin
	select @NameAproval = dbo.PDX_SubstringReturn(@NameAproval,charindex('<',@NameAproval),charindex('>',@NameAproval))/* + '>%'*/
end
if isnull(charindex('>',@NameReconcile),0) > isnull(charindex('<',@NameReconcile),0)
begin
	select @NameReconcile = dbo.PDX_SubstringReturn(@NameReconcile,charindex('<',@NameReconcile),charindex('>',@NameReconcile))/* + '>%'*/
end

if len(isnull(@NameCreation,'')) <> 0 
begin
	select @NameCreation = '<' + @NameCreation + '>'
end
if len(isnull(@NameAproval,'')) <> 0 
begin
	select @NameAproval = '<' + @NameAproval + '>'
end
if len(isnull(@NameReconcile,'')) <> 0 
begin
	select @NameReconcile = '<' + @NameReconcile + '>'
end

select 
	1 as 'Ind', 
	D.ClassDoc,
	C.UserName + '<' + C.UserID + '>' as UserRec,
	D.DocID as strID,
	D.Name,
	D.NameCreation, 
	D.StatusDevelopment,
	D.SecurityLevel,
	D.NameAproval
from dbo.Docs D 
	inner join Comments C on C.DocIDInt = D.DocIDInt
		and upper(C.CommentType) = 'VISA' and upper(C.SpecialInfo) = 'VISAWAITING'
where D.NameCreation like '%' + @NameCreation + '%'
	and D.NameAproval like '%' + @NameAproval + '%' 
	and D.ListToReconcile like '%' + @NameReconcile + '%' 
	and D.ClassDoc like '%' + @ClassDoc + '%' 
	and upper(D.isActive) = 'Y'
	and isnull(D.StatusDevelopment,'') <> '0'
	and isnull(D.StatusCompletion,'') <> '0'

union

select 
	2 as 'Ind',
	D1.ClassDoc, 
	'приостановлено ('  + 
		(select top 1 UserName + '<' + UserID + '>' from Comments C1 with (nolock) where C1.DocIDInt = D1.DocIDInt and C1.CommentType = 'VISA' and C1.Comment like 'Согласование приостановлено%' 
		and C1.DateCreation = (select max(DateCreation) from Comments C2 with (nolock) where C2.DocIDInt = C1.DocIDInt
		and C2.CommentType = 'VISA' and C2.Comment like 'Согласование приостановлено%' )) + ')' as UserRec,
	D1.DocID as strID,
	D1.Name,
	D1.NameCreation,
	D1.StatusDevelopment,
	D1.SecurityLevel,
	D1.NameAproval
from dbo.Docs D1
where D1.ListToReconcile like '%(#!)%' 
	and D1.NameCreation like '%' + @NameCreation + '%'
	and D1.NameAproval like '%' + @NameAproval + '%'
	and D1.ListToReconcile like '%' + @NameReconcile + '%' 
	and D1.ClassDoc like '%' + @ClassDoc + '%' 
	and upper(D1.isActive) = 'Y'
	and isnull(D1.StatusDevelopment,'') <> '0'
	and isnull(D1.StatusCompletion,'') <> '0'
order by 2 asc,1 desc, 3 asc

	--select @Result = @@error if @Result <> 0 goto Err

--	return @Result
--Err:
	
--	return @Result

GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_RequestInfo] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO


CREATE proc [dbo].[PDX_REP_RequestInfo]
	@NList varchar(255),
	@DateStart datetime,
	@DateEnd datetime
as

	declare @list table
		(Code varchar(255))

	--результирующя 
	declare @tmp table
		(LinkID varchar(128), OI int,
		DocID varchar(128), DateCreation datetime, DateApproved datetime, UserFieldText5 varchar(1024), 
			Name varchar(255), Descr varchar(1024), StatusDevelopment int, ST varchar(255), isActive varchar(1), isSuspend bit,
		C_DocID varchar(128), C_DateActivation datetime, C_UserFieldText1 varchar(1024), C_Name varchar(255),
		D_DocID varchar(128), D_DateCreation datetime, D_PartnerName varchar(255), D_Name varchar(255),
			D_Descr varchar(1024), D_StatusDevelopment int, D_St varchar(255), D_isActive varchar(1), D_isSuspend bit,

		isOK bit default 0)

	--корреспонденция
	declare @tmp1 table
		(LinkID varchar(128), OI int identity, MN int,
		C_DocID varchar(128), C_DateActivation datetime, C_UserFieldText1 varchar(1024), C_Name varchar(255))

	-- договора
	declare @tmp2 table
		(LinkID varchar(128), OI int identity, MN int,
		D_DocID varchar(128), D_DateCreation datetime, D_PartnerName varchar(255), D_Name varchar(255),
			D_Descr varchar(1024), D_StatusDevelopment int, D_St varchar(255), D_isActive varchar(1), D_isSuspend bit,
	isOK bit default 0)

	--текущий согл
	declare @com table (DocID varchar(255), UserName varchar(255))

--	declare @link table (DocID varchar(128))
	declare @DocID varchar(128),
			@Users varchar(1024),
			@pos int,
			@OneValue varchar(255),
			@Result int

	select @Result = 0

	select @NList = ltrim(rtrim(isnull(@NList,'')))

	--разбор направлений
	if @NList = ''
	begin
		insert into @list (Code) values ('')
		select @Result = @@error if @Result <> 0 goto Err
	end
	else
	begin
		select @NList = @NList + ';'
		while @NList like '%;%'
		begin
			select @pos = charindex(';', @NList)
			select @Result = @@error if @Result <> 0 goto Err
			select @OneValue = left(@NList,@pos)
			select @Result = @@error if @Result <> 0 goto Err
			select @NList = substring(@NList,@pos+1,len(@NList))
			select @Result = @@error if @Result <> 0 goto Err

			if ltrim(rtrim(replace(@OneValue,';',''))) <> '' 
			begin 
				insert into @list (Code) values (ltrim(rtrim(replace(@OneValue,';',''))))
				select @Result = @@error if @Result <> 0 goto Err
			end
		end
	end

	--ЗИПы
	insert into @tmp
		(LinkID, OI, DocID, DateCreation, DateApproved, UserFieldText5, Name, Descr, StatusDevelopment, isActive, isSuspend)
	select 
		D.DocID, -1, D.DocID, D.DateCreation, D.DateApproved, D.UserFieldText5, D.Name, D.Description, D.StatusDevelopment,
		(isnull(D.isActive,'N')), case when isnull(D.ListToReconcile,'') like '%(#!)%' then 1 else 0 end
	from dbo.Docs D with (nolock)
	inner join @list l on ltrim(rtrim(isnull(D.UserFieldText5,''))) like '%' + l.code + '%'
	where D.ClassDoc = 'Проект / Запрос на изменение'
		and D.DateCreation between @DateStart and @DateEnd
		and isnull(D.StatusCompletion,'') <> '0' 
	select @Result = @@error if @Result <> 0 goto Err
	
	--корреспонденция
	insert into @tmp1
		(LinkID, C_DocID, C_DateActivation, C_UserFieldText1, C_Name)
	select
		T.DocID, D.DocID, D.DateActivation, case
												when ClassDoc like '%входящая%'
													then D.PartnerName
												else D.UserFieldText1
											end, D.Name
	from dbo.Comments C
	inner join @tmp T on T.DocID = isnull(C.Subject,'') 
	inner join dbo.Docs D on D.DocIDInt = C.DocIDInt
		and D.ClassDoc like 'Корреспонденция%'
		and upper(isnull(D.isActive,'')) = 'Y'
		and isnull(D.StatusCompletion,'') <> '0' 
	where C.CommentType = 'LINK'
		and C.Comment like ltrim(rtrim(upper('запрос на изменение'))) + '%'
	order by D.DocID
	select @Result = @@error if @Result <> 0 goto Err

	--договора
	insert into @tmp2
		(LinkID, D_DocID, D_DateCreation, D_PartnerName, D_Name, D_Descr, D_StatusDevelopment, 
		/*D_St,*/ D_isActive, D_isSuspend)
	select 
		T.DocID, D.DocID, D.DateCreation, D.PartnerName, D.Name, D.Description, D.StatusDevelopment, 
		/*D_St,*/ D.isActive,case when isnull(D.ListToReconcile,'') like '%(#!)%' then 1 else 0 end
	from dbo.Comments C
	inner join @tmp T on T.DocID = isnull(C.Subject,'') 
	inner join dbo.Docs D on D.DocIDInt = C.DocIDInt
		and D.ClassDoc like 'Договоры / %'
		and upper(isnull(D.isActive,'')) = 'Y'
		and isnull(D.StatusCompletion,'') <> '0' 
	where C.CommentType = 'LINK'
		and C.Comment like ltrim(rtrim(upper('запрос на изменение'))) + '%'
	order by D.DocID
	select @Result = @@error if @Result <> 0 goto Err

	update T
		set MN = T.OI - G.OI 
	from @tmp1 T
	inner join (select LinkID, min(OI)-1 as OI from @tmp1 group by LinkID) as G on G.LinkID = T.LinkID
	select @Result = @@error if @Result <> 0 goto Err

	update T
		set MN = T.OI - G.OI 
	from @tmp2 T
	inner join (select LinkID, min(OI)-1 as OI from @tmp2 group by LinkID) as G on G.LinkID = T.LinkID
	select @Result = @@error if @Result <> 0 goto Err

	--по согласованию ЗИП
	insert into @com (DocID, UserName)
	select distinct
		C.DocID, C.UserName
	from @tmp D 
	inner join dbo.Comments C with (nolock) on C.DocID = D.DocID and C.CommentType = 'VISA'
		and C.SpecialInfo = 'VISAWAITING'
	where D.isActive = 'Y' and StatusDevelopment <> 4
	select @Result = @@error if @Result <> 0 goto Err
	
	while exists (select 1 from @tmp where isOK = 0)
	begin 
		select top 1 
			@DocID = DocID
		from @tmp
		where isOK = 0
		select @Result = @@error if @Result <> 0 goto Err

		select @Users = ''
		select @Users = @Users + case len(@Users) when 0 then '' else '; ' end  + UserName
		from @com 
		where DocID = @DocID 
		order by UserName 
		select @Result = @@error if @Result <> 0 goto Err			

		update @tmp
		set isOK = 1,
			ST = @Users
		where DocID = @DocID
		select @Result = @@error if @Result <> 0 goto Err
	end
	select @Result = @@error if @Result <> 0 goto Err
	
	--по согласованию договора
	delete from @com
	insert into @com (DocID, UserName)
	select distinct
		C.DocID, C.UserName
	from @tmp2 D 
	inner join dbo.Comments C with (nolock) on C.DocID = D.D_DocID and C.CommentType = 'VISA'
		and C.SpecialInfo = 'VISAWAITING'
	where D.D_isActive = 'Y' and D.D_StatusDevelopment <> 4
	select @Result = @@error if @Result <> 0 goto Err
	
	while exists (select 1 from @tmp2 where isOK = 0)
	begin 
		select top 1 
			@DocID = D_DocID
		from @tmp2
		where isOK = 0
		select @Result = @@error if @Result <> 0 goto Err

		select @Users = ''
		select @Users = @Users + case len(@Users) when 0 then '' else '; ' end  + UserName
		from @com 
		where DocID = @DocID 
		order by UserName 
		select @Result = @@error if @Result <> 0 goto Err			

		update @tmp2
		set isOK = 1,
			D_ST = @Users
		where D_DocID = @DocID
		select @Result = @@error if @Result <> 0 goto Err
	end
	select @Result = @@error if @Result <> 0 goto Err

	insert into @tmp
		(LinkID , OI,
		C_DocID, C_DateActivation, C_UserFieldText1, C_Name, D_DocID, D_DateCreation, D_PartnerName, 
		D_Name,	D_Descr, D_StatusDevelopment, D_St, D_isActive, D_isSuspend)
	select
		t1.LinkID, isnull(t1.mn, t2.mn),
		C_DocID, C_DateActivation, C_UserFieldText1, C_Name, D_DocID, D_DateCreation, D_PartnerName, 
		D_Name,	D_Descr, D_StatusDevelopment, D_St, D_isActive, D_isSuspend
	from @tmp1 t1
	full join @tmp2 t2 on t2.mn = t1.mn and t2.LinkID = t1.LinkID

	
	update @tmp
		set ST = case when /*isnull(ST,'') = '' and*/ upper(isActive) = 'N'
							then 'неактивен'
						when /*upper(isActive) = 'Y' and*/ StatusDevelopment = 4
							then 'утвержден'
						when /*isnull(ST,'') = '' and*/ upper(isActive) = 'Y' and isSuspend = 1 and StatusDevelopment = 2
							then 'приостановлен'
						when /*isnull(ST,'') = '' and*/ upper(isActive) = 'Y' and isSuspend = 0 and StatusDevelopment = 3
							then 'на утверждении'
						when /*isnull(ST,'') <> '' and*/ upper(isActive) = 'Y'
							then 'на согласовании: ' + isnull(ST,'')
						else ''
				end,
			D_ST = case when /*isnull(D_ST,'') = '' and*/ upper(D_isActive) = 'N'
							then 'неактивен'
						when upper(D_isActive) = 'Y' and D_StatusDevelopment = 4
							then 'утвержден'
						when /*isnull(D_ST,'') = '' and*/ upper(D_isActive) = 'Y' and D_isSuspend = 1 and D_StatusDevelopment = 2
							then 'приостановлен'
						when /*isnull(D_ST,'') = '' and*/ upper(D_isActive) = 'Y' and D_isSuspend = 0 and D_StatusDevelopment = 3
							then 'на утверждении'
						when /*isnull(D_ST,'') <> '' and*/ upper(D_isActive) = 'Y' --and D_StatusDevelopment = 2
							then 'на согласовании: ' + isnull(D_ST,'')
						else ''
				end
	select @Result = @@error if @Result <> 0 goto Err

	select
		C_DocID, convert(varchar(100),C_DateActivation,104) as C_DateActivation, C_UserFieldText1, C_Name,

		DocID as Z_DocID, convert(varchar(100),DateCreation,104) as DateCreation,convert(varchar(100),DateApproved,104) as DateApproved, UserFieldText5, Name, Descr, ST, 
		D_DocID , convert(varchar(100),D_DateCreation,104) as D_DateCreation, D_PartnerName, D_Name, D_Descr, D_St
	from @tmp 
	order by LinkID, OI
	select @Result = @@error if @Result <> 0 goto Err


	return @Result
Err:
	
	return @Result

GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_ResolutionsFind] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO


CREATE proc [dbo].[PDX_REP_ResolutionsFind]
	@pUserID varchar(128),
	@pDateF datetime,
	@pDateT datetime,
	@pClassDoc varchar(255)

as

	
	select 
		C.DocID, 
		C.DateCreation, 
		C.UserID, 
		C.ContactUserID, 
		C.UserName, 
		C.ContactUserName,
		C.Comment,
		D.ClassDoc,
		D.Name 
	from dbo.Comments C 
		inner join dbo.Docs D on D.DocIDInt = C.DocIDInt
			and D.ClassDoc like @pClassDoc+'%'
	where dbo.PDX_SubstringReturn(@pUserID,charindex('<',@pUserID),charindex('>',@pUserID)) in (C.UserID, C.ContactUserID)
		and C.DateCreation between @pDateF and @pDateT
		and upper(C.CommentType) = 'RESOLUTION'
	order by C.DateCreation desc, C.DocID


GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_RS_RSFind] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[PDX_REP_RS_RSFind]
	@Str varchar(255),
	@CrName varchar(255),
	@DocID varchar(128),
	@Reconcil varchar(255),
	@ActDoc varchar(128),
	@UFT1 varchar(255),
	@UFT4 varchar(255),
	@Access bit = 1
as

--declare @Result int
--select @Result = 0

	select case @Access when 1 then 'system_report' else DocID end as DocID,
		DocID as strID, 
		Name, 
		Description, 
		NameCreation, 
		DateActive ,
		ActDoc,
		UserFieldText1,
		UserFieldText4
	from dbo.Docs with (nolock)
	where (Name like '%'+@Str+'%' or Description like '%'+@Str+'%')
		and NameCreation like '%'+@CrName+'%'
		and DocID like '%'+@DocID+'%'
		and ActDoc like '%'+@ActDoc+'%'
		and UserFieldText1 like '%'+@UFT1+'%'
		and UserFieldText4 like '%'+@UFT4+'%'
		and ListToReconcile like '%'+@Reconcil+'%'
		and ClassDoc = 'Рабочее согласование'
		and upper(isnull(isActive,'')) = 'Y'
		and StatusDevelopment <> '0' 
		and isnull(StatusCompletion,'') <> '0'
	order by dateCreation, DocID
	--select @Result = @@error if @Result <> 0 goto Err

--	return @Result
--Err:
	
--	return @Result

GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_SMKForm] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
create proc [dbo].[PDX_REP_SMKForm]
	@ActDoc varchar(255),
	@UFT3 varchar(255),
	@UFT4 varchar(255),
	@UFT5 varchar(255),
	@UFD1 datetime,
	@Name varchar(255),
	@DocIDParent varchar(255),
	@DocIDPrevious varchar(255),
	@NameCreation varchar(255),
	@DocID varchar(255)
as

--declare @Result int
--select @Result = 0

	select *
	from dbo.Docs whth (nolock)
	where ClassDoc = 'Документы СМК / Формы'
	and upper(isnull(isActive,'')) = 'Y'--активен
	and isnull(StatusCompletion,'') <> '0'

	and (ActDoc like '%' + @ActDoc + '%' or @ActDoc = '')
	and (UserFieldText3 like '%' + @UFT3 + '%' or @UFT3 = '')
	and (UserFieldText4 like '%' + @UFT4 + '%' or @UFT4 = '')
	and (UserFieldText5 like '%' + @UFT5 + '%' or @UFT5 = '')
	and (UserFieldDate1 >= convert(datetime,convert(varchar(10),@UFD1,121),121) )
	and (DocIDParent like '%' + @DocIDParent + '%' or @DocIDParent = '')
	and (DocIDPrevious like '%' + @DocIDPrevious + '%' or @DocIDPrevious = '')
	and (NameCreation like '%' + @NameCreation + '%' or @NameCreation = '')
	and (DocID like '%' + @DocID + '%' or @DocID = '')
	order by UserFieldText4, UserFieldDate1
	--select @Result = @@error if @Result <> 0 goto Err

--	return @Result
--Err:
	
--	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_SMKReglament] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
create proc [dbo].[PDX_REP_SMKReglament]
	@UFT2 varchar(255),
	@UFT3 varchar(255),
	@UFT4 varchar(255),
	@UFT5 varchar(255),
	@UFD1 datetime,
	@Name varchar(255),
	@DocIDParent varchar(255),
	@DocIDPrevious varchar(255),
	@NameCreation varchar(255),
	@DocID varchar(255)
as

--declare @Result int
--select @Result = 0

	select *
	from dbo.Docs whth (nolock)
	where ClassDoc = 'Документы СМК / Регламенты'
	and upper(isnull(isActive,'')) = 'Y'--активен
	and isnull(StatusCompletion,'') <> '0'

	and (UserFieldText2 like '%' + @UFT2 + '%' or @UFT2 = '')
	and (UserFieldText3 like '%' + @UFT3 + '%' or @UFT3 = '')
	and (UserFieldText4 like '%' + @UFT4 + '%' or @UFT4 = '')
	and (UserFieldText5 like '%' + @UFT5 + '%' or @UFT5 = '')
	and (UserFieldDate1 >= convert(datetime,convert(varchar(10),@UFD1,121),121) )
	and (DocIDParent like '%' + @DocIDParent + '%' or @DocIDParent = '')
	and (DocIDPrevious like '%' + @DocIDPrevious + '%' or @DocIDPrevious = '')
	and (NameCreation like '%' + @NameCreation + '%' or @NameCreation = '')
	and (DocID like '%' + @DocID + '%' or @DocID = '')
	order by UserFieldText4, UserFieldDate1
	--select @Result = @@error if @Result <> 0 goto Err

--	return @Result
--Err:
	
--	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_UserActivityMonitor] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[PDX_REP_UserActivityMonitor]
	@UserName varchar(255),
	@DateStart datetime,
	@DateEnd datetime,
	@Dept varchar(1024) = null,
	@Position varchar(256) = null
as

declare @Result int
select @Result = 0
	Create table #ResTable
		(UserID varchar(128), -- логин юзера
		UserName varchar(255),	-- фио юзера
		UserDateCreation datetime, -- дата создания юзера
		UserEntryCount int,--кол-во входов пользователя
		UserLogCount int,--кол-во любых записей в логе.
		DocCreateCount int,--кол-во созданных карточек
		OutMailCount int,--кол-во уведомления от него
		ReconCount int,--кол-во отметок СОГЛАСЕН/НЕ СОГЛАСЕН
		ApprovCount int,--кол-во отметок ПОДПИСАНО/ОТКАЗАНО
		Department varchar(512),
		Position varchar(128))

	Create table #ResTableTemp
		(UserID varchar(128), -- логин юзера
		OutMailCount int,--кол-во уведомления от него
		ReconCount int,--кол-во отметок СОГЛАСЕН/НЕ СОГЛАСЕН
		ApprovCount int)--кол-во отметок ПОДПИСАНО/ОТКАЗАНО

    select @UserName = ltrim(rtrim(ISNULL(@UserName,'')))
    select @UserName = case dbo.PDX_SubstringReturn(@UserName,charindex('<',@UserName),charindex('>',@UserName)) 
						when ''
							then @UserName
						else dbo.PDX_SubstringReturn(@UserName,charindex('<',@UserName),charindex('>',@UserName)) 
					end ,
			@Dept = ltrim(rtrim(iSNULL(@Dept,''))),
			@Position = ltrim(rtrim(iSNULL(@Position,'')))
			
If @UserName = ''
begin
	--собираем всех пользователей имеющих доступ.
	Insert into #ResTable
			(UserID,UserName,UserDateCreation,UserEntryCount,UserLogCount,
			DocCreateCount,OutMailCount,ReconCount,ApprovCount, Department, Position)
	Select UserID,[Name],DateCreation,0,0,0,0,0,0, Department, Position

	from dbo.Users
	where StatusActive='1'
	and  Not Permitions like '%*%'
	and Department like '%' + @Dept + '%'
	and Position like '%' + @Position + '%'
	and DateExpirationSecurity>=convert(datetime,convert(varchar(100),getdate(),104),104)
end 
else
begin
Insert into #ResTable
			(UserID,UserName,UserDateCreation,UserEntryCount,UserLogCount,
			DocCreateCount,OutMailCount,ReconCount,ApprovCount)
	Select UserID,[Name],DateCreation,0,0,0,0,0,0

	from dbo.Users
	where UserID =  @UserName --внезависимоти от его прав в СЭД
end

print 'собрали всех пользователей имеющих доступ.'

--Считаем по каждому пользователю данные из лога: 
--Сколько раз упоминается в логе и сколько карточек создал
   
Update R 
Set 
	UserEntryCount=K.C_In,
	UserLogCount=K.C_All
from #ResTable as R
inner join 
(Select 
	L.UserID as U,
	Count(*) as C_All,
	sum(Case when L.[Action]='Вход в систему' Then 1 Else 0 end) as C_In
  from dbo.Log as L 
  inner join #ResTable as RS on RS.UserID=L.userID
	where L.[datetime] between @DateStart and @DateEnd
   group by L.UserID) as K on R.UserID=K.U
print 'собрали по каждому пользователю данные из лога.'


Insert into #ResTableTemp
		(UserID,OutMailCount,ReconCount,ApprovCount)
Select 
	C.UserID as U,
	sum(Case when C.CommentType='NOTIFICATION' Then 1 Else 0 end) as C_OutMailCount,
	sum(Case when C.CommentType='VISA' and C.specialinfo in ('VISAOK','VISAOKREFUSE') Then 1 Else 0 end) as C_ReconCount,
	sum(Case when C.CommentType='APROVAL' Then 1 Else 0 end) as C_ApprovCount
  from dbo.Comments as C 
  inner join #ResTable as RS on RS.UserID=C.userID
	where C.[DateCreation] between @DateStart and @DateEnd
	and C.CommentType in ('NOTIFICATION','VISA','APROVAL')  
group by C.UserID

--Считаем по каждому пользователю комментарии
Update R 
Set 
	OutMailCount=K.OutMailCount, --сколько пользователь отправил уведомлений
	ReconCount=K.ReconCount, --сколько виз СОГЛ/НЕСОГЛ поставил пользователь
	ApprovCount=K.ApprovCount--
from #ResTable as R
inner join #ResTableTemp as K on R.UserID=K.UserID
print 'собрали по каждому пользователю комментарии.'

--Считает по каждому пользователю кол-во созданных документов
Update R 
Set 
	DocCreateCount=K.C_DocCreate
from #ResTable as R
inner join 
(Select 
	RS.UserID as U,
	Count(*) as C_DocCreate
  from dbo.Docs as D
  inner join #ResTable as RS on D.NameCreation like '%<'+RS.UserID+'>%'
	where D.[dateCreation] between @DateStart and @DateEnd
   group by RS.USerID) as K on R.UserID=K.U


--Выводим результат
Select * from #ResTable
Order by UserName--DocCreateCount asc



GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_UserInfo] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE proc [dbo].[PDX_REP_UserInfo] --ВЫГРУЗКА  ЗАЯВОК на начисление
	@UserID varchar(96) 
as

declare @tbl table (UserID varchar(20), ArcDate datetime, StatusActive char(1), Visible bit, DExS datetime,OI int)
declare @tmp table (I1 int, I2 int)
declare @m int

set @UserID = dbo.PDX_SubstringReturn(@UserID,CHARINDEX('<',@UserID),charindex('>',@UserID))
if @UserID <> ''
begin
	insert into @tbl (UserID,ArcDate,StatusActive,Visible,DExS,OI)
	select 
	UserID, MIN(ArcDate) as ArcDate, StatusActive, case when Permitions like '%*%' then 0 else 1 end, DateExpirationSecurity, ROW_NUMBER() over (order by MIN(ArcDate)) as OI
	from Users_log
	where UserID = @UserID
	group by UserID, StatusActive, case when Permitions like '%*%' then 0 else 1 end, DateExpirationSecurity


	select @m = MAX(OI) from @tbl
	while @m > 0 
	begin
		insert into @tmp (I1, I2) values (@m, @m+1)
		set @m = @m - 1
	end
end

select T1.ArcDate DF, T2.ArcDate DT, 
case T1.StatusActive
	when '1' then 'доступ разрешен'
	when '' then 'доступ запрещен'
	when '-' then 'только как роль'
	else '???'
end + CHAR(13) + CHAR(10) +
case when T1.StatusActive IN ('-','1') then 'дата окончания срока действия ' + CONVERT(varchar(100),T1.DExS,104) else '' end + CHAR(13) + CHAR(10) +
case T1.Visible
	when 1 then ''
	else 'скрыт'
end  as St
from @tmp T
inner join @tbl T1 on T1.OI = T.I1
left join @tbl T2 on T2.OI = T.I2
order by 1,2







GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_UserRightsView] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[PDX_REP_UserRightsView]
	@Dept varchar(255),
	@ActDoc varchar(128),
	@ClassDoc varchar(255),
	@StatusActive varchar(5),
	@WSLevel int = -1,
	@RSLevel int = -1

as

declare @Result int
select @Result = 0

	select 
	* from Users 
	where Department like isnull(@Dept,'') + '%'
		and (Actdoc like '%' + isnull(@ActDoc,'') + '%' or ActDoc like '%ALL%')
		and (ClassDoc like '%' + isnull(@ClassDoc,'') + '%' or ClassDoc like '%ClassDoc%')
		and WriteSecurityLevel = case @WSLevel when -1 then WriteSecurityLevel else @WSLevel end
		and ReadSecurityLevel = case @RSLevel when -1 then ReadSecurityLevel else @RSLevel end

		and (
				(
				StatusActive = case @StatusActive 
								when '-1' 
									then StatusActive 
								else @StatusActive end
	
				--учитывая дату истечения доступа, кроме как для варианта НЕТ и все
				and convert(datetime,convert(varchar(100),DateExpirationSecurity,104),104)>= 
					convert(datetime,convert(varchar(100),case when @StatusActive in ('-1','') then DateExpirationSecurity 
															else getdate() end,104),104)
				)
			or 	--чтобы все с истекшим сроком попадало в доступ НЕТ
				(
				@StatusActive = ''
				and convert(datetime,convert(varchar(100),DateExpirationSecurity,104),104)<= 
				convert(datetime,convert(varchar(100),case @StatusActive when '' then getdate() 
														else DateExpirationSecurity end,104),104)			
				)
			)
	order by Name, UserID
	select @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:
	
	return @Result

GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_Z_TaskSummaryReport] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[PDX_REP_Z_TaskSummaryReport]
	@User varchar(128),
	@Department varchar(512),
	@OrderType int, --0 - подр/польз/срок, 1- польз/срок
	@ReportInf bit, --0-short, 1- fullt,
	@ActDoc varchar(64) = null,
	@UFT4 varchar(1024) = null,
	@NameContr varchar(96) = null
as

declare @Result int
select @Result = 0

declare @cls varchar(256)
select @cls = dbo.PDX_CLSGet('RIK_CategoryName_SYSZADACHI'),
	@ActDoc = ltrim(ISNULL(@ActDoc,'')),
	@UFT4 = ltrim(ISNULL(@UFT4,'')),
	@NameContr = ltrim(ISNULL(@NameContr,''))
	

	create table #task
		(strID varchar(128),
		UserID varchar(64),
		UserName varchar(96),
		Dept varchar(512),
		Position varchar(128),
		NameResp varchar(255),
		NameControl varchar(255),
		Descr varchar(1024),
		History varchar(1024),
		DateStart varchar(100),
		DateEnd varchar(100),
		Status int,
		StatusN varchar(128),
		OI_1 int default 0)
	create table #OI_user
		(UserID varchar(64), Cnt int,  KeyF int identity, 
		UserName varchar(96),
		Dept varchar(512),
		Position varchar(128),
		Diff int)

	select @User = case dbo.PDX_SubstringReturn(@User,charindex('<',@User),charindex('>',@User)) 
						when ''
							then ltrim(rtrim(isnull(@User,'')))
						else '<' + dbo.PDX_SubstringReturn(@User,charindex('<',@User),charindex('>',@User)) + '>'
					end,
			@NameContr = case dbo.PDX_SubstringReturn(@NameContr,charindex('<',@NameContr),charindex('>',@NameContr)) 
						when ''
							then ltrim(rtrim(isnull(@NameContr,'')))
						else  '<' + dbo.PDX_SubstringReturn(@NameContr,charindex('<',@NameContr),charindex('>',@NameContr)) + '>'
					end,
			@Department = ltrim(rtrim(isnull(@Department,'')))
	select @Result = @@error if @Result <> 0 goto Err

	insert into #task
		(strID,UserID,UserName,Dept,Position,NameResp,NameControl,Descr,History,DateStart,DateEnd,Status, StatusN)
	select 
		D.DocID,
		--dbo.PDX_SubstringReturn(D.NameResponsible,charindex('<',D.NameResponsible),charindex('>',D.NameResponsible)),
		U.UserID,
		U.Name,
		case when right(ltrim(rtrim(U.Department)),1) = '/' 
			then left(ltrim(rtrim(U.Department)), len(ltrim(rtrim(U.Department)))-1)
		else ltrim(rtrim(U.Department))
		end,
		U.Position,
		D.NameResponsible,
		case when not ltrim(rtrim(ISNULL(D.NameControl,''))) like '%<%>%'
		   then '' 
		   else rtrim(replace(left(D.NameControl, charindex('<',D.NameControl) - 1),'"',''))
		end,
		D.Description,
		ltrim(rtrim(isnull(D.History,''))),
		convert(varchar(100), D.UserFieldDate3),
		convert(varchar(100), D.DateCompletion, 104),
		dbo.REC_TaskStatusRead(2,D.isActive,D.StatusCompletion,D.UserFieldDate3,D.DateCompletion) as Status,
		dbo.REC_TaskStatusRead(1,D.isActive,D.StatusCompletion,D.UserFieldDate3,D.DateCompletion) as StatusN
	from dbo.Docs D
	inner join dbo.Users U on U.UserID = dbo.PDX_SubstringReturn(D.NameResponsible,charindex('<',D.NameResponsible),charindex('>',D.NameResponsible))
		and U.Department like @Department + '%'
	where D.StatusArchiv<>'1' 
		and D.ExtInt=' ' 
		and not isnull(D.StatusCompletion,'') in ('0','1')
		and D.ClassDoc = @cls
		/*and dbo.PDX_SubstringReturn(D.NameResponsible,charindex('<',D.NameResponsible),charindex('>',D.NameResponsible)) = 
					case @User 
						when '' then dbo.PDX_SubstringReturn(D.NameResponsible,charindex('<',D.NameResponsible),charindex('>',D.NameResponsible))
						else @User
					end*/
		and D.NameResponsible like '%' + @User + '%'
		and D.NameControl like '%' + @NameContr + '%'
		and Upper(D.isActive) = 'Y' 
		and (D.ActDoc = @ActDoc or @ActDoc = '')
		and (D.UserFieldText4 = @UFT4 or @UFT4 = '')
	select @Result = @@error if @Result <> 0 goto Err

	If @OrderType = 0
	begin
		insert into #OI_user
			(UserID, Cnt, UserName, Dept, Position)
		select 
			UserID, count(*), UserName, Dept, Position
		from #task
		group by UserID, Dept, UserName, Position
		order by Dept, UserName
		/*select
			T.UserID, count(*), U.Name, U.Department, U.Position
		from #task T
		inner join dbo.Users U on U.UserID = T.userID
		group by T.UserID, U.Department, U.Name, U.Position
		order by U.Department, U.Name*/
		select @Result = @@error if @Result <> 0 goto Err
	end
	else
	begin
		insert into #OI_user
			(UserID, Cnt, UserName, Dept, Position)
		select 
			UserID, count(*), UserName, Dept, Position
		from #task
		group by UserID, Dept, UserName, Position
		order by UserName
		/*select
			T.UserID, count(*), U.Name, U.Department, U.Position
		from #task T
		inner join dbo.Users U on U.UserID = T.userID
		group by T.UserID, U.Department, U.Name, U.Position
		order by U.Name*/
		select @Result = @@error if @Result <> 0 goto Err
	end

	update OI
		set Diff = isnull((select sum(Cnt) from #OI_user U where U.KeyF < OI.KeyF),0) + KeyF
	from #OI_user OI
	select @Result = @@error if @Result <> 0 goto Err

	insert into #task
		(strID,UserID,NameResp,Descr,History,
		DateStart,DateEnd,Status,StatusN,OI_1)
	select
		OI.UserName,OI.UserID,'',OI.Dept + ' - ' + OI.Position,'',
		'','Из них просрочено: ' + cast(sum(case when T.Status in (5) then 1 else 0 end) as varchar(50)),
		null,'Всего на исполнении: ' + cast(sum(case when T.Status in (2,3,4,5) then 1 else 0 end) as varchar(50)),
		1
	from #task T
	inner join #OI_user OI on T.userID = OI.userID
	group by OI.UserName,OI.UserID,OI.Dept,OI.Position

	select
		T.*,OI.*,
		case T.Status when 5 then datediff(day,convert(datetime,DateEnd,104),getdate()) else null end as MisCnt
	from #task T
	inner join #OI_user OI on T.userID = OI.userID
	where T.OI_1 = case @ReportInf when 0 then 1 else T.OI_1 end
	order by OI.KeyF, T.DateStart

	drop table #OI_user
	drop table #task

	return @Result
Err:
	
	return @Result





GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_Z_ZadachiList] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO




CREATE proc [dbo].[PDX_REP_Z_ZadachiList]
	@Department varchar(255),
	@DateStart datetime,
	@DateEnd datetime,
	@User varchar(128),
	@Type int, --1 - ответственнй исп., 2- контролер, 3 исполнители, 4 - создатель
	@DocID varchar(128),
	@Status int = -1, -- (-1)-все, (-3)- исполнено, (-2)-исполняется, (1)-на исполнении, срок не наступил,
					-- (2)-на исполнении, просрочен , (3)- исполнено в срок, (4)-исполнено с прострочкой
	@Access bit = 1,
	@ActDoc varchar(64) = null,
	@UFT4 varchar(1024) = null

as

declare @Result int
select @Result = 0


declare @Cls varchar(256)
	select @Cls= dbo.PDX_CLSGet('RIK_CategoryName_SYSZADACHI')
	
	select @User = ltrim(rtrim(case dbo.PDX_SubstringReturn(@User,charindex('<',@User),charindex('>',@User)) 
						when ''
							then @User
						else '<' + dbo.PDX_SubstringReturn(@User,charindex('<',@User),charindex('>',@User))  + '>'
					end)),
			@ActDoc = ltrim(ISNULL(@ActDoc,'')),
			@UFT4 = ltrim(ISNULL(@UFT4,''))
	select @Result = @@error if @Result <> 0 goto Err

declare @hist table (docid varchar(128),addhist varchar(4000))


;with ttc (docid,dtevent,dtolddate,dtnewdate,msg,ctype)
as
(
	select 
		d.DocID,
		c.DateCreation,
		case
			when (c.Comment like 'Refuse completion%') or (c.Comment like 'На доработку%')
				then null
			when (c.Comment like 'Информация изменена%: [0-9][0-9].[0-9][0-9].[0-9][0-9][0-9][0-9]->[0-9][0-9].[0-9][0-9].[0-9][0-9][0-9][0-9]%')
							or (c.Comment like 'Information updated%: [0-9][0-9]/[0-9][0-9]/[0-9][0-9][0-9][0-9]->[0-9][0-9]/[0-9][0-9]/[0-9][0-9][0-9][0-9]%')
				then dbo.PDX_TaskDateFromCommentGet(c.Comment,'','->')
			else null 
		end,
		case
			when (c.Comment like 'Refuse completion%') or (c.Comment like 'На доработку%')
				then d.DateCompletion
			when (c.Comment like 'Информация изменена%: [0-9][0-9].[0-9][0-9].[0-9][0-9][0-9][0-9]->[0-9][0-9].[0-9][0-9].[0-9][0-9][0-9][0-9]%')
							or (c.Comment like 'Information updated%: [0-9][0-9]/[0-9][0-9]/[0-9][0-9][0-9][0-9]->[0-9][0-9]/[0-9][0-9]/[0-9][0-9][0-9][0-9]%')
				then dbo.PDX_TaskDateFromCommentGet(c.Comment,'->','')
			else null 
		end,
		c.Comment,
		case
			when (c.Comment like 'Refuse completion%') or (c.Comment like 'На доработку%')
				then 1
			when (c.Comment like 'Информация изменена%: [0-9][0-9].[0-9][0-9].[0-9][0-9][0-9][0-9]->[0-9][0-9].[0-9][0-9].[0-9][0-9][0-9][0-9]%')
							or (c.Comment like 'Information updated%: [0-9][0-9]/[0-9][0-9]/[0-9][0-9][0-9][0-9]->[0-9][0-9]/[0-9][0-9]/[0-9][0-9][0-9][0-9]%')
				then 2
			else 0
		end
	from dbo.Comments c
		inner join dbo.Docs d on (d.DocIDInt =c.DocIDInt)
	where d.ClassDoc=@Cls
		and UPPER(d.IsActive)='Y'
		and c.CommentType='HISTORY'
)
insert into @hist (docid,addhist)
select distinct docid,ordered
from ttc t
	cross apply (select CONVERT(varchar,t2.dtevent,104) + ': ' + case ctype when 1 then 'Возврат на доработку, срок ' + CONVERT(varchar,t2.dtnewdate,104) when 2 then 'Перенос срока с ' + CONVERT(varchar,t2.dtolddate,104) + ' на ' + CONVERT(varchar,t2.dtnewdate,104) else '' end + ' #	'  from ttc t2 where t2.docid=t.docid and t2.ctype in (1,2) order by t2.dtevent for xml path('')) D (ordered)
where not t.dtnewdate is null


	select 
		case @Access when 1 then 'system_report' else D.DocID end as DocID,
		U.Department as UserDept,
		P.Name as ParentName,

		D.DocID as strID,
		D.NameResponsible, D.DateCompletion, D.Description, D.DocIDParent,
		D.UserFieldDate3, D.ListToView, D.NameControl, D.NameCreation, D.DateCreation,
		
		case 
			when isnull(D.StatusCompletion,'') <> '1'
				and convert(datetime,convert(varchar(100),D.DateCompletion,104),104) >= convert(datetime,convert(varchar(100),getdate(),104),104)
				then 1 --'на исполнении, срок не наступил'
			when isnull(D.StatusCompletion,'') <> '1'
				and convert(datetime,convert(varchar(100),D.DateCompletion,104),104) < convert(datetime,convert(varchar(100),getdate(),104),104)
				then 2 --'на исполнении, просрочен'
			when isnull(D.StatusCompletion,'') = '1'
				and convert(datetime,convert(varchar(100),D.DateCompletion,104),104) >= convert(datetime,convert(varchar(100),D.DateCompleted,104),104)
				then 3 --'исполнено в срок'
			when isnull(D.StatusCompletion,'') = '1'
				and convert(datetime,convert(varchar(100),D.DateCompletion,104),104) < convert(datetime,convert(varchar(100),D.DateCompleted,104),104)
				then 4 --'исполнено с прострочкой'
			else 0 --'ошибка'
		end as Status,
		case 
			when isnull(D.StatusCompletion,'') = '+'
				then 1 -- 'запрос исполнено'
			else 0
		end as Status1,
		case 
			when isnull(D.StatusCompletion,'') <> '1'
				and convert(datetime,convert(varchar(100),D.DateCompletion,104),104) >= convert(datetime,convert(varchar(100),getdate(),104),104)
				then 'На исполнении, срок исполнения не наступил' --'на исполнении, срок не наступил'
			when isnull(D.StatusCompletion,'') <> '1'
				and convert(datetime,convert(varchar(100),D.DateCompletion,104),104) < convert(datetime,convert(varchar(100),getdate(),104),104)
				then 'На исполнении, срок исполнения просрочен' --'на исполнении, просрочен'
			when isnull(D.StatusCompletion,'') = '1'
				and convert(datetime,convert(varchar(100),D.DateCompletion,104),104) >= convert(datetime,convert(varchar(100),D.DateCompleted,104),104)
				then 'Исполнено в срок' --'исполнено в срок'
			when isnull(D.StatusCompletion,'') = '1'
				and convert(datetime,convert(varchar(100),D.DateCompletion,104),104) < convert(datetime,convert(varchar(100),D.DateCompleted,104),104)
				then 'Исполнено с нарушением срока' --'исполнено с прострочкой'
			else 'ОШИБКА' --'ошибка'
		end  +
		case 
			when isnull(D.StatusCompletion,'') = '+'
				then ' (запрошено Исполненение)' -- 'запрос исполнено'
			else ''
		end as StatusName,
		D.History + ISNULL(' # ' + h.addhist,'') as History,
		D.ActDoc,
		D.UserFieldText4
	from dbo.Docs D with (nolock)
		inner join dbo.Users U with (nolock) on U.UserID = dbo.PDX_SubstringReturn(D.NameResponsible, charindex('<', D.NameResponsible), charindex('>', D.NameResponsible))
		left join Docs P on P.DocID = D.DocIDParent
		left join @hist h on (h.docid=D.DocID)
	where D.ClassDoc = @Cls
	and (convert(datetime,convert(varchar(100),D.DateCompletion,104),104) between @DateStart and @DateEnd
		or (isnull(D.StatusCompletion,'') <> '1' and convert(datetime,convert(varchar(100),D.DateCompletion,104),104) < convert(datetime,convert(varchar(100),getdate(),104),104)) )

	and upper(isnull(D.isActive ,'')) = 'Y'
	and isnull(D.StatusCompletion,'') <> '0'
	and D.StatusArchiv<>'1' 
	and D.ExtInt=' '
	and D.DocID like '%' + @DocID + '%'
	and (D.ActDoc = @ActDoc or @ActDoc = '')
	and (D.UserFieldText4 = @UFT4 or @UFT4 = '')
	and case @Type when 1 then D.NameResponsible when 2 then D.NameControl when 3 then D.ListToView when 4 then D.NameCreation else '' end like '%' + @User  + '%'
		
	and U.Department like @Department + '%'
	
	and @Status = 
			case 
				when @Status = -1
					then -1
				when @Status = -2 and isnull(D.StatusCompletion,'') <> '1'
					then -2
				when @Status = -3 and isnull(D.StatusCompletion,'') = '1'
					then -3
				when isnull(D.StatusCompletion,'') <> '1'
					and convert(datetime,convert(varchar(100),D.DateCompletion,104),104) >= convert(datetime,convert(varchar(100),getdate(),104),104)
					then 1 --'на исполнении, срок не наступил'
				when isnull(D.StatusCompletion,'') <> '1'
					and convert(datetime,convert(varchar(100),D.DateCompletion,104),104) < convert(datetime,convert(varchar(100),getdate(),104),104)
					then 2 --'на исполнении, просрочен'
				when isnull(D.StatusCompletion,'') = '1'
					and convert(datetime,convert(varchar(100),D.DateCompletion,104),104) >= convert(datetime,convert(varchar(100),D.DateCompleted,104),104)
					then 3 --'исполнено в срок'
				when isnull(D.StatusCompletion,'') = '1'
					and convert(datetime,convert(varchar(100),D.DateCompletion,104),104) < convert(datetime,convert(varchar(100),D.DateCompleted,104),104)
					then 4 --'исполнено с просрочкой'
				else 0 --'ошибка'
			end
	Order by D.DateCompletion, D.DocID
	select @Result = @@error if @Result <> 0 goto Err


	return @Result
Err:
	
	return @Result





GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_Z_ZadachiSummary] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_REP_Z_ZadachiSummary]
	@Department varchar(255),
	@DateStart datetime,
	@DateEnd datetime,
	@VPar varchar(2048) = null, --@Col1:OI:Value,
	@ActDoc varchar(64) = null,
	@UFT4 varchar(1024) = null
	--Col1 - колонка FldX
	--OI - пользователь/подразделение (1/0)
	--Value - значение пользователя/подразделения
as

declare @Result int
select @Result = 0

	declare @Us varchar(255),
			@Dp varchar(255),
			@Col1 int,
			@Pos int,
			@OI varchar(10)

declare @cls varchar(256)
select @cls = dbo.PDX_CLSGet('RIK_CategoryName_SYSZADACHI'),
	@ActDoc = ltrim(ISNULL(@ActDoc,'')),
	@UFT4 = ltrim(ISNULL(@UFT4,''))
		
	declare @Tmp table
		(Department varchar(255),
		NameResponsible varchar(255),
		strID varchar(128),
		Status int,
		Status1 int,
		Name varchar(1024),
		--StatusCompletion char(1),
		DateCompletion datetime)

	declare @Res table
		(OI int,
		Fld0 varchar(255),
		Fld1 varchar(255),
		Fld2 varchar(100),
		Fld3 varchar(100),
		Fld4 varchar(100),
		Fld5 varchar(100),
		Fld6 varchar(100),
		Fld7 varchar(100),
		Fld8 varchar(100),
		step varchar(255) )

	insert into @Tmp
		(Department,
		NameResponsible,
		strID,
		Status,
		Status1,
		Name,
		--StatusCompletion,
		DateCompletion)
	select 
		U.Department,
		D.NameResponsible,
		D.DocID,
		case 
			when isnull(StatusCompletion,'') <> '1'
				and convert(datetime,convert(varchar(100),D.DateCompletion,104),104) >= convert(datetime,convert(varchar(100),getdate(),104),104)
				then 1 --'на исполнении, срок не наступил'
			when isnull(StatusCompletion,'') <> '1'
				and convert(datetime,convert(varchar(100),D.DateCompletion,104),104) < convert(datetime,convert(varchar(100),getdate(),104),104)
				then 2 --'на исполнении, просрочен'
			when isnull(StatusCompletion,'') = '1'
				and convert(datetime,convert(varchar(100),D.DateCompletion,104),104) >= convert(datetime,convert(varchar(100),D.DateCompleted,104),104)
				then 3 --'исполнено в срок'
			when isnull(StatusCompletion,'') = '1'
				and convert(datetime,convert(varchar(100),D.DateCompletion,104),104) < convert(datetime,convert(varchar(100),D.DateCompleted,104),104)
				then 4 --'исполнено с прострочкой'
			else 0 --'ошибка'
		end,
		case 
			when isnull(StatusCompletion,'') = '+'
				then 1 -- 'на рассмотрении'
			else 0
		end,
		D.Description,
		--D.StatusCompletion,
		D.DateCompletion
	/*	D.DocIDParent,
		D.Description,
		D.NameCreation,
		D.NameControl,
		D.StatusDevelopment,
		d.StatusCompletion,
		D.DateCompletion,
		D.DateCompleted,*/
	from dbo.Docs D with (nolock)
	inner join dbo.Users U with (nolock) on U.UserID = dbo.PDX_SubstringReturn(D.NameResponsible, charindex('<', D.NameResponsible), charindex('>', D.NameResponsible))
	where D.ClassDoc = @cls
	and (D.ActDoc = @ActDoc or @ActDoc = '')
	and (D.UserFieldText4 = @UFT4 or @UFT4 = '')
	and U.Department like @Department + '%'
	and (convert(datetime,convert(varchar(100),D.DateCompletion,104),104) between @DateStart and @DateEnd
	or (isnull(D.StatusCompletion,'') <> '1' and convert(datetime,convert(varchar(100),D.DateCompletion,104),104) < convert(datetime,convert(varchar(100),getdate(),104),104)) )
	and upper(isnull(D.isActive ,'')) = 'Y'
	and isnull(D.StatusCompletion,'') <> '0'
	select @Result = @@error if @Result <> 0 goto Err

	If isnull(@VPar,'') = ''
	begin --сводная
		insert into @Res
			(OI,Fld0,Fld1,Fld2,Fld3,Fld4,Fld5,Fld6,Fld7,Fld8, step)
		select
			1 as 'OI',
			Department as 'Fld0',
			max(NameResponsible) as 'Fld1',
			cast(count(*) as varchar(100)) as 'Fld2', --всего 
			cast(sum(case when Status in (1,2) then 1 else 0 end) as varchar(100)) as 'Fld3', --на исполнении
			cast(sum(case when Status in (2) then 1 else 0 end) as varchar(100)) as 'Fld4', --в т.ч. просрочены
			cast(sum(case when Status1 in (1) then 1 else 0 end)  as varchar(100)) as 'Fld5', -- на рассмотрении
			cast(sum(case when Status in (3,4) then 1 else 0 end) as varchar(100)) as 'Fld6', --исполнено
			cast(sum(case when Status in (4) then 1 else 0 end) as varchar(100)) as 'Fld7', --в т.ч. с нарушением
			cast(
				cast(
					round(
						100*sum(case when Status in (2,4) then 1 else 0 end)/count(*)
					,0)
				as int)
			as varchar(100)) as 'Fld8', --% просроченных
			replicate('&nbsp',16) as 'step'
		from @Tmp
		group by Department,
			dbo.PDX_SubstringReturn(NameResponsible, charindex('<', NameResponsible), charindex('>', NameResponsible))
	--	order by 2,1,3
		select @Result = @@error if @Result <> 0 goto Err
	
		insert into @Res
			(OI,Fld0,Fld1,Fld2,Fld3,Fld4,Fld5,Fld6,Fld7,Fld8, step)
		select 
			0 as 'OI',
			Department as 'Fld0',
			Department as 'Fld1',
			cast(count(*) as varchar(100)) as 'Fld2', --всего 
			cast(sum(case when Status in (1,2) then 1 else 0 end) as varchar(100)) as 'Fld3', --на исполнении
			cast(sum(case when Status in (2) then 1 else 0 end) as varchar(100)) as 'Fld4', --в т.ч. просрочены
			cast(sum(case when Status1 in (1) then 1 else 0 end) as varchar(100)) as 'Fld5', -- на рассмотрении
			cast(sum(case when Status in (3,4) then 1 else 0 end) as varchar(100)) as 'Fld6', --исполнено
			cast(sum(case when Status in (4) then 1 else 0 end) as varchar(100)) as 'Fld7', --в т.ч. с нарушением
			cast(
				cast(
					round(
						100*sum(case when Status in (2,4) then 1 else 0 end)/count(*)
					,0)
				as int)
			as varchar(100)) as 'Fld8', --% просроченных
			'' as 'step'
		from @Tmp
		group by Department
		select @Result = @@error if @Result <> 0 goto Err
	
		update @Res
			set
				Fld2 = case Fld2 when '0' then '' else Fld2 end,				
				Fld3 = case Fld3 when '0' then '' else Fld3 end,
				Fld4 = case Fld4 when '0' then '' else Fld4 end,
				Fld5 = case Fld5 when '0' then '' else Fld5 end,
				Fld6 = case Fld6 when '0' then '' else Fld6 end,
				Fld7 = case Fld7 when '0' then '' else Fld7 end,
				Fld8 = case when Fld8 in ('0','') then '' else Fld8 + '%' end
		select @Result = @@error if @Result <> 0 goto Err
	
	
		select *
		from @Res
		order by Fld0, OI, Fld1
		select @Result = @@error if @Result <> 0 goto Err
	end
	else --детализация
	begin
		select @Pos = charindex(':',@VPar),
			@Col1 = 0, @Us = null, @Dp = ''
		select @Result = @@error if @Result <> 0 goto Err

		if isnull(@Pos,0)>1
		begin
 			select @Col1 = substring(@VPar, 1, @Pos-1),
				@VPar = stuff(@VPar,1, @Pos,'')
			select @Result = @@error if @Result <> 0 goto Err
		end

		select @Pos = charindex(':',@VPar)
		select @Result = @@error if @Result <> 0 goto Err

		if isnull(@Pos,0)>1
		begin
 			select @OI = substring(@VPar, 1, @Pos-1)
			select @Result = @@error if @Result <> 0 goto Err
		
			select @Us = case @OI 
							when 1 
								then stuff(@VPar,1, @Pos,'')
							else null
						end,
				    @Dp = case @OI 
							when 0
								then stuff(@VPar,1, @Pos,'')
							else null
						end
			select @Result = @@error if @Result <> 0 goto Err
		end


		select *,
			case Status
				when 1 then 'на исполнении, срок не наступил'
				when 2 then 'на исполнении, просрочен'
				when 3 then 'исполнено в срок'
				when 4 then 'исполнено с прострочкой'
				else 'ошибка'
			end  + 
			case Status1
				when 1 then ' (на рассмотрении)'
				else ''
			end as StatusName
		from @Tmp
		where case when @Us is null 
				then Department 
				else dbo.PDX_SubstringReturn(NameResponsible, charindex('<', NameResponsible), charindex('>', NameResponsible,charindex('<', NameResponsible)+1))
			  end = case when @Us is null 
				then @Dp 
				else dbo.PDX_SubstringReturn(@Us, charindex('<', @Us), charindex('>', @Us,charindex('<', @Us)+1))
			  end 
		and
        case @Col1
			when 0 then '-1' --нет данных - ошибка в параметрах
			when 5 then Status1
			else Status
		end in (
				case @Col1 
					when 0 then '0'--нет данных - ошибка в параметрах
					when 5 then '1'					
					when 2 then Status

					when 3 then '1'
					when 4 then '2'
					when 6 then '3'
					when 7 then '4'
				end,
				case @Col1 
					when 0 then '0' --нет данных - ошибка в параметрах
					when 5 then '1'
					when 2 then Status

					when 3 then '2'
					when 4 then '2'
					when 6 then '4'
					when 7 then '4'
				end
				) 
		select @Result = @@error if @Result <> 0 goto Err
	end

	return @Result
Err:
	
	return @Result

GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_Z_ZadReport] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[PDX_REP_Z_ZadReport]
	@User varchar(128),
	@Type int, --1 - ответственнй 2- контролер,
	@ActDoc varchar(64) = null,
	@UFT4 varchar(1024) = null
as

declare @Result int
select @Result = 0

	declare @Cls varchar(256)
	select @Cls= dbo.PDX_CLSGet('RIK_CategoryName_SYSZADACHI')
	
	select @User = case dbo.PDX_SubstringReturn(@User,charindex('<',@User),charindex('>',@User)) 
						when ''
							then @User
						else dbo.PDX_SubstringReturn(@User,charindex('<',@User),charindex('>',@User)) 
					end ,
			@ActDoc = ltrim(ISNULL(@ActDoc,'')),
			@UFT4 = ltrim(ISNULL(@UFT4,''))
	select @Result = @@error if @Result <> 0 goto Err

	select D.*,
		/*D.DocID as strID,
		D.DateCompletion, D.Description,D.DocIDParent, D.UserFieldDate3, D.NameControl, D.NameCreation, D.DateCreation,
		*/P.Name as ParentName,
		case 
			when convert(datetime,convert(varchar(100),getdate(),104),104) between D.UserFieldDate3 and D.DateCompletion 
				then 'исполняется' 
			when convert(datetime,convert(varchar(100),getdate(),104),104)<D.UserFieldDate3 
				then 'ожидает' 
			when convert(datetime,convert(varchar(100),getdate(),104),104)>D.DateCompletion 
				then 'просрочен' 
		else 'ошибка' 
	end as StatusName,
	D.ActDoc,
	D.UserFieldText4
	from Docs D
	left join Docs P on P.DocID = D.DocIDParent
	where D.StatusArchiv<>'1' 
		and D.ExtInt=' ' 
		and not isnull(D.StatusCompletion,'') in ('0','1')
		and D.ClassDoc = @Cls
		and dbo.PDX_SubstringReturn(case @Type when 1 then D.NameResponsible else D.NameControl end,
				charindex('<',case @Type when 1 then D.NameResponsible else D.NameControl end),
				charindex('>',case @Type when 1 then D.NameResponsible else D.NameControl end)) = @User 
		and Upper(D.isActive) = 'Y' 
		and (D.ActDoc = @ActDoc or @ActDoc = '')
		and (D.UserFieldText4 = @UFT4 or @UFT4 = '')
	order by D.DateCompletion

	select @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:
	
	return @Result

GO
/****** Object:  StoredProcedure [dbo].[PDX_REP_ZaprosReestr] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
create proc [dbo].[PDX_REP_ZaprosReestr]
		@DateFrom datetime,
		@DateTo datetime,
		@Code varchar(12)
as

	declare @Result int
	select @Result = 0

	declare @tmp table
		(DocID varchar(128),
		DateActivation datetime,
		UserFieldText5 varchar(1024),--направления
		UserFieldText5_1 varchar(1024),--направления1
		Name varchar(255),
		Description varchar(1024),-- описание		
		Department varchar(1024), --инициатор
		UserFieldText1 varchar(1024),--примеч.
		DateApproved datetime,
		StatusDevelopment int,
		NameCreation varchar(256))
	
	declare @tmp1 table 
			(FullNapr varchar(1024))
	
	create table #tmp2 
			(Napr varchar(512),
			Name varchar(256))

	declare @FullNapr varchar(8000)

	--все что есть в БД	
	insert into @tmp
		(DocID,
		DateActivation,
		UserFieldText5,
		Name,
		Description,
		Department,
		UserFieldText1,
		DateApproved,
		StatusDevelopment,
		NameCreation)
	select
		DocID,
		DateActivation,
		space(1) + replace(UserFieldText5, char(13) + char(10), space(1)) + space(1),
		Name,
		Description,
		Department,
		UserFieldText1,
		DateApproved,
		StatusDevelopment,
		NameCreation
	from dbo.Docs
	where ClassDoc = 'Проект / Запрос на изменение'
		and upper(isnull(isActive,'N')) = 'Y' --активные
		and isnull(StatusCompletion,'') <> '0' --неотмененные 
		and DateActivation between @DateFrom and @DateTo
		and UserFieldText5 like '%' + ltrim(rtrim(isnull(@Code,''))) + '%'
	select @Result = @@error if @Result <> 0 goto Err

	while exists (select 1 from @tmp where UserFieldText5 like '%' + space(2) + '%')
	begin
		update @tmp
		set UserFieldText5 = replace(UserFieldText5, space(2), space(1))
		where UserFieldText5 like '%' + space(2) + '%'
		select @Result = @@error if @Result <> 0 goto Err
	end
	select @Result = @@error if @Result <> 0 goto Err

	insert into @tmp1
		(FullNapr)
	select distinct
		UserFieldText5
	from @tmp
	where ltrim(rtrim(UserFieldText5)) <> ''
	select @Result = @@error if @Result <> 0 goto Err

	while exists (select 1 from @tmp1)
	begin
		select top 1
			@FullNapr = FullNapr
		from @tmp1
		select @Result = @@error if @Result <> 0 goto Err

		delete from @tmp1 where FullNapr = @FullNapr
		select @Result = @@error if @Result <> 0 goto Err

		select @FullNapr = 'insert into #tmp2 (Napr) values (ltrim(rtrim(''' + replace(ltrim(rtrim(@FullNapr)),space(1),'''))) insert into #tmp2 (Napr) values (ltrim(rtrim(''') + '''))) '
--print @FullNapr
		exec (@FullNapr)
	end
	select @Result = @@error if @Result <> 0 goto Err			
	
	update T
		set Name = I.Descr
	from #tmp2 T
	inner join dbo.UserDir_ISR I on I.Code = T.Napr

	select
		1 as OI2,
		T2.Napr as OI1,
		T.DocID as strID,
		T.DateActivation,
		UserFieldText5 as UserFieldText5,
		T.Name,
		T.Description,
		case ltrim(rtrim(T.Department))
			when ''
				then T.Department
			else reverse(substring(reverse(T.Department) + '/',1,charindex('/',reverse(T.Department) + '/')-1))
		end as Department,
		T.UserFieldText1,
		T.DateApproved,
		T.StatusDevelopment,
		T.NameCreation
	from @tmp T
	inner join (select distinct Napr from #tmp2) T2 on T.UserFieldText5 like '%' + space(1) + T2.Napr + space(1) + '%'
	union
		select 
			0 as OI2,		
			Napr as OI1,	
			'<b>' + Napr + ' - ' + isnull(Name, 'НЕ СУЩЕСТВУЕТ') + '</b>' as strID,
			'1900-01-01' as DateActivation,
			'' as UserFieldText5,
			'' as Name,
			'' as Description,
			'' as Department,
			'' as UserFieldText1,
			'1900-01-01' as DateApproved,
			null as StatusDevelopment,
			'' as NameCreation
		from #tmp2
	order by 2,1,3
		
	drop table #tmp2
	return @Result
Err:
	
	drop table #tmp2
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_ResolGroups_Change] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE proc [dbo].[PDX_ResolGroups_Change]
	@Name varchar(1024),
	@Projects varchar(1024),
	@ForUsers varchar(1024),
	@Users varchar(1024),
	@SetID uniqueidentifier,
	@NC varchar(128),
	@Act int, --1--ceate, 2-update,3 delete
	@Chk bit = 0
	
as
	declare  @Res int

	declare @ErrList varchar(1024), @Projects1 varchar(1024)
	declare @restbl table (Val varchar(1024), Pos int, Flag bit)
	select @Res = 0,@ErrList = ''
	


	select
		@Name = ltrim(rtrim(isnull(@Name,''))),
		@Projects = ltrim(rtrim(isnull(@Projects,''))),
		@Users = ltrim(rtrim(isnull(@Users,''))),
		@ForUsers = ltrim(rtrim(isnull(@ForUsers,''))),
		@NC  = ltrim(rtrim(isnull(@NC,'')))
	select @Res = @@error if @Res <> 0 goto Err

/************************************
ПРОВЕРКИ ВВЕДЕННЫХ ЗНАЧЕНИЙ
*************************************/

If @Name = ''
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Введите резолюцию'
	goto NXT
end

If @Users = ''
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Укажите пользователей'
	goto NXT
end
else
begin
	insert into @restbl
	exec dbo.PDX_ArrayToTable '<','>',@Users
	
	
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Пользователь [' + R.Val + '] не существует'
	from @restbl R
	left join dbo.Users U on U.UserID = r.Val
		and U.StatusActive in ('1','-') and U.DateExpirationSecurity >= GETDATE()
		and not U.Permitions like '%*%'
	where R.Val <> '' and U.UserID is null
	goto NXT
end

If @ForUsers <> ''
begin
	delete from @restbl
	
	insert into @restbl
	exec dbo.PDX_ArrayToTable '<','>',@ForUsers
	
	
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Пользователь [' + R.Val + '] не существует'
	from @restbl R
	left join dbo.Users U on U.UserID = r.Val
		and U.StatusActive in ('1','-') and U.DateExpirationSecurity >= GETDATE()
		and not U.Permitions like '%*%'
	where R.Val <> '' and U.UserID is null
	goto NXT
end

If @Projects <> ''
begin
	select @Projects1 = '<' + REPLACE(@Projects,CHAR(13)+CHAR(10),'><') + '>'
	delete from @restbl
	
	insert into @restbl
	exec dbo.PDX_ArrayToTable '<','>',@Projects1
	
	
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Проект [' + R.Val + '] не существует'
	from @restbl R
	left join dbo.UserDirValues U on U.UDKeyField = 35 and U.Field1 = r.Val
	where R.Val <> '' and U.IntKeyField is null
	goto NXT
end

NXT:

If @Chk = 0
begin --если это создание , то нужно генерить ошибкуесли она есть
	If @ErrList <> '' 
	begin
		RAISERROR (@ErrList, 16,1)
		goto Err
	end
end
else --если это проверка просто выводим сообщение, даже если оно пустое
begin
	select @ErrList as ErrList 
	select @Res = @@error if @Res <> 0 goto Err
end

IF @ErrList = '' and @Chk = 0
BEGIN
	if @Act = 2
	begin
		update dbo.PDXResolGroups
			set 
				Name = @Name,
				Projects = @Projects,
				Users = @Users,
				forUsers = @ForUsers,
				NLM = @NC,
				DLM = getdate()
		where SetID = @SetID
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 1
	begin
		insert into dbo.PDXResolGroups
			(Name, Projects, Users, ForUsers, NLM, DLM)
		values 
			(@Name, @Projects, @Users, @ForUsers, @NC, getdate())
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 3
	begin
		delete from dbo.PDXResolGroups where SetID = @SetID
		select @Res = @@error if @Res <> 0 goto Err
	end
END
	select @Res = @@error if @Res <> 0 goto Err

OK:

	return @Res
Err:
	return @Res




GO
/****** Object:  StoredProcedure [dbo].[PDX_Resolutions_Change] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_Resolutions_Change]
	@Descr varchar(1024),
	@Projects varchar(1024),
	@Users varchar(1024),
	@SetID uniqueidentifier,
	@NC varchar(128),
	@Act int, --1--ceate, 2-update,3 delete
	@Chk bit = 0
	
as
	declare  @Res int

	declare @ErrList varchar(1024), @Projects1 varchar(1024)
	declare @restbl table (Val varchar(1024), Pos int, Flag bit)
	select @Res = 0,@ErrList = ''
	


	select
		@Descr = ltrim(rtrim(isnull(@Descr,''))),
		@Projects = ltrim(rtrim(isnull(@Projects,''))),
		@Users = ltrim(rtrim(isnull(@Users,''))),
		@NC  = ltrim(rtrim(isnull(@NC,'')))
	select @Res = @@error if @Res <> 0 goto Err

/************************************
ПРОВЕРКИ ВВЕДЕННЫХ ЗНАЧЕНИЙ
*************************************/

If @Descr = ''
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Введите резолюцию'
	goto NXT
end

/*If @Users = ''
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Укажите пользователей'
	goto NXT
end
else*/
If @Users <> ''
begin
	insert into @restbl
	exec dbo.PDX_ArrayToTable '<','>',@Users
	
	
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Пользователь [' + R.Val + '] не существует'
	from @restbl R
	left join dbo.Users U on U.UserID = r.Val
		and U.StatusActive in ('1','-') and U.DateExpirationSecurity >= GETDATE()
		and not U.Permitions like '%*%'
	where R.Val <> '' and U.UserID is null
	goto NXT
end

If @Projects <> ''
begin
	select @Projects1 = '<' + REPLACE(@Projects,CHAR(13)+CHAR(10),'><') + '>'
	delete from @restbl
	
	insert into @restbl
	exec dbo.PDX_ArrayToTable '<','>',@Projects1
	
	
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Проект [' + R.Val + '] не существует'
	from @restbl R
	left join dbo.UserDirValues U on U.UDKeyField = 35 and U.Field1 = r.Val
	where R.Val <> '' and U.IntKeyField is null
	goto NXT
end

NXT:

If @Chk = 0
begin --если это создание , то нужно генерить ошибкуесли она есть
	If @ErrList <> '' 
	begin
		RAISERROR (@ErrList, 16,1)
		goto Err
	end
end
else --если это проверка просто выводим сообщение, даже если оно пустое
begin
	select @ErrList as ErrList 
	select @Res = @@error if @Res <> 0 goto Err
end

IF @ErrList = '' and @Chk = 0
BEGIN
	if @Act = 2
	begin
		update dbo.PDXResolutions
			set 
				Descr = @Descr,
				Projects = @Projects,
				Users = @Users,
				NLM = @NC,
				DLM = getdate()
		where SetID = @SetID
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 1
	begin
		insert into dbo.PDXResolutions
			(Descr, Projects, Users, NLM, DLM)
		values 
			(@Descr, @Projects, @Users, @NC, getdate())
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 3
	begin
		delete from dbo.PDXResolutions where SetID = @SetID
		select @Res = @@error if @Res <> 0 goto Err
	end
END
	select @Res = @@error if @Res <> 0 goto Err

OK:

	return @Res
Err:
	return @Res





GO
/****** Object:  StoredProcedure [dbo].[PDX_RLRules_Change] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_RLRules_Change]
	@UName varchar(96),
	@ActD varchar(64),
	@Class varchar(128),
	@RLPos int,
	@DateF datetime,
	@DateT datetime,
	@NotAppr varchar(1024),
	@Dept varchar(1024),
	@DT varchar(1024) = null,
	@NC varchar(96),
	@SetID uniqueidentifier,
	@CheckOnly bit = 0
	
as
	declare  @Res int

	declare @UserID varchar(16),
			@ErrList varchar(1024),
			@Cls varchar(1024),
			@ErrorStr varchar(1024),
			@ClassGr varchar(128),
			@PayClass varchar(128)

	select @Res = 0,@ErrList = ''
	
	select
		@UName = ltrim(rtrim(isnull(@UName,''))),
		@Class = ltrim(rtrim(isnull(@Class,''))),
		@ActD = ltrim(rtrim(isnull(@ActD,''))),
		@Dept = ltrim(rtrim(isnull(@Dept,''))),
		@DT = ltrim(rtrim(isnull(@DT,''))),
		@RLPos = ltrim(rtrim(isnull(@RLPos,2))),
		@DateF = convert(datetime,convert(varchar(50),isnull(@DateF,'1900-01-01'),104),104),
		@DateT = convert(datetime,convert(varchar(50),isnull(@DateT,'1900-01-01'),104),104),
		@NotAppr = ltrim(rtrim(isnull(@NotAppr,''))),
		@NC = ltrim(rtrim(isnull(@NC,'')))
	select @Res = @@error if @Res <> 0 goto Err

	if @Dept like '%/'
	begin
		select @Dept = LEFT(@Dept,LEN(@dept)-1)
	end
/************************************
ПРОВЕРКИ ВВЕДЕННЫХ ЗНАЧЕНИЙ
*************************************/

set @PayClass = dbo.PDX_CLSGrGet('RIK_CategoryName_KAZ_ORDPAY')

--категория обязательно д.б. указана
IF @Class = ''
BEGIN
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Не указана категория(группа категорий) документа.'
	select @Res = @@error if @Res <> 0 goto Err
END
IF not exists (select 1 from dbo.DocTypes where Name like @Class + case right(@Class,1) when '/' then '%' else '' end)
BEGIN
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Указана несуществующая категория документа.'
	select @Res = @@error if @Res <> 0 goto Err
END

If @Class like @PayClass +'%'
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Указана некорректная категория документа (категории группы ' + @PayClass + ' в данных настройках использоваться не могут).'
	select @Res = @@error if @Res <> 0 goto Err
end

select @ClassGr = case when @Class like '%/%' and not @Class like '%/'
						then left(@Class,charindex('/',@Class))
						else @Class
					end
select @Res = @@error if @Res <> 0 goto Err

If @Dept <> ''
begin
	IF not exists (select 1 from dbo.Departments where Name like @Dept + '%')
	BEGIN
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Указано несуществующее подразделение.'
		select @Res = @@error if @Res <> 0 goto Err
	END
end

IF @UName <> ''
BEGIN
	If @UName like '%<%>%<%' 
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Согласующим может быть указан только один пользователь.'
		select @Res = @@error if @Res <> 0 goto Err
	end

	--проверяем пользователя
	select @UserID  = ''
	select @UserID = dbo.PDX_SubstringReturn(@UName, charindex('<',@UName), charindex('>',@UName))
	select @Res = @@error if @Res <> 0 goto Err
	--если "не выделился" логин - значит некорректно указан пользователь
	if @UserID = ''
	begin
		If not @UName like '{%}'
		begin
			select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
				'Некорректно указан согласующий. Выберите значение из справочника пользователей или укажите ключевое слово.'
			select @Res = @@error if @Res <> 0 goto Err
		end
		/*else
		begin--правило  {} - может быть только одно для одной категории
			if exists (select 1 from dbo.PDXReconcilationRules
						where (@Class = ClassDoc
								or @ClassGr = ClassDoc
								or ClassDoc like case @Class when @ClassGr
													then @ClassGr
													else @Class end + '%')
						and UserName like '{%}'
						and SetID <> isnull(@SetID,'00000000-0000-0000-0000-000000000000'))
			begin
				select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
					'Специальное правило {XXXX} - может быть только одно для категории(группы).'
				select @Res = @@error if @Res <> 0 goto Err
			end
		end*/
	end
	--если пользователь не нашелся, или у него нет доступа
	else if not exists (select 1 from dbo.Users where UserID=@UserID
			and ((StatusActive in ('1','-') and DateExpirationSecurity > convert(datetime,convert(varchar(50),getdate(),104),104)
					and not Permitions like '%*%') 
				or Comment like '%$RLsyslogin$%'))
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Указанный пользователь не существует (или его доступ в систему приостановлен).'
		select @Res = @@error if @Res <> 0 goto Err
	end
END

--если указан вид деят-ти
IF @ActD <> ''
BEGIN
	select---ищем какие для него доступны категории
		@Cls = ltrim(rtrim(isnull(ClassDoc,'')))
	from dbo.Activities
	where Name = @ActD
	select @Res = @@error if @Res <> 0 goto Err
	--значит что вид деят-ти выбран несуществующий
	if @Cls is null
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Указан не существующий вид деятельности.'
		select @Res = @@error if @Res <> 0 goto Err
	end
	--проверяем что категория и ВД "совместимы"
	If not @Cls like '%' + @ClassGr + '%'
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Выбрана недопустимая комбинация Вида деятельности и категории документа.'
		select @Res = @@error if @Res <> 0 goto Err
	end
END
	
IF @NotAppr <> ''
BEGIN
	If not @NotAppr like '%<%>%'
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'В списке [Исключения по утверждающему] пользователи должны быть выбраны из справочника.'
		select @Res = @@error if @Res <> 0 goto Err
	end
	else 
	begin --'эта процедура превратилась в универсальный механизм разбора строкового списка пользователей
		exec @Res = dbo.PDX_ReconcilationListContent
			@ListToReconcile = @NotAppr,
			@ErrorStr = @ErrorStr out,
			@FieldName = '[Исключения по утверждающему]'
		if @Res <> 0 goto Err
		--если есть ошибки
		if isnull(@ErrorStr,'') <> '' 
		begin
			select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end + @ErrorStr
			select @Res = @@error if @Res <> 0 goto Err
		end
	end
END


--проверяем даты
IF year(@DateF) = 1900
BEGIN
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Не указана дата начала действия правила.'
	select @Res = @@error if @Res <> 0 goto Err
END
IF year(@DateT) = 1900
BEGIN
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Не указана дата окончания действия правила.'
	select @Res = @@error if @Res <> 0 goto Err
END
IF @DateF>@DateT
BEGIN
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Дата начала действия не может быть больше даты окончания.'
	select @Res = @@error if @Res <> 0 goto Err
END
	
--позицию проверяем
IF not @RLPos in (0,1,2)
BEGIN
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Указано недопустимое значение Позиции.'
	select @Res = @@error if @Res <> 0 goto Err
END

IF  @RLPos in (0,1) -- 'это позиции, где может быть определен только один согласующий на период
BEGIN 
	if exists (select 1 from dbo.PDXReconcilationRules where ActDoc = @ActD
				and (@Class in (ClassDoc,case when ClassDoc like '%/%' and not ClassDoc like '%/'
													then left(ClassDoc,charindex('/',ClassDoc))
													else ClassDoc
												end) 
						or ClassDoc in (@Class, @ClassGr)
						)
				and RLPos = @RLPos
				and not (DateFrom > @DateT or @DateF > DateTo)
				and (Dept like @Dept + '%' or @Dept like Dept + '%')
				and SetID <> isnull(@SetID,'00000000-0000-0000-0000-000000000000')
			   )
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Для указанной категории, Вида деятельности и подразделения (на указанный период) правило уже существует.'
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @NotAppr <> ''
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Для выбранной Позиции указать [Исключения по утверждающему] невозможно'
		select @Res = @@error if @Res <> 0 goto Err
	end
	If @DT <> ''
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Для выбранной Позиции указать [Вид документа] невозможно'
		select @Res = @@error if @Res <> 0 goto Err
	end
END
ELSE
BEGIN
	if exists (select 1 from dbo.PDXReconcilationRules where ActDoc = @ActD
					and (@Class in (ClassDoc,case when ClassDoc like '%/%' and not ClassDoc like '%/'
													then left(ClassDoc,charindex('/',ClassDoc))
													else ClassDoc
												end) 
						or ClassDoc in (@Class, @ClassGr)
						)
					and (
						(UserName like '%<' + @UserID + '>%' or UserName = @UName)
						)
					and RLPos = @RLPos
					and not (DateFrom > @DateT or @DateF > DateTo)
					and (Dept like @Dept + '%' or @Dept like Dept + '%')
					and SetID <> isnull(@SetID,'00000000-0000-0000-0000-000000000000')
				)
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Такое правило уже существует (пересечение периодов).'
		select @Res = @@error if @Res <> 0 goto Err
	end
END


/************************************/

If @CheckOnly = 0
begin --если это создание , то нужно генерить ошибкуесли она есть
	If @ErrList <> '' 
	begin
		RAISERROR (@ErrList, 16,1)
		goto Err
	end
end
else --если это проверка просто выводим сообщение, даже если оно пустое
begin
	select @ErrList as ErrList 
	select @Res = @@error if @Res <> 0 goto Err
end

IF @ErrList = '' and @CheckOnly = 0
BEGIN
	If @SetID is null
	begin
		insert into dbo.PDXReconcilationRules
			(UserName, ClassDoc, ActDoc, RLPos, DateFrom, DateTo, NotAppr, Dept, DocType, NC, DC, NLM, DLM)
		values 
			(@UName, @Class, @ActD, @RLPos, @DateF, @DateT, @NotAppr,  @Dept, @DT,
			@NC, getdate(), @NC, getdate()) 
		select @Res = @@error if @Res <> 0 goto Err
	end
	else
	begin
		update dbo.PDXReconcilationRules
			set 
				UserName = @UName, 
				ClassDoc = @Class,
				ActDoc = @ActD, 
				Dept = @Dept,
				RLPos = @RLPos, 
				DateFrom = @DateF, 
				DateTo = @DateT, 
				NotAppr = @NotAppr, 
				DocType = @DT,
				NLM = @NC,
				DLM = getdate()
		where SetID = @SetID
		select @Res = @@error if @Res <> 0 goto Err
	end
END
	select @Res = @@error if @Res <> 0 goto Err

OK:

	return @Res
Err:
	return @Res






GO
/****** Object:  StoredProcedure [dbo].[PDX_Scenariy_Change] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE proc [dbo].[PDX_Scenariy_Change]
	@Descr  varchar(256) ,
	@iType tinyint ,
	@KF int,
	@NC varchar(128),
	@Act int, --1--ceate, 2-update,3 delete
	@Chk bit = 0
	
as
	declare  @Res int

	declare @ErrList varchar(1024),
		/*@ParentID int,*/ @Cnt int, @flg tinyint

	select @Res = 0,@ErrList = ''

	select
		@Descr = ltrim(rtrim(isnull(@Descr,''))),
		@iType = ISNULL(@iType,0),
		@NC  = ltrim(rtrim(isnull(@NC,'')))
	select @Res = @@error if @Res <> 0 goto Err

/************************************
ПРОВЕРКИ ВВЕДЕННЫХ ЗНАЧЕНИЙ
*************************************/

If @Act <> 3
BEGIN
	
	
	If @Descr = ''
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Укажите наименование'
		goto NXT
	end
	else 
	begin
		
		if exists (select 1 from dbo.Scenariy where Descr = @Descr and ID <> isnull(@KF,0))
		begin
			select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
				'Указанное наименование уже существует'
			goto NXT
		end
	end
	
	if not @iType in (0,1)
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Укажите тип'
		goto NXT
	end
	
END
/************************************/

NXT:

If @Chk = 0
begin --если это создание , то нужно генерить ошибкуесли она есть
	If @ErrList <> '' 
	begin
		RAISERROR (@ErrList, 16,1)
		goto Err
	end
end
else --если это проверка просто выводим сообщение, даже если оно пустое
begin
	select @ErrList as ErrList 
	select @Res = @@error if @Res <> 0 goto Err
end

IF @ErrList = '' and @Chk = 0
BEGIN
	if @Act = 2
	begin
		update dbo.Scenariy
			set 
				Descr = @Descr,
				iType = @iType,
				NLM = @NC,
				DLM = getdate()
		where ID = @KF
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 1
	begin
		insert into dbo.Scenariy
			(Descr, iType, NC, DC, NLM, DLM)
		values 
			(@Descr,@iType, @NC, getdate(), @NC, getdate())
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 3
	begin
			delete dbo.Scenariy where ID = @KF
			select @Res = @@error if @Res <> 0 goto Err
	
	end
END

OK:

	return @Res
Err:
	return @Res



GO
/****** Object:  StoredProcedure [dbo].[PDX_SecurityLevelChange] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

create proc [dbo].[PDX_SecurityLevelChange]
	@DocID varchar(255)
	
as
	declare @Res int,
		@ActDoc varchar(128),
		@ClassDoc varchar(128),
		@Projects varchar(1024),
		@SecurityLevel int,
		@OldSecurityLevel int

	select
		@ActDoc = ActDoc,
		@ClassDoc = ClassDoc,
		@Projects = UserFieldText4,
		@OldSecurityLevel = SecurityLevel
	from dbo.Docs
	where DocID = @DocID
	
	if @ClassDoc in (dbo.PDX_CLSGet('RIK_CategoryName_ISHO_VNUTR'),
					dbo.PDX_CLSGet('RIK_CategoryName_ISHO_VNESH'),
					dbo.PDX_CLSGet('RIK_CategoryName_VHOD_VNESH'))
	begin
		select top 1 
			@SecurityLevel = SecurityLevel 
		from dbo.SecurityLevelSettings 
		where (ActDoc = @ActDoc or ActDoc = '') 
			and ClassDoc = @ClassDoc
			and Projects = @Projects
		order by ActDoc desc
		select @Res = @@error if @Res <> 0 goto Err
	    
		if @OldSecurityLevel <> ISNULL(@SecurityLevel,0)
			and ISNULL(@SecurityLevel,0) <> 0
		begin
			update dbo.Docs
			set SecurityLevel = @SecurityLevel
			where DocID = @DocID
			select @Res = @@error if @Res <> 0 goto Err
		end
	end

OK:

	return @Res
Err:
	return @Res

GO
/****** Object:  StoredProcedure [dbo].[PDX_SecurityLevelSet_Change] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE proc [dbo].[PDX_SecurityLevelSet_Change]
	@ClassDoc varchar(128),
	@ActDoc varchar(64),
	@Projects varchar(1024),
	@SecLevel int,
	@ID uniqueidentifier,
	@NC varchar(128),
	@Act int, --1--ceate, 2-update,3 delete
	@Chk bit = 0
	
as
	declare  @Res int

	declare @ErrList varchar(1024), @ClsGr varchar(128)

	select @Res = 0,@ErrList = ''
	


	select
		@ClassDoc = ltrim(rtrim(isnull(@ClassDoc,''))),
		@ActDoc = ltrim(rtrim(isnull(@ActDoc,''))),
		@SecLevel = ltrim(rtrim(isnull(@SecLevel,1))),
		@NC  = ltrim(rtrim(isnull(@NC,'')))
	select @Res = @@error if @Res <> 0 goto Err

    set @ClsGr = dbo.PDX_CLSGrByNameGet(@ClassDoc)

/************************************
ПРОВЕРКИ ВВЕДЕННЫХ ЗНАЧЕНИЙ
*************************************/
If @ClassDoc = ''
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Укажите категорию'
	goto NXT
end

if @ClsGr <> dbo.PDX_CLSGrGet('RIK_CategoryName_ISHO_VNESH')
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Данные настройки допустимы только для Корреспонденции'
	goto NXT
end

/*
If @ActDoc = ''
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Укажите вид деятельности'
	goto NXT
end*/

If @Projects = ''
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Укажите проект'
	goto NXT
end

if exists(select 1 from dbo.SecurityLevelSettings where ClassDoc = @ClassDoc	
	and ActDoc = @ActDoc and Projects = @Projects
	and ID <> isnull(@ID,'00000000-0000-0000-0000-000000000000'))
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Настройка для указанных Категории, Вида деят-ти  и Проекта уже существует'
	goto NXT
end	

/************************************/

NXT:

If @Chk = 0
begin --если это создание , то нужно генерить ошибкуесли она есть
	If @ErrList <> '' 
	begin
		RAISERROR (@ErrList, 16,1)
		goto Err
	end
end
else --если это проверка просто выводим сообщение, даже если оно пустое
begin
	select @ErrList as ErrList 
	select @Res = @@error if @Res <> 0 goto Err
end

IF @ErrList = '' and @Chk = 0
BEGIN
	if @Act = 2
	begin
		update dbo.SecurityLevelSettings
			set 
				ClassDoc = @ClassDoc,
				ActDoc = @ActDoc,
				Projects = @Projects,
				SecurityLevel = @SecLevel,
				NLM = @NC,
				DLM = getdate()
		where ID = @ID
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 1
	begin
		insert into dbo.SecurityLevelSettings
			(ClassDoc, ActDoc, Projects, SecurityLevel, NLM, DLM)
		values 
			(@ClassDoc, @ActDoc, @Projects, @SecLevel, @NC, getdate())
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 3
	begin
		delete from dbo.SecurityLevelSettings where ID = @ID
		select @Res = @@error if @Res <> 0 goto Err
	end
END
	select @Res = @@error if @Res <> 0 goto Err

OK:

	return @Res
Err:
	return @Res




GO
/****** Object:  StoredProcedure [dbo].[PDX_SET_ListToViewByUser] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_SET_ListToViewByUser]
	@UserID varchar(16),
	@Comm varchar(1024)='Проставлено автоматом',
--Проставлено автоматом, т.к. Швайко Д.Б. уволен 13.03.2009. На момент увольнения с документом ознакомлен не был
	@DateFrom datetime,
	@DateTo datetime 
as

declare @Result int
select @Result = 0

	create table #dcs
		(DocID varchar(255),
		ClassDoc varchar(255),
		Type int,
		dtDate datetime)

	declare @Cls1 varchar(255), 
			@Cls2 varchar(255), 
			@Cls_9 varchar(255), 
			@Cls_10 varchar(255),
			@UserName varchar(255)

	If @DateFrom is null or @DateTo is null or isnull(@UserID,'') = '' or isnull(@Comm,'') = ''
	begin
		select 'Один или несколько параметров процедуры неопределены'
		select @Result = @@error if @Result <> 0 goto Err
		goto OK	
	end

	select @Cls1 = dbo.PDX_CLSGrGet ('RIK_CategoryName_INVKOM_PRO'),
			@Cls2 = dbo.PDX_CLSGrGet ('RIK_CategoryName_SOVDIR_PRO'),

			@Cls_9 = dbo.PDX_CLSGet('RIK_CategoryName_VHOD_VNESH'),
			@Cls_10 = dbo.PDX_CLSGet('RIK_CategoryName_VHOD_VNUTR')

	select @Result = @@error if @Result <> 0 goto Err

	
	select @UserName = Name + ' <' + UserID + '>;'
	from dbo.Users where UserID = @UserID
	select @Result = @@error if @Result <> 0 goto Err

	select @UserName = ltrim(rtrim(isnull(@UserName,''))),
			@Comm = ltrim(rtrim(isnull(@Comm,'')))
	select @Result = @@error if @Result <> 0 goto Err

/*	30 - подписание
	40 - На утверждение
	50 - ознакомление
	10 - На согласование
	20 - На рецензию
	60 - на контроле
	70 - к исполнению
*/

	--подписание / утв  / ознакомл
	INSERT INTO #dcs
		(DocID,
		ClassDoc,
		Type,
		dtDate)
	SELECT 
		DocID, 
		ClassDoc,
		1,
		DateActive
	FROM dbo.Docs	
	WHERE 
		CHARINDEX('<' + @UserID + '>', NameAproval) > 0 
		AND ClassDoc in (@Cls_9, @Cls_10) 
		AND UPPER(ISNULL(IsActive, '')) = 'Y'
		AND NOT (ISNULL(StatusCompletion, '') IN ('1', '0')) 
		AND isnull(StatusDevelopment,'') <> '0'
		AND ltrim(rtrim(isnull(NameApproved,''))) = ''
		AND dbo.PDX_CompareReconcilationList(ListToReconcile, ListReconciled) = 1

		AND convert(datetime,convert(varchar(100),DateActive,104),104) between 
			convert(datetime,convert(varchar(100),@DateFrom,104),104) and convert(datetime,convert(varchar(100),@DateTo,104),104)
	select @Result = @@error if @Result <> 0 goto Err

	INSERT INTO #dcs --ознакомление2
		(DocID,
		ClassDoc,
		Type,
		dtDate)
	SELECT 
		DocID, 
		ClassDoc,
		2,
		isnull(DateApproved,DateActive)
	FROM dbo.Docs 
	where CHARINDEX('<' + @UserID + '>', ListToView) > 0  
		and CHARINDEX('<' + @UserID + '>-', ListToView)<=0
		and upper(isnull(isActive,'')) = 'Y' 
		and (isnull(NameAproval,'') = '' or isnull(NameApproved,'') <> '')
		and (isnull(LocationPath,'') = '' or isnull(LocationPath,'') like '%+%')
		AND NOT (ISNULL(StatusCompletion, '') IN ('1', '0')) 
		AND isnull(StatusDevelopment,'') <> '0'
		AND not (ClassDoc like @Cls1 + '%' or 
				ClassDoc like @Cls2 + '%')
		AND convert(datetime,convert(varchar(100),isnull(DateApproved,DateActive),104),104) between 
			convert(datetime,convert(varchar(100),@DateFrom,104),104) and convert(datetime,convert(varchar(100),@DateTo,104),104)	
	select @Result = @@error if @Result <> 0 goto Err

	select * from #dcs
	order by Type, dtDate	
	select @Result = @@error if @Result <> 0 goto Err

--select * from #dcs	

	--аля утверждение
	UPDATE D
		SET NameApproved = NameAproval,
			DateApproved = getdate(),
			StatusDevelopment = '4'
	from dbo.Docs D
	inner join #dcs S on D.DocID = S.DocID and S.Type = 1
	select @Result = @@error if @Result <> 0 goto Err

	--аля ознакомление
	UPDATE D
		SET ListToView = replace(ListToView,'<' + @UserID + '>','<' + @UserID + '>-')
	from dbo.Docs D
	inner join #dcs S on D.DocID = S.DocID and S.Type = 2
	where len(D.ListToview) < 1024
	select @Result = @@error if @Result <> 0 goto Err


	insert into dbo.Comments
		(UserID,
		UserName,
		ContactUserName,
		ContactUserID,
		PartnerName,
		DocID,
		DateCreation,
		DateEvent,
		DateEventEnd,
		Address,
		Subject,
		Comment,
		CommentType,
		SpecialInfo,
		FileName,
		--KeyField,
		PartnerID,
		Version,
		GUID,
		GUIDPartner,
		GUIDUser,
		GUIDDoc,
		Amount,
		FileNameOriginal,
		RIK_CommentType)
	select
		'Admin',--UserID,
		'System Administrator',--UserName,
		null,--ContactUserName,
		null,--ContactUserID,
		null,--PartnerName,
		DocID,--DocID,
		getdate(),--DateCreation,
		null,--DateEvent,
		null,--DateEventEnd,
		null,--Address,
		null,--Subject,
		'(VIEW)ОЗНАКОМЛЕНИЕ: ' + @UserName + '. ' + @Comm,
		'VIEWED',--CommentType,
		'',--SpecialInfo,
		null,--FileName,
		--KeyField,
		null,--PartnerID,
		null,--Version,
		newid(),--GUID,
		null,--GUIDPartner,
		null,--GUIDUser,
		null,--GUIDDoc,
		null,--Amount,
		null,--FileNameOriginal,
		null--RIK_CommentType
	from #dcs
	select @Result = @@error if @Result <> 0 goto Err

OK:
	drop table #dcs
	return @Result
Err:
	
	drop table #dcs
	return @Result

GO
/****** Object:  StoredProcedure [dbo].[PDX_SetShCodeByKF] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_SetShCodeByKF]			
	@KF int,
	@SHCode varchar(128),
	@Place varchar(128),
	@UserID varchar(24),
	@UserName varchar(96),
	@RoleID varchar(24),
	@RoleName varchar(96)
as
	declare @UName varchar(96), @RName varchar(96), @Mask varchar(128)
	set @KF = ISNULL(@KF,0)
	set @SHCode = ltrim(isnull(@SHCode,''))
	set @Place = ltrim(isnull(@Place,''))
	set @UserID = ltrim(isnull(@UserID,''))
	set @UserName = ltrim(isnull(@UserName,''))
	set @RoleID = ltrim(isnull(@RoleID,''))
	set @RoleName = ltrim(isnull(@RoleName,''))
	
	if @KF > 0 and @UserID <> ''
	begin
		set @UName = dbo.User_PaydoxLoginByParam(@UserID,@UserName)
		set @RName = ''
		if @RoleID <> ''
		begin
			set @RName = ' / ' + dbo.User_PaydoxLoginByParam(@RoleID,@RoleName)
		end 

		select
			@Mask = right('000' + dbo.PDX_SubstringReturn(ActDoc, CHARINDEX('<',ActDoc), charindex('>',ActDoc)),3) + '[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]'
		from dbo.PDXShCode 
		where KeyField = @KF
	
		If @SHCode like @Mask or @SHCode = ''
		begin
			update dbo.PDXShCode 
				set Code =@SHCode,
				Place = @Place,
				DLM = getdate(),
				NLM = @UName + @RName
			where KeyField = @KF

			select '' as Err
		end
		else
		begin
			select 'Штрихкод не соответствует маске' as Err
		end 
		
	end
	else
	begin
		select 
			case @UserID when '' then 'Не получилось определить текущего пользователя<br>' else '' end +
			case when @KF <= 0  then 'Не получилось определить штрихкод, который редактируется<br>' else '' end as Err
	end

GO
/****** Object:  StoredProcedure [dbo].[PDX_SHCodeRefresh] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE proc [dbo].[PDX_SHCodeRefresh]
	@DocID varchar(128),
	@UserID varchar(24),
	@UserName varchar(96),
	@RoleID varchar(24),
	@RoleName varchar(96)
	
as
declare @DocIDInt int, @ClassDoc varchar(128), @ClassConst varchar(128),
@PN1 varchar(1024), @PN2 varchar(1024), @ActDoc1 varchar(128), @ActDoc2 varchar(128),
@isApr bit,@isReg bit, @UName varchar(128), @RName varchar(128), @OI1 tinyint, @OI2 tinyint, @OI tinyint,
@isExists bit

    set @UserID = ltrim(isnull(@UserID,''))
	set @UserName = ltrim(isnull(@UserName,''))
	set @RoleID = ltrim(isnull(@RoleID,''))
	set @RoleName = ltrim(isnull(@RoleName,''))
	set @OI1 = 1
	set @OI2 = 2
	
	set @UName = dbo.User_PaydoxLoginByParam(@UserID,@UserName)
	set @RName = ''
	if @RoleID <> ''
	begin
		set @RName = ' / ' + dbo.User_PaydoxLoginByParam(@RoleID,@RoleName)
	end 
		
	select
		@DocIDInt = DocIDInt,
		@ClassDoc = ClassDoc,
		@PN2 = PartnerName,
		@PN1 = UserFieldText8,
		@isApr = case when IsActive = 'Y' and isnull(StatusDevelopment,'') = '4' and not isnull(StatusCompletion,'') = '0'
					then 1
				else 0
				end,
		@isReg = case when LocationPath like '%+%' then 1 else 0 end
	from dbo.Docs
	where DocID = @DocID
	
	if @isApr = 1 and @isReg = 1 or exists (select top 1 1 from dbo.PDXSHCode where DocIDInt = @DocIDInt and isDel = 0)
	begin	
		select 
			@PN2 = rtrim(isnull(@PN2,'')),
			@PN1 = rtrim(isnull(@PN1,''))
		select @ClassConst = ConstName from dbo.PDXDocTypesConst where DocType = @ClassDoc
		/*select @ActDoc1 = ActDoc from dbo.Partners where Name = @PN1
		select @ActDoc2 = ActDoc from dbo.Partners where Name = @PN2*/
		select top 1 @ActDoc1 = Field2 from dbo.UserDirValues where UDKeyField = 239 and Field1 = @PN1
		select top 1 @ActDoc2 = Field2 from dbo.UserDirValues where UDKeyField = 239 and Field1 = @PN2
		
		select
			@ActDoc1 = isnull(@ActDoc1,''),
			@ActDoc2 = isnull(@ActDoc2,'')
			
		If @ClassConst in ('RIK_CategoryName_DOGOVORY_B',
							'RIK_CategoryName_DOGOVORY_C',
							'RIK_CategoryName_DOGOVORY_E',
							'RIK_CategoryName_DOGOVORY_F',
							'RIK_CategoryName_DOGOVORY_H',
							'RIK_CategoryName_DOGOVORY_L',
							'RIK_CategoryName_DOGOVORY_M',
							'RIK_CategoryName_DOGOVORY_P',
							'RIK_CategoryName_DOGOVORY_S',
							'RIK_CategoryName_DOGOVORY_T',
							'RIK_CategoryName_DOGOVORY_X',
							'RIK_CategoryName_DOGOVORY_Y',
							'RIK_CategoryName_DOGOVORY_Z')
		begin
		
			update dbo.PDXSHCode
			set isDel = 1,
				NLM = @UName+@RName,
				DLM = GETDATE()
			where DocIDInt = @DocIDInt
				and not ((PartnerName = @PN1 and ActDoc = @ActDoc1) or (PartnerName = @PN2 and ActDoc = @ActDoc2))
				and isDel = 0
			
			If @PN1 <> '' and exists (select 1 from dbo.Activities where Name = @ActDoc1)
			begin
				select @OI = null, @isExists = 0
				select @OI = OI, @isExists = 1 from dbo.PDXSHCode where DocIDInt = @DocIDInt and isDel = 0 and PartnerName = @PN1 and ActDoc= @ActDoc1
				if @isExists = 0
				begin
					insert into dbo.PDXSHCode 
						(ActDoc,PartnerName,Code,Place,DocIDInt,DC,NC,DLM,NLM, isDel, OI)
					values
						(@ActDoc1,@PN1,'','',@DocIDInt, GETDATE(),@UName+@RName,GETDATE(),@UName+@RName,0, @OI1)
				end
				else if isnull(@OI,0) <> @OI1
				begin	
					update dbo.PDXSHCode 
						set OI = @OI1
					where DocIDInt = @DocIDInt
						and ActDoc = @ActDoc1
						and PartnerName = @PN1
						and isDel = 0
				end
				
			end
			If @PN2 <> '' and exists (select 1 from dbo.Activities where Name = @ActDoc2)
			begin
				select @OI = null, @isExists = 0
				select @OI = OI, @isExists = 1 from dbo.PDXSHCode where DocIDInt = @DocIDInt and isDel = 0 and PartnerName = @PN2 and ActDoc = @ActDoc2
				if @isExists = 0
				begin
					insert into dbo.PDXSHCode 
						(ActDoc,PartnerName,Code,Place,DocIDInt,DC,NC,DLM,NLM, isDel, OI)
					values
						(@ActDoc2,@PN2,'','',@DocIDInt, GETDATE(),@UName+@RName,GETDATE(),@UName+@RName,0, @OI2)
				end
				else if isnull(@OI,0) <> @OI1
				begin	
					update dbo.PDXSHCode 
						set OI = @OI2
					where DocIDInt = @DocIDInt
						and ActDoc = @ActDoc2
						and PartnerName = @PN2
						and isDel = 0
				end
			end
		
		end
	end



GO
/****** Object:  StoredProcedure [dbo].[PDX_SovetDirectorovProCreate] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_SovetDirectorovProCreate]
	@DocID varchar(128),
	@NewDocID varchar(128),
	@NameCreation varchar(255),
	@Predsedatel varchar(255),
	@Secretar varchar(255),
	@ClassDocPr varchar(255),
	@ClassDocPv varchar(255),
	@ClassDocR varchar(255),
	@ClassDocV varchar(255)
	
as
declare 
	@Res int,
	@FileNamePrefix varchar(255),
	@FileName1 varchar(255),
	@FileNameNameLastModification varchar(1024),
	@FileNameDateLastAccessed datetime,
	@FileNameDateLastModification datetime,
	@Date datetime,
	@ListToReconcile varchar(1024)

declare @TmpID table
	(DID varchar(255),
	Ind int identity)	
	
select @Res = 0
	select @FileNamePrefix = cast(replace(cast(NEWID() as varchar(40)),'-','') as varchar(24))
	select @Res = @@error if @Res <> 0 goto Err

	select @FileName1 = ''
	select @Res = @@error if @Res <> 0 goto Err

	select @FileNameNameLastModification = ''
	select @Res = @@error if @Res <> 0 goto Err

	select @FileNameDateLastAccessed = null
	select @Res = @@error if @Res <> 0 goto Err

	select @FileNameDateLastAccessed = null
	select @Res = @@error if @Res <> 0 goto Err

	/*select @InventoryUnit = ''
	select @Res = @@error if @Res <> 0 goto Err

	select @BusinessProcessStep = ''
	select @Res = @@error if @Res <> 0 goto Err

	select @CurrencyRate = null
	select @Res = @@error if @Res <> 0 goto Err

	*/select @Date = '1900-02-01 00:00:00.000'
	select @Res = @@error if @Res <> 0 goto Err

	if exists (select 1 from dbo.Docs where DocID = @DocID and ClassDoc = @ClassDocPv)--существует повестка
	begin
		if not exists (select 1 from dbo.Docs where DocIDParent = @DocID
						and ClassDoc = @ClassDocPr)
		begin
			if not exists (select 1 from dbo.Docs where DocID = @NewDocID)
			begin --протокол

                select top 1 @ListToReconcile = Field2
				from dbo.UserDirValues 
				where UDKeyField = 34
					and Field3 = @ClassDocPr
				select @Res = @@error if @Res <> 0 goto Err
				select @ListToReconcile = ltrim(rtrim(isnull(@ListToReconcile,'')))
				select @Res = @@error if @Res <> 0 goto Err
				
				insert into dbo.Docs
					(DocID,
					GUID,
					DocIDadd,
					DocIDIncoming,
					DocIDParent,
					DocIDPrevious,
					Author,
					Correspondent,
					Resolution,
					History,
					Result,
					PercentCompletion,
					Department,
					Name,
					Description,
					LocationURL,
					LocationPaper,
					FileNamePrefix,
					FileName,
					FileNameNameLastModification,
					FileNameDateLastAccessed,
					FileNameDateLastModification,
					LocationPath,
					ExtInt,
					PartnerName,
					StatusDevelopment,
					StatusPayment,
					StatusArchiv,
					StatusCompletion,
					StatusDelivery,
					TypeDoc,
					ClassDoc,
					ActDoc,
					InventoryUnit,
					PaymentMethod,
					AmountDoc,
					QuantityDoc,
					DateActivation,
					SecurityLevel,
					DateCreation,
					DateCompletion,
					DateCompleted,
					DateExpiration,
					NameCreation,
					NameAproval,
					NameApproved,
					DateApproved,
					ListToEdit,
					ListToReconcile,
					ListReconciled,
					NameResponsible,
					NameControl,
					NameLastModification,
					DateLastModification,
					UserFieldText1,
					UserFieldText2,
					UserFieldText3,
					UserFieldText4,
					UserFieldText5,
					UserFieldText6,
					UserFieldText7,
					UserFieldText8,
					UserFieldMoney1,
					UserFieldMoney2,
					UserFieldDate1,
					UserFieldDate2,
					UserFieldDate3,
					UserFieldDate4,
					UserFieldDate5,
					UserFieldDate6,
					UserFieldDate7,
					UserFieldDate8,
					IsActive,
					DateActive,
					BusinessProcessStep,
					ExtPassword,
					DateSigned,
					Currency,
					CurrencyRate,
					Rank,
					ListToView,
					Content)
				select
					@NewDocID,--DocID,
					NewID(),--GUID,
					'',--DocIDAdd,--DocIDadd,
					'',--DocIDIncoming,--DocIDIncoming,
					@DocID,--DocIDParent,
					'',--DocIDPrevious,--DocIDPrevious,
					Author,--Author,
					Correspondent,--!!!!Correspondent,
					null,--Resolution,--Resolution,
					'',--,--History,--History,
					'',--Result,--Result,
					null,--PercentCompletion,--PercentCompletion,
					Department,--Department,
					'',--Name,--Name,
					Description,--!!!!!!!!!!!111Description,
					null,--LocationURL,--LocationURL,
					null,--LocationPaper,--LocationPaper,
					@FileNamePrefix,--FileNamePrefix,
					@FileName1,--FileName,
					@FileNameNameLastModification,-- FileNameNameLastModification,
					@FileNameDateLastAccessed, --FileNameDateLastAccessed,
					@FileNameDateLastModification, --FileNameDateLastModification,
					null,--LocationPath, --LocationPath,
					'',--ExtInt,-- ExtInt,
					'',--PartnerName,-- PartnerName,
					'1',--@StatusDevelopment, -- StatusDevelopment,
					'',--@StatusPayment,-- StatusPayment,
					'',--@StatusArchiv,-- StatusArchiv,
					'',--@StatusCompletion,-- StatusCompletion,
					null,--@StatusDelivery,-- StatusDelivery,
					'',--TypeDoc,-- TypeDoc,
					@ClassDocPr,--@ClassDoc,-- ClassDoc,
					'',--ActDoc,-- ActDoc,
					'',--InventoryUnit,-- InventoryUnit,
					'',--PaymentMethod,-- PaymentMethod,
					0,--AmountDoc,-- AmountDoc,
					0,--QuantityDoc,-- QuantityDoc,
					@Date,--DateActivation,--DateActivation,
					'4',--@SecurityLevel,-- SecurityLevel,
					getdate(),--@DateCreation,-- DateCreation,
					DateCompletion,-- DateCompletion,
					null,--@DateCompleted,-- DateCompleted,
					@Date,--DateExpiration, --DateExpiration,
					@NameCreation, --NameCreation,
					@Predsedatel,--@NameAproval, --NameAproval,
					'',--@NameApproved, --NameApproved
					null,--@DateApproved, --DateApproved
					'',--ListToEdit, -- ListToEdit
					@ListToReconcile,--@ListToReconcile, --ListToReconcile
					'',--@ListReconciled, --ListReconciled
					'',--NameResponsible, -- NameResponsible
					NameControl, -- NameControl
					@NameCreation, --NameLastModification,
					getdate(),--DateLastModification,
					'',--@UserFieldText1, --UserFieldText1
					'',--@UserFieldText2, -- UserFieldText2
					'',--@UserFieldText3,  --UserFieldText3
					'',--@UserFieldText4, --UserFieldText4
					'',--@UserFieldText5, -- UserFieldText5
					'',--@UserFieldText6, -- UserFieldText6
					'',--@UserFieldText7, -- UserFieldText7
					'',--@UserFieldText8, -- UserFieldText8
					0,--@UserFieldMoney1, --UserFieldMoney1
					0,--@UserFieldMoney2,--UserFieldMoney2
					@Date,--@UserFieldDate1, --UserFieldDate1
					@Date,--@UserFieldDate2, --UserFieldDate2
					@Date,--@UserFieldDate3,--UserFieldDate3
					@Date,--@UserFieldDate4, --UserFieldDate4
					@Date,--@UserFieldDate5, --UserFieldDate5
					@Date,--@UserFieldDate6, --UserFieldDate6
					@Date,--@UserFieldDate7, --UserFieldDate7
					@Date,--@UserFieldDate8, --UserFieldDate8
					'Y',--@IsActive, -- IsActive
					null,--@DateActive, --DateActive
					'',--BusinessProcessStep, --BusinessProcessStep
					'',--@ExtPassword, -- ExtPassword
					null,--@DateSigned, --DateSigned
					'',--Currency, --Currency
					null,--CurrencyRate, --CurrencyRate
					'',--Rank, --Rank
					'',--ListToView, --ListToView
					''--Content -- Content
				from dbo.Docs 
				where DocID = @DocID
				select @Res = @@error if @Res <> 0 goto Err
			
				--решения
				insert into @TmpID
					(DID)
				select
					DocID
				from dbo.Docs 
				where DocIDParent = @DocID
					and ClassDoc = @ClassDocV
				order by QuantityDoc
				select @Res = @@error if @Res <> 0 goto Err
	
				insert into dbo.Docs
					(DocID,
					GUID,
					DocIDadd,
					DocIDIncoming,
					DocIDParent,
					DocIDPrevious,
					Author,
					Correspondent,
					Resolution,
					History,
					Result,
					PercentCompletion,
					Department,
					Name,
					Description,
					LocationURL,
					LocationPaper,
					FileNamePrefix,
					FileName,
					FileNameNameLastModification,
					FileNameDateLastAccessed,
					FileNameDateLastModification,
					LocationPath,
					ExtInt,
					PartnerName,
					StatusDevelopment,
					StatusPayment,
					StatusArchiv,
					StatusCompletion,
					StatusDelivery,
					TypeDoc,
					ClassDoc,
					ActDoc,
					InventoryUnit,
					PaymentMethod,
					AmountDoc,
					QuantityDoc,
					DateActivation,
					SecurityLevel,
					DateCreation,
					DateCompletion,
					DateCompleted,
					DateExpiration,
					NameCreation,
					NameAproval,
					NameApproved,
					DateApproved,
					ListToEdit,
					ListToReconcile,
					ListReconciled,
					NameResponsible,
					NameControl,
					NameLastModification,
					DateLastModification,
					UserFieldText1,
					UserFieldText2,
					UserFieldText3,
					UserFieldText4,
					UserFieldText5,
					UserFieldText6,
					UserFieldText7,
					UserFieldText8,
					UserFieldMoney1,
					UserFieldMoney2,
					UserFieldDate1,
					UserFieldDate2,
					UserFieldDate3,
					UserFieldDate4,
					UserFieldDate5,
					UserFieldDate6,
					UserFieldDate7,
					UserFieldDate8,
					IsActive,
					DateActive,
					BusinessProcessStep,
					ExtPassword,
					DateSigned,
					Currency,
					CurrencyRate,
					Rank,
					ListToView,
					Content)
				select
					@NewDocID + '-' + replicate('0',2-len(cast(Ind as varchar(100)))) + cast(Ind as varchar(100)),--DocID,
					NewID(),--GUID,
					'',--DocIDAdd,--DocIDadd,
					'',--DocIDIncoming,--DocIDIncoming,
					@NewDocID,--DocIDParent,
					DocID,--DocIDPrevious,--DocIDPrevious,
					Author,--!!!!!!!Author,
					Correspondent,--!!!!Correspondent,
					'',--Resolution,--Resolution,
					History,--History,
					null,--Result,--Result,
					null,--PercentCompletion,--PercentCompletion,
					'',--Department,
					'',--Name,
					Description,--!!!!!!!!!!!111Description,
					null,--,--LocationURL,
					null,--LocationPaper,--LocationPaper,
					@FileNamePrefix,--FileNamePrefix,
					@FileName1,--FileName,
					@FileNameNameLastModification,-- FileNameNameLastModification,
					@FileNameDateLastAccessed, --FileNameDateLastAccessed,
					@FileNameDateLastModification, --FileNameDateLastModification,
					null, --LocationPath,
					'',-- ExtInt,
					'',-- PartnerName,
					'1',--@StatusDevelopment, -- StatusDevelopment,
					'',--@StatusPayment,-- StatusPayment,
					'',--@StatusArchiv,-- StatusArchiv,
					'',--@StatusCompletion,-- StatusCompletion,
					null,--@StatusDelivery,-- StatusDelivery,
					TypeDoc,-- TypeDoc,
					@ClassDocR,--@ClassDoc,-- ClassDoc,
					'',-- ActDoc,
					'',--InventoryUnit,-- InventoryUnit,
					'',--PaymentMethod,-- PaymentMethod,
					0,--AmountDoc,-- AmountDoc,
					QuantityDoc,-- QuantityDoc,
					@Date,--DateActivation,--DateActivation,
					'4',--@SecurityLevel,-- SecurityLevel,
					getdate(),--@DateCreation,-- DateCreation,
					@Date,--DateCompletion,-- DateCompletion,
					null,--@DateCompleted,-- DateCompleted,
					@Date,--DateExpiration, --DateExpiration,
					@NameCreation, --NameCreation,
					'',--@NameAproval, --NameAproval,
					null,--@NameApproved, --NameApproved
					null,--@DateApproved, --DateApproved
					replace(ListToView,'>-;','>;') + 
					case charindex(@Secretar,replace(ListToView,'>-;','>;')) when 0 then char(13) + char(10) + @Secretar else '' end, -- ListToEdit
					'',--@ListToReconcile, --ListToReconcile
					'',--@ListReconciled, --ListReconciled
					'',--NameResponsible, -- NameResponsible
					@Secretar,--NameControl, -- NameControl
					@NameCreation, --NameLastModification,
					getdate(),--DateLastModification,
					'',--@UserFieldText1, --UserFieldText1
					'',--@UserFieldText2, -- UserFieldText2
					'',--@UserFieldText3,  --UserFieldText3
					'',--@UserFieldText4, --UserFieldText4
					'',--@UserFieldText5, -- UserFieldText5
					'',--@UserFieldText6, -- UserFieldText6
					'',--@UserFieldText7, -- UserFieldText7
					'',--@UserFieldText8, -- UserFieldText8
					0,--@UserFieldMoney1, --UserFieldMoney1
					0,--@UserFieldMoney2,--UserFieldMoney2
					@Date,--@UserFieldDate1, --UserFieldDate1
					@Date,--@UserFieldDate2, --UserFieldDate2
					UserFieldDate3,--UserFieldDate3
					@Date,--@UserFieldDate4, --UserFieldDate4
					@Date,--@UserFieldDate5, --UserFieldDate5
					@Date,--@UserFieldDate6, --UserFieldDate6
					@Date,--@UserFieldDate7, --UserFieldDate7
					@Date,--@UserFieldDate8, --UserFieldDate8
					'Y',--@IsActive, -- IsActive
					null,--@DateActive, --DateActive
					'',--BusinessProcessStep, --BusinessProcessStep
					'',--@ExtPassword, -- ExtPassword
					null,--@DateSigned, --DateSigned
					Currency, --Currency
					null,--CurrencyRate, --CurrencyRate
					'',--Rank, --Rank
					case 
						when not ltrim(rtrim(isnull(ListToEdit,'') + isnull(Author,'') + isnull(Correspondent,''))) like '%<' + dbo.PDX_SubstringReturn(NameCreation,charindex('<',NameCreation),charindex('>',NameCreation)) + '>%'
							then NameCreation + char(13) + char(10)
						else ''
					end  + 
					case 
						when isnull(NameResponsible,'') <> '' and not ltrim(rtrim(isnull(ListToEdit,'') + isnull(Author,'') + isnull(Correspondent,'') + isnull(NameCreation,''))) like '%<' + dbo.PDX_SubstringReturn(NameResponsible,charindex('<',NameResponsible),charindex('>',NameResponsible)) + '>%'
							then NameResponsible + char(13) + char(10)
						else ''
					end,	--'',--ListToView, --ListToView
					Content -- Content
				from dbo.Docs D
				inner join @TmpID T on T.DID = D.DocID
				where DocIDParent = @DocID
					and ClassDoc = @ClassDocV
				select @Res = @@error if @Res <> 0 goto Err
				
				select '' as res, '' as DocID
				select @Res = @@error if @Res <> 0 goto Err
			end
			else 
			begin
				select 
					'Документ с таким номером уже существует' as res,
					DocID
				from dbo.Docs where DocID = @NewDocID
				select @Res = @@error if @Res <> 0 goto Err
			end
		end
		else
		begin	
			select 
				'Протокол к этой повестке уже существует' as res,
				DocID
			from dbo.Docs where DocIDParent = @DocID
						and ClassDoc = @ClassDocPr
			select @Res = @@error if @Res <> 0 goto Err
		end
	end
	else
	begin	
		select 'Указанный документ не существует' as res
		select @Res = @@error if @Res <> 0 goto Err		
	end
	

	return @Res
Err:
	
	return @Res
GO
/****** Object:  StoredProcedure [dbo].[PDX_SovetDirectorovVypiska] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_SovetDirectorovVypiska]
	@DocIDParent varchar(255),
	@DocID varchar(255),
	@ClassDoc varchar(255),
	@SDMembers varchar(4000)=null,
	@SDPredsedatel varchar(500)=null,
	@SDSecretar varchar(500)=null
as
	declare @Result int
	set @Result = 0
	
	declare 
		@UserList varchar(2048),
		@Ind int,
		@OneValue varchar(255),
		@UserRes varchar(4000),
		@UserNameOUT varchar(255),
		@Type int

	declare @TblRes table
    --create table @TblRes
		(DocID varchar(255),
		UserFieldText1 varchar(1024),
		Author varchar(255),
		Correspondent varchar(4000), --приглашенные
		ListToView varchar(1024), --члены СД ИСД
		UserFieldText5 varchar(4000), --рассылка
		NameControl varchar(255),
		Type int default 0,
		Name varchar(1024),
		Ind int,
		NameLastModification varchar(512),
		DateLastModification datetime,
		DateCreation datetime,
		UserFieldText2 ntext)

	declare @TableTmp table
		(UserList varchar(2048),
		Type int)
	
	--получаем карточки решений
	insert into @TblRes
		(DocID, UserFieldText1, UserFieldText2, Author, Correspondent, ListToView, UserFieldText5, Name, NameControl, Ind,
		NameLastModification, DateLastModification, DateCreation)
	select 
		DocID,
		replace(isnull(UserFieldText1,''),char(13) + char(10),'<br>') as 'Обсуждали',
		/*isnull(UserFieldText2,'') + isnull(UserFieldText3,'')*/isnull(Content,'') as 'Решили',
		Author,
		replace(Correspondent,'===Добавлены==================================================',''), --приглашенные
		replace(ListToEdit,'===Добавлены==================================================',''),
		replace(ListToView,'===Добавлены==================================================',''), --рассылка будет
		Description,
		NameControl,
		cast(QuantityDoc as int),
		NameLastModification,
		DateLastModification,
		DateCreation
	from dbo.Docs with (nolock)
	where DocIDParent = @DocIDParent 
		and ClassDoc = @ClassDoc
		and (DocID = @DocID or @DocID = '')
	order by DocID
	select @Result = @@error if @Result <> 0 goto Err

	--!!!!НЕ работает для документов созданных до 11,07,2007
	if exists (select 1 from @TblRes where convert(datetime,convert(varchar(100),DateCreation,104),104) < '2007-07-01')
	begin 
		delete from @TblRes
		select @Result = @@error if @Result <> 0 goto Err
		goto Res
	end
	select @Result = @@error if @Result <> 0 goto Err

--формируем списки пользователей,котрые е=нужно вывести на документе
	--члены сд исд (из протокола)
	insert into @TableTmp (UserList,Type)
	select
		case isnull(charindex('===Добавлены==================================================',Correspondent),0)
			when 0 
				then Correspondent
			else left(Correspondent,charindex('===Добавлены==================================================',Correspondent)-1)
		end,5
	from dbo.Docs
	where DocID = @DocIDParent
	select @Result = @@error if @Result <> 0 goto Err

	--секретарь (из протокола)
	insert into @TableTmp (UserList,Type)
	select NameControl,1
	from dbo.Docs P
	where DocID = @DocIDParent
	select @Result = @@error if @Result <> 0 goto Err

	--УДАЛИТЬ ИЗ ЧЛЕНОВ СД секретаря
	update @TableTmp
		set UserList = replace(UserList,(select replace(UserList,';','') from @TableTmp where Type = 1),'')
	where Type = 5
	select @Result = @@error if @Result <> 0 goto Err

	--председатель
	insert into @TableTmp (UserList,Type)
	select
		D.NameAproval,6
	from dbo.Docs D
	where D.DocID = @DocIDParent
	select @Result = @@error if @Result <> 0 goto Err

	--ген. директор РИК(из протокола)
	insert into @TableTmp (UserList,Type)
	select
		D.Author,7
	from dbo.Docs D
	where D.DocID = @DocIDParent
	select @Result = @@error if @Result <> 0 goto Err

	If isnull(@DocID,'') <> ''
	begin
		--список рассылка
		insert into @TableTmp (UserList,Type)
		select distinct UserFieldText5,4
		from @TblRes
		where not UserFieldText5 is null
		select @Result = @@error if @Result <> 0 goto Err
	end
	Else
	begin	
		--приглашенные
		insert into @TableTmp (UserList,Type)
		select distinct Correspondent,3
		from @TblRes
		where not Correspondent is null
		select @Result = @@error if @Result <> 0 goto Err
	
		--докладчики
		insert into @TableTmp (UserList,Type)
		select distinct Author,2
		from @TblRes
		where not Author is null
		select @Result = @@error if @Result <> 0 goto Err
	end

--разбор списков пользователей (по-фамильно)
	insert into @TblRes
		(UserFieldText5, Type)
	select distinct '',Type
	from @TableTmp
	where Type <> 0
	select @Result = @@error if @Result <> 0 goto Err

	while exists (select 1 from @TableTmp)
	begin
		select top 1 
			@UserList = UserList,
			@Type = Type
 		from @TableTmp
		select @Result = @@error if @Result <> 0 goto Err

		delete @TableTmp
		where UserList = @UserList and @Type = Type
		select @Result = @@error if @Result <> 0 goto Err

		while len(@UserList) <> 0
		begin
			select @Ind = 0,@OneValue = ''
			select @Result = @@error if @Result <> 0 goto Err
			select @Ind = charindex(';',@UserList,1)
			select @Result = @@error if @Result <> 0 goto Err
			if @Ind = 0 select @Ind = len(@UserList)
			select @Result = @@error if @Result <> 0 goto Err
		
			select @OneValue = substring(@UserList,1,@Ind)
			select @Result = @@error if @Result <> 0 goto Err
			select @UserList = replace(@UserList,@OneValue,'')
			select @Result = @@error if @Result <> 0 goto Err

			select @UserNameOUT = ''
			exec dbo.PDX_FullUserNameGet 
				@UserNameIN = @OneValue,
		    	@UserNameOUT = @UserNameOUT out,
				@Type = 1
			if @Result <> 0 goto Err

			update @TblRes
				set UserFieldText5 = UserFieldText5 + ' ' + @UserNameOUT + '<br>'
			where Type = @Type
			and not UserFieldText5 like '%' + @UserNameOUT + '%'
			select @Result = @@error if @Result <> 0 goto Err
		end		
	end

	--информация о дате последнего изменения и пользователе
	insert into @TblRes
		(UserFieldText5, Type, DateLastModification)
	select 
		'Изменено: ' + T.NameLastModification + ' ' + convert(varchar(100),T.DateLastModification,104) + ' ' + convert(varchar(100),T.DateLastModification,114), -100, 
		DateLastModification
	from (
		select top 1 * from @TblRes T where Type = 0
		order by DateLastModification desc) as T
	select @Result = @@error if @Result <> 0 goto Err

	--уточнем инфу по последнему изменению
	update T
	set UserFieldText5 =  
						case when T.DateLastModification < P.DateCreation
								then 'Изменено: ' + P.UserName + ' <' + P.UserID + '> ' + convert(varchar(100),P.DateCreation,104) + ' ' + convert(varchar(100),P.DateCreation,114)
							else T.UserFieldText5
						end
	from @TblRes T
	inner join ( 
		select top 1 *
		from dbo.Comments  with (nolock) 
		where (DocID in (select distinct DocID from @TblRes)
				or DocID = case isnull(@DocID,'') when '' then @DocIDParent else '' end)
			and CommentType in ('CHECKINOUT','FILE')
		order by DateCreation desc
		) as P on 1 = 1
	where T.Type = -100
	select @Result = @@error if @Result <> 0 goto Err

Res:
	select * from @TblRes
	order by Type desc, Ind
	select @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_SovetDirectorovVypiskaEmail] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_SovetDirectorovVypiskaEmail]
	@DocIDParent varchar(255),
	@DocID varchar(255),
	@ClassDoc varchar(255),
	@SDMembers varchar(2000),
	@SDPredsedatel varchar(500),
	@SDSecretar varchar(500),
	@Emails varchar(512) = ''
as
declare @Result int
	set @Result = 0
	
	declare 
		@UserList varchar(2048),
		@OneValue varchar(1024),
		@email  varchar(2048),
		@Users varchar(2048)

	declare @TblRes table
		(DocID varchar(255),
		UserList varchar(2048),
		Email varchar(4000),
		FileName varchar(255),
		FileDescr varchar(255),
		FileType varchar(255),
		FileExists int default 0,
		Type int,
		isPRCL int)

	declare @TableTmp table
		(UserList varchar(2048),
		DocID  varchar(255),
		isPRCL int,
		DateCreation datetime)
	
	if isnull(@DocIDParent,'') = '' goto Res
	select @Result = @@error if @Result <> 0 goto Err

--списки пользователей
--сд исд + рассылка + приглашенные + автор
	insert into @TableTmp (UserList,DocID,isPRCL,DateCreation)
	select distinct 
		case DocID 
			when @DocIDParent
				then @SDPredsedatel + @SDMembers + @SDSecretar 
			else ''
		end + isnull(ListToView,'') + isnull(Correspondent,'') +
		isnull(Author,''), DocID,
		case DocID
			when @DocIDParent
				then 1
			else 0
		end, DateCreation
	from dbo.Docs with (nolock)
	where (DocIDParent = @DocIDParent or DocID = @DocIDParent)
		--and ClassDoc = @ClassDoc
		and (DocID = @DocID or @DocID = '')
	order by DocID
	select @Result = @@error if @Result <> 0 goto Err

	--!!!!НЕ работает для документов созданных до 11,07,2007
	if exists (select 1 from @TableTmp where convert(datetime,convert(varchar(100),DateCreation,104),104) < '2007-07-12')
	begin 
		goto Res
	end
	select @Result = @@error if @Result <> 0 goto Err

    --файлы
	insert into @TblRes
		(DocID, Type, FileName, FileDescr,FileType, isPRCL)
	select
		DocID, 1, FileName, DocID + '_' + Version, substring(FileName,charindex('.',FileName), len(FileName)),
		case DocID
			when @DocIDParent
				then 1
			else 0
		end
	from dbo.Comments C with (nolock)
	where CommentType = 'FILE'
		and Amount = 0
		and isnull(FileName,'') <> ''
		and DocID in (select DocID from @TableTmp)
	select @Result = @@error if @Result <> 0 goto Err
  
	if exists (select 1 from @TableTmp where DocID = @DocIDParent)
	begin
		insert into @TblRes
			(DocID, Type, FileName, FileDescr,FileType, isPRCL, FileExists)
		select 
			@DocIDParent, R.Type, R.FileName, R.FileDescr, R.FileType, 1, 1
		from @TblRes R 
		where R.Type = 1
			and DocID <> @DocIDParent
		select @Result = @@error if @Result <> 0 goto Err
	end
	select @Result = @@error if @Result <> 0 goto Err

	if isnull(@Emails,'') <> '' --если есть конкретные email - ы отправляем на них
	begin
		--разбор списков пользователей
		insert into @TblRes
			(DocID, Type, email,isPRCL,UserList)
		select distinct DocID, 0, @Emails, isPRCL, @Emails
		from @TableTmp
		select @Result = @@error if @Result <> 0 goto Err
	end 
	else --if isnull(@emails,'') <> ''
	begin
		--списки пользователей
		--разбор списков пользователей
		insert into @TblRes
			(DocID, Type, email,isPRCL,UserList)
		select distinct DocID, 0, '', isPRCL, ''
		from @TableTmp
		select @Result = @@error if @Result <> 0 goto Err

		while exists (select 1 from @TableTmp)
		begin
			select top 1 
				@UserList = UserList,
				@DocID = DocID,
 				@email = '', @Users = ''
	 		from @TableTmp
			select @Result = @@error if @Result <> 0 goto Err
	
			delete @TableTmp
			where UserList = @UserList
				and DocID = @DocID
			select @Result = @@error if @Result <> 0 goto Err
	
			while charindex('<',@UserList)> 0 and  charindex('>',@UserList)> 0 
			begin
				select @OneValue = '', @email = '', @Users = ''
				select @OneValue = dbo.PDX_SubstringReturn (@UserList,charindex('<',@UserList),charindex('>',@UserList))
	  		    select @Result = @@error if @Result <> 0 goto Err
	
				select @UserList = replace(@UserList,'<' + @OneValue + '>','')
				select @Result = @@error if @Result <> 0 goto Err
				
				select @email = email, @Users = case len(Name)
													when len(replace(name,' ','')) + 2 --т.е. имя состоит из 3-х слов
														then substring(name,1,charindex(' ',name) -1) + ' ' + substring(Name,charindex(' ', name)+1,1) + '. ' + substring(reverse(name),charindex(' ',reverse(name))-1,1) + '.'
													else name
												end + '<' + UserID + '>; '
				from dbo.Users with (nolock) 
				where UserID = @OneValue
				select @Result = @@error if @Result <> 0 goto Err
	
				--ищем замов
				select @email = @email + ';' + z.email, 
					@Users = @Users + 
							case len(z.Name)
								when len(replace(z.name,' ','')) + 2 --т.е. имя состоит из 3-х слов
									then substring(z.name,1,charindex(' ',z.name) -1) + ' ' + substring(z.Name,charindex(' ', z.name)+1,1) + '. ' + substring(reverse(z.name),charindex(' ',reverse(z.name))-1,1) + '.'
								else z.name
							end + 
							'<' + z.UserID + '>; '
				from dbo.Users U with (nolock) 
				inner join dbo.Users Z with (nolock) on Z.UserID = U.DeputyID
				where U.UserID = @OneValue
					and getdate() between U.DeputyDateFrom and U.DeputyDateTo
				select @Result = @@error if @Result <> 0 goto Err
	
				update @TblRes
					set Email = email + ';' + @email
				where DocID= @DocID
				and not Email like '%' + @Email + '%'
				select @Result = @@error if @Result <> 0 goto Err		

				update @TblRes --отдельно так как по пайдокс email-s могут совпадать (начальник / руководитель)
					set UserList = UserList + @Users
				where DocID= @DocID
				and not UserList like '%' + @Users + '%'
				select @Result = @@error if @Result <> 0 goto Err		
			end		
		end
	end --if isnull(@emails,'') <> ''
Res:
	select DocID,isnull(Email,'') as Email,	FileName,FileDescr,	FileType,FileExists,
		Type,isPRCL,isnull(UserList,'') as UserList
	from @TblRes
	order by isPRCL, DocID, Type 
	select @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_SovetDirektorov_Email] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_SovetDirektorov_Email]
	@DocID varchar(250)
as

	declare @Result int
	set @Result = 0

	declare @TableList table
		(UserName varchar(1024))

	declare @TableTmp table
		(UserList varchar(4000),
		UID int identity)
	
	declare
		@OneValue varchar(1024),	
		@UserList varchar(4000),
		@Ind int,
		@UID int

	--совет директоров
	insert into @TableTmp (UserList)
	select Correspondent
	from dbo.Docs  with (nolock) 
	where DocID = @DocID
	select @Result = @@error if @Result <> 0 goto Err
	--приглашенные на вопросы
	insert into @TableTmp (UserList)
	select Correspondent
	from dbo.Docs  with (nolock)
	where DocIDParent = @DocID
		and ClassDoc = 'Совет директоров / Вопрос'
	select @Result = @@error if @Result <> 0 goto Err
	--докладчики по вопросам
	insert into @TableTmp (UserList)
	select Author
	from dbo.Docs  with (nolock)
	where DocIDParent = @DocID
		and ClassDoc = 'Совет директоров / Вопрос'
	select @Result = @@error if @Result <> 0 goto Err

	while exists (select 1 from @TableTmp)
	begin
		select top 1
			@UserList = ltrim(rtrim(isnull(UserList,''))),
			@UID = UID
		from @TableTmp
		select @Result = @@error if @Result <> 0 goto Err

		while len(@UserList) <> 0
		begin
			select @Ind = 0,@OneValue = ''
			select @Result = @@error if @Result <> 0 goto Err
			select @Ind = charindex(';',@UserList,1)
			select @Result = @@error if @Result <> 0 goto Err
			if @Ind = 0 select @Ind = len(@UserList)
			select @Result = @@error if @Result <> 0 goto Err
		
			select @OneValue = substring(@UserList,1,@Ind)
			select @Result = @@error if @Result <> 0 goto Err
			select @UserList = replace(@UserList,@OneValue,'')
			select @Result = @@error if @Result <> 0 goto Err

			if not exists (select 1 from @TableList where UserName = replace(@OneValue,';',''))
			begin
				insert into @TableList (UserName)
    			values (replace(@OneValue,';',''))
				select @Result = @@error if @Result <> 0 goto Err
			end
			select @Result = @@error if @Result <> 0 goto Err
		end		
		
		delete @TableTmp
		where UID = @UID
		select @Result = @@error if @Result <> 0 goto Err
	end
  	select @Result = @@error if @Result <> 0 goto Err


	select distinct
		U.UserID,
		U.Name,
		U.email + case when isnull(R.email,'')<>'' and right(rtrim(U.email),1) <> ';' then '; ' else '' end + isnull(R.email,'') as email
	from @TableList T
	inner join dbo.Users U with (nolock) on T.UserName like '%<' + U.UserID + '>%'
	left join dbo.Users R with (nolock) on R.UserID = U.DeputyID and 
		convert(datetime,convert(varchar(100),getdate(),104),104) between U.DeputyDateFrom and U.DeputyDateTo
  	select @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:
	
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_SovetDirektorov_Povestka] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_SovetDirektorov_Povestka]
	@DocID varchar(250)
as

	declare @Result int
	set @Result = 0

	declare @TableList table
		(DocID varchar(255),
         UserName varchar(255),
		 DT datetime,
 		 Type int)

	declare @TableTmp table
		(DocID varchar(255),
         UserList varchar(4000),
		 DT datetime)
	
	declare
		@TmpDocID varchar(250),
		@OneValue varchar(250),	
		@UserList varchar(4000),
		@Ind int,
		@DT datetime,
		@ClassDoc varchar(255)

	select 
		@ClassDoc = DocType
	from dbo.PDXDocTypesConst with (nolock)
	where ConstName = 'RIK_CategoryName_SOVDIR_VOP'
	select @Result = @@error if @Result <> 0 goto Err

	--отв. испольнитель = отв. за подготовку материалов
	insert into @TableList
		(DocID,UserName,Type,DT)
    select D.DocID, replace(D.NameResponsible,';',''),1,UserFieldDate2
	from dbo.Docs D with (nolock)
	where D.DocIDParent = @DocID	
		and isnull(ltrim(rtrim(replace(replace(D.NameResponsible,char(10),''),char(13),''))),'') <> ''
		and D.ClassDoc = @ClassDoc
		and lower(D.isActive) = 'y'
		and D.StatusCompletion <> '1'
	select @Result = @@error if @Result <> 0 goto Err
	--докладчик
	insert into @TableList
		(DocID,UserName,Type,DT)
    select D.DocID, replace(D.Author,';',''),2,UserFieldDate2
	from dbo.Docs D with (nolock)
	where D.DocIDParent = @DocID	
		and isnull(ltrim(rtrim(replace(replace(D.Author,char(10),''),char(13),''))),'') <> ''
		and D.ClassDoc = @ClassDoc
		and lower(D.isActive) = 'y'
	select @Result = @@error if @Result <> 0 goto Err

	--список приглашенных
 	insert into @TableTmp
		(DocID,UserList,DT)
    select D.DocID, replace(replace(D.Correspondent,char(10),''),char(13),''),UserFieldDate2
	from dbo.Docs D with (nolock)
	where D.DocIDParent = @DocID	
		and isnull(ltrim(rtrim(replace(replace(D.Correspondent,char(10),''),char(13),''))),'') <> ''
		and D.ClassDoc = @ClassDoc
		and lower(D.isActive) = 'y'
	select @Result = @@error if @Result <> 0 goto Err

 	while exists (select 1 from @TableTmp)
	begin
		select top 1 
			@UserList = UserList,
			@TmpDocID = DocID,
			@DT = DT
 		from @TableTmp
		select @Result = @@error if @Result <> 0 goto Err

		delete @TableTmp
		where DocID = @TmpDocID 
			and UserList = @UserList
		select @Result = @@error if @Result <> 0 goto Err

		while len(@UserList) <> 0
		begin
			select @Ind = 0,@OneValue = ''
			select @Result = @@error if @Result <> 0 goto Err
			select @Ind = charindex(';',@UserList,1)
			select @Result = @@error if @Result <> 0 goto Err
			if @Ind = 0 select @Ind = len(@UserList)
			select @Result = @@error if @Result <> 0 goto Err
		
			select @OneValue = substring(@UserList,1,@Ind)
			select @Result = @@error if @Result <> 0 goto Err
			select @UserList = replace(@UserList,@OneValue,'')
			select @Result = @@error if @Result <> 0 goto Err

			insert into @TableList
				(DocID,UserName,Type,DT)
    		values
				(@TmpDocID, replace(@OneValue,';',''),0,@DT)
			select @Result = @@error if @Result <> 0 goto Err
		end		
	end
    
	select 
		DocID,
		UserName,
		Type,
		convert(varchar(100),DT,104) as [DT],
		convert(varchar(5),DT,114) as [DT1] 
	from @TableList
  	select @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:
	
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_SovetDirektorov_UsersList] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_SovetDirektorov_UsersList]
	@DocID varchar(250),
	@ClassDoc varchar(255)
as

	declare @Result int
	set @Result = 0

	declare @TableList table
		(DocID varchar(255),
         UserName varchar(1024),
		 DT datetime,
 		 Type int)

	declare @TableTmp table
		(DocID varchar(255),
         UserList varchar(4000),
		 DT datetime)
	
	declare
		@TmpDocID varchar(250),
		@OneValue varchar(1024),	
		@UserList varchar(4000),
		@Ind int,
		@DT datetime

--1 - отв. исп/NameResponcible
--2 - докладчик/Author
--3 - приглашенные/Correspondent

	--отв. испольнитель = отв. за подготовку материалов
	insert into @TableList
		(DocID,UserName,Type,DT)
    select D.DocID, replace(D.NameResponsible,';',''),1,UserFieldDate2
	from dbo.Docs D with (nolock)
	where D.DocIDParent = @DocID	
		and isnull(ltrim(rtrim(replace(replace(D.NameResponsible,char(10),''),char(13),''))),'') <> ''
		and D.ClassDoc = @ClassDoc
		and lower(D.isActive) = 'y'
		and D.StatusCompletion <> '1'
	select @Result = @@error if @Result <> 0 goto Err

	--докладчик
	insert into @TableList
		(DocID,UserName,Type,DT)
    select D.DocID, replace(D.Author,';',''),2,UserFieldDate2
	from dbo.Docs D with (nolock)
	where D.DocIDParent = @DocID	
		and isnull(ltrim(rtrim(replace(replace(D.Author,char(10),''),char(13),''))),'') <> ''
		and D.ClassDoc = @ClassDoc
		and lower(D.isActive) = 'y'
	select @Result = @@error if @Result <> 0 goto Err

	--список приглашенных
 	insert into @TableTmp
		(DocID,UserList,DT)
    select D.DocID, replace(replace(D.Correspondent,char(10),''),char(13),''),UserFieldDate2
	from dbo.Docs D with (nolock)
	where D.DocIDParent = @DocID	
		and isnull(ltrim(rtrim(replace(replace(D.Correspondent,char(10),''),char(13),''))),'') <> ''
		and D.ClassDoc = @ClassDoc
		and lower(D.isActive) = 'y'
	select @Result = @@error if @Result <> 0 goto Err

 	while exists (select 1 from @TableTmp)
	begin
		select top 1 
			@UserList = UserList,
			@TmpDocID = DocID,
			@DT = DT
 		from @TableTmp
		select @Result = @@error if @Result <> 0 goto Err

		delete @TableTmp
		where DocID = @TmpDocID 
			and UserList = @UserList
		select @Result = @@error if @Result <> 0 goto Err

		while len(@UserList) <> 0
		begin
			select @Ind = 0,@OneValue = ''
			select @Result = @@error if @Result <> 0 goto Err
			select @Ind = charindex(';',@UserList,1)
			select @Result = @@error if @Result <> 0 goto Err
			if @Ind = 0 select @Ind = len(@UserList)
			select @Result = @@error if @Result <> 0 goto Err
		
			select @OneValue = substring(@UserList,1,@Ind)
			select @Result = @@error if @Result <> 0 goto Err
			select @UserList = replace(@UserList,@OneValue,'')
			select @Result = @@error if @Result <> 0 goto Err

			insert into @TableList
				(DocID,UserName,Type,DT)
    		values
				(@TmpDocID, replace(@OneValue,';',''),0,@DT)
			select @Result = @@error if @Result <> 0 goto Err
		end		
	end
    
	select 
		DocID,
		UserName,
		Type,
		convert(varchar(100),DT,104) as [DT],
		convert(varchar(5),DT,114) as [DT1] 
	from @TableList
	order by DocID,Type,UserName
  	select @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:
	
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_SubscribeGet] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_SubscribeGet]
	@UserID varchar(250)
AS

	declare @Result int
	set @Result = 0

	declare @tmp table (Sub1 int, Sub2 int, Add2 int)

	insert into @tmp (Sub1, Sub2, Add2)
	values (0,0,2)
	select @Result = @@error if @Result <> 0 goto Err
	
	update t
	set Sub1 = cast(S.Sub1 as int),
	Sub2 = cast(S.Sub2 as int),	
	Add2 = S.Add2
	from @tmp t
	inner join dbo.PDXSubscribe S on S.UserID = @UserID
	select @Result = @@error if @Result <> 0 goto Err

	select Sub1, Sub2, Add2 from @tmp
	select @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:

	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_SubscribeSet] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_SubscribeSet]
	@UserID varchar(250),
	@Sub1 bit = null,
	@Sub2 bit = null,
	@Add2 int = null,
	@NLM varchar(255)
AS

	declare @Result int
	set @Result = 0

	if exists (select 1 from dbo.PDXSubscribe with (nolock) where UserID = @UserID)
	begin
		update dbo.PDXSubscribe
		set Sub1 = case when @Sub1 is null then Sub1 else @Sub1 end,
			Sub2 = case when @Sub2 is null then Sub2 else @Sub2 end,
			Add2 = case when @Sub2 is null then Add2 else @Add2 end,
		NLM = @NLM,
		DLM = getdate()
		where UserID = @UserID
		select @Result = @@error if @Result <> 0 goto Err
	end
	else
	begin
		insert into dbo.PDXSubscribe (UserID, Sub1, Sub2, Add2, NC, DC, NLM, DLM)
		values (@UserID, isnull(@Sub1,0), isnull(@Sub2,0), isnull(@Add2,2), @UserID, getdate(), @UserID, getdate())
		select @Result = @@error if @Result <> 0 goto Err
	end 
	select @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:

	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_TaskSettings_Change] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_TaskSettings_Change]
	@ClassDoc varchar(128),
	@ActDoc varchar(64),
	@DateCompletionCnt int,
	@UserName varchar(128),
	@SetID uniqueidentifier,
	@NC varchar(128),
	@Act int, --1--ceate, 2-update,3 delete
	@Chk bit = 0
	
as
	declare  @Res int

	declare @UserID varchar(16),
			@ErrList varchar(1024),
			@Cls varchar(1024),
			@ErrorStr varchar(1024),
			@ClassGr varchar(128)

	select @Res = 0,@ErrList = ''
	


	select
		@ClassDoc = ltrim(rtrim(isnull(@ClassDoc,''))),
		@ActDoc = ltrim(rtrim(isnull(@ActDoc,''))),
		@DateCompletionCnt = isnull(@DateCompletionCnt,0),
		@UserName = ltrim(rtrim(isnull(@UserName,''))),
		@NC  = ltrim(rtrim(isnull(@NC,'')))
	select @Res = @@error if @Res <> 0 goto Err


/************************************
ПРОВЕРКИ ВВЕДЕННЫХ ЗНАЧЕНИЙ
*************************************/
IF @UserName <> ''
BEGIN
	If @UserName like '%<%>%<%' 
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Контролером может быть указан только один пользователь.'
		select @Res = @@error if @Res <> 0 goto Err
	end

	--проверяем пользователя
	select @UserID  = ''
	select @UserID = dbo.PDX_SubstringReturn(@UserName, charindex('<',@UserName), charindex('>',@UserName))
	select @Res = @@error if @Res <> 0 goto Err
	--если "не выделился" логин - значит некорректно указан пользователь
	if @UserID = ''
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Некорректно указан согласующий. Выберите значение из справочника пользователей.'
		select @Res = @@error if @Res <> 0 goto Err
	end
	--если пользователь не нашелся, или у него нет доступа
	else if not exists (select 1 from dbo.Users where UserID=@UserID
			and ((StatusActive in ('1','-') and DateExpirationSecurity > convert(datetime,convert(varchar(50),getdate(),104),104)
					and not Permitions like '%*%') 
				or Comment like '%$RLsyslogin$%'))
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Указанный пользователь не существует (или его доступ в систему приостановлен).'
		select @Res = @@error if @Res <> 0 goto Err
	end
END
ELSE
BEGIN
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Не указан Контролер.'
		select @Res = @@error if @Res <> 0 goto Err
END


--категория обязательно д.б. указана
IF @ClassDoc = ''
BEGIN
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Не указана категория(группа категорий) документа.'
	select @Res = @@error if @Res <> 0 goto Err
END
IF not exists (select 1 from dbo.DocTypes where Name like @ClassDoc + case right(@ClassDoc,1) when '/' then '%' else '' end)
BEGIN
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Указана несуществующая категория документа.'
	select @Res = @@error if @Res <> 0 goto Err
END
select @ClassGr = case when @ClassDoc like '%/%' and not @ClassDoc like '%/'
						then left(@ClassDoc,charindex('/',@ClassDoc))
						else @ClassDoc
					end
select @Res = @@error if @Res <> 0 goto Err

--если указан вид деят-ти
IF @ActDoc <> ''
BEGIN
	select---ищем какие для него доступны категории
		@Cls = ltrim(rtrim(isnull(ClassDoc,'')))
	from dbo.Activities
	where Name = @ActDoc
	select @Res = @@error if @Res <> 0 goto Err
	--значит что вид деят-ти выбран несуществующий
	if @Cls is null
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Указан не существующий вид деятельности.'
		select @Res = @@error if @Res <> 0 goto Err
	end
	--проверяем что категория и ВД "совместимы"
	If not @Cls like '%' + @ClassGr + '%'
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Выбрана недопустимая комбинация Вида деятельности и категории документа.'
		select @Res = @@error if @Res <> 0 goto Err
	end
END

	if exists (select 1 from dbo.PDXTaskDefSettings where ActDoc in (@ActDoc,'')
					and (@ClassDoc in (ClassDoc,case when ClassDoc like '%/%' and not ClassDoc like '%/'
													then left(ClassDoc,charindex('/',ClassDoc))
													else ClassDoc
												end) 
						or ClassDoc in (@ClassDoc, @ClassGr)
						)
					and SetID <> isnull(@SetID,'00000000-0000-0000-0000-000000000000')
				)
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Настройка по указанной комбинации Вид деятельности-Категория(группа категорий) уже существует.'
		select @Res = @@error if @Res <> 0 goto Err
	end


/************************************/

If @Chk = 0
begin --если это создание , то нужно генерить ошибкуесли она есть
	If @ErrList <> '' 
	begin
		RAISERROR (@ErrList, 16,1)
		goto Err
	end
end
else --если это проверка просто выводим сообщение, даже если оно пустое
begin
	select @ErrList as ErrList 
	select @Res = @@error if @Res <> 0 goto Err
end

IF @ErrList = '' and @Chk = 0
BEGIN
	If @SetID is null
	begin
		insert into dbo.PDXTaskDefSettings
			(ClassDoc, ActDoc, DateCompletionCnt, UserName, NC, DC, NLM, DLM)
		values 
			(@ClassDoc, @ActDoc, @DateCompletionCnt, @UserName,
			@NC, getdate(), @NC, getdate()) 
		select @Res = @@error if @Res <> 0 goto Err
	end
	else
	begin
		update dbo.PDXTaskDefSettings
			set 
				UserName = @UserName, 
				ClassDoc = @ClassDoc,
				ActDoc = @ActDoc, 
				DateCompletionCnt = @DateCompletionCnt, 
				NLM = @NC,
				DLM = getdate()
		where SetID = @SetID
		select @Res = @@error if @Res <> 0 goto Err
	end
END

	select @Res = @@error if @Res <> 0 goto Err

OK:

	return @Res
Err:
	return @Res
GO
/****** Object:  StoredProcedure [dbo].[PDX_Trip_ExtCheck] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_Trip_ExtCheck]
	@DocID varchar(128),
	@isContext bit = 0
	
as
declare 
	@Res int, @Mess varchar(4096), @UFT6 varchar(1024),@Obj varchar(1024), @DocIDInt int
	
	select @Res = 0, @Mess = ''

	declare @Tbl table (Val varchar(64), Pos int, Flag bit)
	
	select
		@UFT6 = UserFieldText6,
		@DocIDInt = DocIDInt
	from dbo.Docs 
	where DocID = ltrim(rtrim(isnull(@DocID,'')))
	select @Res = @@error if @Res <> 0 goto Err

	select
		@Obj = Obj
	from dbo.PDXTrip
	where DocIDInt = @DocIDInt
	
	select @Obj = ISNULL(@Obj,'')
	
	If @UFT6 = 'по прямым расходам'
	begin
		if @Obj = ''
		begin
			select @Mess = @Mess + case len(@Mess) when 0 then '' else '<br>' end +
				'<font color=red>ОШИБКА! </font> Поле [Объект] не может быть пустым</font>'
		end
		else if not exists (select top 1 1 from dbo.UserDir_ISR where @Obj like '%<' + Code + '>%')
		begin
			select @Mess = @Mess + case len(@Mess) when 0 then '' else '<br>' end +
				'<font color=red>ОШИБКА! </font> Поле [Объект]: значение [' + @Obj + '] в справочнике не существует</font>'
		end		
	end
	else
	begin
		if @Obj <> ''
		begin
			select @Mess = @Mess + case len(@Mess) when 0 then '' else '<br>' end +
				'<font color=red>ОШИБКА! </font> Поле [Объект] должно быть пустым</font>'
		end
	end
	
	select @Mess = @Mess + case len(@Mess) when 0 then '' else '<br>' end
    select @Res = @@error if @Res <> 0 goto Err

OK:

	select @Mess as 'res'
	return @Res
Err:
	select @Mess  as 'res'
	return @Res











GO
/****** Object:  StoredProcedure [dbo].[PDX_TRIP_Unload] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_TRIP_Unload] --ВЫГРУЗКА заявок на командировку
	@Date datetime 
as

set nocount on

	declare @Result int
	set @Result = 0

	create table #TRP
	(			
		TransferGUID	uniqueidentifier,		--УНИКАЛЬНЫЙ ИД ЗАПИСИС. DocID - теоретически м.б. изменен
		DocID			varchar(128),			--Номер документа
		ActDoc			varchar(128),			--Вид деятельности
		Department		varchar(255),			--Подразделение
		Author			varchar(1024),			--ФИО командируемого
		AuthorName		varchar(1024),			--ФИО командируемого
		Name			varchar(256),				--Место выбытия
		UserFieldText2	varchar(1024),	--Место назначения (страна, населенный пункт)-
		UserFieldText4	varchar(1024),	--Пункт назначения (наименование Организации)-
		UserFieldText6	varchar(1024),	--Вид командировки
		UserFieldText5	varchar(1024),	--Цель командировки по управленческому учету-
		Description		varchar(1024),		--Цель командировки по бухгалтерскому учету-
		UserFieldText8	varchar(1024),	--Командировка за счет средств
		UserFieldText7	varchar(1024),	--Основание Командировки-
		UserFieldDate1	datetime,	--Дата начала командировки
		UserFieldDate2	datetime,	--Дата окончания командировки
		UserFieldDate4	datetime,	--Срок предоставления отчета о командировке
		UserFieldText3	varchar(1024),	--ЦФО
		ID_UFT3			varchar(1024),
		UserFieldText1	varchar(1024),	--Наименование листа согласования
		ListToReconcile varchar(4096),	--Лист согласования
		NameAproval		varchar(96),		--Утверждающий
		NameApp			varchar(96),
		ListToView		varchar(4000),		--Список ознакомления
		Correspondent	varchar(4000),	--Адресаты, список рассылки
		NameCreation	varchar(96),		--Автор карточки
		NameCr			varchar(96),
		Obj				varchar(1024),
		ID_Obj			varchar(1024),
		ClassDoc		varchar(128)
		)
		
		
	insert into #TRP
	exec PayDoxOP.dbo.[PDX_TRIP_UnloadFromDB]
	@Date = @Date
	/*
	insert into #TRP
	exec PayDoxPV.dbo.[PDX_TRIP_UnloadFromDB]
	@Date = @Date
	
	insert into #TRP
	exec PayDoxOPD.dbo.[PDX_TRIP_UnloadFromDB]
	@Date = @Date
	*/
	select * from #TRP

	drop table #TRP
	
set nocount off
	return @Result
Err:

set nocount off
		return @Result













GO
/****** Object:  StoredProcedure [dbo].[PDX_TRIP_UnloadFromDB] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_TRIP_UnloadFromDB]
	@Date datetime
	
as
/*
ВСЕ ВОЗМОЖНЫЕ СТАТУСЫ - STATUS:
	-3 - ошибка в статусе
	-2 - отменен
	-1 - неактивен
	 0 - отказано в согласовании
	 1 - на согласовании
	 2 - утверждена
	 4 - отменена
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
данная процедура оперирует только статусами:
	-3 - ошибка в статусе
 	 0 - отказано в согласовании
	 1 - на согласовании
	 2 - утверждена
	 4 - отменена
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Процедура отбирает карточки документов "Плановая заявка", которые были:
	АКТИВИРОВАНЫ - дата последней активации (DateActive из табл. Docs)
		(Изменения только полей карточке, загрузка файлов, написание комментариев к карточке не учитывается)
	ИЛИ
	ИЗМЕНЕНЫ - дата последнего изменения (DateLastModifacation из табл. Docs)
	ИЛИ
	УТВЕРЖДЕНЫ - дата последнего утверждения (DateApproved из табл. Docs)
после указанной даты (@Date)
    ИЛИ 
    ОТМЕНЕНЫ - статус отменено
В выборку также попадают документы, в которых после указанной даты (@Date) были отказы в согласовании.
Но если такой отказ был отозван(отправлено на повторное согласование или отказавший был исключен из ЛС), 
то карточка в выборку не попадает.
Это обусловлено тем, что нас интересует только ТЕКУЩИЙ(действительный) статус документа "отказано в согласоании".
Если отказ был отозван, то статус документа вернулся в состояние "требует согласования" и документ нас будет интересовать, 
если он попадает под DateActive/DateLastModification/DateApproved
	
*/
	

	declare @DocID varchar(128)

	set nocount on

	create table #tbl_pay
		(DocID varchar(128),
		DocIDInt int,
		StatusDevelopment varchar(1),
		VisaRefuse bit,
		Flg bit default 0,
		ClassDoc varchar(128)
		)
		
	declare @ErrList varchar(4000),
		@ClassName varchar(128),
		@ClassName2 varchar(128),
		@StopRefuseFlag bit,
		@StopRefuseFlag2 bit

	select @ClassName = DocType,
		@StopRefuseFlag = StopRefuseFlag 
	from dbo.PDXDocTypesConst
	where ConstName = 'RIK_CategoryName_OTHERS_TRP'
	
	
	select @ClassName2 = DocType,
		@StopRefuseFlag2 = StopRefuseFlag 
	from dbo.PDXDocTypesConst
	where ConstName = 'RIK_CategoryName_OTHERS_ZPR'

	select @ErrList = ''
	
	--по датам из комментов
	--отказ в согласовании, причем только если этот отказ не был отозван
	insert into #tbl_pay
		(DocID,	DocIDInt, ClassDoc, StatusDevelopment, VisaRefuse)
	select distinct D.DocID, D.DocIDInt, D.ClassDoc, D.StatusDevelopment, 
			case --условие, что отказ не был отозван (отзыв отказа - это или удалили из ЛС отказника или отменили его оказ в согл.)
				when isnull(D.ListReconciled,'') like '%-<%' 
						and isnull(D.ListToReconcile,'') like '%<' + C.UserID + '>%'
						and isnull(D.ListReconciled,'') like '%-<' + C.UserID + '>%'
					then 1 
				else 0 
			end
	from dbo.Comments C
	inner join 	dbo.Docs D on C.DocID = D.DocID
		and D.ClassDoc in (@ClassName,@ClassName2) --смотрим чтобы была нужная категория
		and Upper(isnull(D.isActive,'')) = 'Y' --активная карточка
		and isnull(D.StatusCompletion,'') <> '0' --неотмененая карточка (отмененные это отдельный блок)
		and case when isnull(ListReconciled,'') like '%-<%' then 1 else 0 end = 1
	where Upper(isnull(C.CommentType,'')) = 'VISA' --берем отказ в согласовании
		and Upper(isnull(C.SpecialInfo,'')) = 'VISAOKREFUSE'
		and C.DateCreation >= @Date

	--по датам из комментов
	--отправка на повторное согласование - смысл в том, чтобы "засечь" изменение статуса с "приостановлено-есть отказ" на "требует согласоание"
	--вариант когда при отмене стаус не меняется нам в принципе не интересен, но так как отделить эти ситуации невозможно - будем "брать" все
	insert into #tbl_pay
		(DocID,	DocIDInt, ClassDoc, StatusDevelopment, VisaRefuse)
	select distinct D.DocID, D.DocIDInt, D.ClassDoc, D.StatusDevelopment, 
			dbo.PDX_fn_stopReconcilation(D.ListToReconcile, D.ListReconciled, case D.ClassDoc when @ClassName then @StopRefuseFlag else @StopRefuseFlag2 end)
	from dbo.Comments C
	inner join 	dbo.Docs D on C.DocID = D.DocID
		and D.ClassDoc in (@ClassName,@ClassName2) --смотрим чтобы была нужная категория
		and Upper(isnull(D.isActive,'')) = 'Y' --активная карточка
		and isnull(D.StatusCompletion,'') <> '0' --неотмененая карточка (отмененные это отдельный блок)
	where Upper(isnull(C.CommentType,'')) = 'VISA' --берем отказ в согласовании
		and Upper(isnull(C.SpecialInfo,'')) = 'PARTVISACANCEL'
		and C.DateCreation >= @Date
		and not exists(select 1 from #tbl_pay P where P.DocID = D.DocID)--не повторяемся, если карточка отобралась через отказ
	

	--по датам из картчоки
	insert into #tbl_pay
		(DocID,	DocIDInt, ClassDoc, StatusDevelopment, VisaRefuse)
	select distinct D.DocID, D.DocIDInt, D.ClassDoc, D.StatusDevelopment, 
		dbo.PDX_fn_stopReconcilation(D.ListToReconcile, D.ListReconciled, case D.ClassDoc when @ClassName then @StopRefuseFlag else @StopRefuseFlag2 end)
	from dbo.Docs D
	where D.ClassDoc in (@ClassName,@ClassName2) --смотрим чтобы была нужная категория
	and (isnull(D.DateActive,D.DateLastModification) >= @Date or --отбираем по дате последней активаци
		isnull(D.DateLastModification, D.DateCreation) >= @Date or --отбираем по дате последнего изм-я
		isnull(D.DateApproved,'1900-01-01') >= @Date) --отбираем по дате утв-я
	and Upper(isnull(D.isActive,'')) = 'Y'--активная карточка
	and isnull(D.StatusCompletion,'') <> '0'	--неотмененая карточка (отмененные это отдельный блок)
	and not exists(select 1 from #tbl_pay P where P.DocID = D.DocID)--не повторяемся, если карточка отобралась через отказ

		

    /*************************************************************************************************/
    /*************************************************************************************************/
    /*************************************************************************************************/

	--тепер собираем информацию
	select
		D.TransferGUID,		--УНИКАЛЬНЫЙ ИД ЗАПИСИС. DocID - теоретически м.б. изменен
		D.DocID,			--Номер документа
		D.ActDoc,			--Вид деятельности
		D.Department,		--Подразделение
		D.Author,			--ФИО командируемого
		isnull(AU.Name,'') as AuthorName,
		D.Name,				--Место выбытия
		D.UserFieldText2,	--Место назначения (страна, населенный пункт)-
		D.UserFieldText4,	--Пункт назначения (наименование Организации)-
		D.UserFieldText6,	--Вид командировки
		D.UserFieldText5,	--Цель командировки по управленческому учету-
		D.Description,		--Цель командировки по бухгалтерскому учету-
		D.UserFieldText8,	--Командировка за счет средств
		D.UserFieldText7,	--Основание Командировки-
		D.UserFieldDate1,	--Дата начала командировки
		D.UserFieldDate2,	--Дата окончания командировки
		D.UserFieldDate4,	--Срок предоставления отчета о командировке
		D.UserFieldText3,	--ЦФО
		dbo.PDX_fn_pay_CFOGET(D.UserFieldText3) as ID_UFT3,
		D.UserFieldText1,	--Наименование листа согласования
		D.ListToReconcile,	--Лист согласования
		D.NameAproval,		--Утверждающий
		isnull(NA.Name,'') as NameApp,
		D.ListToView,		--Список ознакомления
		D.Correspondent,	--Адресаты, список рассылки
		D.NameCreation,		--Автор карточки
		isnull(NC.Name,'') as NameCr,
		T.Obj as Obj,
		dbo.PDX_SubstringReturn(T.Obj, CHARINDEX('<', T.Obj), CHARINDEX('>', T.Obj)) as ID_Obj,
		D.ClassDoc
	from #tbl_pay P
	inner join dbo.Docs D on D.DocIDInt = P.DocIDInt
	left join dbo.PDXTrip T on T.DocIDInt = D.DocIDInt
	left join dbo.Users NA on dbo.PDX_SubstringReturn(D.NameAproval, CHARINDEX('<', D.NameAproval), CHARINDEX('>', D.NameAproval)) = NA.UserID--D.NameAproval like '%<' + NA.UserID + '>%'
	left join dbo.Users NC on dbo.PDX_SubstringReturn(D.NameCreation, CHARINDEX('<', D.NameCreation), CHARINDEX('>', D.NameCreation)) = NC.UserID--D.NameCreation like '%<' + NC.UserID + '>%'
	left join dbo.Users AU on dbo.PDX_SubstringReturn(D.Author, CHARINDEX('<', D.Author), CHARINDEX('>', D.Author)) = AU.UserID--D.Author like '%<' + AU.UserID + '>%'
	where P.ClassDoc = @ClassName
	
	union
	
	select
		D.TransferGUID,		--УНИКАЛЬНЫЙ ИД ЗАПИСИС. DocID - теоретически м.б. изменен
		D.DocID,			--Номер документа
		D.ActDoc,			--Вид деятельности
		D.Department,		--Подразделение
		D.Author,			--ФИО направляемого сотрудника
		isnull(AU.Name,'') as AuthorName,
		'' as Name,				--
		D.UserFieldText2,	--Место назначения (страна, населенный пункт)-
		D.UserFieldText4,	--Пункт назначения (наименование Организации)-
		'' as UserFieldText6,	--Вид командировки
		D.UserFieldText5,	--Цель командировки по управленческому учету-
		D.Description,		--Цель командировки по бухгалтерскому учету-
		[dbo].[fnGetSelectValueForUFM]('RIK_CategoryName_OTHERS_ZPR',1, D.UserFieldMoney1)  as UserFieldText8,	--Полевые работы за счет средств
		D.UserFieldText7,	--Основание полевых работ-
		D.UserFieldDate1,	--Дата начала командировки
		D.UserFieldDate2,	--Дата окончания командировки
		D.UserFieldDate4,	--Срок предоставления отчета о выполнении задания
		D.UserFieldText3,	--ЦФО
		dbo.PDX_fn_pay_CFOGET(D.UserFieldText3) as ID_UFT3,
		D.UserFieldText1,	--Наименование листа согласования
		D.ListToReconcile,	--Лист согласования
		D.NameAproval,		--Утверждающий
		isnull(NA.Name,'') as NameApp,
		D.ListToView,		--Список ознакомления
		D.Correspondent,	--Адресаты, список рассылки
		D.NameCreation,		--Автор карточки
		isnull(NC.Name,'') as NameCr,
		D.UserFieldText6 as Obj, --Обьект
		dbo.PDX_SubstringReturn(D.UserFieldText6, CHARINDEX('<', D.UserFieldText6), CHARINDEX('>', D.UserFieldText6)) as ID_Obj,
		D.ClassDoc		
	from #tbl_pay P
	inner join dbo.Docs D on D.DocIDInt = P.DocIDInt
	left join dbo.Users NA on dbo.PDX_SubstringReturn(D.NameAproval, CHARINDEX('<', D.NameAproval), CHARINDEX('>', D.NameAproval)) = NA.UserID--D.NameAproval like '%<' + NA.UserID + '>%'
	left join dbo.Users NC on dbo.PDX_SubstringReturn(D.NameCreation, CHARINDEX('<', D.NameCreation), CHARINDEX('>', D.NameCreation)) = NC.UserID--D.NameCreation like '%<' + NC.UserID + '>%'
	left join dbo.Users AU on dbo.PDX_SubstringReturn(D.Author, CHARINDEX('<', D.Author), CHARINDEX('>', D.Author)) = AU.UserID--D.Author like '%<' + AU.UserID + '>%'
	where P.ClassDoc = @ClassName2
	
	order by D.DocID


	set nocount off






GO
/****** Object:  StoredProcedure [dbo].[PDX_UD_ISR] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE proc [dbo].[PDX_UD_ISR]
	--@Project varchar(255) = ''
as

declare @Result int
select @Result = 0

	declare @Level int,
	@Res int

	declare @Tmp table (FullCode varchar(8000), Code varchar(255), Descr varchar(512), 
	Lev int, KeyField int, ParentKeyField int, Project varchar(255))
	
/*
	select @Level = 1
	select @Result = @@error if @Result <> 0 goto Err

	insert into @Tmp (FullCode, Code, Descr, KeyField, ParentKeyField, Lev)
	select Descr, Code, Descr, KeyField, ParentKeyField, case when ParentKeyField IS null then 1 else null end
	from dbo.UserDir_ISR I
	
	while exists (select 1 from @Tmp where Lev is null)
	begin
		select @Level = @Level + 1
		
		update P
			set 
				--FullCode = T.FullCode + T.Descr + '/',
				FullCode = T.FullCode + '/' + 
					case	
						when exists(select 1 from @Tmp X where X.ParentKeyField = P.KeyField)
							then P.Descr
						else ''
					end,
				Lev = @Level
		from @Tmp T
		inner join @Tmp P on P.ParentKeyField = T.KeyField
		where T.Lev = @Level - 1		
	end
		
	select
		--, 
		'<'+Code+'>' + Descr as Descr,	
		case right(FullCode,1) when '/' then FullCode else FullCode + '/' end as FullCode,-- case Lev when 1 then Descr + '/' else FullCode end as FullCode,
		Code
	from @Tmp
	order by 3,1*/
	
	
	select @Level = 0
	select @Result = @@error if @Result <> 0 goto Err

	select '<' + U.Code + '> ' + U.Descr as Descr, I.Code + isnull(' - ' + replace(I.Descr,'/','_'),'') + '/' as FullCode, U.Code
	from dbo.UserDir_ISR I
	inner join dbo.UserDir_ISR U on (U.Code like I.Code + '%' and U.Code <> I.Code)
	where I.ParentKeyField is null or I.ParentKeyField = 0
	union
	select '<' + I.Code + '> ' + I.Descr as Descr, I.Code + isnull(' - ' + replace(I.Descr,'/','_'),'') + '/' as FullCode, I.Code
	from dbo.UserDir_ISR I	
	where I.ParentKeyField is null or I.ParentKeyField =0
	order by 3,1--U.Code, U.Descr
	
	/*select I.Code, I.Descr, I.Project + '/' + left(I.Code,2) + isnull(' - ' + S.Descr,'') + '/' as FullCode
	from dbo.UserDir_ISR I
	left join dbo.UserDir_ISR S on S.Code = left(I.Code,2)
	where (I.Project = @Project or @Project = '')	
	order by 1,2*/
	select @Res = @@rowcount, @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:
	
	return @Result




GO
/****** Object:  StoredProcedure [dbo].[PDX_UD_PRJISR] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[PDX_UD_PRJISR]
	@Project varchar(1024) = '',
	@Field varchar(64) = ''
as

declare @Result int
select @Result = 0

	declare @Level int,
	@Res int

	;with DT (Code, Descr, KeyField, ParentKeyField, RootID) as (
	select Code, Descr, KeyField, ParentKeyField, KeyField
	from dbo.UserDir_ISR
	where ParentKeyField is null
	and ((Project = @Project and @Project <>'') or @Field = '')
		
	union all

	select I.Code, I.Descr, I.KeyField, I.ParentKeyField, P.RootID
	from dbo.UserDir_ISR I
	inner join DT P on P.KeyField = I.ParentKeyField
	)

   select
   '<' + U.Code + '> ' + U.Descr as Descr, R.Code + isnull(' - ' + R.Descr,'') + '/' as FullCode, U.Code
   from DT as U
   inner join DT R on R.KeyField = U.RootID
   order by U.Code

	return @Result
Err:
	
	return @Result




GO
/****** Object:  StoredProcedure [dbo].[PDX_UNI_DocsToVISA] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE proc [dbo].[PDX_UNI_DocsToVISA]
	@UserID varchar(16),
	@Type int = null
as

declare @Result int
select @Result = 0

	declare @tmp table
		(UserID varchar(16),
		Info varchar(255))

	declare @stoprefuse table
		(DocType varchar(255),
		StopRefuseFlag bit)

	create table #dcs
		(DocID varchar(255),
		ClassDoc varchar(255),
		UserID varchar(255),
		Descr varchar(512),
		DateEvent datetime,
		DateEventEnd datetime,
		Type int,
		CommentType varchar(16),
		Address varchar(512),
		SpecialInfo varchar(512),
		UserName varchar(64),
		Comment varchar(255),
		Cnt1 int,
		Cnt2 int)

	declare @Cls1 varchar(255), 
			@Cls2 varchar(255), 
			@Cls3 varchar(255), 
			@Cls4 varchar(255), 
			@Cls_5 varchar(255), 
			@Cls_6 varchar(255), 
			@Cls_7 varchar(255), 
			@Cls_8 varchar(255), 
			@Cls_9 varchar(255), 
			@Cls_10 varchar(255), 
			@Cls11 varchar(255), 
			@Cls12 varchar(255), 
			@Cls13 varchar(255),
			@Cls14 varchar(255),
			@Cls15 varchar(255),
			@Cls16 varchar(255),
			@Cls17 varchar(255)



	select @Cls1 = dbo.PDX_CLSGrGet ('RIK_CategoryName_INVKOM_PRO'),
			@Cls2 = dbo.PDX_CLSGrGet ('RIK_CategoryName_SOVDIR_PRO'),

			@Cls3 = dbo.PDX_CLSGrGet('RIK_CategoryName_DOGOVORY_B'),
			@Cls4 = dbo.PDX_CLSGrGet('RIK_CategoryName_RASPDOC_PR'),
			@Cls_5 = dbo.PDX_CLSGet('RIK_CategoryName_ISHO_VNESH'),
			@Cls_6 = dbo.PDX_CLSGet('RIK_CategoryName_SOVDIR_PRO'),
			@Cls_7 = dbo.PDX_CLSGet('RIK_CategoryName_PR_REQUEST'),
			@Cls_8 = dbo.PDX_CLSGet('RIK_CategoryName_INVKOM_PRO'),
			@Cls_9 = dbo.PDX_CLSGet('RIK_CategoryName_VHOD_VNESH'),
			@Cls_10 = dbo.PDX_CLSGet('RIK_CategoryName_VHOD_VNUTR'),

			@Cls11 = dbo.PDX_CLSGet ('RIK_CategoryName_SYSZADACHI'),
			@Cls12 = dbo.PDX_CLSGet ('RIK_CategoryName_CORPZADACH'),
			@Cls13 = dbo.PDX_CLSGet('RIK_CategoryName_ATTORNEYRC'),
			@Cls14 = dbo.PDX_CLSGet('RIK_CategoryName_ATTORNEYID'),
			@Cls15 = dbo.PDX_CLSGet('RIK_CategoryName_CLAIMS_CLM'),
			@Cls16 = dbo.PDX_CLSGet('RIK_CategoryName_CLAIMS_CRT'),
			@Cls17 = dbo.PDX_CLSGet('RIK_CategoryName_OTHERS_DOG')
			
	select @Result = @@error if @Result <> 0 goto Err

	--выводим документы текущ. пользователя
	insert into @tmp(UserID, Info) values (@UserID, '')
	select @Result = @@error if @Result <> 0 goto Err

	if @Type is null --для union-a, когда не null - для списокв на главной странице
	begin
		--документы заместителей тоже нужны
		insert into @tmp(UserID, Info) 
	--	select UserID, case when len(Name) <> 0 then '<font size=1 color = #CC3300><i>Замещение:</font><font size=1 color = black> ' + Name + ' / ' + UserID + ' (' + convert(varchar(100),DeputyDateFrom,104) + ' - ' + convert(varchar(100),DeputyDateTo,104) + ')</font></i>'else '' end
		select UserID, case when len(Name) <> 0 then '<font size=1 color = #CC3300><i>Замещение:</font><font size=1 color = black> ' + UserID + '</font></i>'else '' end
		from dbo.Users 
		where DeputyID = @UserID
			and convert(datetime,convert(varchar(100),getdate(),104),104) between
					convert(datetime,convert(varchar(100),DeputyDateFrom,104),104) and
					convert(datetime,convert(varchar(100),DeputyDateTo,104),104)
		select @Result = @@error if @Result <> 0 goto Err
	end

/*	30 - подписание
	40 - На утверждение
	50 - ознакомление
	10 - На согласование
	20 - На рецензию
	60 - на контроле
	70 - к исполнению
*/

	--подписание / утв  / ознакомл
	If @Type in (30,40,50) or @Type is null
	begin
		--список категорий - нужен флаг остановки согласования в случае отказа
		insert into  @stoprefuse 
			(DocType,StopRefuseFlag)
		select DocType,StopRefuseFlag
		from dbo.PDXDocTypesConst
		select @Result = @@error if @Result <> 0 goto Err

		INSERT INTO #dcs
			(DocID,
			ClassDoc,
			UserID,
			Descr,
			DateEvent,
			DateEventEnd,
			Type)
		SELECT 
			D.DocID, 
			D.ClassDoc, 
			U.UserID , 
			cast('<b>' + case len(isnull(D.Name,'')) when 0 then D.Description else D.Name end + '</b>' as varchar(125)) +
				case when len('<b>' + case isnull(len(D.Name),0) when 0 then D.Description else D.Name end + '</b>') > 125 then ' ...' else '' end +
				 + case len(isnull(D.Name,'')+isnull(D.Description,'')) when 0 then '' else '<br>' end + U.Info AS Descr, 
	        null as DateEvent,
			null as DateEventEnd,
			case 
				when D.ClassDoc like @Cls3 + '%'
					 or D.ClassDoc like @Cls4 + '%'
					 or D.ClassDoc = @Cls17
					 or D.ClassDoc = @Cls_5
					 or D.ClassDoc = @Cls_6
					 or D.ClassDoc = @Cls_7
					 or D.ClassDoc = @Cls_8
					 or D.ClassDoc = @Cls14
					then 30
				when D.ClassDoc in (@Cls_9, @Cls_10) 
					then 50
				else 40
			end as Type
		FROM dbo.Docs AS D 
		inner join @stoprefuse s on S.DocType = D.ClassDoc
		INNER JOIN @tmp U on CHARINDEX('<' + U.UserID + '>', D.NameAproval) > 0 
		WHERE UPPER(ISNULL(D.IsActive, '')) = 'Y'
			AND NOT (ISNULL(D.StatusCompletion, '') IN ('1', '0')) 
			AND isnull(D.StatusDevelopment,'') <> '0'
			AND ltrim(rtrim(isnull(D.NameApproved,''))) = ''
			AND dbo.PDX_CompareReconcilationList(D.ListToReconcile, D.ListReconciled) = 1
			and dbo.PDX_fn_stopReconcilation (D.ListToReconcile, D.ListReconciled, S.StopRefuseFlag) = 0
		select @Result = @@error if @Result <> 0 goto Err
	end
	If @Type in (30,40,50)
	begin
		delete from #dcs where Type <> @Type
		select @Result = @@error if @Result <> 0 goto Err
	end
	
	
	If @Type = 50 or @Type is null
	begin
		INSERT INTO #dcs --ознакомление2
			(DocID,
			ClassDoc,
			UserID,
			Descr,
			DateEvent,
			DateEventEnd,
			Type)
		SELECT 
			D.DocID, 
			D.ClassDoc, 
			U.UserID , 
			cast('<b>' + case len(isnull(D.Name,'')) when 0 then D.Description else D.Name end + '</b>' as varchar(125)) +
				case when len('<b>' + case isnull(len(D.Name),0) when 0 then D.Description else D.Name end + '</b>') > 125 then ' ...' else '' end +
				 + case len(isnull(D.Name,'')+isnull(D.Description,'')) when 0 then '' else '<br>' end + U.Info AS Descr, 
	        null as DateEvent,
			null as DateEventEnd,
			50 as Type
		FROM dbo.Docs AS D 
		INNER JOIN @tmp U on CHARINDEX('<' + U.UserID + '>', D.ListToView) > 0  
			and CHARINDEX('<' + U.UserID + '>-', ListToView)<=0
		where upper(isnull(D.isActive,'')) = 'Y' 
			and (isnull(D.NameAproval,'') = '' or isnull(D.NameApproved,'') <> '')
			and (isnull(D.LocationPath,'') = '' or isnull(D.LocationPath,'') like '%+%')
			AND NOT (ISNULL(D.StatusCompletion, '') IN ('1', '0')) 
			AND isnull(D.StatusDevelopment,'') <> '0'
			AND not (D.ClassDoc like @Cls1 + '%' or 
					D.ClassDoc like @Cls2 + '%')
		select @Result = @@error if @Result <> 0 goto Err
	end
	
	
	If @Type = 10 or @Type is null
	begin
		INSERT INTO #dcs
			(DocID,
			ClassDoc,
			UserID,
			Descr,
			DateEvent,
			DateEventEnd,
			Type,
			CommentType,
			SpecialInfo,
			UserName,
			Comment)
		SELECT
			D.DocID, 
			D.ClassDoc, 
			C.UserID, 
			cast('<b>' + case len(isnull(D.Name,'')) when 0 then D.Description else D.Name end + '</b>' as varchar(125)) +
				case when len('<b>' + case isnull(len(D.Name),0) when 0 then D.Description else D.Name end + '</b>') > 125 then ' ...' else '' end +
				 + case len(isnull(D.Name,'')+isnull(D.Description,'')) when 0 then '' else '<br>' end + U.Info AS Descr, 
	        C.DateEvent,
			C.DateEventEnd,
			10 as Type,
			C.CommentType,
			C.SpecialInfo,
			C.UserName,
			cast(C.Comment as varchar(255))
		FROM dbo.Docs AS D 
		INNER JOIN @tmp U on CHARINDEX('<' + U.UserID + '>', D.ListToReconcile) > 0 
			AND CHARINDEX('<' + U.UserID + '>', D.ListReconciled) <= 0 		
		INNER JOIN dbo.Comments AS C ON D.DocIDInt = C.DocIDInt
				AND C.UserID = U.UserID
				AND C.CommentType = 'VISA' 
				AND C.SpecialInfo = 'VISAWAITING' 
				AND CHARINDEX('<' + C.UserID + '>', D.ListToReconcile) > 0 
				AND CHARINDEX('<' + C.UserID + '>', D.ListReconciled) <= 0
		WHERE UPPER(ISNULL(D.IsActive, '')) = 'Y'
			AND NOT (ISNULL(D.StatusCompletion, '') IN ('1', '0')) 
			AND not D.StatusDevelopment in ('0','4')
			AND NOT D.ListToReconcile like '%(#!)%'
			AND NOT D.ListToReconcile like '%(#$)%'
		select @Result = @@error if @Result <> 0 goto Err
	end
	
	
	If @Type = 10 or @Type is null
	begin
		INSERT INTO #dcs
			(DocID,
			ClassDoc,
			UserID,
			Descr,
			DateEvent,
			DateEventEnd,
			Type,
			CommentType,
			SpecialInfo,
			UserName,
			Address,
			Comment) --рецензия
		SELECT 
			D.DocID, 
			D.ClassDoc, 
			C.UserID, 
			cast('<b>' + case len(isnull(D.Name,'')) when 0 then D.Description else D.Name end + '</b>' as varchar(125)) +
				case when len('<b>' + case isnull(len(D.Name),0) when 0 then D.Description else D.Name end + '</b>') > 125 then ' ...' else '' end +
				 + case len(isnull(D.Name,'')+isnull(D.Description,'')) when 0 then '' else '<br>' end + U.Info AS Descr, 
	        C.DateEvent,
			C.DateEventEnd,
			20 as Type,
			C.CommentType,
			C.SpecialInfo,
			C.UserName,
			C.Address,
			cast(C.Comment as varchar(255))
		FROM dbo.Docs AS D 
		INNER JOIN dbo.Comments AS C ON D.DocIDInt = C.DocIDInt
				AND C.CommentType = 'REVIEW' 
				AND isnull(C.SpecialInfo,'') = ''
				AND C.Address = 'REQUEST' 
		INNER JOIN @tmp U on C.Comment like '%<' + U.UserID + '>%'
				AND not C.Comment like '%+<' + U.UserID + '>%'
		WHERE UPPER(ISNULL(D.IsActive, '')) = 'Y'
			AND NOT (ISNULL(D.StatusCompletion, '') IN ('1', '0')) 
			AND not D.StatusDevelopment in ('0','4')
		select @Result = @@error if @Result <> 0 goto Err
	end
	
	
	If @Type = 60 or @Type is null
	begin
		INSERT INTO #dcs
			(DocID,
			ClassDoc,
			UserID,
			Descr,
			DateEvent,
			DateEventEnd,
			Type) --корпоративные поручения,задачи - на контроле
		select
			D.DocID, 
			D.ClassDoc, 
			U.UserID,
			'<b>' + convert(varchar(118),D.Content) + '</b>' +
	  			+ case when len(convert(varchar(125),D.Content))> len(convert(varchar(118),D.Content)) then '...' else '' end +
				+ case len(convert(varchar(118),D.Content)) when 0 then '' else '<br>' end
			 + U.Info AS Descr, 
	        null as DateEvent,
			null as DateEventEnd,
			60 as Type
	    from dbo.Docs D
		INNER JOIN @tmp U on D.NameControl like '%<' + U.UserID + '>%'
		WHERE UPPER(ISNULL(D.IsActive, '')) = 'Y'
			AND (
				(D.ClassDoc in (@Cls11,@Cls12,@Cls13) AND ISNULL(D.StatusCompletion, '') = '+')
				OR 
				D.ClassDoc in (@Cls15,@Cls16)
				)
		select @Result = @@error if @Result <> 0 goto Err
	end
	
	
	If @Type =70 or @Type is null
	begin
		INSERT INTO #dcs
			(DocID,
			ClassDoc,
			UserID,
			Descr,
			DateEvent,
			DateEventEnd,
			Type)--корпоративные поручения, задачи - к исполнению
		select
			D.DocID, 
			D.ClassDoc, 
			U.UserID,
			'<b>' + 
			Upper(case 
				when ISNULL(D.StatusCompletion, '') <> '+' and convert(datetime,convert(varchar(100),D.DateCompletion,104),104) < convert(datetime,convert(varchar(100),getdate(),104),104)
					then '<font color = #FF0000>просрочено'
				else '<font color = #2E8B57>исполняется'
			end) + '</font><br>' +
	        case D.ClassDoc
				when 'Задачи'
					then cast(D.Description as varchar(50)) +
						case when len( D.Description) > 50 then ' ...' else '' end +
				 		+ case len(isnull(D.Description,'')) when 0 then '' else '<br>' end
					else convert(varchar(50),D.Content) +
	  			  		+ case when len(convert(varchar(55),D.Content))> len(convert(varchar(50),D.Content)) then '...' else '' end +
						+ case len(convert(varchar(50),D.Content)) when 0 then '' else '<br>' end
			end + '</b>' + U.Info AS Descr, 
	        null as DateEvent,
			D.DateCompletion as DateEventEnd,
			70 as Type
	    from dbo.Docs D
		INNER JOIN @tmp U on D.NameResponsible like '%<' + U.UserID + '>%'
		WHERE D.ClassDoc in (@Cls11,@Cls12,@Cls13)
			AND UPPER(ISNULL(D.IsActive, '')) = 'Y'
			AND NOT ISNULL(D.StatusCompletion, '') in ('0','1','+')
		select @Result = @@error if @Result <> 0 goto Err
	end

	If @Type is null
	begin
		select * from #dcs
		ORDER BY Type,DateEventEnd,DocID 
		--ORDER BY 7,6,1 
		select @Result = @@error if @Result <> 0 goto Err
	end
	else
	begin
		update C
			set Cnt1 = Cnt
		from #dcs C
		inner join (
			select ClassDoc, count(*) as Cnt
			from #dcs
			group by ClassDoc) as D on D.ClassDoc = C.ClassDoc
		select @Result = @@error if @Result <> 0 goto Err

		update C
			set Cnt2 = Cnt
		from #dcs C
		inner join (
			select substring(ClassDoc,1,charindex('/',ClassDoc)-1) as Cls, count(*) as Cnt
			from #dcs
			where ClassDoc like '%/%'
			group by substring(ClassDoc,1,charindex('/',ClassDoc)-1)) as D on C.ClassDoc like D.Cls + '/%'
		select @Result = @@error if @Result <> 0 goto Err

		select D.*, 
			C.UserID,
			C.UserName,
			'' as ContactUserID,
			C.DateEvent,
			C.DateEventEnd,
			C.Address as Address,
			'' as Subject,
			C.Comment,
			C.CommentType,
			C.SpecialInfo,
			0 as KeyField,
			'' as Version,
			C.DateEvent as CommentsDateCreation, 
			D.DateCreation as DocsDateCreation, 
			'' as CommentsFileName,
			C.Cnt1, isnull(C.Cnt2,C.Cnt1) as Cnt2
		from #dcs C
		inner join dbo.Docs D on D.DocID = C.DocID
		order by case when @Type in (10,20,30) then '1900-01-01' else C.DateEvent end, 
				D.ClassDoc, 
				case when @Type in (10,20,30) then C.DateEvent else '1900-01-01' end, 
				C.DocID
		select @Result = @@error if @Result <> 0 goto Err
	
	end


	drop table #dcs
	return @Result
Err:
	
	drop table #dcs
	return @Result



GO
/****** Object:  StoredProcedure [dbo].[PDX_UNI_Users] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_UNI_Users]
	@UserID varchar(255),
	@FIO varchar(255)
as

declare @Result int
select @Result = 0

	select 
		UserID,
		Name as UserName,
		Email,
		Department,
		PartnerName,
		Position,
		case StatusActive
			when '' then 'Нет'
			when '0' then 'Да (только Email-клиент)'
			when '1' then 'Да'
			when '-' then 'Нет (только как роль)'
			when '=' then 'Нет (только файлы по email)'
		end as StatusActive,
		case ReadSecurityLevel
			when '0' then 'Запрещен'
			when '1' then 'Общедоступный'
			when '2' then 'Для служебного пользования'
			when '3' then 'Конфиденциальный'
			when '4' then 'Только для лиц, указанных в карточке'
			when '10' then 'Системный администратор'
		end as ReadSecurityLevel,
		case WriteSecurityLevel
			when '0' then 'Запрещен'
			when '1' then 'Общедоступный'
			when '2' then 'Для служебного пользования'
			when '3' then 'Конфиденциальный'
			when '4' then 'Только для лиц, указанных в карточке'
			when '10' then 'Системный администратор'
		end as WriteReadSecurityLevel,
		ActDoc,
		ClassDoc,
		CompanyDoc,
		PossibleRoles,
		Comment		
	from dbo.Users 
	where UserID = @UserID
		or Name like '%' + @FIO + '%'
	select @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:
	
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_urepList] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_urepList]
	@UserID varchar(128) = ''

as

declare @Result int
select @Result = 0


	select
		L.SetID,
		L.ReportName,
		L.STProc,
		L.XSLTName
	from dbo.PDXrepList  L
	left join dbo.Users U on U.UserID = @UserID
	where isnull(L.UsersList,'') like '%<' + @UserID + '>%' --доступ по доменному логину
		or
			(ltrim(rtrim(isnull(L.UsersList,''))) = '' and ltrim(rtrim(isnull(L.ReportType,''))) <> ''
			and (isnull(U.ReportTypes,'') like '%' + L.ReportType + '%'
				or isnull(U.ReportTypes,'') like '%ALL%') --если не прописан доступ по логину, то может быть доступ по группе отчетов
			)
		or isnull(U.WriteSecurityLevel,0) >= 10 --доступ для админа на все
		
		/*and (U.ReportTypes like '%' + L.ReportType + '%'
		or U.ReportTypes like '%ALL%')*/
	order by L.ReportName
	select @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:
	
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_urepReportParam] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_urepReportParam]
	@ReportID uniqueidentifier
as

declare @Result int
select @Result = 0

  
	select
		--P.SetID,
		P.ParamType,
		P.ParamID,
		case when P.ParamType = 0 then '' else P.ParamName end as ParamName,
		case
			when exists (select 1 from dbo.PDXrepParamVal V where V.ParamID = P.SetID)
				then 'exec dbo.PDX_urepReportParamVal @ParamID=''' + cast(P.SetID as varchar(40)) + ''''
			when P.ParamValue like 'exec%' or P.ParamValue like 'select%' or P.ParamType = 0--скрытое
				then P.ParamValue
			else ''
		end as ParamValue, 
		P.OrderIndex
	from dbo.PDXrepParam P
	where P.ReportID = @ReportID
	order by P.OrderIndex
	select @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:
	
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_urepReportParamVal] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDX_urepReportParamVal]
	@ParamID uniqueidentifier
as

declare @Result int
select @Result = 0

  
	select
		ValueID,
		Value
	from dbo.PDXrepParamVal
	where ParamID = @ParamID
	order by Value
	select @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:
	
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[PDX_UserDirNomGrp_Change] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--drop proc [dbo].[PDX_UserDirNomGrp_Change]
--go
CREATE proc [dbo].[PDX_UserDirNomGrp_Change]
	@Code varchar(64),
	@Descr varchar(512),
	@SetID int,
	@ParentName varchar(512),
	@NC varchar(128),
	@Act int, --1--ceate, 2-update,3 delete
	@Chk bit = 0
	
as
	declare  @Res int

	declare @ErrList varchar(1024),
		@ParentID int, @Cnt int,
		@ParentCode varchar(64),
		@GrParent varchar(256)

	select @Res = 0,@ErrList = ''
	
	create table #cfo (SetID int, ParentID int)

	select
		@Code = ltrim(rtrim(isnull(@Code,''))),
		@Descr = ltrim(rtrim(isnull(@Descr,''))),
		@NC  = ltrim(rtrim(isnull(@NC,''))),
		@ParentID = null,
		@ParentName = ltrim(rtrim(isnull(@ParentName,''))),
		@Cnt = 1
		select @Res = @@error if @Res <> 0 goto Err

If @ParentName like '%<%>%'
begin
	select @ParentCode = dbo.PDX_SubstringReturn(@ParentName, charindex('<',@ParentName), charindex('>',@ParentName))
	select @Res = @@error if @Res <> 0 goto Err
end

/************************************
ПРОВЕРКИ ВВЕДЕННЫХ ЗНАЧЕНИЙ
*************************************/

If @Code = ''
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Укажите код'
	goto NXT
end
If len(@Code) > 64 
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Превышена максимально допустимая длина Кода (всего - ' + cast(len(@Code) as varchar(100)) + ', макс. - 64)'
	goto NXT
end

If exists (select 1 from dbo.UserDir_NomGrp where Code = @Code 
		and KeyField <> isnull(@SetID,-1))
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Номенклатурная группа с указаным кодом в справочнике уже существует'
	select @Res = @@error if @Res <> 0 goto Err		
end

If not @ParentCode is null
begin
	select @ParentID = KeyField
	from dbo.UserDir_NomGrp 
	where Code = @ParentCode
	select @Res = @@error if @Res <> 0 goto Err
	
	If @ParentID is null
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Родительская Номенклатурная группа не существует'
		select @Res = @@error if @Res <> 0 goto Err		
	end
	IF @Act = 2 
	begin 
		insert into #cfo (SetID)
		values (@SetID)
		select @Res = @@error if @Res <> 0 goto Err	

		while @cnt > 0 and not exists (select 1 from #cfo where SetID = @ParentID)
		begin
			insert into #cfo (SetID)
			select C.KeyField
			from dbo.UserDir_NomGrp C
			inner join #cfo F on F.SetID = C.ParentKeyField
			where not exists (select 1 from #cfo V where V.SetID = C.KeyField)
			select @cnt=@@rowcount,@Res = @@error if @Res <> 0 goto Err	
		end
		select @Res = @@error if @Res <> 0 goto Err	
		
		If exists (select 1 from #cfo where SetID = @ParentID)
		begin
			select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
				'Некорректно указана Родительская Номенклатурная группа (нельзя в качестве родителя указывать дочерний узел).'
			select @Res = @@error if @Res <> 0 goto Err		
		end
	end
	
	
end --If not @ParentCode is null

IF @Act = 3
begin
	If exists (select 1 from dbo.UserDir_NomGrp where ParentKeyField = @SetID)
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Нальзя удалить элемент, у него есть подчиненые.'
		select @Res = @@error if @Res <> 0 goto Err		
	end
end
/************************************/

NXT:

If @Chk = 0
begin --если это создание , то нужно генерить ошибкуесли она есть
	If @ErrList <> '' 
	begin
		RAISERROR (@ErrList, 16,1)
		goto Err
	end
end
else --если это проверка просто выводим сообщение, даже если оно пустое
begin
	select @ErrList as ErrList 
	select @Res = @@error if @Res <> 0 goto Err
end

IF @ErrList = '' and @Chk = 0
BEGIN
	if @Act = 2
	begin
		update dbo.UserDir_NomGrp
			set 
				Code = @Code,
				Descr = @Descr,
				ParentKeyField = @ParentID,
				NLM = @NC,
				DLM = getdate()
		where KeyField = @SetID
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 1
	begin
		insert into dbo.UserDir_NomGrp
			(Code, Descr, ParentKeyField,  NC, DC, NLM, DLM)
		values 
			(@Code, @Descr, @ParentID, @NC, getdate(), @NC, getdate())
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 3
	begin
		delete from dbo.UserDir_NomGrp where KeyField = @SetID
		select @Res = @@error if @Res <> 0 goto Err
	end
END
	select @Res = @@error if @Res <> 0 goto Err

	drop table #cfo
OK:

	return @Res
Err:
	return @Res








GO
/****** Object:  StoredProcedure [dbo].[PDX_UserDirOborot_Change] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--drop proc [dbo].[PDX_UserDirOborot_Change]
--go
CREATE proc [dbo].[PDX_UserDirOborot_Change]
	@Code varchar(64),
	@Descr varchar(512),
	@SetID int,
	@ParentName varchar(512),
	@NC varchar(128),
	@Act int, --1--ceate, 2-update,3 delete
	@Chk bit = 0
	
as
	declare  @Res int

	declare @ErrList varchar(1024),
		@ParentID int, @Cnt int,
		@ParentCode varchar(64),
		@GrParent varchar(256)

	select @Res = 0,@ErrList = ''
	
	create table #cfo (SetID int, ParentID int)

	select
		@Code = ltrim(rtrim(isnull(@Code,''))),
		@Descr = ltrim(rtrim(isnull(@Descr,''))),
		@NC  = ltrim(rtrim(isnull(@NC,''))),
		@ParentID = null,
		@ParentName = ltrim(rtrim(isnull(@ParentName,''))),
		@Cnt = 1
		select @Res = @@error if @Res <> 0 goto Err

If @ParentName like '%<%>%'
begin
	select @ParentCode = dbo.PDX_SubstringReturn(@ParentName, charindex('<',@ParentName), charindex('>',@ParentName))
	select @Res = @@error if @Res <> 0 goto Err
end

/************************************
ПРОВЕРКИ ВВЕДЕННЫХ ЗНАЧЕНИЙ
*************************************/

If @Code = ''
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Укажите код статьи'
	goto NXT
end
If len(@Code) > 64 
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Превышена максимально допустимая длина Кода (всего - ' + cast(len(@Code) as varchar(100)) + ', макс. - 64)'
	goto NXT
end

If exists (select 1 from dbo.UserDir_Oborot where Code = @Code 
		and KeyField <> isnull(@SetID,-1))
begin
	select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Статья оборотов БИТ с указаным кодом в справочнике уже существует'
	select @Res = @@error if @Res <> 0 goto Err		
end

If not @ParentCode is null
begin
	select @ParentID = KeyField
	from dbo.UserDir_Oborot 
	where Code = @ParentCode
	select @Res = @@error if @Res <> 0 goto Err
	
	If @ParentID is null
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Родительская Статья оборотов БИТ не существует'
		select @Res = @@error if @Res <> 0 goto Err		
	end
	IF @Act = 2 
	begin 
		insert into #cfo (SetID)
		values (@SetID)
		select @Res = @@error if @Res <> 0 goto Err	

		while @cnt > 0 and not exists (select 1 from #cfo where SetID = @ParentID)
		begin
			insert into #cfo (SetID)
			select C.KeyField
			from dbo.UserDir_Oborot C
			inner join #cfo F on F.SetID = C.ParentKeyField
			where not exists (select 1 from #cfo V where V.SetID = C.KeyField)
			select @cnt=@@rowcount,@Res = @@error if @Res <> 0 goto Err	
		end
		select @Res = @@error if @Res <> 0 goto Err	
		
		If exists (select 1 from #cfo where SetID = @ParentID)
		begin
			select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
				'Некорректно указана Родительская Статья оборотов БИТ (нельзя в качестве родителя указывать дочерний узел).'
			select @Res = @@error if @Res <> 0 goto Err		
		end
	end
	
	
end --If not @ParentCode is null

IF @Act = 3
begin
	If exists (select 1 from dbo.UserDir_Oborot where ParentKeyField = @SetID)
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Нальзя удалить элемент, у него есть подчиненые.'
		select @Res = @@error if @Res <> 0 goto Err		
	end
end
/************************************/

NXT:

If @Chk = 0
begin --если это создание , то нужно генерить ошибкуесли она есть
	If @ErrList <> '' 
	begin
		RAISERROR (@ErrList, 16,1)
		goto Err
	end
end
else --если это проверка просто выводим сообщение, даже если оно пустое
begin
	select @ErrList as ErrList 
	select @Res = @@error if @Res <> 0 goto Err
end

IF @ErrList = '' and @Chk = 0
BEGIN
	if @Act = 2
	begin
		update dbo.UserDir_Oborot
			set 
				Code = @Code,
				Descr = @Descr,
				ParentKeyField = @ParentID,
				NLM = @NC,
				DLM = getdate()
		where KeyField = @SetID
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 1
	begin
		insert into dbo.UserDir_Oborot
			(Code, Descr, ParentKeyField,  NC, DC, NLM, DLM)
		values 
			(@Code, @Descr, @ParentID, @NC, getdate(), @NC, getdate())
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 3
	begin
		delete from dbo.UserDir_Oborot where KeyField = @SetID
		select @Res = @@error if @Res <> 0 goto Err
	end
END
	select @Res = @@error if @Res <> 0 goto Err

	drop table #cfo
OK:

	return @Res
Err:
	return @Res








GO
/****** Object:  StoredProcedure [dbo].[PDX_VISAAmountListGet] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE proc [dbo].[PDX_VISAAmountListGet]
	@DocID varchar(128)
as

declare @DocIDInt int

select 
	@DocIDInt = DocIDInt
from dbo.Docs
where DocID = @DocID


select
L.LogEntryTime,
case L.LogEntryType
	when 'VISAOK' then 'СОГЛАСОВАНО'
	when 'VISAOKREFUSE' then 'ОТКАЗАНО В СОГЛ.'
	else L.LogEntryType
end as LogEntryType,
case 
	when U.UserID IS null then L.LogEntryUserID
	else U.Name + ' (' + U.UserID + ')'
end as LogEntryUserID,
L.AmountDoc,
L.UserFieldMoney1,
L.Currency
from dbo.PDXLogDocs L
inner join dbo.PDX_FinanceUserList() F on F.UserID = L.LogEntryUserID
left join dbo.Users U on U.UserID = L.LogEntryUserID
where L.DocIDInt = @DocIDInt
order by 1

GO
/****** Object:  StoredProcedure [dbo].[PDX_ZOOGet] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE proc [dbo].[PDX_ZOOGet]
	@DocID varchar(128)
as

declare @Cls varchar(128), @NA varchar(128)
set @Cls = dbo.PDX_CLSGet('RIK_CategoryName_OTHERS_ZOO')

select
	@NA = case when NA.Name is null	
			then U.Field3
			else dbo.PDX_FIObyFullNameGet2(NA.Name)
		end
from dbo.UserDirValues U
left join dbo.Users NA on U.Field3 like '%<' + NA.UserID + '>%'
where U.UDKeyField = 68
and U.Field1= '{56780D82-D474-459A-9FC6-87E95B75F141}'

select 
	D.Department, 
	D.NameCreation, 
	case when A.Name is null	
		then D.Author
		else dbo.PDX_FIObyFullNameGet2(A.Name)
	end as Author,--D.Author, 
	D.Description, 
	dbo.PDX_FIObyFullNameGet2(NA.Name) as NameAproval, --D.NameAproval
	/*case when D.DateApproved IS null 
		then '«___» ____________ _____г.'
		else
	'«' + right('0'+cast(DATEPART(DAY,D.DateApproved) as varchar(2)) ,2) + '» ' +
		case DATEPART(MONTH,D.DateApproved) 
			when 1 then 'января'
			when 2 then 'февраля'
			when 3 then 'марта'
			when 4 then 'апреля'
			when 5 then 'мая'
			when 6 then 'июня'
			when 7 then 'июля'
			when 8 then 'августа'
			when 9 then 'сентября'
			when 10 then 'октярбя'
			when 11 then 'ноября'
			when 12 then 'декабря'
		end + ' ' + cast(DATEPART(YEAR,D.DateApproved) as varchar(4)) + 'г.'
	end*/ '«____» ____________ _____г.' as DateApproved,
	
	case when IsActive = 'Y' and ISNULL(StatusDevelopment,'')='0' then 0 
		when IsActive = 'Y' and ISNULL(StatusDevelopment,'')='4' then 1
		else -1
	end as ST,
	@NA as NA,
	D.DocID,
	D.NameCreation
from dbo.Docs D
left join dbo.Users A on D.Author like '%<' + A.UserID + '>%'
left join dbo.Users NA on D.NameAproval like '%<' + NA.UserID + '>%'
where D.DocID =@DocID
and D.ClassDoc = @Cls

GO
/****** Object:  StoredProcedure [dbo].[PDXLogCreate] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE proc [dbo].[PDXLogCreate]
	@DocID		varchar(128),
	@UserID		varchar(32),
	@EventType	varchar(512)
as
declare	
	@sClassDoc		varchar(64)
	,@logentryid	int
	,@errormsg		varchar(2048)
	
set @sClassDoc = null

if ltrim(rtrim(isnull(@DocID,''))) <> '' and ltrim(rtrim(isnull(@UserID,''))) <> '' and ltrim(rtrim(isnull(@EventType,''))) <> ''
begin

	select @sClassDoc=ClassDoc from dbo.Docs where DocID=@DocID
	if not @sClassDoc is null -- document exists
	begin
		begin tran 

		begin try
			if exists(select top 1 * from dbo.PDXLogSettings ls where ls.ClassDoc=@sClassDoc and ls.EventType=@EventType and UPPER(ls.TableName)='DOCS') 
			begin
				insert into dbo.PDXLogDocs( 
					LogEntryTime
					,LogEntryType
					,LogEntryUserID
					,DocID,GUID,DocIDadd,DocIDIncoming,DocIDParent,DocIDPrevious,Author,Correspondent,Resolution,History,Result,PercentCompletion,Department,Name,Description
					,LocationURL,LocationPaper,FileNamePrefix,FileName,FileNameNameLastModification,FileNameDateLastAccessed,FileNameDateLastModification,LocationPath,ExtInt
					,PartnerName,StatusDevelopment,StatusPayment,StatusArchiv,StatusCompletion,StatusDelivery,TypeDoc,ClassDoc,ActDoc,InventoryUnit,PaymentMethod,AmountDoc
					,QuantityDoc,DateActivation,SecurityLevel,DateCreation,DateCompletion,DateCompleted,DateExpiration,NameCreation,NameAproval,NameApproved,DateApproved,ListToEdit
					,ListToReconcile,ListReconciled,NameResponsible,NameControl,NameLastModification,DateLastModification,UserFieldText1,UserFieldText2,UserFieldText3
					,UserFieldText4,UserFieldText5,UserFieldText6,UserFieldText7,UserFieldText8,UserFieldMoney1,UserFieldMoney2,UserFieldDate1,UserFieldDate2,UserFieldDate3
					,UserFieldDate4,UserFieldDate5,UserFieldDate6,UserFieldDate7,UserFieldDate8,IsActive,DateActive,BusinessProcessStep,ExtPassword,DateSigned,Currency
					,CurrencyRate,Rank,ListToView,License,TransferGUID, DocIDInt)
				select
					getdate()
					,@EventType
					,@UserID
					,DocID,GUID,DocIDadd,DocIDIncoming,DocIDParent,DocIDPrevious,Author,Correspondent,Resolution,History,Result,PercentCompletion,Department,Name,Description
					,LocationURL,LocationPaper,FileNamePrefix,FileName,FileNameNameLastModification,FileNameDateLastAccessed,FileNameDateLastModification,LocationPath,ExtInt
					,PartnerName,StatusDevelopment,StatusPayment,StatusArchiv,StatusCompletion,StatusDelivery,TypeDoc,ClassDoc,ActDoc,InventoryUnit,PaymentMethod,AmountDoc
					,QuantityDoc,DateActivation,SecurityLevel,DateCreation,DateCompletion,DateCompleted,DateExpiration,NameCreation,NameAproval,NameApproved,DateApproved,ListToEdit
					,ListToReconcile,ListReconciled,NameResponsible,NameControl,NameLastModification,DateLastModification,UserFieldText1,UserFieldText2,UserFieldText3
					,UserFieldText4,UserFieldText5,UserFieldText6,UserFieldText7,UserFieldText8,UserFieldMoney1,UserFieldMoney2,UserFieldDate1,UserFieldDate2,UserFieldDate3
					,UserFieldDate4,UserFieldDate5,UserFieldDate6,UserFieldDate7,UserFieldDate8,IsActive,DateActive,BusinessProcessStep,ExtPassword,DateSigned,Currency
					,CurrencyRate,Rank,ListToView,License,TransferGUID, DocIDInt
			  from dbo.Docs
			  where DocID=@DocID

			  select @logentryid = SCOPE_IDENTITY()

			end
			
			if exists(select top 1 * from dbo.PDXLogSettings ls where ls.ClassDoc=@sClassDoc and ls.EventType=@EventType and UPPER(ls.TableName)='PDXDOCDETAILS') 
			begin
				insert into dbo.PDXLogDocDetails (
					DocLogEntryID
					,LogEntryTime
					,LogEntryType
					,LogEntryUserID
					,SetID,DocID,ClassDoc,Tx1,Tx2,Tx3,Tx4,Tx5,TxL1,TxL2,Dt1,Dt2,Dt3,Dt4,Dt5,Am1,Am2,Am3,Am4,Am5,Bl1,Bl2,Bl3,Bl4,Bl5,NC,DC,NLM,DLM)
				select
					@logentryid
					,getdate()
					,@EventType
					,@UserID
					,SetID,DocID,ClassDoc,Tx1,Tx2,Tx3,Tx4,Tx5,TxL1,TxL2,Dt1,Dt2,Dt3,Dt4,Dt5,Am1,Am2,Am3,Am4,Am5,Bl1,Bl2,Bl3,Bl4,Bl5,NC,DC,NLM,DLM
				from dbo.PDXDocDetails
				where DocID=@DocID
			end			
			
			if not @logentryid is null
			begin
				-- Write log entry
				insert into dbo.Log (DateTime,UserID,DocID,Action,UserName,DocName,IPAddress) 
				select getdate(),@UserID,@DocID,'Данные документа ' + @DocID + ' сохранены в лог с id=' + convert(varchar,@logentryid),u.Name,LEFT(isnull(d.Name,'') + ' ' + ISNULL(d.Description,''),128),''
				from dbo.Docs d
					left join dbo.Users u on u.UserID=@UserID
				where d.DocID=@DocID
			end
			commit tran
		end try
		begin catch

			select @errormsg = left(2000,convert(varchar,ERROR_NUMBER()) + '(' + CONVERT(varchar,ERROR_LINE()) + '): ' + convert(varchar(2000),ERROR_MESSAGE()))

			rollback tran

			-- Write log entry
			insert into dbo.Log (DateTime,UserID,DocID,Action,UserName,DocName,IPAddress) 
			select getdate(),@UserID,@DocID,'Ошибка сохранения данных документа ' + @errormsg,u.Name,LEFT(isnull(d.Name,'') + ' ' + ISNULL(d.Description,''),128),''
			from dbo.Docs d
				left join dbo.Users u on u.UserID=@UserID
			where d.DocID=@DocID
			raiserror(@errormsg,10,1)
		end catch
	end
end

GO
/****** Object:  StoredProcedure [dbo].[PDXLogSelectOrderToPay] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[PDXLogSelectOrderToPay]
	@docid varchar(128)
as

declare @vhist table (rowid int,userid varchar(16), vtype varchar(32), vtime datetime)

insert into @vhist (rowid,userid, vtype,vtime)
select
	KeyField,UserID,SpecialInfo,DateEventEnd
from dbo.Comments c
where DocID=@docid
	and CommentType='VISA'
	and SpecialInfo in ('VISAOK','VISAOKREFUSE')
order by DateEventEnd

/*select * from @vhist

select
		dl.LogEntryID
		,v.rowid
		,v.userid
		,v.vtype
		,v.vtime
		,dl.Currency
	from @vhist v
		inner join dbo.PDXLogDocs dl on dl.DocID=@docid
	where v.vtime = (select MAX(vtime) from @vhist where userid=v.userid)
		and dl.LogEntryTime = (select MAX(LogEntryTime) from dbo.PDXLogDocs where LogEntryUserID=v.userid and DocID=dl.DocID)
*/
;with l (id, commentid, userid, entrytype, eventtime, logtime, cur) as 
(
	select
		dl.LogEntryID
		,v.rowid
		,v.userid
		,v.vtype
		,v.vtime
		,dl.LogEntryTime
		,dl.Currency
	from @vhist v
		inner join dbo.PDXLogDocs dl on (dl.DocID=@docid and dl.LogEntryUserID=v.userid and dl.LogEntryType=v.vtype)
	where v.vtime = (select MAX(vtime) from @vhist where userid=v.userid)
--		and ABS(DATEDIFF(mcs,dl.LogEntryTime,v.vtime)) = (select MIN(ABS(DATEDIFF(mcs,LogEntryTime,v.vtime))) from dbo.PDXLogDocs where LogEntryUserID=v.userid and DocID=dl.DocID)
		
)
select
	ld.LogEntryID as DocLogEntryID,
	0 as DetailLogID,
	ld.LogEntryTime,
	llog.eventtime,
	ld.LogEntryType,
	ld.LogEntryUserID,
	u.Name as LogEntryUserName,
	ld.DocID,
	ld.Name,
	ld.AmountDoc,
	ld.Currency
from dbo.PDXLogDocs ld
	inner join l as llog on (llog.id = ld.LogEntryID)
	inner join dbo.Users u on u.UserID=ld.LogEntryUserID
where ABS(DATEDIFF(ms,llog.eventtime,llog.logtime)) = (select MIN(ABS(DATEDIFF(ms,l2.eventtime,l2.logtime))) from l l2 where l2.userid=llog.userid)
union all
select 
	ldd.DocLogEntryID,
	1 as DetailLogID,--ldd.DetailLogID,
	ldd.LogEntryTime,
	llog.eventtime,
	'',
	ldd.LogEntryUserID,
	u.Name as LogEntryUserName,
	ldd.DocID,
	ldd.Tx1 as Name,
	ldd.Am1 as AmountDoc,
	null as Currency
from dbo.PDXLogDocDetails ldd
	inner join l as llog on (llog.id = ldd.DocLogEntryID)
	inner join dbo.Users u on u.UserID=ldd.LogEntryUserID
where ABS(DATEDIFF(ms,llog.eventtime,llog.logtime)) = (select MIN(ABS(DATEDIFF(ms,l2.eventtime,l2.logtime))) from l l2 where l2.userid=llog.userid)
order by 3 asc,2 asc,Name asc
GO
/****** Object:  StoredProcedure [dbo].[PDXLTVRules_Change] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

create proc [dbo].[PDXLTVRules_Change]
	@ADoc varchar(256),
	@ClassDoc varchar(256),
	@Dept varchar(256),
	@Users varchar(1024),
	@notSL4 int,
	@SetID uniqueidentifier,
	@NC varchar(128),
	@Act int, --1--ceate, 2-update,3 delete
	@Chk bit = 0
	
as
	declare  @Res int

	declare @ErrList varchar(1024),
			@ErrorStr varchar(1024)

	select @Res = 0,@ErrList = ''
	declare @tbl table (Val varchar(1024), Pos int, Flag bit, Val2 varchar(128))
	
	select
		@ADoc = ltrim(rtrim(isnull(@ADoc,''))),
		@ClassDoc = ltrim(rtrim(isnull(@ClassDoc,''))),
		@Dept = ltrim(rtrim(isnull(@Dept,''))),
		@Users = ltrim(rtrim(isnull(@Users,''))),
		@notSL4 = case when ISNULL(@notSL4,0)>1 then 1 else ISNULL(@notSL4,0) end
	select @Res = @@error if @Res <> 0 goto Err


/************************************
ПРОВЕРКИ ВВЕДЕННЫХ ЗНАЧЕНИЙ
*************************************/
If @Act in (1,2)
begin

	If @ADoc <> '' and not exists (select 1 from dbo.Activities where Name = @ADoc)
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Выбран не существующий вид дея-ти.'
		goto NXT
	end
	
	If @ClassDoc = '' or not exists (select 1 from dbo.DocTypes where Name like @ClassDoc + '%')
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Не указана категория или выбрана не существующая категория.'
		goto NXT
	end
	else
	begin
        If @ADoc = '' and isnull((select case when min(upper(bActDoc))=max(upper(bActDoc)) and min(upper(bActDoc)) = 'Y' then 1 else 0 end from dbo.DocTypes where Name like @ClassDoc + '%'),0) <> 0
		begin
			select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Для выбранной категории должен обязательно быть указан вид деятельности.'
			goto NXT
		end
		select @Res = @@error if @Res <> 0 goto Err
	end
	
	 If @Dept <> '' and not exists(select 1 from Departments where Name like @Dept+'%')
	begin
      select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
		'Указано несуществующее подразделение.'
		goto NXT
	end
	
	if @Users <> ''
	begin
		insert into @Tbl(Val,Pos,Flag)
		exec dbo.PDX_ArrayToTable
			@Separator1 ='<',
			@Separator2 ='>',
			@Value = @Users
		select @Res = @@error if @Res <> 0 goto Err
	
		update T	
			set Pos = case when U.UserID is null then null else Pos end,
			Val2 = U.Name
		from @tbl T
		left join dbo.Users U on U.UserID = T.Val
			and U.DateExpirationSecurity > convert(datetime, convert(varchar(100), GETDATE(), 104), 104)
			and U.StatusActive = '1'
			and not U.Permitions like '%*%'
		--where U.UserID is null
		select @Res = @@error if @Res <> 0 goto Err
		
		if exists (select 1 from @tbl where Pos is null)
		begin 
			select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Пользователь [' + Val + '] не существует.' 
			from @tbl where Pos is null
			select @Res = @@error if @Res <> 0 goto Err
			delete from @tbl where Pos is null
			select @Res = @@error if @Res <> 0 goto Err
			--goto NXT
		end
		select @Users = ''
		select @Users  = @Users + case len(@Users) when 0 then '' else CHAR(13)+CHAR(10) end + '"' + dbo.PDX_FIObyFullNameGet(Val2) + '" <' + Val + '>;' 
		from @tbl
		select @Res = @@error if @Res <> 0 goto Err
	end	
end

/************************************/

NXT:
	
If @Chk = 0
begin --если это создание , то нужно генерить ошибкуесли она есть
	If @ErrList <> '' 
	begin
		RAISERROR (@ErrList, 16,1)
		goto Err
	end
end
else --если это проверка просто выводим сообщение, даже если оно пустое
begin
	select @ErrList as ErrList 
	select @Res = @@error if @Res <> 0 goto Err
end

IF @ErrList = '' and @Chk = 0
BEGIN
	if @Act = 1
	begin
		insert into dbo.PDXLTVRules
			(SetID,
			ActDoc,
			ClassDoc,
			Department,
			Users,			
			notForSL4,			
			NC,
			DC,
			NLM,
			DLM)
		values
			(NEWID(),
			@ADoc,
			@ClassDoc,
			@Dept,
			ltrim(rtrim(@Users)),
			@notSL4,
			@NC,
			getdate(),
			@NC,
			getdate())
		select @Res = @@error if @Res <> 0 goto Err

	end
	else
	if @Act = 2
	begin
		update dbo.PDXLTVRules
			set 
				ActDoc = @ADoc,
				ClassDoc = @ClassDoc,
				Department= @Dept,
				Users = ltrim(rtrim(@Users)),		
				notForSL4 = @notSL4,			
				NLM = @NC,
				DLM = getdate()
		where SetID = @SetID
		select @Res = @@error if @Res <> 0 goto Err
	end
	else
	If @Act = 3
	begin
		delete dbo.PDXLTVRules 
		where SetID = @SetID	
		select @Res = @@error if @Res <> 0 goto Err
	end

END
	select @Res = @@error if @Res <> 0 goto Err

OK:

	return @Res
Err:
	return @Res

GO
/****** Object:  StoredProcedure [dbo].[PDXLTVRules_Get] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE proc [dbo].[PDXLTVRules_Get]
	@ADoc varchar(256),
	@ClassDoc varchar(256),
	@Dept varchar(256)
as
	declare  @Res int

	declare @ErrList varchar(1024),
			@ErrorStr varchar(1024)

	select @Res = 0,@ErrList = ''
	declare @tbl table (OI smallint, notForSL4 int, onlyDefault int, Position varchar(256))
	
	select
		@ADoc = ltrim(rtrim(isnull(@ADoc,''))),
		@ClassDoc = ltrim(rtrim(isnull(@ClassDoc,''))),
		@Dept = ltrim(rtrim(isnull(@Dept,'')))
	select @Res = @@error if @Res <> 0 goto Err

	if @ClassDoc in (
		dbo.PDX_CLSGet('RIK_CategoryName_OTHERS_MOB'),
		dbo.PDX_CLSGet('RIK_CategoryName_CLEARING_C'),
		dbo.PDX_CLSGet('RIK_CategoryName_RAB_SOGLAS'),
		dbo.PDX_CLSGet('RIK_CategoryName_RASPDOC_PR'),
		dbo.PDX_CLSGet('RIK_CategoryName_OTHERS_ZOO'),
		dbo.PDX_CLSGet('RIK_CategoryName_VHOD_VNESH'),
		dbo.PDX_CLSGet('RIK_CategoryName_RASPDOC_RS'),
		dbo.PDX_CLSGet('RIK_CategoryName_ORDER_CONT'),
		dbo.PDX_CLSGet('RIK_CategoryName_OTHERS_N_Z'),
		dbo.PDX_CLSGet('RIK_CategoryName_OTHERS_TRP')
		)
	begin
		select R.notForSL4, '"' + dbo.PDX_FIObyFullNameGet(U.Name) + '" <' + U.UserID + '>;' as 'Position'
		from dbo.PDXLTVRules R
		inner join dbo.Users U on R.Users like '%<' + U.UserID + '>%'
			and U.DateExpirationSecurity > CONVERT(datetime, convert(varchar(100), getdate(), 104), 104)
			and U.StatusActive = '1'
			and not U.Permitions like '%*%'
		where (R.ClassDoc = '' or @ClassDoc like R.ClassDoc + '%')
			and (R.ActDoc = '' or R.ActDoc = @ADoc)
			and (R.Department = '' or @Dept like R.Department + '%')
		
		order by 2
		select @Res = @@error if @Res <> 0 goto Err
	
	end
	else
	begin
		select top 0 0 as notForSL4, '' as 'Position'
	end
		
	select @Res = @@error if @Res <> 0 goto Err

OK:

	return @Res
Err:
	return @Res


GO
/****** Object:  StoredProcedure [dbo].[PDXRecPayRules_Change] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE proc [dbo].[PDXRecPayRules_Change]
	@ClassDoc [varchar](128),
	@CFO varchar(256),
	@BE varchar(256),
	@AmRUBmin varchar(128),
	@AmRUBmax varchar(128),
	@AmEURmin varchar(128),
	@AmEURmax varchar(128),
	@AmUSDmin varchar(128),
	@AmUSDmax varchar(128),
	@UserName [varchar](96),
	@RLPos [int],
	@DateFrom [datetime],
	@DateTo [datetime],
	@SetID uniqueidentifier,
	
	@NC varchar(128),
	@Act int, --1--ceate, 2-update,3 delete
	@Chk bit = 0
	
as
	declare  @Res int

	declare @ErrList varchar(1024), @GrClass varchar(128),
	@AmRUBmin2 money,	@AmRUBmax2 money,
	@AmEURmin2 money,	@AmEURmax2 money,
	@AmUSDmin2 money,	@AmUSDmax2 money,
	@UserID varchar(128)
	

	select @Res = 0,@ErrList = ''
	
	select
		@ClassDoc = ltrim(rtrim(isnull(@ClassDoc,''))),
		@CFO = ltrim(rtrim(isnull(@CFO,''))),
		@BE = ltrim(rtrim(isnull(@BE,''))),
		@UserName = ltrim(rtrim(isnull(@UserName,''))),
		@RLPos = isnull(@RLPos,0),
		@NC  = ltrim(rtrim(isnull(@NC,''))),
		
		@AmRUBmin = replace(replace(replace(ISNULL(@AmRUBmin,''),CHAR(160),''),' ',''),',','.'),
		@AmRUBmax = replace(replace(replace(ISNULL(@AmRUBmax,''),CHAR(160),''),' ',''),',','.'),
		@AmUSDmin = replace(replace(replace(ISNULL(@AmUSDmin,''),CHAR(160),''),' ',''),',','.'),
		@AmUSDmax = replace(replace(replace(ISNULL(@AmUSDmax,''),CHAR(160),''),' ',''),',','.'),
		@AmEURmin = replace(replace(replace(ISNULL(@AmEURmin,''),CHAR(160),''),' ',''),',','.'),
		@AmEURmax = replace(replace(replace(ISNULL(@AmEURmax,''),CHAR(160),''),' ',''),',','.'),
		
		@DateFrom = cast(ISNULL(@DateFrom,'1900-01-01') as DATE),		
		@DateTo = cast(ISNULL(@DateTo,'1900-01-01') as DATE)
	select @Res = @@error if @Res <> 0 goto Err

	set @GrClass = dbo.PDX_CLSGrGet('RIK_CategoryName_KAZ_ORDPAY')
/************************************
ПРОВЕРКИ ВВЕДЕННЫХ ЗНАЧЕНИЙ
*************************************/
If @Act in (1,2)
begin
	If @ClassDoc = ''
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Укажите категорию'
		goto NXT
	end
	/*if @BE = ''
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Укажите бизнес-единицу'
		goto NXT
	end*/
	If @CFO = ''
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Укажите ЦФО'
		goto NXT
	end

	If @UserName = ''
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Укажите пользователя'
		goto NXT
	end

	If YEAR(@DateFrom) = 1900
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Укажите Дата начала действия'
		goto NXT
	end
	If YEAR(@DateTo) = 1900
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Укажите Даты окончания действия'
		goto NXT
	end
	
	IF @DateFrom>@DateTo
	BEGIN
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Дата начала действия не может быть больше даты окончания.'
		select @Res = @@error if @Res <> 0 goto Err
	END

	if ISNUMERIC(@AmRUBmin) = 1
	begin
		set @AmRUBmin2 = CAST(@AmRUBmin as money)
		select @Res = @@error if @Res <> 0 goto Err	
	end
	else
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Некорректно указана "Сумма в РУБ мин."'
		select @Res = @@error if @Res <> 0 goto Err	
	end
	if ISNUMERIC(@AmRUBmax) = 1
	begin
		set @AmRUBmax2 = CAST(@AmRUBmax as money)
		select @Res = @@error if @Res <> 0 goto Err	
	end
	else
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Некорректно указана "Сумма в РУБ макс."'
		select @Res = @@error if @Res <> 0 goto Err	
	end
	if ISNUMERIC(@AmEURmin) = 1
	begin
		set @AmEURmin2 = CAST(@AmEURmin as money)
		select @Res = @@error if @Res <> 0 goto Err	
	end
	else
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Некорректно указана "Сумма в EUR мин."'
		select @Res = @@error if @Res <> 0 goto Err	
	end
	if ISNUMERIC(@AmEURmax) = 1
	begin
		set @AmEURmax2 = CAST(@AmEURmax as money)
		select @Res = @@error if @Res <> 0 goto Err	
	end
	else
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Некорректно указана "Сумма в EUR макс."'
		select @Res = @@error if @Res <> 0 goto Err	
	end
	if ISNUMERIC(@AmUSDmin) = 1
	begin
		set @AmUSDmin2 = CAST(@AmUSDmin as money)
		select @Res = @@error if @Res <> 0 goto Err	
	end
	else
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Некорректно указана "Сумма в USD мин."'
		select @Res = @@error if @Res <> 0 goto Err	
	end
	if ISNUMERIC(@AmUSDmax) = 1
	begin
		set @AmUSDmax2 = CAST(@AmUSDmax as money)
		select @Res = @@error if @Res <> 0 goto Err	
	end
	else
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Некорректно указана "Сумма в USD макс."'
		select @Res = @@error if @Res <> 0 goto Err	
	end

	if @AmRUBmin2 < 0
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Сумма в РУБ мин. должна быть >= 0'
		select @Res = @@error if @Res <> 0 goto Err	
	end
	if @AmRUBmax2 < 0
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Сумма в РУБ макс. должна быть >= 0'
		select @Res = @@error if @Res <> 0 goto Err	
	end
	if @AmEURmin2 < 0
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Сумма в EUR мин. должна быть >= 0'
		select @Res = @@error if @Res <> 0 goto Err	
	end
	if @AmEURmax2 < 0
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Сумма в EUR макс. должна быть >= 0'
		select @Res = @@error if @Res <> 0 goto Err	
	end
	if @AmUSDmin2 < 0
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Сумма в USD мин. должна быть >= 0'
		select @Res = @@error if @Res <> 0 goto Err	
	end
	if @AmUSDmax2 < 0
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Сумма в USD макс. должна быть >= 0'
		select @Res = @@error if @Res <> 0 goto Err	
	end
	
	if @AmRUBmin2 = 0 and @AmRUBmax2 = 0 and @AmEURmin2 = 0 and @AmEURmax2 = 0 and @AmUSDmin2 = 0 and @AmUSDmax2 = 0
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Укажите сумму'
		select @Res = @@error if @Res <> 0 goto Err	
	end
	
	if @AmRUBmax2 < @AmRUBmin2 
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Макс. сумма не может быть меньше минимальной (РУБ)'
		select @Res = @@error if @Res <> 0 goto Err	
	end
	if @AmEURmax2 < @AmEURmin2 
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Макс. сумма не может быть меньше минимальной (EUR)'
		select @Res = @@error if @Res <> 0 goto Err	
	end
	if @AmUSDmax2 < @AmUSDmin2 
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Макс. сумма не может быть меньше минимальной (USD)'
		select @Res = @@error if @Res <> 0 goto Err	
	end
	
	If not exists (select 1 from dbo.DocTypes where Name = @ClassDoc)
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Указанная категория не существует'
		select @Res = @@error if @Res <> 0 goto Err		
	end
	else if not @ClassDoc like @GrClass + '%'
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Указанна некорректная категория. Выберете категорию из группы ' + @GrClass
		select @Res = @@error if @Res <> 0 goto Err	
	end

	If @BE <> '' and not exists (select 1 from dbo.PDX_pay_Firms where Name = @BE)
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Указанная бизнес-единица не существует'
		select @Res = @@error if @Res <> 0 goto Err		
	end
	If not exists (select 1 from dbo.PDX_pay_CFO where Name = @CFO)
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Указанное ЦФО не существует'
		select @Res = @@error if @Res <> 0 goto Err		
	end
		
	If @UserName like '%<%>%<%' 
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Согласующим может быть указан только один пользователь.'
		select @Res = @@error if @Res <> 0 goto Err
	end
	--проверяем пользователя
	select @UserID  = ''
	select @UserID = dbo.PDX_SubstringReturn(@UserName, charindex('<',@UserName), charindex('>',@UserName))
	select @Res = @@error if @Res <> 0 goto Err
	--если "не выделился" логин - значит некорректно указан пользователь
	if @UserID = ''
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
				'Некорректно указан согласующий. Выберите значение из справочника пользователей.'
		select @Res = @@error if @Res <> 0 goto Err
	end
	--если пользователь не нашелся, или у него нет доступа
	else if not exists (select 1 from dbo.Users where UserID=@UserID
			and ((StatusActive in ('1','-') and DateExpirationSecurity > convert(datetime,convert(varchar(50),getdate(),104),104)
					and not Permitions like '%*%') 
				or Comment like '%$RLsyslogin$%'))
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Указанный пользователь не существует (или его доступ в систему приостановлен).'
		select @Res = @@error if @Res <> 0 goto Err
	end
	
 
	If @RLPos in (0,1) and 
		exists (select 1 from dbo.PDXRecPayRules where ClassDoc = @ClassDoc
			and CFO = @CFO and (BE = @BE or BE = '' or @BE = '') and RLPos = @RLPos
			and not (DateFrom > @DateTo or @DateFrom > DateTo)
			and not (AmEURmin > @AmEURmax2 or @AmEURmin > AmEURmax)
			and not (AmUSDmin > @AmUSDmax2 or @AmUSDmax > AmUSDmax)
			and not (AmRUBmin > @AmRUBmax2 or @AmRUBmax > AmRUBmax)
			and SetID <> isnull(@SetID,'{00000000-0000-0000-0000-000000000000}'))
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Обязательный согласующий с указанными параметрами (Категория+БЕ+ЦФО+Позиция+период+диапазон сумм) уже существует'
		select @Res = @@error if @Res <> 0 goto Err		
	end
	
	If @RLPos = 2 and 
		exists (select 1 from dbo.PDXRecPayRules where ClassDoc = @ClassDoc
			and CFO = @CFO and BE = @BE
			and dbo.PDX_SubstringReturn(@UserName,CHARINDEX('<', @UserName), CHARINDEX('>', @UserName)) = dbo.PDX_SubstringReturn(UserName,CHARINDEX('<', UserName), CHARINDEX('>', UserName)) 
			and not (DateFrom > @DateTo or @DateFrom > DateTo)
			and SetID <> isnull(@SetID,'{00000000-0000-0000-0000-000000000000}'))
	begin
		select @ErrList = @ErrList + case len(@ErrList) when 0 then '' else '<br>' end +
			'Обязательный согласующий с указанными параметрами (Категория+БЕ+ЦФО+Позиция+период+пользователь) уже существует'
		select @Res = @@error if @Res <> 0 goto Err		
	end
end
/************************************/

NXT:

If @Chk = 0
begin --если это создание , то нужно генерить ошибкуесли она есть
	If @ErrList <> '' 
	begin
		RAISERROR (@ErrList, 16,1)
		goto Err
	end
end
else --если это проверка просто выводим сообщение, даже если оно пустое
begin
	select @ErrList as ErrList 
	select @Res = @@error if @Res <> 0 goto Err
end

IF @ErrList = '' and @Chk = 0
BEGIN
	if @Act = 2
	begin
		update dbo.PDXRecPayRules
			set 
				ClassDoc= @ClassDoc,
				CFO = @CFO,
				BE = @BE,
				AmRUBmin = @AmRUBmin2,
				AmRUBmax = @AmRUBmax2,
				AmEURmin = @AmEURmin2,
				AmEURmax = @AmEURmax2,
				AmUSDmin = @AmUSDmin2,
				AmUSDmax = @AmUSDmax2,
				UserName = @UserName,
				RLPos = @RLPos,
				DateFrom = @DateFrom,
				DateTo = @DateTo,
				NLM = @NC,
				DLM = getdate()
		where SetID = @SetID
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 1
	begin
		insert into dbo.PDXRecPayRules
			(ClassDoc,CFO,BE,AmRUBmin,AmRUBmax,AmEURmin,AmEURmax,AmUSDmin,AmUSDmax,UserName,RLPos,DateFrom,DateTo,SetID, NC, DC, NLM, DLM)
		values 
			(@ClassDoc,@CFO,@BE,@AmRUBmin2,@AmRUBmax2,@AmEURmin2,@AmEURmax2,@AmUSDmin2,@AmUSDmax2,@UserName,@RLPos,@DateFrom,@DateTo,NEWID(), @NC, getdate(), @NC, getdate())
		select @Res = @@error if @Res <> 0 goto Err
	end

	If @Act = 3
	begin
		delete from dbo.PDXRecPayRules where SetID = @SetID
		select @Res = @@error if @Res <> 0 goto Err
	end
END
	select @Res = @@error if @Res <> 0 goto Err

OK:

	return @Res
Err:
	return @Res



GO
/****** Object:  StoredProcedure [dbo].[REP_ReconcilationStatistic] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[REP_ReconcilationStatistic]
	@UserName varchar(255),
	@DateS datetime,
	@DateE datetime,
	@UFT2 varchar(1024),
	@UFT6 varchar(1024)
as

declare @Result int
select @Result = 0

declare @ClassDoc1 varchar(128),@ClassDoc2 varchar(128),@ClassDoc3 varchar(128),
@ClassDoc1a varchar(128),@ClassDoc2a varchar(128),@ClassDoc3a varchar(128),
@UserID varchar(96)
set @ClassDoc1 = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_ORDPAY')
set @ClassDoc2 = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_CORPAY')
set @ClassDoc3 = dbo.PDX_CLSGet('RIK_CategoryName_KAZ_PLNPAY')
set @ClassDoc1a = dbo.PDX_CLSGet('RIK_CategoryName_FIN_ORDPAY')
set @ClassDoc2a = dbo.PDX_CLSGet('RIK_CategoryName_FIN_CORPAY')
set @ClassDoc3a = dbo.PDX_CLSGet('RIK_CategoryName_FIN_PLNPAY')
set @DateE = DATEADD(second,59,DATEADD(minute,59,DATEADD(hour,23,@DateE)))

set @UserID = dbo.PDX_SubstringReturn(@UserName, charindex('<',@UserName),charindex('>',@UserName))
/*
	create table #tbl_c  (
		strID varchar(128),
		DateCreation datetime,
		SpecialInfo varchar(128),
		SpecialInfo1 varchar(128),
		Descr varchar(4096),
		Partnername varchar(512),
		ClassDoc varchar(128),
		NameCreation varchar(96),
		Comment varchar(4096),
		DateEvent datetime,
		UserID varchar(96),
		KeyField int,
		KF int identity)

	insert into #tbl_c
		(strID,
		DateCreation,
		SpecialInfo,
		SpecialInfo1,
		Descr,
		Partnername,
		ClassDoc,
		NameCreation,
		Comment,
		DateEvent,
		UserID,
		KeyField)
	select
		D.DocID as strID, 
		C.DateCreation,
		case C.SpecialInfo when 'VISAOK' then 'согласовано' when 'VISAOKREFUSE' then 'отказано' 
			when 'VISASUSPENDING' then 'приостановлено' else '' end as SpecialInfo,
		SpecialInfo as SpecialInfo1,
		replace(
		cast(isnull(D.Name ,'') + case len(ltrim(rtrim(isnull(D.Name ,'')))) when 0 then '' else ' | ' end + D.Description as varchar(240)) + 
			case when len(isnull(D.Name ,'') + case len(ltrim(rtrim(isnull(D.Name ,'')))) when 0 then '' else ' | ' end + D.Description) > 240
				then '...' else '' end,
		char(13)+char(10),' | ') as Descr,
		
		D.PartnerName,
		D.ClassDoc,
		D.NameCreation,
		case C.SpecialInfo when 'VISAOK' then C.Comment else '' end as Comment,
		C.DateEvent,
		C.UserID,
		C.KeyField--,
		--DATEDIFF(HOUR,C.DateCreation,C.DateEvent) as Hr,
		--DATEDIFF(day,C.DateCreation,C.DateEvent) as DY
		*/
		
	select 
		D.UserFieldText2 as UFT2,
		D.UserFieldText6 as UFT6,
		C.SpecialInfo as SI,
		dbo.PDX_FixLen(2,month(C.DateEvent)) + '.' + cast(year(C.DateEvent) as varchar(4)) as Y,
		SUM(case when D.ClassDoc in (@ClassDoc1,@ClassDoc1a) then 1 else 0 end) as Cnt_OP, 
		SUM(case when D.ClassDoc in (@ClassDoc2,@ClassDoc2a) then 1 else 0 end) as Cnt_KP, 
		SUM(case when D.ClassDoc in (@ClassDoc3,@ClassDoc3a) then 1 else 0 end) as Cnt_PP, 
		COUNT(*) as Cnt
	from dbo.Comments C
		inner join dbo.Docs D on D.DocID = C.DocID
			and D.ClassDoc in (@ClassDoc1, @ClassDoc2, @ClassDoc3,
								@ClassDoc1a, @ClassDoc2a, @ClassDoc3a)
			and (D.UserFieldText2 = @UFT2 or @UFT2 = '')
			and (D.UserFieldText6 = @UFT6 or @UFT6 = '')
	where C.CommentType = 'VISA'
		and C.SpecialInfo in ('VISAOK','VISAOKREFUSE','VISASUSPENDING')
		and C.DateEvent between @DateS and @DateE
		and @UserID = C.UserID
	--order by C.DateCreation, D.DocID
	group by D.UserFieldText2,
		D.UserFieldText6,
		C.SpecialInfo,
		year(C.DateEvent),
		month(C.DateEvent)
	order by Y,UFT2,UFT6,SI
	select @Result = @@error if @Result <> 0 goto Err
/*
	update X
		set DateEvent = Z.DateEvent
	from #tbl_c X
	inner join (
		select T.KF, max(C.KeyField) as KeyField from #tbl_c T
		inner join dbo.Comments C on C.DocID = T.strID and C.UserID = T.UserID
			and C.SpecialInfo = 'VISASUSPENDINGUSER'
			and C.KeyField < T.KeyField--C.DateCreation<=T.DateCreation
		where T.SpecialInfo1 = 'VISASUSPENDING'
		group by T.KF) as Y on Y.KF = X.KF
	inner join dbo.Comments Z on Z.KeyField = Y.KeyField
	select @Result = @@error if @Result <> 0 goto Err

	select *,
		DATEDIFF(HOUR,DateEvent, DateCreation) as Hr,
		DATEDIFF(day,DateEvent, DateCreation) as DY,
		dbo.PDX_CalculateWorkHours(DateEvent, DateCreation) as WHr
	from #tbl_c
	order by DateCreation, strID
	select @Result = @@error if @Result <> 0 goto Err	

	drop table #tbl_c
	*/
	return @Result
Err:
	
	return @Result

GO
/****** Object:  StoredProcedure [dbo].[REP_Z_GetResonseLetters] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE procedure [dbo].[REP_Z_GetResonseLetters]
	@dateF		datetime,
	@dateT		datetime,
	@type		int,
	@ActDoc varchar(64) = null,
	@UFT4 varchar(1024) = null
as
-- @type = 0 // Только с зарегистрированными письмами
-- @type = 1 // Со всеми письмами
-- @type = 2 // С любыми поручениями
declare
	@iclass varchar(255),
	@tclass varchar(255),
	@oclass varchar(255)
	
select
	@iclass = dbo.PDX_CLSGet('RIK_CategoryName_VHOD_VNESH'),
	@tclass = dbo.PDX_CLSGet('RIK_CategoryName_SYSZADACHI'),
	@oclass = dbo.PDX_CLSGet('RIK_CategoryName_ISHO_VNESH'),
	@ActDoc = ltrim(ISNULL(@ActDoc,'')),
	@UFT4 = ltrim(ISNULL(@UFT4,''))
if @type = 0
begin
	select 
		tasks.DocID as taskID,
		tasks.Description as task,
		tasks.NameResponsible as taskResponsible,
		convert(varchar(32),tasks.DateCompletion,104) as taskDate,
		incom.DocID as incomeID,
		convert(varchar(32),incom.DateActivation,104) as incomeDate,
		incom.DocIDIncoming as incomeNumber,
		incom.Name as incomeName,
		outcom.DocID as outcomeID,
		outcom.Name as outcomeName,
		convert(varchar(32),outcom.DateActivation,104) as outcomeDate,
		outcom.NameCreation as outcomeAuthor,
		tasks.ActDoc as taskActDoc,
		tasks.UserFieldText4 as taskUFT4
	from dbo.Docs tasks
		inner join dbo.Docs incom on incom.DocID = tasks.DocIDParent
		inner join dbo.Comments c on c.DocID = tasks.DocID
		inner join dbo.Docs outcom on outcom.DocID = c.Subject
	where incom.ClassDoc = @iclass
		and tasks.ClassDoc = @tclass
		and c.CommentType='LINK'
		and outcom.ClassDoc = @oclass
		and incom.DateActivation between @dateF and @dateT	-- входящее относится к заданному периоду
		and tasks.IsActive = 'Y'							-- активные поручения
		and incom.IsActive = 'Y'							-- по активным входящим
		and outcom.IsActive = 'Y'							-- с активными исходящими
		and not tasks.StatusCompletion in ('0','1')			-- не отменененные и не исполненные
		and outcom.LocationPath like '%+%'					-- исходящее зарегистрировано
		and (tasks.ActDoc = @ActDoc or @ActDoc = '')
		and (tasks.UserFieldText4 = @UFT4 or @UFT4 = '')
	order by incom.DateActivation
end

if @type = 1
begin
	select 
		tasks.DocID as taskID,
		tasks.Description as task,
		tasks.NameResponsible as taskResponsible,
		convert(varchar(32),tasks.DateCompletion,104) as taskDate,
		incom.DocID as incomeID,
		convert(varchar(32),incom.DateActivation,104) as incomeDate,
		incom.DocIDIncoming as incomeNumber,
		incom.Name as incomeName,
		outcom.DocID as outcomeID,
		outcom.Name as outcomeName,
		convert(varchar(32),outcom.DateActivation,104) as outcomeDate,
		outcom.NameCreation as outcomeAuthor,
		tasks.ActDoc as taskActDoc,
		tasks.UserFieldText4 as taskUFT4
	from dbo.Docs tasks
		inner join dbo.Docs incom on incom.DocID = tasks.DocIDParent
		inner join dbo.Comments c on c.DocID = tasks.DocID
		inner join dbo.Docs outcom on outcom.DocID = c.Subject
	where incom.ClassDoc = @iclass
		and tasks.ClassDoc = @tclass
		and c.CommentType='LINK'
		and outcom.ClassDoc = @oclass
		and incom.DateActivation between @dateF and @dateT	-- входящее относится к заданному периоду
		and tasks.IsActive = 'Y'							-- активные поручения
		and incom.IsActive = 'Y'							-- по активным входящим
		and outcom.IsActive = 'Y'							-- с активными исходящими
		and not tasks.StatusCompletion in ('0','1')			-- не отменененные и не исполненные
		and (tasks.ActDoc = @ActDoc or @ActDoc = '')
		and (tasks.UserFieldText4 = @UFT4 or @UFT4 = '')
	order by incom.DateActivation
end

if @type = 2
begin
	select 
		tasks.DocID as taskID,
		tasks.Description as task,
		tasks.NameResponsible as taskResponsible,
		convert(varchar(32),tasks.DateCompletion,104) as taskDate,
		incom.DocID as incomeID,
		convert(varchar(32),incom.DateActivation,104) as incomeDate,
		incom.DocIDIncoming as incomeNumber,
		incom.Name as incomeName,
		outcom.DocID as outcomeID,
		outcom.Name as outcomeName,
		convert(varchar(32),outcom.DateActivation,104) as outcomeDate,
		outcom.NameCreation as outcomeAuthor,
		tasks.ActDoc as taskActDoc,
		tasks.UserFieldText4 as taskUFT4
	from dbo.Docs tasks
		inner join dbo.Docs incom on incom.DocID = tasks.DocIDParent
		left join dbo.Comments c on c.DocID = tasks.DocID
		left join dbo.Docs outcom on outcom.DocID = c.Subject
	where incom.ClassDoc = @iclass
		and tasks.ClassDoc = @tclass
		and c.CommentType='LINK'
		and outcom.ClassDoc = @oclass
		and incom.DateActivation between @dateF and @dateT	-- входящее относится к заданному периоду
		and tasks.IsActive = 'Y'							-- активные поручения
		and incom.IsActive = 'Y'							-- по активным входящим
		and outcom.IsActive = 'Y'							-- с активными исходящими
		and not tasks.StatusCompletion in ('0','1')			-- не отменененные и не исполненные
		and (tasks.ActDoc = @ActDoc or @ActDoc = '')
		and (tasks.UserFieldText4 = @UFT4 or @UFT4 = '')
	order by incom.DateActivation
end
GO
/****** Object:  StoredProcedure [dbo].[sp_1C_GetNciContractorRequests] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*
  Выбор Заявок НСИ СЭД из раздела "Прочие / НСИ(договор контрагента)"
  Параметры:
	@DateTimeFrom - Выбираем заявки, активированные после указанной даты (условие "включительно")
	@HasntCompletedComment - необязательный параметр, значение по умолчанию = 1
       0 - Выбираем все заявки
       1 - Игнорируем заявки, у которых есть комментарий "Договор добавлен в 1С"
  Пример вызова
    EXEC [sp_1C_GetNciContractorRequests] '20210901', 0
*/
CREATE PROCEDURE [dbo].[sp_1C_GetNciContractorRequests]
	@DateTimeFrom datetime,
	@HasntCompletedComment int = 1
as
	set nocount on

	-- 1. Создание временной таблицы для данных основного договора по заявке

	create table #tbl (
	   [P_DocID] varchar(128)--рег номер документа
      ,[P_GUID] uniqueidentifier-- не используется
      ,[P_DocIDadd]  varchar(128)-- проектный номер документа
      ,[P_DocIDIncoming] varchar(128)--№ договора контрагента
      ,[P_DocIDParent] varchar(128)--Осн.договор (для доп. соглаш.)
      ,[P_DocIDPrevious] varchar(128)--Для работ по договору
      ,[P_Author] varchar(1024)--не используется
      ,[P_Correspondent] varchar(4000)--список рассылки
      ,[P_Resolution] varchar(1024)--не используется
      ,[P_History] varchar(1024)--не используется
      ,[P_Result] varchar(1024)--не используется
      ,[P_PercentCompletion] int--не используется
      ,[P_Department] varchar(255)--Подразделение отв. за исполнение договора
      ,[P_Name] varchar(255) --Заголовок
      ,[P_Description] varchar(4000)--Предмет договор
      ,[P_LocationURL] varchar(128)--не используется
      ,[P_LocationPaper] varchar(128)--не используется
      ,[P_FileNamePrefix] varchar(255)--не используется
      ,[P_FileName] varchar(255)--не используется
      ,[P_FileNameNameLastModif1ication] varchar(1024)--не используется
      ,[P_FileNameDateLastAccessed] datetime--не используется
      ,[P_FileNameDateLastModification] datetime--не используется
      ,[P_LocationPath] varchar(1024)-- Принято в Бухгалтерию
      ,[P_ExtInt] char(1)--не используется
      ,[P_PartnerName]varchar(128)--Контрагент 2
      ,[P_StatusDevelopment] char(1)--статус разработки
      ,[P_StatusPayment] char(2)--не используется
      ,[P_StatusArchiv] char(1)--не используется
      ,[P_StatusCompletion] char(1)--не используется
      ,[P_StatusDelivery] char(1)--не используется
      ,[P_TypeDoc] char(1)--не используется
      ,[P_ClassDoc] varchar(64)--категория документа
      ,[P_ActDoc] varchar(64)--вид документа
      ,[P_InventoryUnit] varchar(64)--не используется
      ,[P_PaymentMethod] varchar(64)--не используется
      ,[P_AmountDoc] money--сумма докмуента
      ,[P_QuantityDoc] real--не используется
      ,[P_DateActivation] datetime--рег. дата
      ,[P_SecurityLevel] tinyint--уровень доступа
      ,[P_DateCreation] datetime--дата создания
      ,[P_DateCompletion] datetime--Дата прекращения срока действия
      ,[P_DateCompleted] datetime--не используется
      ,[P_DateExpiration] datetime--не используется
      ,[P_NameCreation]  varchar(96)--содатель документа
      ,[P_NameAproval] varchar(96)--Подписывающий 1
      ,[P_NameApproved] varchar(96)--фактический Подписант1(техническое поле)
      ,[P_DateApproved] datetime--дата подписания
      ,[P_ListToEdit] varchar(1024)--список редакторов
      ,[P_ListToReconcile] varchar(4096)--список согласующих
      ,[P_ListReconciled] varchar(4096)--список согласовавших
      ,[P_NameResponsible] varchar(96)--ответственный за исполнение
      ,[P_NameControl] varchar(96)--не используется
      ,[P_NameLastModification] varchar(96)--кто последний редактировал карточку
      ,[P_DateLastModification] datetime--дата последнего редактирования карточки
      ,[P_UserFieldText1] varchar(1024)--Наименование листа согласования
      ,[P_UserFieldText2] varchar(1024)--Вид договора
      ,[P_UserFieldText3] varchar(1024)--Сторона 1
      ,[P_UserFieldText4] varchar(1024)--Проект
      ,[P_UserFieldText5] varchar(1024)--Подписывающий 2
      ,[P_UserFieldText6] varchar(1024)--Дополнительные контрагенты -
      ,[P_UserFieldText7] varchar(1024)--Объект
      ,[P_UserFieldText8] varchar(1024)--не используется
      ,[P_UserFieldMoney1] money--в т.ч. НДС
      ,[P_UserFieldMoney2] money--не используется
      ,[P_UserFieldDate1] datetime--не используется
      ,[P_UserFieldDate2] datetime--не используется
      ,[P_UserFieldDate3] datetime--не используется
      ,[P_UserFieldDate4] datetime--не используется
      ,[P_UserFieldDate5] datetime--не используется
      ,[P_UserFieldDate6] datetime--не используется
      ,[P_UserFieldDate7] datetime--не используется
      ,[P_UserFieldDate8] datetime--не используется
      ,[P_IsActive] varchar(1)--статус Активен
      ,[P_DateActive] datetime--дата последней активации
      ,[P_BusinessProcessStep] varchar(255)--не используется
      ,[P_ExtPassword] varchar(48)--не используется
      ,[P_DateSigned] datetime--подписано Контрагентом(дата)
      ,[P_Currency] varchar(12)--валюта
      ,[P_CurrencyRate] money--не используется
      ,[P_Rank] varchar(64)--срочность соглаосвания
      ,[P_ListToView] varchar(4000)--не используется
      ,[P_Content] ntext--не используется
      ,[P_License] nvarchar(18)--не используется
      ,[P_TransferGUID] uniqueidentifier--GUID идентификатор
      ,P_CurrCode2 varchar(12)--цифровой код валюты из справочника Валют
	  ,P_NameApp varchar(128)--ФИО подписанта1
	  ,P_NameCr varchar(128)--ФИО создателя карточки
	  ,P_NameResp varchar(128)--ФИО ответственного исполнителя
	  ,P_RegDate_first datetime--дата регистрации(нажатия кнопки) первая
	  ,P_RegDate_last datetime--дата регистрации(нажатия кнопки) последняя
	  ,P_Reg_Count int--кол-во "регистраций"
	  ,P_ID_UFT7 varchar(64)--код Объекта
	  ,P_ID_UFT2 int--ИД Вида договора
	  ,P_CFO  varchar(10)  --ЦФО
	  ,P_isGP bit-- Содержит % генподряда  (значения 0 или 1)
	  ,P_GP decimal(5,2)--% генподряда
	  ,P_ExistAvans char(1)--Особый % зачета аванса
	  ,P_AvansPercent decimal(5,2))--% зачета аванса
	  
	
	-- 2. Пробегаем по заявкам и извлекаем данные основного договора
	  
	declare @ParentID varchar(128)

	declare c_parent cursor for 
	select distinct DocIDParent from [dbo].[Docs]
	where Docs.DateApproved is not null
  	  and Docs.DateApproved >= @DateTimeFrom
	  and Docs.ClassDoc = 'Прочие / НСИ(договор контрагента)'
	  and (
	        @HasntCompletedComment = 0 OR 
			not exists(select * from Comments where Comments.DocID = Docs.DocID AND Comment like '%Договор добавлен в 1С%')
	      )

	open c_parent
	fetch next from c_parent into @ParentID
	while @@fetch_status = 0
	begin
		insert into #tbl
		exec [dbo].[PDX_payDocData_GetFromDB] @DocId = @ParentID

		fetch next from c_parent into @ParentID
	end
	close c_parent
	deallocate c_parent

	-- 3. Получаем данные из заявок, делаем join основного договора

	select 
		Docs.GUID,
		Docs.DocID, 
		Docs.UserFieldDate3 RegDate,
		Docs.DocIDParent ContractNo,
		Docs.UserFieldText6 OperationType,
		Docs.Name ContractName,
		case when UserFieldMoney1 = 1 then 'Основной' else 'Дополнительный' end ContractCharacter,
		Docs.UserFieldText3 OperationDetails,
		Docs.UserFieldText4 PaymentsInUSD,
		Docs.UserFieldText5 Method,
		Docs.Description,
		Docs.NameCreation,
		dbo.fn_1C_GetUserEmail(Docs.NameCreation) EmailCreation,
		Docs.DateCreation
		
		,DocsNSI.[PN] ContractContragent
		,partner3.PortalID ContractContragent_PortalID
		,DocsNSI.[UFT8] ContractOrg
		,partner4.PortalID ContractOrg_PortalID 
		,DocsNSI.[Descr] ContractSubject
		,DocsNSI.[Currency] ContractCurrency
		,Curr.Code2 ContractCurrencyCode
		,DocsNSI.[UFT2] ContractType
		,DocsNSI.[Percent] ContractPercent
		,DocsNSI.[DocDate] ContractDate
		,DocsNSI.[NLM] ContractInfoChangeBy
		,DocsNSI.[DLM] ContractInfoChanged

		-- parent

      ,parent.[P_DocID]
      ,parent.[P_GUID]
      ,parent.[P_DocIDadd]
      ,parent.[P_DocIDIncoming]
      ,parent.[P_DocIDParent]
      ,parent.[P_DocIDPrevious]
      ,parent.[P_Author]
      ,parent.[P_Correspondent]
      ,parent.[P_Resolution]
      ,parent.[P_History]
      ,parent.[P_Result]
      ,parent.[P_PercentCompletion]
      ,parent.[P_Department]
      ,parent.[P_Name]
      ,parent.[P_Description]
      ,parent.[P_LocationURL]
      ,parent.[P_LocationPaper]
      ,parent.[P_FileNamePrefix]
      ,parent.[P_FileName]
      ,parent.[P_FileNameNameLastModif1ication]
      ,parent.[P_FileNameDateLastAccessed]
      ,parent.[P_FileNameDateLastModification]
      ,parent.[P_LocationPath]
      ,parent.[P_ExtInt]
      ,parent.[P_PartnerName]
	  ,partner1.PortalID P_Partner1ID
      ,parent.[P_StatusDevelopment]
      ,parent.[P_StatusPayment]
      ,parent.[P_StatusArchiv]
      ,parent.[P_StatusCompletion]
      ,parent.[P_StatusDelivery]
      ,parent.[P_TypeDoc]
      ,parent.[P_ClassDoc]
      ,parent.[P_ActDoc]
      ,parent.[P_InventoryUnit]
      ,parent.[P_PaymentMethod]
      ,parent.[P_AmountDoc]
      ,parent.[P_QuantityDoc]
      ,parent.[P_DateActivation]
      ,parent.[P_SecurityLevel]
      ,parent.[P_DateCreation]
      ,parent.[P_DateCompletion]
      ,parent.[P_DateCompleted]
      ,parent.[P_DateExpiration]
      ,parent.[P_NameCreation]
      ,parent.[P_NameAproval]
      ,parent.[P_NameApproved]
      ,parent.[P_DateApproved]
      ,parent.[P_ListToEdit]
      ,parent.[P_ListToReconcile]
      ,parent.[P_ListReconciled]
      ,parent.[P_NameResponsible]
      ,parent.[P_NameControl]
      ,parent.[P_NameLastModification]
      ,parent.[P_DateLastModification]
      ,parent.[P_UserFieldText1]
      ,parent.[P_UserFieldText2]
      ,parent.[P_UserFieldText3]
      ,parent.[P_UserFieldText4]
      ,parent.[P_UserFieldText5]
      ,parent.[P_UserFieldText6]
      ,parent.[P_UserFieldText7]
      ,parent.[P_UserFieldText8]
	  ,partner2.PortalID P_Partner2ID
      ,parent.[P_UserFieldMoney1]
      ,parent.[P_UserFieldMoney2]
      ,parent.[P_UserFieldDate1]
      ,parent.[P_UserFieldDate2]
      ,parent.[P_UserFieldDate3]
      ,parent.[P_UserFieldDate4]
      ,parent.[P_UserFieldDate5]
      ,parent.[P_UserFieldDate6]
      ,parent.[P_UserFieldDate7]
      ,parent.[P_UserFieldDate8]
      ,parent.[P_IsActive]
      ,parent.[P_DateActive]
      ,parent.[P_BusinessProcessStep]
      ,parent.[P_ExtPassword]
      ,parent.[P_DateSigned]
      ,parent.[P_Currency]
      ,parent.[P_CurrencyRate]
      ,parent.[P_Rank]
      ,parent.[P_ListToView]
      ,parent.[P_Content]
      ,parent.[P_License]
      ,parent.[P_TransferGUID]
      ,parent.[P_CurrCode2]
      ,parent.[P_NameApp]
      ,parent.[P_NameCr]
      ,parent.[P_NameResp]
      ,parent.[P_RegDate_first]
      ,parent.[P_RegDate_last]
      ,parent.[P_Reg_Count]
      ,parent.[P_ID_UFT7]
      ,parent.[P_ID_UFT2]
      ,parent.[P_CFO]
      ,parent.[P_isGP]
      ,parent.[P_GP]
      ,parent.[P_ExistAvans]
      ,parent.[P_AvansPercent]

	from Docs
	left outer join DocsNSI on Docs.DocIDInt = DocsNSI.DocIDInt
	left outer join Partners partner3 on partner3.Name = DocsNSI.PN
	left outer join Partners partner4 on partner4.Name = DocsNSI.UFT8
	left outer join CurrencyRates Curr on Curr.Code = DocsNSI.[Currency]
	left outer join #tbl parent on parent.P_DocID = Docs.DocIDParent
	left outer join Partners partner1 on partner1.Name = parent.[P_PartnerName]
	left outer join Partners partner2 on partner2.Name = parent.[P_UserFieldText8]
	where Docs.DateApproved is not null
  	  and Docs.DateApproved >= @DateTimeFrom
	  and Docs.ClassDoc = 'Прочие / НСИ(договор контрагента)'
	  and (
	        @HasntCompletedComment = 0 OR 
			not exists(select * from Comments where Comments.DocID = Docs.DocID AND Comment like '%Договор добавлен в 1С%')
	      )

	-- 4. Чистим временные структуры
	drop table #tbl 

GO
/****** Object:  StoredProcedure [dbo].[sp_1C_SetNciContractorRequests] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

/*
  Добавление комментария 'Договор добавлен в 1С. / "Служба ведения справочников." <DirectoryServ>' к документу
  Параметры
	@DocID - Идентификатор документа
	@Force - Условие обработки уже обработанных данных. Значение по умолчанию = 0
        0 - Если комментарий уже проставлен, ничего не делаем
        1 - Добавляем комментарий в заявку, даже есть такой комментарий уже есть
  Пример вызова
    EXEC [sp_1C_SetNciContractorRequests] 'ЗДКоп-202109-000007', 1
*/
CREATE PROCEDURE [dbo].[sp_1C_SetNciContractorRequests]
	@DocID varchar(128),
	@Force int = 0
as
	set nocount on
	declare @msg varchar(max)

	-- Такой комментарий уже есть. Не дублируем, если это не требуется
	IF (@Force != 1 and exists(select * from Comments where Comments.DocID = @DocID AND Comment like '%Договор добавлен в 1С%'))
	begin
	  SELECT DocID FROM Docs WHERE DocID = @DocID	
	  return
	end
		
	-- Дополнительная проверка корректности входного параметра для диагностики на стороне 1С
	declare @count int	
	SELECT @count = count(*) FROM Docs WHERE DocID = @DocID
	IF (@count != 1)
	BEGIN
		set @msg = 'Document definition error. '+convert(varchar(10),@count)+' documents where found';
		RAISERROR (@msg,16,1)
		return
	END

	-- Добавляем комментарий
	INSERT	Comments (UserID, UserName, DocID, DateCreation, 
			Comment, CommentType, GUID, DocIDInt)
	SELECT	'DirectoryServ', 'Служба ведения справочников.', DocID, getdate(), 
			'Договор добавлен в 1С. / "Служба ведения справочников." <DirectoryServ>', 'comment', newid(), DocIDInt
	FROM Docs
	WHERE DocID = @DocID

	SELECT DocID FROM Docs WHERE DocID = @DocID	
GO
/****** Object:  StoredProcedure [dbo].[UserDirISR_ForXSL] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[UserDirISR_ForXSL]
as


	create table #tmpRes (
		isChoice bit, id_dst int, parentid_dst int, hlevel int, 
		nameru_dst varchar(1024), descr varchar(1024), parentId_str varchar(4096), 
		inActive bit, orderstr varchar(4096))	

	insert into #tmpRes
	(isChoice, id_dst, parentid_dst, hlevel, nameru_dst, descr, parentId_str, inActive, orderstr)
	exec dbo.UserDirISR_List @findStr = ''

	declare @max int, @i int, @SQL varchar(8000)

	select @max = MAX(hlevel) from #tmpRes

	select @SQL = 'select '
	set @i = 1
	while @i<@max
	begin
	set @SQL = @SQL + ' case hlevel when ' + CAST(@i as varchar(10)) + ' then nameru_dst else '''' end as h' + CAST(@i as varchar(10)) + ', 
	' 
	set @i = @i + 1
	end

	set @SQL = @SQL + ' descr from #tmpRes order by orderstr'

	exec (@SQL)

	drop table  #tmpRes
GO
/****** Object:  StoredProcedure [dbo].[UserDirISR_List] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[UserDirISR_List]
	@Prj		varchar(1024)	= NULL,
	@FD			tinyint	= NULL,
	@actual_flt		bit = null, --1 актуальные, 0 все
	@findStr	varchar(1024)	= NULL

as

	/*
	exec DocSubTypes_List @cls='Договоры / Договор'  , @actDoc	= 'РУС-Инжиниринг' , @findStr = 'Агентирование'
	*/

	--select @findStr = 'Агентский'

	declare @Result int, @clsID int, @ActDocID int, @FD_1 tinyint, @inActual bit, @inActual_1 bit
	select @Result = 0
	
	
	select @findStr=ISNULL(@findStr, '')
	set @FD_1 = 0
	set @inActual = case @actual_flt when 1 then 0 else 1 end
	set @inActual_1 = 0
	
	create table #treeRes (KeyField int, ParentKeyField int, hlevel int, code varchar(1024), descr varchar(1024), pathstr varchar(4096), parentid_str varchar(4096), inActive bit, orderstr varchar(4096))
	--create table #tmp (dstId int, parentDstId int, nameRu varchar(1024), hlevel int, pathStr varchar(4096), parentId_str varchar(1024))
	create table #tmpFind (KeyField int, ParentKeyField int, code varchar(1024), descr varchar(1024), hlevel int, pathStr varchar(4096), parentId_str varchar(4096), inActive bit)	
	create table #tmpRes (KeyField int, ParentKeyField int, code varchar(1024), descr varchar(1024), hlevel int, pathStr varchar(4096), parentId_str varchar(4096), inActive bit)	

	declare @kolvo int, @num int, @dstID int, @parentID int, @i int, @Level int, @cnt int, @MainID int, @Str varchar(2048)
	
	
	-- дерево с учетом категории и фильтра
	;with treeRes (KeyField, ParentKeyField, hlevel, code, descr, pathstr, parentid_str, inActive, orderstr) 
	as 
	(
		select KeyField, ParentKeyField, 1, 
				cast(code as varchar(max)),
				cast(descr as varchar(max)),
				cast(code as varchar(max)) + ' ' + cast(descr as varchar(max)),
				isnull(cast(isnull(ParentKeyField,0) as varchar(max)),''),
				inActive,
				cast(code as varchar(max)) + '/' + cast(KeyField as varchar(max)) 
				--cast(code as varchar(max)) + '/'
		from UserDir_ISR
		where ([ParentKeyField] is null or [ParentKeyField] = 0)
			and FD in (@FD,@FD_1)
			and inActive in (@inActual, @inActual_1)
		union all
		select I.KeyField, I.ParentKeyField, T.hlevel+1, 
				cast(I.code as varchar(max)) as nameRu_dst,
				cast(I.descr as varchar(max)),
				T.pathstr + ' ' + cast(I.code as varchar(max)) +  ' ' + cast(I.descr as varchar(max)),
				cast(T.ParentId_str as varchar(max)) + '_' + CAST(isNull(I.ParentKeyField,'') as VARCHAR(max)),
				case T.inActive when 1 then T.inActive else I.inActive end,
				cast(T.orderstr as varchar(max))+ '/' + cast(I.code as varchar(max)) + '/' + cast(I.KeyField as varchar(max))
				--cast(T.Code as varchar(max))+ '/' + cast(I.Code as varchar(max))+ '/'
		from UserDir_ISR I
			 inner join treeRes T on T.KeyField = I.ParentKeyField
		where I.FD in (@FD,@FD_1)
		and I.inActive in (@inActual, @inActual_1)
		
	)
	insert into #treeRes
		(KeyField, ParentKeyField, hlevel, code, descr, pathstr, parentid_str, inActive, orderstr) 
	select
		KeyField, ParentKeyField, hlevel, code, descr, pathstr, parentid_str, inActive, orderstr
	from treeRes
	
--select * from treeRes	 order by hlevel
	insert into #tmpFind (KeyField, ParentKeyField, hlevel, code, descr, pathStr, parentId_str)
	select distinct 
			KeyField, ParentKeyField, hlevel, code, descr, pathstr, parentId_str
	from #treeRes T
	where T.pathstr like '%' + @findStr + '%'									-- фильтр из формы
	
	--order by pathStr
--select * from #tmpFind	
	-- 2-ой проход. Ну типа все снова
	
	-- и еще раз достраиваем верхние уровни
	;with treeResFirst (KeyField, ParentKeyField, code, descr, hlevel, parentId_str)
	as
	(
		-- сами узелки
		select T1.KeyField, T1.ParentKeyField, cast(T1.Code as varchar(max)), cast(T1.descr as varchar(max)), T1.hlevel, T1.parentId_str
		from #tmpFind T1
		-- Верхние
		union all
		select	I.KeyField, I.ParentKeyField,
				cast(I.Code as varchar(max)) as Code,
				cast(I.descr as varchar(max)),
				T.hlevel-1,
				left(T.parentId_str, len(T.parentId_str) - len('_' + isnull(cast(T.ParentKeyField as varchar(max)),'')))
		from UserDir_ISR I 
			inner join treeResFirst T on T.ParentKeyField = I.KeyField	
	)

	insert into #tmpRes (KeyField, ParentKeyField, hlevel, Code, descr,  parentId_str)
	select distinct 
			KeyField, ParentKeyField, hlevel, Code ,descr, parentId_str
	from treeResFirst T

	
		-- и еще раз достраиваем нижние уровни
	;with treeResFirst2 (KeyField, ParentKeyField, code, descr, hlevel, parentId_str)
	as
	(
		-- сами узелки
		select T1.KeyField, T1.ParentKeyField, cast(T1.Code as varchar(max)), cast(T1.descr as varchar(max)), T1.hlevel, cast(T1.parentId_str as varchar(max))
		from #tmpFind T1
		-- нижние
		union all
		select	I.KeyField, I.ParentKeyField,
				cast(I.Code as varchar(max)) as Code,
				cast(I.descr as varchar(max)),
				T.hlevel+1,
				cast(T.ParentId_str as varchar(max)) + '_' + CAST(isNull(I.ParentKeyField,'') as VARCHAR(max))
		from UserDir_ISR I 
			inner join treeResFirst2 T on T.KeyField = I.ParentKeyField	
		where I.FD in (@FD,@FD_1)
	)

	insert into #tmpRes (KeyField, ParentKeyField, hlevel, Code, descr, parentId_str)
	select distinct 
			KeyField, ParentKeyField, hlevel, Code ,descr, parentId_str
	from treeResFirst2 T
	where not exists (select 1 from #tmpRes R where R.KeyField = T.KeyField)
	
	select 
		isnull((select top 1 1 from UserDir_ISR where ParentKeyField = T.KeyField),0) as isChoice,
		T.KeyField as id_dst,
		T.ParentKeyField as parentid_dst,
		T.hlevel,
		T.Code as nameru_dst,
		T.descr,
		T.parentId_str,
		R.inActive, R.orderstr
	from #tmpRes T
	inner join #treeRes R on R.KeyField = T.KeyField
	order by R.orderstr--T.Code
	
	drop table #tmpFind 
	drop table #tmpRes
	drop table #treeRes

	select @Result = @@error if @Result <> 0 goto Err


	return @Result
Err:
	
	return @Result







GO
/****** Object:  StoredProcedure [dbo].[UserDirItems_List] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

create proc [dbo].[UserDirItems_List]
	@actual_flt		bit = null, --1 актуальные, 0 все
	@findStr	varchar(1024)	= NULL

as

	/*
	exec DocSubTypes_List @cls='Договоры / Договор'  , @actDoc	= 'РУС-Инжиниринг' , @findStr = 'Агентирование'
	*/

	--select @findStr = 'Агентский'

	declare @Result int, @clsID int, @ActDocID int,  @inActual bit, @inActual_1 bit
	select @Result = 0
	
	
	select @findStr=ISNULL(@findStr, '')
	set @inActual = case @actual_flt when 1 then 0 else 1 end
	set @inActual_1 = 0
	
	create table #treeRes (KeyField int, ParentKeyField int, hlevel int, code varchar(1024), descr varchar(1024), pathstr varchar(4096), parentid_str varchar(4096), inActive bit, orderstr varchar(4096))
	--create table #tmp (dstId int, parentDstId int, nameRu varchar(1024), hlevel int, pathStr varchar(4096), parentId_str varchar(1024))
	create table #tmpFind (KeyField int, ParentKeyField int, code varchar(1024), descr varchar(1024), hlevel int, pathStr varchar(4096), parentId_str varchar(4096), inActive bit)	
	create table #tmpRes (KeyField int, ParentKeyField int, code varchar(1024), descr varchar(1024), hlevel int, pathStr varchar(4096), parentId_str varchar(4096), inActive bit)	

	declare @kolvo int, @num int, @dstID int, @parentID int, @i int, @Level int, @cnt int, @MainID int, @Str varchar(2048)
	
	insert into #treeRes
		(KeyField, ParentKeyField, hlevel, code, descr, pathstr, parentid_str, inActive) 
	select -1*ROW_NUMBER() over (order by GrName) as KF, 0, 1, '', GrName, cast(GrName as varchar(max)), '0', 0
	from (
		select distinct	
			GrName
		from [dbo].[PDX_pay_Items]) as X
	update #treeRes set orderstr = '/' + CAST(KeyField as varchar(max))
	
	-- дерево с учетом категории и фильтра
	;with treeRes (KeyField, ParentKeyField, hlevel, code, descr, pathstr, parentid_str, inActive, orderstr) 
	as 
	(
		/*select SetID, ParentID, 1, 
				cast(code as varchar(max)),
				cast(Name as varchar(max)),
				cast(code as varchar(max)) + ' ' + cast(Name as varchar(max)),
				isnull(cast(isnull(ParentID,0) as varchar(max)),''),
				inActive,
				cast(code as varchar(max)) + '/' + cast(SetID as varchar(max)) 
		from [dbo].[PDX_pay_Items]
		where (ParentID is null or ParentID = 0)
			and inActive in (@inActual, @inActual_1)*/
			
		select I.SetID, R.KeyField, 2, 
				cast(I.code as varchar(max)),
				cast(I.Name as varchar(max)),
				cast(I.code as varchar(max)) + ' ' + cast(I.Name as varchar(max)),
				CAST(isNull(I.ParentID,'') as VARCHAR(max)) + '_' + isnull(cast(isnull(R.KeyField,0) as varchar(max)),''),
				I.inActive,
				cast(R.orderstr as varchar(max))+ '/' + cast(I.code as varchar(max)) + '/' + cast(I.SetID as varchar(max)) 
		from [dbo].[PDX_pay_Items] I
		inner join #treeRes R on R.descr = I.GrName
		where (I.ParentID is null or I.ParentID = 0)
			and I.inActive in (@inActual, @inActual_1)		
		union all
		select I.SetID, I.ParentID, T.hlevel+1, 
				cast(I.code as varchar(max)) as nameRu_dst,
				cast(I.name as varchar(max)),
				T.pathstr + ' ' + cast(I.code as varchar(max)) +  ' ' + cast(I.Descr as varchar(max)),
				cast(T.ParentId_str as varchar(max)) + '_' + CAST(isNull(I.ParentID,'') as VARCHAR(max)),
				case T.inActive when 1 then T.inActive else I.inActive end,
				cast(T.orderstr as varchar(max))+ '/' + cast(I.code as varchar(max)) + '/' + cast(I.SetID as varchar(max))
				--cast(T.Code as varchar(max))+ '/' + cast(I.Code as varchar(max))+ '/'
		from [dbo].[PDX_pay_Items] I
			 inner join treeRes T on T.KeyField = I.ParentID
		where I.inActive in (@inActual, @inActual_1)
		
	)
	insert into #treeRes
		(KeyField, ParentKeyField, hlevel, code, descr, pathstr, parentid_str, inActive, orderstr) 
	select
		KeyField, ParentKeyField, hlevel, code, descr, pathstr, parentid_str, inActive, orderstr
	from treeRes
	
	
--select * from treeRes	 order by hlevel
	insert into #tmpFind (KeyField, ParentKeyField, hlevel, code, descr, pathStr, parentId_str)
	select distinct 
			KeyField, ParentKeyField, hlevel, code, descr, pathstr, parentId_str
	from #treeRes T
	where T.pathstr like '%' + @findStr + '%'									-- фильтр из формы
	
	--order by pathStr
--select * from #tmpFind	
	-- 2-ой проход. Ну типа все снова
	
	-- и еще раз достраиваем верхние уровни
	;with treeResFirst (KeyField, ParentKeyField, code, descr, hlevel, parentId_str)
	as
	(
		-- сами узелки
		select T1.KeyField, T1.ParentKeyField, cast(T1.Code as varchar(max)), cast(T1.descr as varchar(max)), T1.hlevel, T1.parentId_str
		from #tmpFind T1
		-- Верхние
		union all
		select	I.KeyField, I.ParentKeyField,--I.ParentID,
				cast(I.Code as varchar(max)) as Code,
				cast(I.descr as varchar(max)),
				T.hlevel-1,
				left(T.parentId_str, len(T.parentId_str) - len('_' + isnull(cast(T.ParentKeyField as varchar(max)),'')))
		from #treeRes I 
			inner join treeResFirst T on T.ParentKeyField = I.KeyField	
	)

	insert into #tmpRes (KeyField, ParentKeyField, hlevel, Code, descr,  parentId_str)
	select distinct 
			KeyField, ParentKeyField, hlevel, Code ,descr, parentId_str
	from treeResFirst T
	
		-- и еще раз достраиваем нижние уровни
	;with treeResFirst2 (KeyField, ParentKeyField, code, descr, hlevel, parentId_str)
	as
	(
		-- сами узелки
		select T1.KeyField, T1.ParentKeyField, cast(T1.Code as varchar(max)), cast(T1.descr as varchar(max)), T1.hlevel, cast(T1.parentId_str as varchar(max))
		from #tmpFind T1
		-- нижние
		union all
		select	I.KeyField, I.ParentKeyField,
				cast(I.Code as varchar(max)) as Code,
				cast(I.descr as varchar(max)),
				T.hlevel+1,
				cast(T.ParentId_str as varchar(max)) + '_' + CAST(isNull(I.ParentKeyField,'') as VARCHAR(max))
		from #treeRes I 
			inner join treeResFirst2 T on T.KeyField = I.ParentKeyField
		
	)

	insert into #tmpRes (KeyField, ParentKeyField, hlevel, Code, descr, parentId_str)
	select distinct 
			KeyField, ParentKeyField, hlevel, Code ,descr, parentId_str
	from treeResFirst2 T
	where not exists (select 1 from #tmpRes R where R.KeyField = T.KeyField)
		
	select 
		case 
			when T.KeyField < 0 then 1
			else isnull((select top 1 1 from [dbo].[PDX_pay_Items] where ParentID = T.KeyField),0) 
		end as isChoice,
		T.KeyField as id_dst,
		T.ParentKeyField  as parentid_dst,
		T.hlevel as hlevel,
		T.Code as nameru_dst,
		T.descr,
		T.parentId_str as parentId_str,
		R.inActive, R.orderstr
	from #tmpRes T
	inner join #treeRes R on R.KeyField = T.KeyField	
	--where R.KeyField > 0
	order by R.orderstr
	
	drop table #tmpFind 
	drop table #tmpRes
	drop table #treeRes

	select @Result = @@error if @Result <> 0 goto Err


	return @Result
Err:
	
	return @Result








GO
/****** Object:  StoredProcedure [dbo].[UserDirItems2016_List] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

create proc [dbo].[UserDirItems2016_List]
	@actual_flt		bit = null, --1 актуальные, 0 все
	@findStr	varchar(1024)	= NULL

as

	/*
	exec DocSubTypes_List @cls='Договоры / Договор'  , @actDoc	= 'РУС-Инжиниринг' , @findStr = 'Агентирование'
	*/

	--select @findStr = 'Агентский'

	declare @Result int, @clsID int, @ActDocID int,  @inActual bit, @inActual_1 bit
	select @Result = 0
	
	
	select @findStr=ISNULL(@findStr, '')
	set @inActual = case @actual_flt when 1 then 0 else 1 end
	set @inActual_1 = 0
	
	create table #treeRes (KeyField int, ParentKeyField int, hlevel int, code varchar(1024), descr varchar(1024), pathstr varchar(4096), parentid_str varchar(4096), inActive bit, orderstr varchar(4096))
	--create table #tmp (dstId int, parentDstId int, nameRu varchar(1024), hlevel int, pathStr varchar(4096), parentId_str varchar(1024))
	create table #tmpFind (KeyField int, ParentKeyField int, code varchar(1024), descr varchar(1024), hlevel int, pathStr varchar(4096), parentId_str varchar(4096), inActive bit)	
	create table #tmpRes (KeyField int, ParentKeyField int, code varchar(1024), descr varchar(1024), hlevel int, pathStr varchar(4096), parentId_str varchar(4096), inActive bit)	

	declare @kolvo int, @num int, @dstID int, @parentID int, @i int, @Level int, @cnt int, @MainID int, @Str varchar(2048)
		
	insert into #treeRes
		(KeyField, ParentKeyField, hlevel, code, descr, pathstr, parentid_str, inActive) 
	select ROW_NUMBER() over (order by GrName) as KF, 0, 1, '', GrName, cast(GrName as varchar(max)), '0', 0
	from (
		select distinct	
			GrName
		from [dbo].[PDX_pay_Items2016]) as X
	update #treeRes set KeyField = -1*KeyField, orderstr = '/-' + right('000' + CAST(KeyField as varchar(max)),4)
	
	-- дерево с учетом категории и фильтра
	;with treeRes (KeyField, ParentKeyField, hlevel, code, descr, pathstr, parentid_str, inActive, orderstr) 
	as 
	(
			
		select I.SetID, R.KeyField, 2, 
				cast(I.code as varchar(max)),
				cast(I.Name as varchar(max)),
				cast(I.code as varchar(max)) + ' ' + cast(I.Name as varchar(max)),
				CAST(isNull(I.ParentID,'') as VARCHAR(max)) + '_' + isnull(cast(isnull(R.KeyField,0) as varchar(max)),''),
				I.inActive,
				cast(R.orderstr as varchar(max))+ '/' + cast(right('000000'+right('.'+I.code,charindex('.',REVERSE('.'+I.code))-1),7) as varchar(max)) + '/' --+ right('000000' + cast(I.SetID as varchar(max)),7) 
		from [dbo].[PDX_pay_Items2016] I
		inner join #treeRes R on R.descr = I.GrName
		where (I.ParentID is null or I.ParentID = 0)
			and I.inActive in (@inActual, @inActual_1)		
		union all
		select I.SetID, I.ParentID, T.hlevel+1, 
				cast(I.code as varchar(max)) as nameRu_dst,
				cast(I.name as varchar(max)),
				T.pathstr + ' ' + cast(I.code as varchar(max)) +  ' ' + cast(I.Descr as varchar(max)),
				cast(T.ParentId_str as varchar(max)) + '_' + CAST(isNull(I.ParentID,'') as VARCHAR(max)),
				case T.inActive when 1 then T.inActive else I.inActive end,
				cast(T.orderstr as varchar(max))+ '/' + cast(right('000000'+right('.'+I.code,charindex('.',REVERSE('.'+I.code))-1),7) as varchar(max)) + '/' --+ right('000000' + cast(I.SetID as varchar(max)),7) 
		from [dbo].[PDX_pay_Items2016] I
			 inner join treeRes T on T.KeyField = I.ParentID
		where I.inActive in (@inActual, @inActual_1)
		
	)
	insert into #treeRes
		(KeyField, ParentKeyField, hlevel, code, descr, pathstr, parentid_str, inActive, orderstr) 
	select
		KeyField, ParentKeyField, hlevel, code, descr, pathstr, parentid_str, inActive, orderstr
	from treeRes
	
	
--select * from treeRes	 order by hlevel
	insert into #tmpFind (KeyField, ParentKeyField, hlevel, code, descr, pathStr, parentId_str)
	select distinct 
			KeyField, ParentKeyField, hlevel, code, descr, pathstr, parentId_str
	from #treeRes T
	where T.pathstr like '%' + @findStr + '%'									-- фильтр из формы
	
	--order by pathStr
--select * from #tmpFind	
	-- 2-ой проход. Ну типа все снова
	
	-- и еще раз достраиваем верхние уровни
	;with treeResFirst (KeyField, ParentKeyField, code, descr, hlevel, parentId_str)
	as
	(
		-- сами узелки
		select T1.KeyField, T1.ParentKeyField, cast(T1.Code as varchar(max)), cast(T1.descr as varchar(max)), T1.hlevel, T1.parentId_str
		from #tmpFind T1
		-- Верхние
		union all
		select	I.KeyField, I.ParentKeyField,--I.ParentID,
				cast(I.Code as varchar(max)) as Code,
				cast(I.descr as varchar(max)),
				T.hlevel-1,
				left(T.parentId_str, len(T.parentId_str) - len('_' + isnull(cast(T.ParentKeyField as varchar(max)),'')))
		from #treeRes I 
			inner join treeResFirst T on T.ParentKeyField = I.KeyField	
	)

	insert into #tmpRes (KeyField, ParentKeyField, hlevel, Code, descr,  parentId_str)
	select distinct 
			KeyField, ParentKeyField, hlevel, Code ,descr, parentId_str
	from treeResFirst T
	
		-- и еще раз достраиваем нижние уровни
	;with treeResFirst2 (KeyField, ParentKeyField, code, descr, hlevel, parentId_str)
	as
	(
		-- сами узелки
		select T1.KeyField, T1.ParentKeyField, cast(T1.Code as varchar(max)), cast(T1.descr as varchar(max)), T1.hlevel, cast(T1.parentId_str as varchar(max))
		from #tmpFind T1
		-- нижние
		union all
		select	I.KeyField, I.ParentKeyField,
				cast(I.Code as varchar(max)) as Code,
				cast(I.descr as varchar(max)),
				T.hlevel+1,
				cast(T.ParentId_str as varchar(max)) + '_' + CAST(isNull(I.ParentKeyField,'') as VARCHAR(max))
		from #treeRes I 
			inner join treeResFirst2 T on T.KeyField = I.ParentKeyField
		
	)

	insert into #tmpRes (KeyField, ParentKeyField, hlevel, Code, descr, parentId_str)
	select distinct 
			KeyField, ParentKeyField, hlevel, Code ,descr, parentId_str
	from treeResFirst2 T
	where not exists (select 1 from #tmpRes R where R.KeyField = T.KeyField)
		
	select 
		case 
			when T.KeyField < 0 then 1
			else isnull((select top 1 1 from [dbo].[PDX_pay_Items2016] where ParentID = T.KeyField),0) 
		end as isChoice,
		T.KeyField as id_dst,
		T.ParentKeyField  as parentid_dst,
		T.hlevel as hlevel,
		T.Code as nameru_dst,
		T.descr,
		T.parentId_str as parentId_str,
		R.inActive, R.orderstr
	from #tmpRes T
	inner join #treeRes R on R.KeyField = T.KeyField	
	--where R.KeyField > 0
	order by R.orderstr
	
	drop table #tmpFind 
	drop table #tmpRes
	drop table #treeRes

	select @Result = @@error if @Result <> 0 goto Err


	return @Result
Err:
	
	return @Result









GO
/****** Object:  StoredProcedure [dbo].[UserDirNomGrp_List] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
--drop proc [dbo].[UserDirNomGrp_List]
--go
create proc [dbo].[UserDirNomGrp_List]
	--@actual_flt		bit = null, --1 актуальные, 0 все
	@findStr	varchar(1024)	= NULL

as

	

	declare @Result int, @clsID int, @ActDocID int--, @inActual bit, @inActual_1 bit
	select @Result = 0
	
	
	select @findStr=ISNULL(@findStr, '')
	--set @inActual = case @actual_flt when 1 then 0 else 1 end
	--set @inActual_1 = 0
	
	create table #treeRes (KeyField int, ParentKeyField int, hlevel int, code varchar(1024), descr varchar(1024), pathstr varchar(4096), parentid_str varchar(4096), inActive bit, orderstr varchar(4096))
	--create table #tmp (dstId int, parentDstId int, nameRu varchar(1024), hlevel int, pathStr varchar(4096), parentId_str varchar(1024))
	create table #tmpFind (KeyField int, ParentKeyField int, code varchar(1024), descr varchar(1024), hlevel int, pathStr varchar(4096), parentId_str varchar(4096), inActive bit)	
	create table #tmpRes (KeyField int, ParentKeyField int, code varchar(1024), descr varchar(1024), hlevel int, pathStr varchar(4096), parentId_str varchar(4096), inActive bit)	

	declare @kolvo int, @num int, @dstID int, @parentID int, @i int, @Level int, @cnt int, @MainID int, @Str varchar(2048)
	
	
	-- дерево с учетом категории и фильтра
	;with treeRes (KeyField, ParentKeyField, hlevel, code, descr, pathstr, parentid_str, /*inActive,*/ orderstr) 
	as 
	(
		select KeyField, ParentKeyField, 1, 
				cast(code as varchar(max)),
				cast(descr as varchar(max)),
				cast(code as varchar(max)) + ' ' + cast(descr as varchar(max)),
				isnull(cast(isnull(ParentKeyField,0) as varchar(max)),''),
				/*inActive,*/
				cast(code as varchar(max)) + '/' + cast(KeyField as varchar(max)) 
				--cast(code as varchar(max)) + '/'
		from dbo.UserDir_NomGrp
		where ([ParentKeyField] is null or [ParentKeyField] = 0)
			--and FD in (@FD,@FD_1)
			--and inActive in (@inActual, @inActual_1)
		union all
		select I.KeyField, I.ParentKeyField, T.hlevel+1, 
				cast(I.code as varchar(max)) as nameRu_dst,
				cast(I.descr as varchar(max)),
				T.pathstr + ' ' + cast(I.code as varchar(max)) +  ' ' + cast(I.descr as varchar(max)),
				cast(T.ParentId_str as varchar(max)) + '_' + CAST(isNull(I.ParentKeyField,'') as VARCHAR(max)),
				/*case T.inActive when 1 then T.inActive else I.inActive end,*/
				cast(T.orderstr as varchar(max))+ '/' + cast(I.code as varchar(max)) + '/' + cast(I.KeyField as varchar(max))
				--cast(T.Code as varchar(max))+ '/' + cast(I.Code as varchar(max))+ '/'
		from dbo.UserDir_NomGrp I
			 inner join treeRes T on T.KeyField = I.ParentKeyField
		--where I.FD in (@FD,@FD_1)
		--and I.inActive in (@inActual, @inActual_1)
		
	)
	insert into #treeRes
		(KeyField, ParentKeyField, hlevel, code, descr, pathstr, parentid_str, /*inActive, */orderstr) 
	select
		KeyField, ParentKeyField, hlevel, code, descr, pathstr, parentid_str, /*inActive,*/ orderstr
	from treeRes
	
--select * from treeRes	 order by hlevel
	insert into #tmpFind (KeyField, ParentKeyField, hlevel, code, descr, pathStr, parentId_str)
	select distinct 
			KeyField, ParentKeyField, hlevel, code, descr, pathstr, parentId_str
	from #treeRes T
	where T.pathstr like '%' + @findStr + '%'									-- фильтр из формы
	
	--order by pathStr
--select * from #tmpFind	
	-- 2-ой проход. Ну типа все снова
	
	-- и еще раз достраиваем верхние уровни
	;with treeResFirst (KeyField, ParentKeyField, code, descr, hlevel, parentId_str)
	as
	(
		-- сами узелки
		select T1.KeyField, T1.ParentKeyField, cast(T1.Code as varchar(max)), cast(T1.descr as varchar(max)), T1.hlevel, T1.parentId_str
		from #tmpFind T1
		-- Верхние
		union all
		select	I.KeyField, I.ParentKeyField,
				cast(I.Code as varchar(max)) as Code,
				cast(I.descr as varchar(max)),
				T.hlevel-1,
				left(T.parentId_str, len(T.parentId_str) - len('_' + isnull(cast(T.ParentKeyField as varchar(max)),'')))
		from dbo.UserDir_NomGrp I 
			inner join treeResFirst T on T.ParentKeyField = I.KeyField	
	)

	insert into #tmpRes (KeyField, ParentKeyField, hlevel, Code, descr,  parentId_str)
	select distinct 
			KeyField, ParentKeyField, hlevel, Code ,descr, parentId_str
	from treeResFirst T

	
		-- и еще раз достраиваем нижние уровни
	;with treeResFirst2 (KeyField, ParentKeyField, code, descr, hlevel, parentId_str)
	as
	(
		-- сами узелки
		select T1.KeyField, T1.ParentKeyField, cast(T1.Code as varchar(max)), cast(T1.descr as varchar(max)), T1.hlevel, cast(T1.parentId_str as varchar(max))
		from #tmpFind T1
		-- нижние
		union all
		select	I.KeyField, I.ParentKeyField,
				cast(I.Code as varchar(max)) as Code,
				cast(I.descr as varchar(max)),
				T.hlevel+1,
				cast(T.ParentId_str as varchar(max)) + '_' + CAST(isNull(I.ParentKeyField,'') as VARCHAR(max))
		from dbo.UserDir_NomGrp I 
			inner join treeResFirst2 T on T.KeyField = I.ParentKeyField	
		--where I.FD in (@FD,@FD_1)
	)

	insert into #tmpRes (KeyField, ParentKeyField, hlevel, Code, descr, parentId_str)
	select distinct 
			KeyField, ParentKeyField, hlevel, Code ,descr, parentId_str
	from treeResFirst2 T
	where not exists (select 1 from #tmpRes R where R.KeyField = T.KeyField)
	
	select 
		isnull((select top 1 1 from dbo.UserDir_NomGrp where ParentKeyField = T.KeyField),0) as isChoice,
		T.KeyField as id_dst,
		T.ParentKeyField as parentid_dst,
		T.hlevel,
		T.Code as nameru_dst,
		T.descr,
		T.parentId_str,
		/*R.inActive, */R.orderstr
	from #tmpRes T
	inner join #treeRes R on R.KeyField = T.KeyField
	order by R.orderstr--T.Code
	
	drop table #tmpFind 
	drop table #tmpRes
	drop table #treeRes

	select @Result = @@error if @Result <> 0 goto Err


	return @Result
Err:
	
	return @Result








GO
/****** Object:  StoredProcedure [dbo].[UserDirOborot_List] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
--drop proc [dbo].[UserDirOborot_List]
--go
create proc [dbo].[UserDirOborot_List]
	--@actual_flt		bit = null, --1 актуальные, 0 все
	@findStr	varchar(1024)	= NULL

as

	

	declare @Result int, @clsID int, @ActDocID int--, @inActual bit, @inActual_1 bit
	select @Result = 0
	
	
	select @findStr=ISNULL(@findStr, '')
	--set @inActual = case @actual_flt when 1 then 0 else 1 end
	--set @inActual_1 = 0
	
	create table #treeRes (KeyField int, ParentKeyField int, hlevel int, code varchar(1024), descr varchar(1024), pathstr varchar(4096), parentid_str varchar(4096), inActive bit, orderstr varchar(4096))
	--create table #tmp (dstId int, parentDstId int, nameRu varchar(1024), hlevel int, pathStr varchar(4096), parentId_str varchar(1024))
	create table #tmpFind (KeyField int, ParentKeyField int, code varchar(1024), descr varchar(1024), hlevel int, pathStr varchar(4096), parentId_str varchar(4096), inActive bit)	
	create table #tmpRes (KeyField int, ParentKeyField int, code varchar(1024), descr varchar(1024), hlevel int, pathStr varchar(4096), parentId_str varchar(4096), inActive bit)	

	declare @kolvo int, @num int, @dstID int, @parentID int, @i int, @Level int, @cnt int, @MainID int, @Str varchar(2048)
	
	
	-- дерево с учетом категории и фильтра
	;with treeRes (KeyField, ParentKeyField, hlevel, code, descr, pathstr, parentid_str, /*inActive,*/ orderstr) 
	as 
	(
		select KeyField, ParentKeyField, 1, 
				cast(code as varchar(max)),
				cast(descr as varchar(max)),
				cast(code as varchar(max)) + ' ' + cast(descr as varchar(max)),
				isnull(cast(isnull(ParentKeyField,0) as varchar(max)),''),
				/*inActive,*/
				cast(code as varchar(max)) + '/' + cast(KeyField as varchar(max)) 
				--cast(code as varchar(max)) + '/'
		from dbo.UserDir_Oborot
		where ([ParentKeyField] is null or [ParentKeyField] = 0)
			--and FD in (@FD,@FD_1)
			--and inActive in (@inActual, @inActual_1)
		union all
		select I.KeyField, I.ParentKeyField, T.hlevel+1, 
				cast(I.code as varchar(max)) as nameRu_dst,
				cast(I.descr as varchar(max)),
				T.pathstr + ' ' + cast(I.code as varchar(max)) +  ' ' + cast(I.descr as varchar(max)),
				cast(T.ParentId_str as varchar(max)) + '_' + CAST(isNull(I.ParentKeyField,'') as VARCHAR(max)),
				/*case T.inActive when 1 then T.inActive else I.inActive end,*/
				cast(T.orderstr as varchar(max))+ '/' + cast(I.code as varchar(max)) + '/' + cast(I.KeyField as varchar(max))
				--cast(T.Code as varchar(max))+ '/' + cast(I.Code as varchar(max))+ '/'
		from dbo.UserDir_Oborot I
			 inner join treeRes T on T.KeyField = I.ParentKeyField
		--where I.FD in (@FD,@FD_1)
		--and I.inActive in (@inActual, @inActual_1)
		
	)
	insert into #treeRes
		(KeyField, ParentKeyField, hlevel, code, descr, pathstr, parentid_str, /*inActive, */orderstr) 
	select
		KeyField, ParentKeyField, hlevel, code, descr, pathstr, parentid_str, /*inActive,*/ orderstr
	from treeRes
	
--select * from treeRes	 order by hlevel
	insert into #tmpFind (KeyField, ParentKeyField, hlevel, code, descr, pathStr, parentId_str)
	select distinct 
			KeyField, ParentKeyField, hlevel, code, descr, pathstr, parentId_str
	from #treeRes T
	where T.pathstr like '%' + @findStr + '%'									-- фильтр из формы
	
	--order by pathStr
--select * from #tmpFind	
	-- 2-ой проход. Ну типа все снова
	
	-- и еще раз достраиваем верхние уровни
	;with treeResFirst (KeyField, ParentKeyField, code, descr, hlevel, parentId_str)
	as
	(
		-- сами узелки
		select T1.KeyField, T1.ParentKeyField, cast(T1.Code as varchar(max)), cast(T1.descr as varchar(max)), T1.hlevel, T1.parentId_str
		from #tmpFind T1
		-- Верхние
		union all
		select	I.KeyField, I.ParentKeyField,
				cast(I.Code as varchar(max)) as Code,
				cast(I.descr as varchar(max)),
				T.hlevel-1,
				left(T.parentId_str, len(T.parentId_str) - len('_' + isnull(cast(T.ParentKeyField as varchar(max)),'')))
		from dbo.UserDir_Oborot I 
			inner join treeResFirst T on T.ParentKeyField = I.KeyField	
	)

	insert into #tmpRes (KeyField, ParentKeyField, hlevel, Code, descr,  parentId_str)
	select distinct 
			KeyField, ParentKeyField, hlevel, Code ,descr, parentId_str
	from treeResFirst T

	
		-- и еще раз достраиваем нижние уровни
	;with treeResFirst2 (KeyField, ParentKeyField, code, descr, hlevel, parentId_str)
	as
	(
		-- сами узелки
		select T1.KeyField, T1.ParentKeyField, cast(T1.Code as varchar(max)), cast(T1.descr as varchar(max)), T1.hlevel, cast(T1.parentId_str as varchar(max))
		from #tmpFind T1
		-- нижние
		union all
		select	I.KeyField, I.ParentKeyField,
				cast(I.Code as varchar(max)) as Code,
				cast(I.descr as varchar(max)),
				T.hlevel+1,
				cast(T.ParentId_str as varchar(max)) + '_' + CAST(isNull(I.ParentKeyField,'') as VARCHAR(max))
		from dbo.UserDir_Oborot I 
			inner join treeResFirst2 T on T.KeyField = I.ParentKeyField	
		--where I.FD in (@FD,@FD_1)
	)

	insert into #tmpRes (KeyField, ParentKeyField, hlevel, Code, descr, parentId_str)
	select distinct 
			KeyField, ParentKeyField, hlevel, Code ,descr, parentId_str
	from treeResFirst2 T
	where not exists (select 1 from #tmpRes R where R.KeyField = T.KeyField)
	
	select 
		isnull((select top 1 1 from dbo.UserDir_Oborot where ParentKeyField = T.KeyField),0) as isChoice,
		T.KeyField as id_dst,
		T.ParentKeyField as parentid_dst,
		T.hlevel,
		T.Code as nameru_dst,
		T.descr,
		T.parentId_str,
		/*R.inActive,*/ R.orderstr
	from #tmpRes T
	inner join #treeRes R on R.KeyField = T.KeyField
	order by R.orderstr--T.Code
	
	drop table #tmpFind 
	drop table #tmpRes
	drop table #treeRes

	select @Result = @@error if @Result <> 0 goto Err


	return @Result
Err:
	
	return @Result








GO
/****** Object:  StoredProcedure [dbo].[UsersLogEx_Insert] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[UsersLogEx_Insert]
	@DocID				varchar(128)	= NULL,
	@userID				varchar(28)		= NULL,
	@strUserAction		varchar(1024)	= NULL

as

	declare @Result int, @DocIdInt int  
	select @Result = 0

	--

	select @DocIdInt=DocIdInt from docs where DocID=@DocID		
	select @Result = @@error if @Result <> 0 goto Err
	
	insert into UsersLogEx (UserID, DateAction, ActionID, DocIDInt, DocID) 
	values (@UserID, getDate(), @strUserAction, @DocIdInt, @DocID )
	select @Result = @@error if @Result <> 0 goto Err


	return @Result
Err:
	
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[ViewSelectValueForUFM] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[ViewSelectValueForUFM]
		@ClassDoc	varchar(128),
		@UFM_Num	tinyint,
		@Val		money

as	
	declare @NameConst varchar(128), @Values varchar(4000), @Descr varchar(4000)

	set @NameConst = dbo.PDX_CLSConstGet(@ClassDoc)

	select Descr as Name
	from dbo.SelectValueForUFM
	where ClsConstName = @NameConst
		and UFM_Num = @UFM_Num
		and Val = @Val
	order by Val
GO
/****** Object:  StoredProcedure [dbo].[xxx_PDX_CreateDoc] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[xxx_PDX_CreateDoc]
	@DocID varchar(128) out,
	@Error varchar(4096) out,

	@DocIDadd varchar(128) = '',
	@DocIDIncoming varchar(128) = '',
	@DocIDParent varchar(128) = '', --родит. док-т
	@DocIDPrevious varchar(128) = '',
	@Author varchar(1024) = '',
	@Correspondent varchar(1024) = '',
	@Resolution varchar(1024) = null,
	@History varchar(1024) = '',
	@Result varchar(1024) = '',
	@PercentCompletion int = null,
	@Department varchar(128) = '', --подразделение 
	@Name  varchar(255) = '', --заголовок
	@Description varchar(1024) = '', --предмет
	@LocationURL varchar(128) = null,
	@LocationPaper varchar(128) = null,
	--@FileNamePrefix varchar(255) = '',
	--@FileName varchar(255) = '',
	--@FileNameNameLastModification varchar(1024) = '',
	--@FileNameDateLastAccessed datetime = getdate(),
	--@FileNameDateLastModification datetime = getdate(),
	@LocationPath varchar(1024) = '',
	@ExtInt char(1) = '',
	@PartnerName  varchar(128) = '',
	@StatusDevelopment char(1) = 1, --на согласовании = 2
	@StatusPayment varchar(2) = '',
	@StatusArchiv char(1) = '',
	@StatusCompletion char(1) = '',
	@StatusDelivery char(1) = null,
	@TypeDoc char(1) = '',
	@ClassDoc varchar(64) = '',
	@ActDoc varchar(64) = '',
	--@InventoryUnit varchar(64) = '',
	@PaymentMethod  varchar(64) = '',
	@AmountDoc money = 0,
	@QuantityDoc real = 0,
	@DateActivation datetime = null,
	@SecurityLevel tinyint = 1, --общедоступный
	@DateCreation datetime = '1900-02-01 00:00:00.000',
	@DateCompletion datetime = '1900-02-01 00:00:00.000',
	@DateCompleted datetime = null,
	@DateExpiration datetime = '1900-02-01 00:00:00.000',
	@NameCreation varchar(96) = '' out,
	@NameAproval varchar(96) = '',
	@NameApproved varchar(96) = '',
	@DateApproved datetime = null,
	@ListToEdit varchar(1024) = '',
	@ListToReconcile varchar(1024) = '',
	@ListReconciled varchar(1024) = '',
	@NameResponsible  varchar(96) = '',
	@NameControl varchar(96) = '',
	--@NameLastModification varchar(96) = '',
	--@DateLastModification datetime = getdate(),
	@UserFieldText1 varchar(1024) = '',--Наименование листа согласования
	@UserFieldText2 varchar(1024) = '',--Вид договора
	@UserFieldText3 varchar(1024) = '',--Сторона 1
	@UserFieldText4 varchar(1024) = '',--Проект
	@UserFieldText5 varchar(1024) = '',--Подписывающий 2
	@UserFieldText6 varchar(1024) = '',--Дополнительные контрагенты -
	@UserFieldText7 varchar(1024) = '',--Коды Инвест.Мероприятий - 
	@UserFieldText8 varchar(1024) = '',--Контрагент 2
	@UserFieldMoney1 money = 0,--в т.ч. НДС
	@UserFieldMoney2 money = 0,
	@UserFieldDate1 datetime = '1900-02-01 00:00:00.000',
	@UserFieldDate2 datetime = '1900-02-01 00:00:00.000',
	@UserFieldDate3 datetime = '1900-02-01 00:00:00.000',
	@UserFieldDate4 datetime = '1900-02-01 00:00:00.000',
	@UserFieldDate5 datetime = '1900-02-01 00:00:00.000',
	@UserFieldDate6 datetime = '1900-02-01 00:00:00.000',
	@UserFieldDate7 datetime = '1900-02-01 00:00:00.000',
	@UserFieldDate8 datetime = '1900-02-01 00:00:00.000',
	@IsActive varchar(1) = 'N',
	@DateActive datetime = null,
	--@BusinessProcessStep varchar(255) = '',
	@ExtPassword varchar(48) = '',
	@DateSigned datetime = null,
	@Currency varchar(12) = '',
	--@CurrencyRate money = null,
	@Rank varchar(64) = '',
	@ListToView varchar(1024) = '',
	@Content ntext = ''

	
as
declare 
	@Res int,
	@FileNamePrefix varchar(255),
	@FileName1 varchar(255),
	@FileNameNameLastModification varchar(1024),
	@FileNameDateLastAccessed datetime,
	@FileNameDateLastModification datetime,
	@InventoryUnit varchar(64),
	@BusinessProcessStep varchar(255),
	@CurrencyRate money,
	@LS varchar(1024),
	@UserName varchar(128),
	@F varchar(128),	
	@N varchar(128),
	@O varchar(128)
	
select @Res = 0

	declare @Dep varchar(255),
			@DocDate datetime,
			@OrderIndex varchar(50),
			@RealDocID varchar(128)

	select @RealDocID = ltrim(rtrim(isnull(@DocID,'')))
	select @Res = @@error if @Res <> 0 goto Err

	select @Error = ''
	select @Res = @@error if @Res <> 0 goto Err

	if not exists (select * from dbo.DocTypes where Name = @ClassDoc)
	begin
		select @Error = 'Указана недопустимая категория документа.'
		goto Err
	end

	if not exists (select * from dbo.Activities where Name = @ActDoc /*and ClassDoc like '%'+@ClassDoc+'%'*/)
	begin
		select @Error = 'Указан недопустимый Вид деят-ти.'
		goto Err
	end

	select @DocIDadd = ''
	select @Res = @@error if @Res <> 0 goto Err
	--параметры для рассчета номера
	If @ClassDoc like 'Договоры / %' 
	begin
		select @Dep = @Department,
			 @DocDate = getdate(),
			 @OrderIndex = ''
		select @Res = @@error if @Res <> 0 goto Err
	end
	else if @ClassDoc in ('Проект / Задание на платеж',
						'Проект / Заявка на включение в бюджет',
						'Проект / Заявка на изменение ППП')
	begin 
		select @Dep = '',
			 @DocDate = @UserFieldDate1,
			 @OrderIndex = month(@UserFieldDate1)
		select @Res = @@error if @Res <> 0 goto Err
	end
	else if @ClassDoc in ('Проект / ППП на месяц')
	begin 
		if isnull(@QuantityDoc,0) = 0
		begin
			select @Error = 'Не указан номер редакции документа.'
			goto Err
		end
		select @DocDate = @UserFieldDate1,
			 @OrderIndex = isnull(replicate('0',2-len(cast(month(@UserFieldDate1) as varchar(2)))),0) + cast(month(@UserFieldDate1) as varchar(2)) +
							+ '.' + isnull(replicate('0',2-len(cast(@QuantityDoc as varchar(2)))),0) + cast(@QuantityDoc as varchar(50))
		select @Res = @@error if @Res <> 0 goto Err
	end
	else if @ClassDoc in ('Проект / ППП бюджет')
	begin 
		select @Dep = '',
			 @DocDate = getdate(),
			 @OrderIndex = ''
		select @Res = @@error if @Res <> 0 goto Err
		select
			 @OrderIndex = Field2
		from dbo.UserDirValues
		where UDKeyField = 87
			and Field1 = @UserFieldText1
		select @Res = @@error if @Res <> 0 goto Err

		if @OrderIndex = ''
		begin
		  select @Error = 'Указан недопустимый Вид документа(UserFieldText1)'
		  goto Err
		end	

		if isnull(@QuantityDoc,0) = 0
		begin
			select @Error = 'Не указан номер редакции документа.'
			goto Err
		end

		select @OrderIndex = @OrderIndex + '.' + isnull(replicate('0',2-len(cast(@QuantityDoc as varchar(2)))),0) + cast(@QuantityDoc as varchar(50))
		select @Res = @@error if @Res <> 0 goto Err
	end	
	else
	begin
		select @Error = 'Указанная категория документов данной процедурой не обрабатывается.!'
		goto Err
	end
	
	exec @Res = dbo.PDX_NC_NumberCalculate
		@Activity = @ActDoc, --вид деят-ти
		@Department = @Dep, --подразделение 
		--!!!!подразделение М.Б. задано с ключевым словом "<BYUSER:>" - это значит, что подразделение определяется через переданного в этой переменной пользователя
		@ParentDocID = @DocIDParent, --номер родит. 
		@ClassDoc =@ClassDoc,--категория
	
		@DocDate = @DocDate,--дата
		@OrderIndex = @OrderIndex, --пользовательский счетчик/код  (задается через интерфейс) - может быть дополнен 0 до определенного кол-ва знаков
		@isReg = 0,	--признак расчета рег. номера
	
		@OldDocID = '',--старый номер документа (тот, который хотим изменить/проверить: при регистрации это введенный регистратором номер, иначе введенный пользователем номер)
		@RealDocID = @RealDocID,--тот номер под которым в данный момент находится документ в системе
		@StatusActive = @isActive,--статус активный
		@PreviousDocID = @DocIDPrevious, --для проверки предыдущей версии (новый номер д.б. = Prev + 1)? для этого значение должно быть указано в формате "<CHK:>номер док-та"
		@Error = @Error out , --сообщение об ошибке
		@DocID = @DocID out, --рассчитанный номер документа
		--параметры для формирования сообщений об ошибке
		@s_Activity = null,
		@s_Department = null,
		@s_OrderIndex  = null,
		@s_PreviousDocID = null,
		@s_ParentDocID  = null
	if @Res <> 0 goto Err

    if @DocIDadd = '' 
	begin
		select @DocIDadd = @DocID
		select @Res = @@error if @Res <> 0 goto Err
	end

	--произошла ошибка при расчете номера
	if isnull(@Error,'') <> '' 
	begin
		goto Err
	end

	if exists (select 1 from dbo.Docs where DocID = @DocID)
	begin
		select @Error = 'Документ с указанными параметрами в PayDox уже существует.'
		goto Err		
	end

	select @FileNamePrefix = cast(replace(cast(NEWID() as varchar(40)),'-','') as varchar(24))
	select @Res = @@error if @Res <> 0 goto Err

	select @FileName1 = ''
	select @Res = @@error if @Res <> 0 goto Err

	select @FileNameNameLastModification = ''
	select @Res = @@error if @Res <> 0 goto Err

	select @FileNameDateLastAccessed = null
	select @Res = @@error if @Res <> 0 goto Err

	select @FileNameDateLastAccessed = null
	select @Res = @@error if @Res <> 0 goto Err

	select @InventoryUnit = ''
	select @Res = @@error if @Res <> 0 goto Err

	select @BusinessProcessStep = ''
	select @Res = @@error if @Res <> 0 goto Err

	select @CurrencyRate = null
	select @Res = @@error if @Res <> 0 goto Err

	select @UserFieldText1 = ltrim(rtrim(isnull(@UserFieldText1,'')))
	select @Res = @@error if @Res <> 0 goto Err

	select @LS = null
	select @LS = isnull(Field2 ,'')
	from dbo.UserDirValues where UDKeyField =34 and Field1 = @UserFieldText1
	select @Res = @@error if @Res <> 0 goto Err

	If @LS is null --or @UserFieldText1 = ''
	begin
		select @UserFieldText1 = 'Произвольный'
		select @Res = @@error if @Res <> 0 goto Err
	end
	else
	begin
		select @ListToReconcile = @LS
		select @Res = @@error if @Res <> 0 goto Err
	end
	
-------------------------------------------------------------------------
	select @NameCreation = ltrim(rtrim(isnull(@NameCreation,'')))
	select @Res = @@error if @Res <> 0 goto Err

	select @UserName = ''
	select @UserName = Name from dbo.Users where UserID = @NameCreation
	select @Res = @@error if @Res <> 0 goto Err

	if @NameCreation = '' or ltrim(rtrim(isnull(@UserName,''))) = ''
	begin
		select @NameCreation = '"КИСУП" <KISUP>;'
		select @Res = @@error if @Res <> 0 goto Err
	end
	else
	begin
		select @NameCreation = '"' + dbo.PDX_FIObyFullNameGet(@UserName) + '" <' + @NameCreation + '>;'
		select @Res = @@error if @Res <> 0 goto Err
	end
	select @Res = @@error if @Res <> 0 goto Err
-------------------------------------------------------------------------
	select @NameAproval = ltrim(rtrim(isnull(@NameAproval,'')))
	select @Res = @@error if @Res <> 0 goto Err

	select @UserName = ''
	select @UserName = Name from dbo.Users where UserID = @NameAproval
	select @Res = @@error if @Res <> 0 goto Err

	if @NameAproval = '' or ltrim(rtrim(isnull(@UserName,''))) = ''
	begin
		select @NameAproval = '"КИСУП" <KISUP>;'
		select @Res = @@error if @Res <> 0 goto Err
	end
	else
	begin
		select @NameAproval = '"' + dbo.PDX_FIObyFullNameGet(@UserName) + '" <' + @NameAproval + '>;'
		select @Res = @@error if @Res <> 0 goto Err
	end
	select @Res = @@error if @Res <> 0 goto Err
-------------------------------------------------------------------------
	select @NameResponsible = ltrim(rtrim(isnull(@NameResponsible,'')))
	select @Res = @@error if @Res <> 0 goto Err

	select @UserName = ''
	select @UserName = Name from dbo.Users where UserID = @NameResponsible
	select @Res = @@error if @Res <> 0 goto Err

	if @NameResponsible = '' or ltrim(rtrim(isnull(@UserName,''))) = ''
	begin
		select @NameResponsible = '"КИСУП" <KISUP>;'
		select @Res = @@error if @Res <> 0 goto Err
	end
	else
	begin
		select @NameResponsible = '"' + dbo.PDX_FIObyFullNameGet(@UserName) + '" <' + @NameResponsible + '>;'
		select @Res = @@error if @Res <> 0 goto Err
	end
	select @Res = @@error if @Res <> 0 goto Err
-------------------------------------------------------------------------
	insert into dbo.Docs
		(DocID,
		GUID,
		DocIDadd,
		DocIDIncoming,
		DocIDParent,
		DocIDPrevious,
		Author,
		Correspondent,
		Resolution,
		History,
		Result,
		PercentCompletion,
		Department,
		Name,
		Description,
		LocationURL,
		LocationPaper,
		FileNamePrefix,
		FileName,
		FileNameNameLastModification,
		FileNameDateLastAccessed,
		FileNameDateLastModification,
		LocationPath,
		ExtInt,
		PartnerName,
		StatusDevelopment,
		StatusPayment,
		StatusArchiv,
		StatusCompletion,
		StatusDelivery,
		TypeDoc,
		ClassDoc,
		ActDoc,
		InventoryUnit,
		PaymentMethod,
		AmountDoc,
		QuantityDoc,
		DateActivation,
		SecurityLevel,
		DateCreation,
		DateCompletion,
		DateCompleted,
		DateExpiration,
		NameCreation,
		NameAproval,
		NameApproved,
		DateApproved,
		ListToEdit,
		ListToReconcile,
		ListReconciled,
		NameResponsible,
		NameControl,
		NameLastModification,
		DateLastModification,
		UserFieldText1,
		UserFieldText2,
		UserFieldText3,
		UserFieldText4,
		UserFieldText5,
		UserFieldText6,
		UserFieldText7,
		UserFieldText8,
		UserFieldMoney1,
		UserFieldMoney2,
		UserFieldDate1,
		UserFieldDate2,
		UserFieldDate3,
		UserFieldDate4,
		UserFieldDate5,
		UserFieldDate6,
		UserFieldDate7,
		UserFieldDate8,
		IsActive,
		DateActive,
		BusinessProcessStep,
		ExtPassword,
		DateSigned,
		Currency,
		CurrencyRate,
		Rank,
		ListToView,
		Content)
	values
		(
		@DocID,--DocID,
		NewID(),--GUID,
		@DocIDadd,--DocIDadd,
		@DocIDIncoming,--DocIDIncoming,
		@DocIDParent,--DocIDParent,
		@DocIDPrevious,--DocIDPrevious,
		@Author,--Author,
		@Correspondent,--Correspondent,
		@Resolution,--Resolution,
		@History,--History,
		@Result,--Result,
		@PercentCompletion,--PercentCompletion,
		@Department,--Department,
		@Name,--Name,
		@Description,--Description,
		@LocationURL,--LocationURL,
		@LocationPaper,--LocationPaper,
		@FileNamePrefix,--FileNamePrefix,
		@FileName1,--FileName,
		@FileNameNameLastModification,-- FileNameNameLastModification,
		@FileNameDateLastAccessed, --FileNameDateLastAccessed,
		@FileNameDateLastModification, --FileNameDateLastModification,
		@LocationPath, --LocationPath,
		@ExtInt,-- ExtInt,
		@PartnerName,-- PartnerName,
		@StatusDevelopment, -- StatusDevelopment,
		@StatusPayment,-- StatusPayment,
		@StatusArchiv,-- StatusArchiv,
		@StatusCompletion,-- StatusCompletion,
		@StatusDelivery,-- StatusDelivery,
		@TypeDoc,-- TypeDoc,
		@ClassDoc,-- ClassDoc,
		@ActDoc,-- ActDoc,
		@InventoryUnit,-- InventoryUnit,
		@PaymentMethod,-- PaymentMethod,
		@AmountDoc,-- AmountDoc,
		@QuantityDoc,-- QuantityDoc,
		@DateActivation,--DateActivation,
		@SecurityLevel,-- SecurityLevel,
		@DateCreation,-- DateCreation,
		@DateCompletion,-- DateCompletion,
		@DateCompleted,-- DateCompleted,
		@DateExpiration, --DateExpiration,
		@NameCreation, --NameCreation,
		@NameAproval, --NameAproval,
		@NameApproved, --NameApproved
		@DateApproved, --DateApproved
		@ListToEdit, -- ListToEdit
		@ListToReconcile, --ListToReconcile
		@ListReconciled, --ListReconciled
		@NameResponsible, -- NameResponsible
		@NameControl, -- NameControl
		@NameCreation, --NameLastModification,
		@DateCreation,--DateLastModification,
		@UserFieldText1, --UserFieldText1
		@UserFieldText2, -- UserFieldText2
		@UserFieldText3,  --UserFieldText3
		@UserFieldText4, --UserFieldText4
		@UserFieldText5, -- UserFieldText5
		@UserFieldText6, -- UserFieldText6
		@UserFieldText7, -- UserFieldText7
		@UserFieldText8, -- UserFieldText8
		@UserFieldMoney1, --UserFieldMoney1
		@UserFieldMoney2,--UserFieldMoney2
		@UserFieldDate1, --UserFieldDate1
		@UserFieldDate2, --UserFieldDate2
		@UserFieldDate3,--UserFieldDate3
		@UserFieldDate4, --UserFieldDate4
		@UserFieldDate5, --UserFieldDate5
		@UserFieldDate6, --UserFieldDate6
		@UserFieldDate7, --UserFieldDate7
		@UserFieldDate8, --UserFieldDate8
		@IsActive, -- IsActive
		@DateActive, --DateActive
		@BusinessProcessStep, --BusinessProcessStep
		@ExtPassword, -- ExtPassword
		@DateSigned, --DateSigned
		@Currency, --Currency
		@CurrencyRate, --CurrencyRate
		@Rank, --Rank
		@ListToView, --ListToView
		@Content -- Content
		)
	select @Res = @@error if @Res <> 0 goto Err

	insert into dbo.Comments
		(UserID,
		UserName,
		ContactUserName,
		ContactUserID,
		PartnerName,
		DocID,
		DateCreation,
		DateEvent,
		DateEventEnd,
		Address,
		Subject,
		Comment,
		CommentType,
		SpecialInfo,
		FileName,
		--KeyField,
		PartnerID,
		Version,
		GUID,
		GUIDPartner,
		GUIDUser,
		GUIDDoc,
		Amount)
	values (
		substring(@NameCreation,
					charindex('<',@NameCreation),
					charindex('>',@NameCreation)-charindex('<',@NameCreation)-1),--UserID,
		replace(substring(@NameCreation,1,charindex('<',@NameCreation)-1),'"',''),-- UserName,
		null,--ContactUserName,
		null,--ContactUserID,
		null,--PartnerName,
		@DocID,--DocID,
		getdate(),--DateCreation,
		null,--DateEvent,
		null,--DateEventEnd,
		'',--Address,
		null,--Subject,
		'КИСУП',--Comment,
		'system',--CommentType,
		null,--SpecialInfo,
		null,--FileName,
		--KeyField,
		null,--PartnerID,
		null,--Version,
		null,--GUID,
		null,--GUIDPartner,
		null,--GUIDUser,
		null,--GUIDDoc,
		0)--Amount)
	select @Res = @@error if @Res <> 0 goto Err
	
OK:
	return @Res
Err:
	
	return @Res
GO
/****** Object:  StoredProcedure [dbo].[xxx_PDX_DeleteDoc] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[xxx_PDX_DeleteDoc]
	@DocID varchar(255)
as
	declare @Result int
	set @Result = 0
	
	if not exists (select 1 from dbo.Docs where DocID = @DocID)
	begin
		raiserror ('Указанный документ не существует!',16,1)
		goto Err
	end
	select @Result = @@error if @Result <> 0 goto Err

	if exists (select 1 from dbo.Comments where DocID = @DocID
				and (CommentType = 'FILE' or isnull(FileName,'') <> ''))
	begin
		raiserror ('Необходимо предварительно удалить файлы в документе!',16,1)
		goto Err
	end
	select @Result = @@error if @Result <> 0 goto Err

	delete dbo.Comments 
	where DocID = @DocID 
	select @Result = @@error if @Result <> 0 goto Err

	delete dbo.Docs
	where DocID = @DocID 
	select @Result = @@error if @Result <> 0 goto Err

	return @Result
Err:
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[xxx_PDX_DocNumberCanChange] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[xxx_PDX_DocNumberCanChange]
	@Create varchar(10) = '',
	@isActive2 varchar(10) = '',
	@DocID varchar(255) = '',
	@Prefix varchar(255) = '',
	@RightSymbol varchar(255) = '',
	@ChangeType char(1) = null out,	
	@Error varchar(255) = null out
as
	declare @Result int
	set @Result = 0

-- 1 - расчет номера нужен
-- 2 - перерасчет не нужен, номер корректный
-- 3 - номер не соответствует, но пересчитать его нельзя (ошибка) - это у активного документа 
select @ChangeType = 1 --расчет номера нужен 
If lower(@Create)<>'y'  --повторное сохранение 
begin

  	--ошибка будет, если в номере нет префикса или если префикс совпадает, но после счетчика есть что-то еще (для ДС - /01)	
    If charindex(@Prefix,@DocID) <> 1 or right(@DocID,len(@RightSymbol)) <> @RightSymbol or 
	(charindex(@Prefix,@DocID) = 1 and right(@DocID,len(@RightSymbol)) = @RightSymbol and 
	not isnumeric(replace(replace(left(@DocID,len(@DocID)-len(@RightSymbol)),@Prefix,''),'.','_')) = 1 ) --в if replace точки на подчеркивание, из-за того, что из isnumeric, точку в числе понимает как десятичные
	begin
		If lower(@isActive2) = 'y' --а документ уже активен
		begin
         	select @ChangeType = 0 --ошибка 
			select @Error = '<font color=red>ОШИБКА! </font> Рег. номер документа не соответствует реквизитам карточки. Для исправления обратитесь к администратору СЭД.'
			goto OK
  		  	--raiserror (@Error,16,1)
			--select @Result = @@error goto Err
		end
       	Else --документ неактивен - пересчет нужен
		begin
        	select @ChangeType = 1 --пользователя предупреждаем
			select @Result = @@error goto Err
	     	--Session("Message")="<font color=red>Внимание! </font> Номер документа был изменен в соответствии с новыми параметрами карточки."
       	End
	end
    Else --ошибки нет - пересчет не нужен
	begin
    	select @ChangeType = 2
		select @Result = @@error goto Err
    End 
End

		
OK:
	return @Result
Err:
	
	return @Result
GO
/****** Object:  StoredProcedure [dbo].[xxx_PDX_EDS_LinkToPD] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
create proc [dbo].[xxx_PDX_EDS_LinkToPD]
	@DocID varchar(128),
	@CurrPDName varchar(128)
as

--declare @Result int
--select @Result = 0

select DocID,
	DocNumber, 
	Comment, 
	isnull(RComment,'') as RComment, 
	PDName, 
	'<a href=javascript:open(''' + PDAddress + '/showdoc.asp?DocID=' + DocNumber + '&l=ru'',''blank'');navigator.back>' + DocNumber + '</a>' as [Link], 
	'<a href=javascript:open(''' + isnull(PDAddress,'') + '/UserAsp/REC_ExtLinkCreate.asp?EL_DocID=' + ltrim(rtrim(isnull(DocNumber,''))) + '&EL_DocNumber=' + ltrim(rtrim(isnull(DocID,'')))+ '&EL_Com=' + replace(ltrim(rtrim(isnull(RComment,''))),' ','_') + '&EL_GUID=' + cast(GUID as varchar(40))+ '&EL_PDName=' + @CurrPDName + '&l=ru'',''blank'');navigator.back>' + 'Выполнить' + '</a>' as [CreateLink],
	GUID 
from PDXLinkToPD 
where DocID = @DocID 
order by DocNumber
	--select @Result = @@error if @Result <> 0 goto Err

--	return @Result
--Err:
	
--	return @Result
GO
/****** Object:  StoredProcedure [dbo].[xxx_PDX_SyncDocFile] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[xxx_PDX_SyncDocFile]
	@DocID varchar(128), -- номер документа
	@NameCreation varchar(96) = '', --ЛОГИН создающего
	@FileName varchar(255) = '',--название файла с расширением
	@FileNameRus varchar(65) = '' --по нему определяем загружаем новую версию старого файла или же новый документ 

	
as
declare 
	@Res int,
	@UserName varchar(255),
	@F varchar(255),
	@N varchar(255),
	@O varchar(255)

select @Res = 0


	select @NameCreation = ltrim(rtrim(isnull(@NameCreation,'')))
	select @Res = @@error if @Res <> 0 goto Err

	select @UserName = ''
	select @UserName = Name from dbo.Users where UserID = @NameCreation
	select @Res = @@error if @Res <> 0 goto Err

	if @NameCreation = '' or ltrim(rtrim(isnull(@UserName,''))) = ''
	begin
		select @NameCreation = 'KISUP',
			   @UserName = 'КИСУП'
		select @Res = @@error if @Res <> 0 goto Err
	end
	else
	begin
		select @UserName = dbo.PDX_FIObyFullNameGet(@UserName) 
		select @Res = @@error if @Res <> 0 goto Err
	end
	select @Res = @@error if @Res <> 0 goto Err


/*
	select @UserName =  Name 
	from dbo.Users 
	--where @NameCreation like '%<' + UserID + '>%'
	where @NameCreation = UserID
	select @Res = @@error if @Res <> 0 goto Err
*/
	--документ должен сцуществовать
	if exists (select 1 from dbo.Docs where DocID = @DocID)
	begin
		if isnull(len(@FileName),0) <> 0 --название файла не д.б. пустым
		begin
			if isnull(len(@FileNameRus),0) <> 0  --наименование файла не дюб. пустым - по нему прослеживается "разнообразность" файлов
			begin
				--текущую версия делаем "старой"
				if exists (select 1 from dbo.Comments where DocID = @DocID
					and CommentType = 'FILE'
					and Version = @FileNameRus
					and Amount = 0)
				begin
					update dbo.Comments
						set
							Amount = 0.1,
							Comment = 'Основная версия документа, файл заменен  ' + Comment
					where DocID = @DocID
					and CommentType = 'FILE'
					and Version = @FileNameRus
					and Amount = 0
					select @Res = @@error if @Res <> 0 goto Err
				end
				select @Res = @@error if @Res <> 0 goto Err	
				--добавляем новую версию файла
				insert into dbo.Comments
					(UserID,
					UserName,
					ContactUserName,
					ContactUserID,
					PartnerName,
					DocID,
					DateCreation,
					DateEvent,
					DateEventEnd,
					Address,
					Subject,
					Comment,
					CommentType,
					SpecialInfo,
					FileName,
					--KeyField,
					PartnerID,
					Version,
					GUID,
					GUIDPartner,
					GUIDUser,
					GUIDDoc,
					Amount)
				values (
					/*substring(@NameCreation,
								charindex('<',@NameCreation)+1,
								charindex('>',@NameCreation)-charindex('<',@NameCreation)-1)*/
					@NameCreation,--UserID,
					@UserName,
					--replace(substring(@NameCreation,1,charindex('<',@NameCreation)-1),'"',''),-- UserName,
					null,--ContactUserName,
					null,--ContactUserID,
					null,--PartnerName,
					@DocID,--DocID,
					getdate(),--DateCreation,
					null,--DateEvent,
					null,--DateEventEnd,
					'',--Address,
					null,--Subject,
					'',--Comment,
					'FILE',--CommentType,
					null,--SpecialInfo,
					@FileName,--FileName,
					--KeyField,
					null,--PartnerID,
					@FileNameRus,--Version,
					null,--GUID,
					null,--GUIDPartner,
					null,--GUIDUser,
					null,--GUIDDoc,
					0)--Amount)
				select @Res = @@error if @Res <> 0 goto Err
			end 
		end
	end

--select * from Comments where DocID = 'X052' and CommentType = 'File'
	return @Res
Err:
	
	return @Res
GO
/****** Object:  StoredProcedure [dbo].[xxx_PDX_UpdateDoc] ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create proc [dbo].[xxx_PDX_UpdateDoc]
	@DocID varchar(128) out, --
	@Error varchar(4096) out,
	--@DocIDadd varchar(128) = null,
	@DocIDIncoming varchar(128) = null,
	@DocIDParent varchar(128) = null, --родит. док-т
	@DocIDPrevious varchar(128) = null,
	@Author varchar(1024) = null,
	@Correspondent varchar(1024) = null,
	--@Resolution varchar(1024) = null,
	--@History varchar(1024) = null,
	--@Result varchar(1024) = null,
	--@PercentCompletion int = null,
	@Department varchar(128) = null, --подразделение 
	@Name  varchar(255) = null, --заголовок
	@Description varchar(1024) = null, --предмет
	--@LocationURL varchar(128) = null,
	--@LocationPaper varchar(128) = null,
	--@FileNamePrefix varchar(255) = null,
	--@FileName varchar(255) = null,
	--@FileNameNameLastModification varchar(1024) = null,
	--@FileNameDateLastAccessed datetime = null,
	--@FileNameDateLastModification datetime = null,
	@LocationPath varchar(1024) = null,
	--@ExtInt char(1) = null,
	@PartnerName  varchar(128) = null,
	--@StatusDevelopment char(1) = null, --на согласовании = 2
	--@StatusPayment varchar(2) = null,
	--@StatusArchiv char(1) = null,
	--@StatusCompletion char(1) = null,
	--@StatusDelivery char(1) = null,
	--@TypeDoc char(1) = null,
	--@ClassDoc varchar(64) = null,
	--@ActDoc varchar(64) = null,
	--@InventoryUnit varchar(64) = null,
	--@PaymentMethod  varchar(64) = null,
	@AmountDoc money = null,
	@QuantityDoc real = null,
	@DateActivation datetime = null,
	--@SecurityLevel tinyint = null, --общедоступный
	--@DateCreation datetime = null,
	@DateCompletion datetime = null,
	--@DateCompleted datetime = null,
	@DateExpiration datetime = null,
	@NameCreation varchar(96) = null,
	@NameAproval varchar(96) = null,
	--@NameApproved varchar(96) = null,
	--@DateApproved datetime = null,
	@ListToEdit varchar(1024) = null,
	@ListToReconcile varchar(1024) = null,
	--@ListReconciled varchar(1024) = null,
	@NameResponsible  varchar(96) = null,
	@NameControl varchar(96) = null,
	@NameLastModification varchar(96) = null,
	--@DateLastModification datetime = null,
	@UserFieldText1 varchar(1024) = null,--Наименование листа согласования
	@UserFieldText2 varchar(1024) = null,--Вид договора
	@UserFieldText3 varchar(1024) = null,--Сторона 1
	@UserFieldText4 varchar(1024) = null,--Проект
	@UserFieldText5 varchar(1024) = null,--Подписывающий 2
	@UserFieldText6 varchar(1024) = null,--Дополнительные контрагенты -
	@UserFieldText7 varchar(1024) = null,--Коды Инвест.Мероприятий - 
	@UserFieldText8 varchar(1024) = null,--Контрагент 2
	@UserFieldMoney1 money = null,--в т.ч. НДС
	@UserFieldMoney2 money = null,
	@UserFieldDate1 datetime = null,
	@UserFieldDate2 datetime = null,
	@UserFieldDate3 datetime = null,
	@UserFieldDate4 datetime = null,
	@UserFieldDate5 datetime = null,
	@UserFieldDate6 datetime = null,
	@UserFieldDate7 datetime = null,
	@UserFieldDate8 datetime = null,
	--@IsActive varchar(1) = null,
	--@DateActive datetime = null,
	--@BusinessProcessStep varchar(255) = null,
	--@ExtPassword varchar(48) = null,
	@DateSigned datetime = null,
	@Currency varchar(12) = null,
	--@CurrencyRate money = null,
	@Rank varchar(64) = null,
	@ListToView varchar(1024) = null,
	@Content ntext = null

	
as
declare 
	@Res int

select @Res = 0
	
	declare @Dep varchar(255),
			@DocDate datetime,
			@OrderIndex varchar(50),
			@RealDocID varchar(128),
			@ClassDoc varchar(64),
			@ActDoc varchar(64),
			@IsActive varchar(1),
			@Flag bit,
			@UserName varchar(128)

	select @Error = '', @ClassDoc = '', @Flag = 0, @ActDoc = ''
	select @Res = @@error if @Res <> 0 goto Err

	--параметры карточки, которые при updatу из вне не передаются
	select 
		@ClassDoc = ClassDoc,
		@ActDoc = ActDoc,
		@IsActive = IsActive,
		@Flag = case when (upper(isnull(isActive ,''))='Y' 
						and ListToReconcile like '%(#!)%' 
						and not isnull(Statusdevelopment,'') in ('0','4')
						and not isnull(StatusCompletion,'') in ('0','1')) 
						or upper(isnull(isActive ,''))<>'Y' 
					 then 1 else 0 end,

		----
		@UserFieldDate1 = isnull(@UserFieldDate1,UserFieldDate1) --если поле не передано, значит мы его не изменяем, но оно нам нужно для анализа, поэому берем то згачение, кот в данный момент находиться в PayDox
	from dbo.Docs 
	where DocID = @DocID 
	select @Res = @@error if @Res <> 0 goto Err

    --запоминаем номер, под которым док-т находиться в PayDox
/******************************************/	
	select @RealDocID = ltrim(rtrim(isnull(@DocID,'')))
	select @Res = @@error if @Res <> 0 goto Err
/******************************************/

	select @Error = ''
	select @Res = @@error if @Res <> 0 goto Err

	--проверки на допустимость категории
	if not exists (select * from dbo.DocTypes where Name = @ClassDoc)
	begin
		select @Error = 'Указан документ недопустимой категории.'
		goto Err
	end
	--проверки на допустимость вида деят-ти
	if not exists (select * from dbo.Activities where Name = @ActDoc /*and ClassDoc like '%'+@ClassDoc+'%'*/)
	begin
		select @Error =  'Указан документ с недопустимым видом деят-ти.'
		goto Err
	end


	--параметры для рассчета номера (дублирование клиента PayDox)
	--также строгая проверка на то, с чем через кисуп можно работать
	--параметры для рассчета номера
	If @ClassDoc like 'Договоры / %' 
	begin
		select @Dep = @Department,
			 @DocDate = getdate(),
			 @OrderIndex = ''
		select @Res = @@error if @Res <> 0 goto Err
	end
	else if @ClassDoc in ('Проект / Задание на платеж',
						'Проект / Заявка на включение в бюджет',
						'Проект / Заявка на изменение ППП')
	begin 
		select @Dep = '',
			 @DocDate = @UserFieldDate1,
			 @OrderIndex = month(@UserFieldDate1)
		select @Res = @@error if @Res <> 0 goto Err
	end
	else if @ClassDoc in ('Проект / ППП на месяц')
	begin 
		if isnull(@QuantityDoc,0) = 0
		begin
			select @Error = 'Не указан номер редакции документа.'
			goto Err
		end
		select @DocDate = @UserFieldDate1,
			 @OrderIndex = isnull(replicate('0',2-len(cast(month(@UserFieldDate1) as varchar(2)))),0) + cast(month(@UserFieldDate1) as varchar(2)) +
							+ '.' + isnull(replicate('0',2-len(cast(@QuantityDoc as varchar(2)))),0) + cast(@QuantityDoc as varchar(50))
		select @Res = @@error if @Res <> 0 goto Err
	end
	else if @ClassDoc in ('Проект / ППП бюджет')
	begin 
		select @Dep = '',
			 @DocDate = getdate(),
			 @OrderIndex = ''
		select @Res = @@error if @Res <> 0 goto Err
		select
			 @OrderIndex = Field2
		from dbo.UserDirValues
		where UDKeyField = 87
			and Field1 = @UserFieldText1
		select @Res = @@error if @Res <> 0 goto Err

		if @OrderIndex = ''
		begin
		  select @Error = 'Указан недопустимый Вид документа(UserFieldText1)'
		  goto Err
		end	

		if isnull(@QuantityDoc,0) = 0
		begin
			select @Error = 'Не указан номер редакции документа.'
			goto Err
		end

		select @OrderIndex = @OrderIndex + '.' + isnull(replicate('0',2-len(cast(@QuantityDoc as varchar(2)))),0) + cast(@QuantityDoc as varchar(50))
		select @Res = @@error if @Res <> 0 goto Err
	end	
	else
	begin
		select @Error = 'Указанная категория документов данной процедурой не обрабатывается.!'
		goto Err
	end
		
	--правки возможны только в приостановленом док-те
	if @Flag = 0 
	begin
		select @Error = 'Изменить документ можно только если его сатус в PayDox равен "приостановлен" (т.е. документ находится на доработке) или неактивен.'
		goto Err
	end

	--проверка/пересчет номера
	exec @Res = dbo.PDX_NC_NumberCalculate
		@Activity = @ActDoc, --вид деят-ти
		@Department = @Dep, --подразделение 
		--!!!!подразделение М.Б. задано с ключевым словом "<BYUSER:>" - это значит, что подразделение определяется через переданного в этой переменной пользователя
		@ParentDocID = @DocIDParent, --номер родит. 
		@ClassDoc =@ClassDoc,--категория
	
		@DocDate = @DocDate,--дата
		@OrderIndex = @OrderIndex, --пользовательский счетчик/код  (задается через интерфейс) - может быть дополнен 0 до определенного кол-ва знаков
		@isReg = 0,	--признак расчета рег. номера
	
		@OldDocID = @RealDocID,--старый номер документа (тот, который хотим изменить/проверить: при регистрации это введенный регистратором номер, иначе введенный пользователем номер)
		@RealDocID = @RealDocID,--тот номер под которым в данный момент находится документ в системе
		@StatusActive = @isActive,--статус активный
		@PreviousDocID = @DocIDPrevious, --для проверки предыдущей версии (новый номер д.б. = Prev + 1)? для этого значение должно быть указано в формате "<CHK:>номер док-та"
		@Error = @Error out , --сообщение об ошибке
		@DocID = @DocID out, --рассчитанный номер документа
		--параметры для формирования сообщений об ошибке
		@s_Activity = null,
		@s_Department = null,
		@s_OrderIndex  = null,
		@s_PreviousDocID = null,
		@s_ParentDocID  = null
	if @Res <> 0 goto Err

	--блокируем правки. если состоялся пересчет номера
	if ltrim(rtrim(isnull(@Error,''))) <> '' or @RealDocID <> @DocID
	begin
		select @Error = 'Нельзя изменять параметры, влияющие на рег. номер карточки. Вам необходимо перегенировать карточку PayDox из КИСУП.'
		goto Err
	end

--------------------------------------------------------------
	select @NameCreation = ltrim(rtrim(isnull(@NameCreation,'')))
	select @Res = @@error if @Res <> 0 goto Err

	select @UserName = ''
	select @UserName = Name from dbo.Users where UserID = @NameCreation
	select @Res = @@error if @Res <> 0 goto Err

	if @NameCreation = '' or ltrim(rtrim(isnull(@UserName,''))) = ''
	begin
		select @NameCreation = '"КИСУП" <KISUP>;'
		select @Res = @@error if @Res <> 0 goto Err
	end
	else
	begin
		select @NameCreation = '"' + dbo.PDX_FIObyFullNameGet(@UserName) + '" <' + @NameCreation + '>;'
		select @Res = @@error if @Res <> 0 goto Err
	end
	select @Res = @@error if @Res <> 0 goto Err
--------------------------------------------------------------------
	select @NameLastModification = ltrim(rtrim(isnull(@NameLastModification,'')))
	select @Res = @@error if @Res <> 0 goto Err

	select @UserName = ''
	select @UserName = Name from dbo.Users where UserID = @NameLastModification
	select @Res = @@error if @Res <> 0 goto Err

	if @NameLastModification = '' or ltrim(rtrim(isnull(@UserName,''))) = ''
	begin
		select @NameLastModification = '"КИСУП" <KISUP>;'
		select @Res = @@error if @Res <> 0 goto Err
	end
	else
	begin
		select @NameLastModification = '"' + dbo.PDX_FIObyFullNameGet(@UserName) + '" <' + @NameLastModification + '>;'
		select @Res = @@error if @Res <> 0 goto Err
	end
	select @Res = @@error if @Res <> 0 goto Err
-------------------------------------------

	update dbo.Docs
	set
		DocIDParent = isnull(@DocIDParent,DocIDParent),
		DocIDIncoming = isnull(@DocIDIncoming,DocIDIncoming),
		DocIDPrevious = isnull(@DocIDPrevious,DocIDPrevious),
		Author = isnull(@Author,Author),
		Correspondent = isnull(@Correspondent,Correspondent),
		--Resolution,
		--History,
		--Result,
		--PercentCompletion,
		Department = isnull(@Department,Department),
		Name = isnull(@Name,Name),
		Description = isnull(@Description,Description),
		--LocationURL,
		--LocationPaper,
		--FileNamePrefix,
		--FileName,
		--FileNameNameLastModification,
		--FileNameDateLastAccessed,
		--FileNameDateLastModification,
		LocationPath = isnull(@LocationPath,LocationPath),
		--ExtInt,
		PartnerName = isnull(@PartnerName,PartnerName),
		--StatusDevelopment,
		--StatusPayment,
		--StatusArchiv,
		--StatusCompletion,
		--StatusDelivery,
		--TypeDoc,
		--ClassDoc,
		--ActDoc = isnull(@ActDoc,ActDoc),
		--InventoryUnit,
		--PaymentMethod,
		AmountDoc = isnull(@AmountDoc,AmountDoc),
		QuantityDoc = isnull(@QuantityDoc,QuantityDoc),
		DateActivation = isnull(@DateActivation,DateActivation),
		--SecurityLevel,
		--DateCreation,
		DateCompletion = isnull(@DateActivation,DateActivation),
		--DateCompleted,
		DateExpiration = isnull(@DateCompletion,DateCompletion),
		NameCreation = isnull(@NameCreation,NameCreation),
		NameAproval = isnull(@NameAproval,NameAproval),
		--NameApproved,
		--DateApproved,
		ListToEdit = isnull(@ListToEdit,ListToEdit),
		ListToReconcile = isnull(@ListToReconcile,ListToReconcile),
		--ListReconciled,
		NameResponsible = isnull(@NameResponsible,NameResponsible),
		NameControl = isnull(@NameControl,NameControl),
		NameLastModification = isnull(@NameLastModification,NameLastModification),
		DateLastModification = getdate(),
		UserFieldText1 = isnull(@UserFieldText1,UserFieldText1),
		UserFieldText2 = isnull(@UserFieldText2,UserFieldText2),
		UserFieldText3 = isnull(@UserFieldText3,UserFieldText3),
		UserFieldText4 = isnull(@UserFieldText4,UserFieldText4),
		UserFieldText5 = isnull(@UserFieldText5,UserFieldText5),
		UserFieldText6 = isnull(@UserFieldText6,UserFieldText6),
		UserFieldText7 = isnull(@UserFieldText7,UserFieldText7),
		UserFieldText8 = isnull(@UserFieldText8,UserFieldText8),
		UserFieldMoney1 = isnull(@UserFieldMoney1,UserFieldMoney1),
		UserFieldMoney2 = isnull(@UserFieldMoney2,UserFieldMoney2),
		UserFieldDate1 = isnull(@UserFieldDate1,UserFieldDate1),
		UserFieldDate2 = isnull(@UserFieldDate2,UserFieldDate2),
		UserFieldDate3 = isnull(@UserFieldDate3,UserFieldDate3),
		UserFieldDate4 = isnull(@UserFieldDate4,UserFieldDate4),
		UserFieldDate5 = isnull(@UserFieldDate5,UserFieldDate5),
		UserFieldDate6 = isnull(@UserFieldDate6,UserFieldDate6),
		UserFieldDate7 = isnull(@UserFieldDate7,UserFieldDate7),
		UserFieldDate8 = isnull(@UserFieldDate8,UserFieldDate8),
		--IsActive,
		--DateActive,
		--BusinessProcessStep,
		--ExtPassword,
		DateSigned = isnull(@DateSigned,DateSigned),
		Currency = isnull(@Currency,Currency),
		--CurrencyRate,
		Rank = isnull(@Rank,Rank),
		ListToView = isnull(@ListToView,ListToView),
		Content= isnull(@Content,Content)
	where DocID = @RealDocID--@DocID
	select @Res = @@error if @Res <> 0 goto Err

	return @Res
Err:
	
	return @Res
GO
